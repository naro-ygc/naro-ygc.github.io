<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta name="referrer" content="no-referrer"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络基础 | naro</title><meta name="author" content="naro-ygc,862450734@qq.com"><meta name="copyright" content="naro-ygc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="计算机网络笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="网络基础">
<meta property="og:url" content="https://naro-ygc.cn/posts/50daec4.html">
<meta property="og:site_name" content="naro">
<meta property="og:description" content="计算机网络笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://naro-ygc.cn/img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2025-02-21T19:27:28.687Z">
<meta property="article:modified_time" content="2024-04-21T08:06:08.000Z">
<meta property="article:author" content="naro-ygc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://naro-ygc.cn/img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B0%81%E9%9D%A2.png"><link rel="shortcut icon" href="/img/log.png"><link rel="canonical" href="https://naro-ygc.cn/posts/50daec4.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-21 16:06:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/log.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B0%81%E9%9D%A2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="naro"><span class="site-name">naro</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-21T19:27:28.687Z" title="发表于 2025-02-22 03:27:28">2025-02-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-21T08:06:08.000Z" title="更新于 2024-04-21 16:06:08">2024-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>74分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>下面出现代码均为c语言</code></p>
<h1 id="1、计算机网络发展"><a href="#1、计算机网络发展" class="headerlink" title="1、计算机网络发展"></a>1、计算机网络发展</h1><ul>
<li>最早的计算机网络是ARPA，但是最早的ARPA无法连接不同类型的计算机和不同的操作系统。</li>
</ul>
<h2 id="1-1、数据交换"><a href="#1-1、数据交换" class="headerlink" title="1-1、数据交换"></a>1-1、数据交换</h2><ul>
<li>通过标有地址的分组进行路由选择传输数据，使得通信通道仅在传送期间被占用的一种交换方式。</li>
</ul>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ARPA.png"></p>
<h2 id="1-2、交换方式"><a href="#1-2、交换方式" class="headerlink" title="1-2、交换方式"></a>1-2、交换方式</h2><p>•交换的方式为存储转发，节点收到分组，先暂时存储下来，再检查它的头部，然后按照首部中的地址，找到合适的节点转发出去。</p>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png"></p>
<h3 id="1-2-3、特点"><a href="#1-2-3、特点" class="headerlink" title="1-2-3、特点"></a>1-2-3、特点</h3><p>1、以分组作为传输单位。</p>
<p>2、独立选择转发路由。</p>
<p>3、逐段占用，动态分配传输带宽。</p>
<h2 id="1-3、发展过程"><a href="#1-3、发展过程" class="headerlink" title="1-3、发展过程"></a>1-3、发展过程</h2><p>•从单个ARPA发展为tcp&#x2F;ip的ARPAnei的标注协议。</p>
<h1 id="2、英特网的结构"><a href="#2、英特网的结构" class="headerlink" title="2、英特网的结构"></a>2、英特网的结构</h1><h2 id="2-1、三级结构英特网"><a href="#2-1、三级结构英特网" class="headerlink" title="2-1、三级结构英特网"></a>2-1、三级结构英特网</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%93%E6%9E%84.png"></p>
<p>•每个国家都有一个主干网，然后层级下发。</p>
<h2 id="2-2、多级英特网"><a href="#2-2、多级英特网" class="headerlink" title="2-2、多级英特网"></a>2-2、多级英特网</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%A7%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%93%E6%9E%84.png"></p>
<h1 id="3、TCP-IP协议族"><a href="#3、TCP-IP协议族" class="headerlink" title="3、TCP&#x2F;IP协议族"></a>3、TCP&#x2F;IP协议族</h1><h2 id="3-1、分层结构"><a href="#3-1、分层结构" class="headerlink" title="3-1、分层结构"></a>3-1、分层结构</h2><p>•由来：主要是为了解决不同计算机之间和不同操作系统直接的差异，就进行分层，只需要保证某些层次是一样的，<br>就可以进行通讯。<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>•最早的分层体系是osi开放系统互联模型，是由国际化标准组织（iso）指定，由于osi过于<br>复杂，所以到现在也没有使用，而是使用的是TCP&#x2F;IP协议族。</p>
<p>•应用层：应用程序沟通的 例如：FTP、HTTP、Telnet等。</p>
<p>•FTP：文件传输协议，如app的上传和下载功能。</p>
<p>•HTTP：超文本协议，通过浏览器访问其他网站，必须通过http协议。</p>
<p>•传输层：提供程序间数据的传输逻辑通讯，例如TCP、UDP。</p>
<p>•网络层：提供基本的数据包传送功能，最大可能的能让每个数据报都能到达主机，例如IP、ICMP等。</p>
<p>•IP：用来找到目的主机。</p>
<p>•链路层：负责数据帧的发送和接收。一个数据称为一帧数据。</p>
<p>•每层完成自己的任务，最终完成不同层次的处理完成数据的收发。<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p>
<p>•上图的ARP协议是通过对方的ip地址找对方MAC地址，<br>而RARP则是通过MAC地址找ip地址。</p>
<p>•数据是从应用层到传输层，一直到链路层，<br>整体把数据交给链路层之后，将数据传给对方，<br>然后最后层层解封。</p>
<h2 id="3-2、-IP协议"><a href="#3-2、-IP协议" class="headerlink" title="3-2、 IP协议"></a>3-2、 IP协议</h2><p>•特指为实现一个相互连接的网络系统上从源地址到<br>目的地传输数据包所提供的必要协议。<br>也称为网际协议。</p>
<p>•特点：	不可靠：它不能保证IP数据包能成功地到达它的目的地，<br>仅提供尽力而为的传输服务。</p>
<p>•无连接：IP并不维护任何关于后续数据包的状态信息。<br>每个数据包的处理是相互独立的。<br>IP数据包可以不按发送顺序接收<br>IP数据包中含有发送它主机的IP地址（源地址）和接收它主机的IP地址（目的地址）。</p>
<h2 id="3-3、tcp协议简介"><a href="#3-3、tcp协议简介" class="headerlink" title="3-3、tcp协议简介"></a>3-3、tcp协议简介</h2><p>•tcp协议是面向连接的，可靠的传输层通讯协议。</p>
<p>•功能：提供不同主机上的进程间通讯。</p>
<p>•特点：<br>1、建立链接-&gt;使用链接-&gt;释放链接（虚电路）。</p>
<p>2、tcp数据包中包含序号和确认序号。</p>
<p>3、对包经行排序并检错，而损坏的包可以被重传。</p>
<p>•服务对象<br>需要高度可靠并面向连接的服务。<br>如：http、ftp、smtp等。<br>smtp为简单邮件传输协议。</p>
<h2 id="3-4、udp协议简介"><a href="#3-4、udp协议简介" class="headerlink" title="3-4、udp协议简介"></a>3-4、udp协议简介</h2><p>•udp是一种面向无连接的传输层通讯协议。也称用户数据报协议。</p>
<p>•功能：<br>提供不同主机上的进程间通讯。</p>
<p>•特点：<br>1、发送数据前不需要建立链接。  </p>
<p>2、不对数据包的顺序进行检查。</p>
<p>3、没有错误检测和重传机制。</p>
<p>•服务对象：<br>主要用于查询应答服务。<br>如：nfs、ntp、dns等</p>
<h2 id="3-5、mac地址"><a href="#3-5、mac地址" class="headerlink" title="3-5、mac地址"></a>3-5、mac地址</h2><p>•mac地址类似于身份证号。出场的时候标出，理论上全球唯一。</p>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/mac%E5%9C%B0%E5%9D%80%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>•组成：以太网内的MAC地址是一个48bit的值。mac地址是可以修改的，但是一般情况下不建议修改mac地址。</p>
<p>•总共分成6组，通过 : 隔开，前三组称为厂商ID，后三组称为设备ID。</p>
<p>•如果是我们自己识别的话是分组识别，如果是输入给计算机的话就是48位的值。</p>
<h2 id="3-6、ip地址"><a href="#3-6、ip地址" class="headerlink" title="3-6、ip地址"></a>3-6、ip地址</h2><p>•ip地址是一种internet上的主机编址，也称为网际协议地址。</p>
<p>•ip地址在网络中具有唯一标识。</p>
<h3 id="3-6-1、IP地址的分类"><a href="#3-6-1、IP地址的分类" class="headerlink" title="3-6-1、IP地址的分类"></a>3-6-1、IP地址的分类</h3><p>•ipv4，占32位</p>
<p>•ipv6，占128位</p>
<h4 id="3-6-1-1、ipv4组成"><a href="#3-6-1-1、ipv4组成" class="headerlink" title="3-6-1-1、ipv4组成"></a>3-6-1-1、ipv4组成</h4><p>•ipv4一般使用点分十进制字符串来标识，如192.168.1.135。</p>
<h3 id="3-6-2、ip组成"><a href="#3-6-2、ip组成" class="headerlink" title="3-6-2、ip组成"></a>3-6-2、ip组成</h3><p>•使用32位，有{网络id，主机id}两部分组成</p>
<p>•子网：IP地址中由1覆盖的连续位</p>
<p>•主机：由ip地址中0覆盖的连续位</p>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ip%E7%BB%84%E6%88%90.png"></p>
<p>•子网ID不同的网络不能直接通讯，如果要通讯要通过路由器转发。</p>
<p>•主机id全为0表示网段地址。</p>
<p>•主机id全为1的ip地址表示该网段的广播地址。</p>
<p>•如192.168.1.0为表示网段，192.168.1.255为广播地址。</p>
<h3 id="3-6-3、ipv4的地址分类（依据前8位进行区分）"><a href="#3-6-3、ipv4的地址分类（依据前8位进行区分）" class="headerlink" title="3-6-3、ipv4的地址分类（依据前8位进行区分）"></a>3-6-3、ipv4的地址分类（依据前8位进行区分）</h3><p>•A类地址：默认8位子网id，<br>第一位为0，前8位00000000 - 0111 1111，<br>范围0.x.x.x - 127.x.x.x</p>
<p>•B类地址：默认16位子网id，<br>前两位为10，前8位1000 0000  -  1011 1111，<br>范围128.x.x.x  -  191.x.x.x</p>
<p>•C类地址：默认24位子网id，<br>前三位为110，前8位为1100 0000   -  1101 1111 ，<br>范围192 .x.x.x  -  223.x.x.x</p>
<p>•D类地址：前四位为1110，<br>多播地址，前8位1110 0000 -  1110 1111，<br>范围224.x.x.x  -  239.x.x.x</p>
<p>•E类地址：前五位为1111 0，<br>保留为今后使用，前八位为1111 0000  -  1111 1111 ，<br>范围240 .x.x.x -  255.x.x.x</p>
<p>•ip地址特点：<br>子网ID不同的网络不能直接通信，<br>如果要通信则需要路由器转发<br>主机ID全为0的IP地址表示网段地址<br>主机ID全为1的IP地址表示该网段的广播地址。</p>
<h3 id="3-6-4、私有ip"><a href="#3-6-4、私有ip" class="headerlink" title="3-6-4、私有ip"></a>3-6-4、私有ip</h3><p>•公有ip(可直接联网)：<br>经由internet同意规划的ip。</p>
<p>•私有ip（不可直接连接internet）：<br>主要用于局域网络内的主机联机规划。		</p>
<p>​	<img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ip%E7%B1%BB%E5%9E%8B.png"></p>
<h3 id="3-6-5、回环ip地址"><a href="#3-6-5、回环ip地址" class="headerlink" title="3-6-5、回环ip地址"></a>3-6-5、回环ip地址</h3><p>•通常127.0.0.1称为回环地址</p>
<p>•功能：<br>主要是测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和ip协议的安装没有问题。</p>
<p>•注意：<br>127.0.0.1—-127.255.255.254中的任何地址都将回环到本机的地址中，不属于任何一个有类别的地址类，<br>它代表着设备的本地接口。</p>
<h3 id="3-6-6、子网掩码"><a href="#3-6-6、子网掩码" class="headerlink" title="3-6-6、子网掩码"></a>3-6-6、子网掩码</h3><p>•子网掩码又称为网络掩码、地址掩码是一个有32位由1和0组成的数值，并且1和0分别连续。</p>
<p>•作用：</p>
<p>​用于指明ip地址中那些是子网，那些是主机号。</p>
<p>•特点：</p>
<p>​必须结合ip地址一起使用，不能单独存在。</p>
<p>​ip地址中由子网掩码中1覆盖的连续位为子网id，其余为主机id。</p>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png"></p>
<h2 id="3-7、端口"><a href="#3-7、端口" class="headerlink" title="3-7、端口"></a>3-7、端口</h2><h3 id="3-7-1、端口概述"><a href="#3-7-1、端口概述" class="headerlink" title="3-7-1、端口概述"></a>3-7-1、端口概述</h3><p>•tcp&#x2F;ip采用端口标识通信进程，用于区分一个系统里的多个进程。</p>
<p>•特点：<br>1、对于同一个端口，在不同的系统中对应着不同的进程。</p>
<p>2、对于同一个系统，一个端口只能被一个进程拥有。</p>
<p>3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，<br>进程送交传输层的数据也通过该端口被送出。</p>
<h3 id="3-7-2、端口号"><a href="#3-7-2、端口号" class="headerlink" title="3-7-2、端口号"></a>3-7-2、端口号</h3><p>•类似pid标识一个进程：在网络程序中，用端口号（port）来标识一个运行的网络程序。</p>
<p>•特点<br>1、端口号是无符号短整型的类型。</p>
<p>2、每个端口都拥有一个端口号。</p>
<p>3、TCP、UDP维护各自的端口号。</p>
<p>4、网络应用程序至少要占用一个端口号，也可以占用多个端口号。</p>
<p>•知名端口（1-1023）<br>由互联网数字分配机构根据用户需求进行同意分配。<br>如：ftp –21，http—-80等<br>服务器通常使用的范围；若强制使用，须加root特权</p>
<p>• 动态端口（1024 -65535）<br>应用程序通常使用的范围。<br>注意：端口号类似于进程号，同一时刻只能标记一个进程。<br>可以重复使用。</p>
<p>​	<img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png"></p>
<h3 id="3-7-3、链路层封包格式"><a href="#3-7-3、链路层封包格式" class="headerlink" title="3-7-3、链路层封包格式"></a>3-7-3、链路层封包格式</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B0%81%E5%8C%85%E6%A0%BC%E5%BC%8F.png"></p>
<p>• 目的地址：目的mac地址</p>
<p>• 源地址：源mac地址</p>
<p>• 类型：<br>以太网后面跟的是那个协议，占两个字节<br>0x0800 ip协议（对应到网络层）<br>0x0806 arp协议<br>0x835 rarp协议</p>
<p>• 注意：</p>
<p>1、IEEE802.2&#x2F;802.3封装常用的无线</p>
<p>2、以太网封装常用在线局域网</p>
<h3 id="3-7-4、网络层的数据报封装"><a href="#3-7-4、网络层的数据报封装" class="headerlink" title="3-7-4、网络层的数据报封装"></a>3-7-4、网络层的数据报封装</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%B0%81%E5%8C%85.png"></p>
<p>•当协议改为6，或者17后，ip数据报后面紧跟的就是udp数据报或者tcp数据报。</p>
<h2 id="3-8、c-s架构"><a href="#3-8、c-s架构" class="headerlink" title="3-8、c&#x2F;s架构"></a>3-8、c&#x2F;s架构</h2><p>•无论是tcp还是udp，都是通过c&#x2F;s架构运行的，client客户端，server服务器端。服务器是被动运行的，<br>客户端是主动运行的。<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/cs%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>•server工作过程：<br>打开一通信通道并告知本地主机，它愿意在一特定端口（如80）上接收客户请求，<br>等待客户请求到达该端口，受客户请求，并发送应答信号，激活一新的线程处理客<br>户的这个请求，服务完成后，关闭新线程的客户的通信链路。</p>
<p>•client工作过程:<br>打开一通信通道并连接到服务器特定的端口，并向服务器发出服务请求，等待并接<br>收应答，根据需要继续提出请求，请求结束后关闭通信通道并终止。</p>
<h1 id="4、字节序、地址转换"><a href="#4、字节序、地址转换" class="headerlink" title="4、字节序、地址转换"></a>4、字节序、地址转换</h1><p>•多数据的存储顺序称之为字节序</p>
<p>•分类：<br>大端格式：将高位字节数据存储低地址<br>小端格式：将低位字节数据存储在低地址</p>
<p>•注意：<br>lsb：低地址<br>msb：高地址</p>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%AD%97%E8%8A%82%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>•如何判断存储字节序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union k&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union k j;</span><br><span class="line">j.a = 0x12345678;</span><br><span class="line">printf(&quot;j.b = %#x\r\n&quot;,j.b);</span><br><span class="line">if(j.b == 0x78)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;小端存储\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">j.b = 0x78</span><br><span class="line">小端存储</span><br></pre></td></tr></table></figure>

<p>一个地址位存储一个字节，一个字节8位。</p>
<h2 id="4-1、字序转换"><a href="#4-1、字序转换" class="headerlink" title="4-1、字序转换"></a>4-1、字序转换</h2><p>•特点：</p>
<p>1、协议指定了通讯字节序为大端存储。</p>
<p>2、只有在多字节数据处理的时候才需要考虑字节序。</p>
<p>3、运行在同一台计算机上的进程互相通讯时，一般不用考虑字节序。</p>
<p>4、异构计算机之间的通讯，需要转换自己的字节序为网络字节序。</p>
<p>在需要字节序转换的时候一般调用特定字节序转换函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">host ‐‐&gt; network</span><br><span class="line">1 ‐‐ htonl</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">uint32_t htonl(uint32_t hostint32);</span><br><span class="line">功能:</span><br><span class="line">将32位主机字节序数据转换成网络字节序数据</span><br><span class="line">参数：</span><br><span class="line">hostint32：待转换的32位主机字节序数据</span><br><span class="line">返回值：</span><br><span class="line"> 成功：返回网络字节序的值</span><br><span class="line"></span><br><span class="line"> 2 ‐‐ htons</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> uint16_t htons(uint16_t hostint16);</span><br><span class="line"> 功能：</span><br><span class="line"> 将16位主机字节序数据转换成网络字节序数据</span><br><span class="line"> 参数：</span><br><span class="line"> uint16_t：unsigned short int</span><br><span class="line"> hostint16：待转换的16位主机字节序数据</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回网络字节序的值</span><br><span class="line"></span><br><span class="line"> network ‐‐&gt; host</span><br><span class="line"> 3 ‐‐ ntohl</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> uint32_t ntohl(uint32_t netint32);</span><br><span class="line"> 功能：</span><br><span class="line"> 将32位网络字节序数据转换成主机字节序数据</span><br><span class="line"> 参数：</span><br><span class="line"> uint32_t： unsigned int</span><br><span class="line"> netint32：待转换的32位网络字节序数据</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回主机字节序的值</span><br><span class="line"></span><br><span class="line"> 4 ‐‐ ntohs</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> uint16_t ntohs(uint16_t netint16);</span><br><span class="line"> 功能：</span><br><span class="line"> 将16位网络字节序数据转换成主机字节序数据</span><br><span class="line"> 参数：</span><br><span class="line"> uint16_t： unsigned short int</span><br><span class="line"> netint16：待转换的16位网络字节序数据</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回主机字节序的值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 0x12345678;</span><br><span class="line">short int b =0x1234;</span><br><span class="line">printf(&quot;%#x\n&quot;,htonl(a));</span><br><span class="line">printf(&quot;%#x\r\n&quot;,htons(b));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">0x78563412</span><br><span class="line">0x3412</span><br></pre></td></tr></table></figure>

<h2 id="4-2、地址转换"><a href="#4-2、地址转换" class="headerlink" title="4-2、地址转换"></a>4-2、地址转换</h2><p>•ip地址人为识别的时候是字符串。</p>
<p>•交给计算机识别时，要将它转化整型数据。<br>如192.168.3.104 </p>
<p>•交给计算机时，转化位四个字节的整型数据，以点好（.）为分割。</p>
<h3 id="4-2-1、转换函数1"><a href="#4-2-1、转换函数1" class="headerlink" title="4-2-1、转换函数1"></a>4-2-1、转换函数1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inet_pton函数</span><br><span class="line"></span><br><span class="line">字符串ip转整型数据</span><br><span class="line"></span><br><span class="line">inet_ntop函数</span><br><span class="line">整型数据转字符串格式IP地址 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">/****************将字符串地址转化为电脑能识别的无符号整形数据**********************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ip[] = &quot;192.168.3.103&quot;;</span><br><span class="line">unsigned int unip = 0;</span><br><span class="line">unsigned int *nip = NULL;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;unip);</span><br><span class="line">printf(&quot;%d\r\n&quot;,unip);/******       一个字节一个字节的取出，不然看不懂       *********/</span><br><span class="line">nip = &amp;unip;</span><br><span class="line">printf(&quot;unip = %d.%d.%d.%d\r\n&quot;,*(nip),*(nip+1),*(nip+2),*(nip+3));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/////////////////////////////////</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">///////////////////////////////////////</span><br><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">1728293056</span><br><span class="line">unip = 1728293056.-1553161620.32767.959575536</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char nip[] = &#123;192,168,3,103&#125;;</span><br><span class="line">    char ip[16];</span><br><span class="line">    inet_ntop(AF_INET,&amp;nip,ip,16);</span><br><span class="line">printf(&quot;%s\r\n&quot;,ip);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    结果
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">192.168.3.103</span><br></pre></td></tr></table></figure>
<h4 id="地址转换："><a href="#地址转换：" class="headerlink" title="地址转换："></a>地址转换：</h4><p>•我们输入认为识别的ip地址是点分十进制的字符串形式，<br>但是计算机或者网络中识别的ip地址是整形数据，<br>所以需要转化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符串ip地址转整型数据</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_pton(int family,const char *strptr, void *addrptr);</span><br><span class="line">功能：</span><br><span class="line">将点分十进制数串转换成32位无符号整数</span><br><span class="line">参数：</span><br><span class="line">family 协议族</span><br><span class="line">AF_INET IPV4网络协议</span><br><span class="line">AF_INET6 IPV6网络协议</span><br><span class="line"> strptr 点分十进制数串</span><br><span class="line"> addrptr 32位无符号整数的地址</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功返回1</span><br><span class="line"> 失败返回其它</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ip_str[]=&quot;192.168.3.103&quot;;</span><br><span class="line">unsigned int ip_int = 0;</span><br><span class="line">unsigned char *ip_p = NULL;</span><br><span class="line">//将点分十进制ip地址转化为32位无符号整形数据</span><br><span class="line"> inet_pton(AF_INET,ip_str,&amp;ip_int);</span><br><span class="line"></span><br><span class="line"> printf(&quot;ip_int = %d\n&quot;,ip_int);</span><br><span class="line"></span><br><span class="line"> ip_p = (char *)&amp;ip_int;</span><br><span class="line"> printf(&quot;in_uint = %d,%d,%d,%d\n&quot;,*ip_p,*(ip_p+1),*(ip_p+2),*</span><br><span class="line">(ip_p+3));</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">整型数据转字符串格式ip地址</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">const char *inet_ntop(int family, const void *addrptr,</span><br><span class="line">char *strptr, size_t len);</span><br><span class="line">功能：</span><br><span class="line">将32位无符号整数转换成点分十进制数串</span><br><span class="line">参数：</span><br><span class="line">family 协议族</span><br><span class="line">addrptr 32位无符号整数</span><br><span class="line"> strptr 点分十进制数串</span><br><span class="line"> len strptr缓存区长度</span><br><span class="line"> len的宏定义</span><br><span class="line"> #define INET_ADDRSTRLEN 16 //for ipv4</span><br><span class="line"> #define INET6_ADDRSTRLEN 46 //for ipv6</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功:则返回字符串的首地址</span><br><span class="line"> 失败:返回NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char ip_int[]=&#123;192, 168, 3, 103&#125;;</span><br><span class="line">char ip_str[16] = &quot;&quot;; //&quot;192.168.3.103&quot;</span><br><span class="line">inet_ntop(AF_INET, &amp;ip_int, ip_str, 16);</span><br><span class="line"> printf(&quot;ip_s = %s\n&quot;, ip_str);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2、转换函数2"><a href="#4-2-2、转换函数2" class="headerlink" title="4-2-2、转换函数2"></a>4-2-2、转换函数2</h3><p>•inet_addr和inet_ntoa用的更多。只能用在ipv4上。比较重要。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这两个函数只能用在ipv4地址的转换</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">功能：将点分十进制ip地址转化为整形数据</span><br><span class="line">参数：</span><br><span class="line">cp：点分十进制的IP地址</span><br><span class="line">返回值：</span><br><span class="line"> 成功：整形数据</span><br><span class="line"></span><br><span class="line"> char *inet_ntoa(struct in_addr in);</span><br><span class="line"> 功能：将整形数据转化为点分十进制的ip地址</span><br><span class="line"> 参数：</span><br><span class="line"> in：保存ip地址的结构体</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：点分十进制的IP地址</span><br></pre></td></tr></table></figure>

<h1 id="5、udp"><a href="#5、udp" class="headerlink" title="5、udp"></a>5、udp</h1><p>•udp的应用：<br>dns域名解析，nfs网络文件系统，rtp流媒体</p>
<h2 id="5-1、网络编程接口socket"><a href="#5-1、网络编程接口socket" class="headerlink" title="5-1、网络编程接口socket"></a>5-1、网络编程接口socket</h2><pre><code>面向无连接的用户数据报协议，
在传输数据前不需要先建立连接；
目地主机的运输层收到
UDP报文后，
不需要给出任何确认
UDP特点
1、相比TCP速度稍快些
2、简单的请求/应答应用程序可以使用UDP
3、对于海量数据传输不应该使用UDP
4、广播和多播应用必须使用UDP
UDP应用
DNS(域名解析)、
NFS(网络文件系统)、
RTP(流媒体)等
一般语音和视频通话都是使用udp来通信的

    socket作用：
    
        提供不同主机上的进程之间的通讯

    socket 特点：
            1、socket也称“套接字”。

            2、是一种文件描述符，
            代表了一个个管道的端点。

            3、类似对文件的操作一样，
            可以使用read、write、close等函数对socket套接
            字进行网络数据的收取和发送等操作。

            4、得到socket套接字（描述符）的方法调用socket

    socket分类：

            1、SOCK_STREAM,流式套接字，用于tcp

            2、SOCK_DGRAM,数据报套接字，用于udp
            
            3、SOCK_RAW,原始套接字，
            对于其他层次的协议操作需要使用到这个类型
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/udp%E9%80%9A%E8%AE%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<pre><code>    编程流程：

    一、	服务器：
    1、创建套接字socket                                                             
    2、将服务器的ip地址、端口号与套接字进行绑定bind
    3、接收数据recvfrom
    4、发送数据sendto

    二、	客户端：

    1、创建套接字socket
    2、发送数据sendto
    3、	接收数据recvfrom
    4、	关闭套接字close

    服务器创建套接字默认属性是主动的，就是当发起服务请求；当作为服务器时，往往需要改成被动的。
</code></pre>
<h3 id="5-1-1-创建socket套接字"><a href="#5-1-1-创建socket套接字" class="headerlink" title="5-1-1 创建socket套接字"></a>5-1-1 创建socket套接字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 创建socket套接字</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">功能：创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">domain：通信域，协议族</span><br><span class="line">AF_UNIX 本地通信</span><br><span class="line">AF_INET ipv4网络协议</span><br><span class="line">AF_INET6 ipv6网络协议</span><br><span class="line"> AF_PACKET 底层接口</span><br><span class="line"> type：套接字的类型</span><br><span class="line"> SOCK_STREAM 流式套接字（tcp）</span><br><span class="line"> SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line"> SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line"> protocol：附加协议，如果不需要，则设置为0</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：文件描述符</span><br><span class="line"> 失败：‐1</span><br><span class="line">特点：</span><br><span class="line">创建套接字时，系统不会分配端口</span><br><span class="line">创建的套接字默认属性是主动的，</span><br><span class="line">即主动发起服务的请求;当作为服务器时，</span><br><span class="line">往往需要修改为被动的</span><br></pre></td></tr></table></figure>
<pre><code>案例：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用socket函数创建套接字</span><br><span class="line">//创建一个用于UDP网络编程的套接字</span><br><span class="line"> int sockfd;</span><br><span class="line"> if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to socket&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;sockfd = %d\n&quot;, sockfd);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BAsocket%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<h2 id="5-2、ipv4套接字的地址结构"><a href="#5-2、ipv4套接字的地址结构" class="headerlink" title="5-2、ipv4套接字的地址结构"></a>5-2、ipv4套接字的地址结构</h2><pre><code>    再网络编程中，
    为了使不同格式的地址能够被传入套接字函数，
    地址需要强制转换成通用套接字地址结构，
    原因是因为不同的场合所使用的结构体不一样，
    但是调用的函数却是同一个，
    所以定义一个通用的结构体，
    在指定场合使用时，
    再根据要求传入指定的结构体就行。

在网络编程中经常使用的结构体sockaddr_in
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">头文件#include &lt;netinet/in.h&gt;</span><br><span class="line">struct in_addr</span><br><span class="line">&#123;</span><br><span class="line">in_addr_t s_addr; //ip地址，4个字节</span><br><span class="line">&#125;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">sa_famila_t sin_family ;//协议族2个字节</span><br><span class="line">in_port sin_port ;//端口号 2个字节</span><br><span class="line">struct in_addr sin_addr;//ip地址 4个字节</span><br><span class="line">char sin_zero[8];填充不起什么作用 8字节</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面这个是通用结构体</span><br><span class="line">struct sockaddr</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sa_family; //2字节</span><br><span class="line">char sa_data[14]//14字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种地址结合"><a href="#两种地址结合" class="headerlink" title="两种地址结合"></a>两种地址结合</h4><pre><code>在定义源地址和目的地址结构的时候，选用struct sockaddr_in;
例：
struct sockaddr_in my_addr;
当调用编程接口函数，且该函数需要传入地址结构时需要用struct sockaddr进行强制转换
例：
bind(sockfd,(struct sockaddr*)&amp;my_addr,sizeof(my_addr));

    注意事项：

    1、在定义源地址和目的地址结构的时候，选用struct  sockaddr_in。
    如：struct sockaddr_in my_addr;

    2、当调用编程接口函数，且该函数需要传入地址结构时需要用struct sockaddr进行强制转换。
    如：bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(my_addr))
</code></pre>
<h2 id="5-3、服务器向客户端发送数据"><a href="#5-3、服务器向客户端发送数据" class="headerlink" title="5-3、服务器向客户端发送数据"></a>5-3、服务器向客户端发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /******************  第二步 ：填充服务器网络信息结构体  sockaddr——in  *************/</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /************ ip地址转化为整形  ************/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h6 id="1、发送数据—sendto函数"><a href="#1、发送数据—sendto函数" class="headerlink" title="1、发送数据—sendto函数"></a>1、发送数据—sendto函数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span><br><span class="line">const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">功能：发送数据</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line">buf：要发送的数据</span><br><span class="line">len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> dest_addr：目的网络信息结构体（需要自己指定要给谁发送）</span><br><span class="line"> addrlen：dest_addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<h2 id="5-4、绑定–bind函数"><a href="#5-4、绑定–bind函数" class="headerlink" title="5-4、绑定–bind函数"></a>5-4、绑定–bind函数</h2><pre><code>    由于服务器是被动的，
    客户端时主动的，
    客户端要找到服务器才能通讯，
    一般不需要要bind绑定，
    只有服务器才需要bind绑定。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：将套接字与网络信息结构体绑定</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line">addr：网络信息结构体</span><br><span class="line">通用结构体（一般不用）</span><br><span class="line">struct sockaddr</span><br><span class="line"> 网络信息结构体 sockaddr_in</span><br><span class="line"> #include &lt;netinet/in.h&gt;</span><br><span class="line"> struct sockaddr_in</span><br><span class="line"> addrlen：addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    给定的IP必须与服务器IP一致，不然就会发生报错。
</code></pre>
<h2 id="5-5、接收数据-recvfrom"><a href="#5-5、接收数据-recvfrom" class="headerlink" title="5-5、接收数据-recvfrom"></a>5-5、接收数据-recvfrom</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line">功能：接收数据</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line">buf：保存接收的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> src_addr：源的网络信息结构体（自动填充，定义变量传参即可）</span><br><span class="line"> addrlen：src_addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：接收的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<h2 id="5-6、客户端向服务器发送数据"><a href="#5-6、客户端向服务器发送数据" class="headerlink" title="5-6、客户端向服务器发送数据"></a>5-6、客户端向服务器发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 128</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************接收客户端发送的数据*********************/</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(recvfrom(sockfd,buf,N,0,(struct sockaddr *)&amp;clientaddr,&amp;addrlen) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;recvfrom_faile&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        /*******s_addr在计算机中是个32为的无符号的整数，需要转为点分十进制整数   inet_ntoa与其他转换函数不同，直接传结构体就可以*********/</span><br><span class="line">    printf(&quot;ip:%s  port:%d\r\n&quot;,inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));</span><br><span class="line">    printf(&quot;from client:%s\n&quot;,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-7、c-s架构"><a href="#5-7、c-s架构" class="headerlink" title="5-7、c&#x2F;s架构"></a>5-7、c&#x2F;s架构</h2><pre><code>•在上面两个例子中发送数据的是client，接收数据的是server，
其实在网络开发中，client和server都可以收发数据，只是一
般认为吧提供服务的一方称为server，接受服务的一方称为client。
</code></pre>
<h2 id="5-8、udp客户端注意点"><a href="#5-8、udp客户端注意点" class="headerlink" title="5-8、udp客户端注意点"></a>5-8、udp客户端注意点</h2><pre><code>1、本地ip、本地端口（我是谁）。
2、目的ip、目的端口（发给谁）。
3、在客户端的代码中、本地port是我们调用sendto的时候linux
系统自动给客户端分配的，分配端口的方式为随机分配，即
每次运行系统给的port不一样。
客户端信息可以指定，也可以不指定，一般不需要。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /*****  第二步 ：填充服务器网络信息结构体  sockaddr——in  *******/</span><br><span class="line">/******一般不需要******/</span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /******** ip地址转化为整形  *********/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-9、服务器注意点"><a href="#5-9、服务器注意点" class="headerlink" title="5-9、服务器注意点"></a>5-9、服务器注意点</h2><pre><code>1、服务器之所以bind是因为它的本地port需要固定，
不能是随机的。
2、服务器也可以主动给客户端发送信息。
3、客户端也可以使用bind绑定，
这样客户端的本地端口就固定了，
但是一般不这样做。
</code></pre>
<h2 id="5-10、TFTP协议"><a href="#5-10、TFTP协议" class="headerlink" title="5-10、TFTP协议"></a>5-10、TFTP协议</h2><pre><code>    tftp：简单文本传送协议（传输小文件，基于udp）。
    ftp：文件传输协议（传输大文件，基于tcp）。
    
    数据传输模式：
    octet：二进制模式。
    netascii：文本模式。
    tftp协议：端口号port 69。
    
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TFTP%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B.png"></p>
<pre><code>tftp通讯总结：
    1、服务器在69号端口等待客户端请求。
    2、服务器若批准此请求，则使用临时端口与客户端进行通信。
    3、每个数据包的编号都有变化（从1开始）。
    4、每个数据包都要得到ACK的缺认，如果出现超时，则需要
    重新发送最够的包（数据或者ACK）。
    5、数据包的长度以521byte传输。
    6、小于512byte的数据意味着传输结束。
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TFTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.png"></p>
<pre><code>    以上的0代表的是‘\0’。不同的差错码对应不同的错误信息。
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E9%94%99%E8%AF%AF%E7%A0%81.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">错误码：</span><br><span class="line">0 未定义,参见错误信息</span><br><span class="line">1 File not found.</span><br><span class="line">2 Access violation.</span><br><span class="line">3 Disk full or allocation exceeded.</span><br><span class="line">4 illegal TFTP operation.</span><br><span class="line">5 Unknown transfer ID.</span><br><span class="line">6 File already exists.</span><br><span class="line">7 No such user.</span><br><span class="line">8 Unsupported option(s) requested.</span><br></pre></td></tr></table></figure>

<h2 id="5-11、使用TFTP下载"><a href="#5-11、使用TFTP下载" class="headerlink" title="5-11、使用TFTP下载"></a>5-11、使用TFTP下载</h2><pre><code>要求：使用tftp协议，下载server上的文件到本地。
思路：
    1、构造请求报文，发送到69端口。
    2、等待服务器回应。
    3、分析服务器回应。
    4、接收数据，直到数据小于512字节。
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BD%BF%E7%94%A8TFTP%E4%B8%8B%E8%BD%BD.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  /**** printf ***/</span><br><span class="line">#include &lt;stdlib.h&gt; /**  exit  **/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt; /** socket **/</span><br><span class="line">#include &lt;sys/socket.h&gt; /**  sockaddr_in **/</span><br><span class="line">#include &lt;arpa/inet.h&gt; /** htons inet_addr **/</span><br><span class="line">#include &lt;unistd.h&gt; /** close**/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">void download(int sockfd,struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[128] = &quot;&quot;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名:\r\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,filename);</span><br><span class="line">    unsigned char text[1024] = &quot;&quot;;</span><br><span class="line">    int text_len;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num =0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    /********* 构建发给服务器的tftp指令，如：01test.txt0octet0 ***************/</span><br><span class="line">    text_len = sprintf(text,&quot;%c%c%s%c%s%c&quot;,0,1,filename,0,&quot;octet&quot;,0);//////////////////</span><br><span class="line">    if(sendto(sockfd,text,text_len,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to sendto&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /*** 接收服务器发来的信息并处理****/</span><br><span class="line">        bytes = recvfrom(sockfd,text,sizeof(text),0,(struct sockaddr *)&amp;serveraddr,&amp;addrlen);</span><br><span class="line">        if(bytes == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;recvfrom_filed&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /*** 判断操作码*****/</span><br><span class="line">        if(text[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;error:%s\n&quot;,text+4);</span><br><span class="line">        return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(text[1] == 3)</span><br><span class="line">       &#123;</span><br><span class="line">         &#123;</span><br><span class="line">            if(flags == 0)/*** 创建文件的，flags为标志位，防止重复创建***/</span><br><span class="line">            &#123;/**创建文件***/</span><br><span class="line">                if((fd = open(filename,O_WRONLY | O_CREAT | O_TRUNC,0664)) &lt; 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;failed_open&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flags = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        /**  对比块编号和接收的数据大小并将文件内容写入文件***/</span><br><span class="line">        if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes == 516))/** 接收到的数据包还要加上操作码和块编号，所以是516 ***/</span><br><span class="line">            &#123;</span><br><span class="line">                num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen))</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to send&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes &lt; 516))/**判断是否是最后一次传输**/</span><br><span class="line">            &#123; </span><br><span class="line">                 num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">                   &#123;</span><br><span class="line">                        perror(&quot;failed_sento&quot;);</span><br><span class="line">                        exit(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                printf(&quot;文件下载完成\r\n&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125; </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /** 创建套接字 **/</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sockfd_fail\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*** 填充服务器信息结构体 **/</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);/*** tftp服务器端地址 ***/</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line">   // if(bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof(serveraddr)) == -1)</span><br><span class="line">   // &#123;</span><br><span class="line">    //    perror(&quot;bind_fail\r\n&quot;);</span><br><span class="line">   //    exit(1);   </span><br><span class="line">   // &#125;</span><br><span class="line">    /*** 下载 ***/</span><br><span class="line">    download(sockfd,serveraddr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>以下是上传服务器的代码
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">上传服务器</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERRLOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line"></span><br><span class="line">void do_help()</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">    printf(&quot;------ 1. 下载 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 2. 上传 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 3. 退出 ------\n&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_download(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    char data[1024] = &quot;&quot;;</span><br><span class="line">    int data_len;</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int recv_len;</span><br><span class="line"></span><br><span class="line">    //组数据并发送</span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 1, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收数据并分析处理</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %u\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;error: %s\n&quot;, data + 4);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(data[1] == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            //防止文件内容清空</span><br><span class="line">            if(flags == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                flags = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断数据包的编号是否是上一次的编号加1</span><br><span class="line">            if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len == 516)</span><br><span class="line">            &#123;</span><br><span class="line">                //向文件写入数据</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">            </span><br><span class="line">                //组数据发送给服务器</span><br><span class="line">                data[1] = 4; </span><br><span class="line">                if(sendto(sockfd, data, 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                num = ntohs(*(unsigned short *)(data + 2));</span><br><span class="line">            &#125;</span><br><span class="line">            //接收到的最后一次的数据</span><br><span class="line">            else if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len &lt; 516)</span><br><span class="line">            &#123;</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件下载成功\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_upload(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要上传的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    //打开文件并判断文件是否存在</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(filename, O_RDONLY)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(errno == ENOENT)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;文件%s不存在，请重新输入\n&quot;, filename);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //组数据并发送给服务器执行上传功能</span><br><span class="line">    char data[1024] = &#123;&#125;;</span><br><span class="line">    int data_len;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 2, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line"></span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收服务器发送的数据并分析处理</span><br><span class="line">    int recv_len;</span><br><span class="line">    int num = 0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %d\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 4 &amp;&amp; num == ntohs(*(unsigned short *)(data + 2)))</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            bytes = read(fd, data + 4, 512);</span><br><span class="line">            data[1] = 3;</span><br><span class="line">            *(unsigned short *)(data + 2) = htons(num);</span><br><span class="line"></span><br><span class="line">            if(bytes == 512)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件上传完毕\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    //创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line"></span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;----请输入help查看帮助信息----\n&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;&gt;&gt;&gt; &quot;);</span><br><span class="line"></span><br><span class="line">    char buf[N] = &#123;&#125;;</span><br><span class="line">NEXT:</span><br><span class="line">    fgets(buf, N, stdin);</span><br><span class="line">    buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">    if(strncmp(buf, &quot;help&quot;, 4) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        do_help();</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">        goto NEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;input&gt;&gt;&gt; &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        switch (num)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            do_download(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            do_upload(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            close(sockfd);</span><br><span class="line">            exit(0);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6、udp广播"><a href="#6、udp广播" class="headerlink" title="6、udp广播"></a>6、udp广播</h1><p>•广播：<br>由一台主机向该主机所在子网内的所有主机发送数据的方式。<br>广播只能用 UDP 或原始 IP 实现， 不能用 TCP。</p>
<p>•用途：<br>单个服务器与多个客户主机通信时减少分组流通。<br>以下几个协议都用到广播<br>1、 地址解析协议（ARP）。<br>2、 动态主机配置协议（DHCP）。<br>3、 网络时间协议（NTP）。  </p>
<p>•特点：<br>1、 处于同一子网的所有主机都必须处理数据。<br>2、 UDP 数据包会沿协议栈向上一直到 UDP 层。<br>3、 运行音视频等较高速率工作的应用， 会带来大负担。<br>4、 局限于局域网内使用。  </p>
<p>•地址：<br>{网络 ID， 主机 ID}<br>网络 ID 表示由子网掩码中 1 覆盖的连续位。<br>主机 ID 表示由子网掩码中 0 覆盖的连续位。<br>定向广播地址： 主机 ID 全 1<br>1、 例： 对于 192.168.220.0&#x2F;24，<br>其定向广播地址为 192.168.220.255。<br>2、 通常路由器不转发该广播<br>受限广播地址： 255.255.255.255，<br>路由器从不转发该广播。  </p>
<p>•广播流程：<br>    发送者：<br>    第一步：创建套接字 socket()<br>    第二步：设置为允许发送广播权限 setsockopt()<br>    第三步：向广播地址发送数据 sendto()<br>    接收者：<br>    第一步：创建套接字 socket()<br>    第二步：将套接字与广播的信息结构体绑定 bind()<br>    第三步：接收数据 recvfrom()  </p>
<h2 id="6-1、单播"><a href="#6-1、单播" class="headerlink" title="6-1、单播"></a>6-1、单播</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%8D%95%E6%92%AD.png"></p>
<h2 id="6-2、广播"><a href="#6-2、广播" class="headerlink" title="6-2、广播"></a>6-2、广播</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B9%BF%E6%92%AD.png"></p>
<h2 id="6-3、广播流程"><a href="#6-3、广播流程" class="headerlink" title="6-3、广播流程"></a>6-3、广播流程</h2><p>•发送者：<br>        第一步：创建套接字 socket()<br>        第二步：设置为允许发送广播权限 setsockopt()<br>        第三步：向广播地址发送数据 sendto()<br>•接收者：<br>        第一步：创建套接字 socket()	  	<br>        第二步：将套接字与广播的信息结构体绑定 bind()<br>        第三步：接收数据 recvfrom()  </p>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B9%BF%E6%92%AD%E8%AE%BE%E7%BD%AE%E5%A5%97%E6%8E%A5%E5%AD%97.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">套接字选项</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int socket, int level, int option_name,</span><br><span class="line">const void *option_value, socklen_t option_len);</span><br><span class="line">功能：设置一个套接字的选项（属性）</span><br><span class="line">参数：</span><br><span class="line">socket：文件描述符</span><br><span class="line">level：协议层次</span><br><span class="line">SOL_SOCKET 套接字层次</span><br><span class="line">IPPROTO_TCP tcp层次</span><br><span class="line"> IPPROTO_IP IP层次</span><br><span class="line"> option_name：选项的名称</span><br><span class="line"> SO_BROADCAST 允许发送广播数据（SOL_SOCKET层次的）</span><br><span class="line"> option_value：设置的选项的值</span><br><span class="line"> int类型的值，存储的是bool的数据（1和0）</span><br><span class="line"> 0 不允许</span><br><span class="line"> 1 允许</span><br><span class="line"> option_len：option_value的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<h3 id="6-3-1、发送者"><a href="#6-3-1、发送者" class="headerlink" title="6-3-1、发送者"></a>6-3-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//广播发送者代码实现</span><br><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(sendaddr);</span><br><span class="line">    int on = 1;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET , SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**SOL_SOCKET：协议层次**/</span><br><span class="line">    /** SO_BROADCAST：允许发送广播权限**/</span><br><span class="line">    /**on：设置是否允许，设置为1表示允许，0表示不允许**/</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST,&amp;on,sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sersockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**绑定广播结构体**/    </span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /**进行通讯**/</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,sizeof(buf),stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;; /**将输入完的数据用 \0 结尾**/</span><br><span class="line">        if(sendto(sockfd, buf, sizeof(buf), 0,(struct sockaddr *)&amp;sendaddr, addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2、接收者"><a href="#6-3-2、接收者" class="headerlink" title="6-3-2、接收者"></a>6-3-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in broadrecv;</span><br><span class="line">    socklen_t socklen;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /**填充信息结构体**/</span><br><span class="line">    broadrecv.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    broadrecv.sin_family = AF_INET;</span><br><span class="line">    broadrecv.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    /**将信息结构体与结构体绑定**/</span><br><span class="line">    socklen = sizeof(broadrecv);</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;broadrecv,socklen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;/**这里还要在申请的原因是要那来接受发送者的信息**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, buf, sizeof(buf), 0 ,(struct sockaddr *)&amp;sendaddr, &amp;socklen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">       //     exit(1);</span><br><span class="line">        &#125; </span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;, inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<pre><code>    接收者只能有一个，发送者可以有多个。
</code></pre>
<h1 id="7、多播"><a href="#7、多播" class="headerlink" title="7、多播"></a>7、多播</h1><h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7-1、概念"></a>7-1、概念</h2><p>•数据的收发只在同一分组中进行。所以多播又称之为组播。<br>    多播的特点：<br>        1、多播地址标示一组接口。<br>        2、多播可以用于广域网使用。<br>        3、在ipv4中，多播是可选的。<br>•广播和多播的区别：广播是向所有的人发送。而多播必须加入多播组</p>
<h2 id="7-1、多播地址"><a href="#7-1、多播地址" class="headerlink" title="7-1、多播地址"></a>7-1、多播地址</h2><pre><code>•ipv4的D类地址是多播地址。
•多播地址向以太网mac地址的映射：
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png"></p>
<pre><code>    ipv4由32个字节构成，后23位组成以太网的都多播地址的底序23位，然后补一位0。
    广播的发送者必须要设置允许发送广播，而多播必须加入多播组，才能接收到信息。
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%8F%91%E9%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>•注意：mac地址后23位由ipv4的后23位构成，<br>    在接收者进行mac地址过滤的时候，进行的是不完全过滤，<br>    原因就在于23位前面有一位被指0，导致可能的错误，所以会在ipv4进行再次的过滤。<br>    比起广播，多播具有可控性，<br>    只有加入多播组的接收者才能接收数据。  </p>
<h2 id="7-2、多播的流程"><a href="#7-2、多播的流程" class="headerlink" title="7-2、多播的流程"></a>7-2、多播的流程</h2><p>•发送者：<br>        第一步：创建套接字socket。<br>        第二步：向多播地址发送数据sendto。<br>•接收者：<br>        第一步：创建套接字socket。<br>        第二步：设置为加入多播组setsockopt（）。<br>        第三步：将套接字与多播信息结构体绑定。<br>        第四步：接收数据。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多播地址结构体名字</span><br><span class="line">struct in_addr；</span><br><span class="line"></span><br><span class="line">struct ip_mreq;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%8F%82%E6%95%B0.png"><br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%8F%82%E6%95%B02.png"></p>
<h3 id="7-2-0、-多播套接口选项"><a href="#7-2-0、-多播套接口选项" class="headerlink" title="7-2-0、 多播套接口选项"></a>7-2-0、 多播套接口选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int socket, int level, int option_name,</span><br><span class="line">const void *option_value, socklen_t option_len);</span><br><span class="line">功能：设置一个套接字的选项（属性）</span><br><span class="line">参数：</span><br><span class="line">socket：文件描述符</span><br><span class="line">level：协议层次</span><br><span class="line">IPPROTO_IP IP层次</span><br><span class="line">option_name：选项的名称</span><br><span class="line"> IP_ADD_MEMBERSHIP 加入多播组</span><br><span class="line"> option_value：设置的选项的值</span><br><span class="line"> struct ip_mreq</span><br><span class="line"> &#123;</span><br><span class="line"> struct in_addr imr_multiaddr; //组播ip地址</span><br><span class="line"> struct in_addr imr_interface; //主机地址</span><br><span class="line"> INADDR_ANY 任意主机地址（自动获取你的主机地址）</span><br><span class="line"> &#125;;</span><br><span class="line"> option_len：option_value的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>


<h3 id="7-2-1、发送者"><a href="#7-2-1、发送者" class="headerlink" title="7-2-1、发送者"></a>7-2-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using : %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**第一步，创建套接字**/</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    /********* ip地址必须设置为224.xxx.xxx.xxx 到239.... *********/</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    addrlen = sizeof(sendaddr);</span><br><span class="line">    /**发送数据**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, sizeof(buf),stdin);</span><br><span class="line">        buf[sizeof(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;sendaddr,addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-2、接收者"><a href="#7-2-2、接收者" class="headerlink" title="7-2-2、接收者"></a>7-2-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in recaddr;</span><br><span class="line">    </span><br><span class="line">    /***创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /***加入多播组**/</span><br><span class="line">    struct ip_mreq mreq;</span><br><span class="line">    mreq.imr_multiaddr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    /** INADDR_ANY表示任意主机**/</span><br><span class="line">    mreq.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    if(setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_setsockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    recaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    recaddr.sin_family = AF_INET;</span><br><span class="line">    recaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    addrlen = sizeof(recaddr);</span><br><span class="line">    /**绑定组播信息结构体**/</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;recaddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /** 进行通信***/</span><br><span class="line">    char text[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, text, sizeof(text), 0 , (struct sockaddr *)&amp;sendaddr,&amp;addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;,inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="8、tcp"><a href="#8、tcp" class="headerlink" title="8、tcp"></a>8、tcp</h1><h2 id="8-1、tcp与udp对比"><a href="#8-1、tcp与udp对比" class="headerlink" title="8-1、tcp与udp对比"></a>8-1、tcp与udp对比</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcp%E4%B8%8Eudp%E7%9A%84%E5%AF%B9%E6%AF%94.png"><br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcp%E4%B8%8Eudp%E7%9A%84%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94.png"></p>
<h2 id="8-2、流程"><a href="#8-2、流程" class="headerlink" title="8-2、流程"></a>8-2、流程</h2><p>•服务器：<br>    创建套接字socket（）。<br>        将套接字与服务器网络信息结构体绑定。<br>        将套接字设置为监听状态listen（）。<br>        阻塞等待客户端的连接请求accept（）。<br>        进行通信recv（）&#x2F;send（）。<br>        关闭套接字close（）。  </p>
<p>•客户端：<br>        创建套接字socket（）。<br>        发送客户端连接请求connect（）。<br>        进行通信send（）&#x2F;recv（）。<br>        关闭套接字close。   </p>
<pre><code>1、这里的socket的要使用的tcp的参数。
2、connect作用是跟服务器建立连接，
    连接成功后才可以进行tcp的数据传输。
    连接成功后不会产生新的套接字。
3、send函数，ssize_t send(int sockfd, const void *buf, size_t len, int flags);
功能用于发送数据。
    
以下为各个函数的详细介绍：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">功能：创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">domain：通信域，协议族</span><br><span class="line">AF_UNIX 本地通信</span><br><span class="line">AF_INET ipv4网络协议</span><br><span class="line">AF_INET6 ipv6网络协议</span><br><span class="line"> AF_PACKET 底层接口</span><br><span class="line"> type：套接字的类型</span><br><span class="line"> SOCK_STREAM 流式套接字（tcp）</span><br><span class="line"> SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line"> SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line"> protocol：附加协议，如果不需要，则设置为0</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：文件描述符</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">connect：</span><br><span class="line">	connect函数：</span><br><span class="line"> #include &lt;sys/types.h&gt; </span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"> 功能：给服务器发送客户端的连接请求</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符，socket函数的返回值</span><br><span class="line"> addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line"> addrlen：add的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>注意：
    1、connect建立连接之后不会产生新的套接字
    2、连接成功后才可以开始传输TCP数据
    3、头文件：#include &lt;sys/socket.h&gt;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socket</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"> 功能：发送数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：发送的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>    注意：不能用tcp协议发送0长度的数据包。
    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">send：</span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"> 功能：发送数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line">客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：发送的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<p><code>不能用TCP协议发送0长度的数据包</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">recv：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"> 功能：接收数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：保存接收到的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line">成功：接收的字节数</span><br><span class="line"> 失败：‐1</span><br><span class="line"> 如果发送端关闭文件描述符或者关闭进程，则recv函数会返回0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bind：</span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"> 功能：将套接字与网络信息结构体绑定</span><br><span class="line"> 参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line"> addr：网络信息结构体</span><br><span class="line"> 通用结构体（一般不用）</span><br><span class="line"> struct sockaddr</span><br><span class="line"> 网络信息结构体 sockaddr_in</span><br><span class="line"> #include &lt;netinet/in.h&gt;</span><br><span class="line"> struct sockaddr_in</span><br><span class="line"> addrlen：addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen：</span><br><span class="line"> #include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int listen(int sockfd, int backlog);</span><br><span class="line"> 功能：将套接字设置为被动监听状态，这样做之后就可以接收到连接请求</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符，socket函数返回值</span><br><span class="line"> backlog：允许通信连接的主机个数，一般设置为5、10</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">accept：</span><br><span class="line"> #include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line"> 功能：阻塞等待客户端的连接请求</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符，socket函数的返回值</span><br><span class="line"> addr：接收到的客户端的信息结构体（自动填充，定义变量即可）</span><br><span class="line"> addrlen：addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，</span><br><span class="line"> 这个新的文件描述符专门与指定的客户端进行通信的）</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<h3 id="8-2-1、客户端"><a href="#8-2-1、客户端" class="headerlink" title="8-2-1、客户端"></a>8-2-1、客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">客户端代码示例</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /***SOCK_STREAM TCP的流式套接字***/</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t socklen;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    socklen = sizeof(serveraddr);</span><br><span class="line">    if(connect(sockfd,(struct sockaddr *)&amp;serveraddr,socklen) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_connect&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    fgets(buf, 128, stdin);</span><br><span class="line">    buf[sizeof(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">    if(send(sockfd, buf, 128, 0) == -1)</span><br><span class="line">    &#123; </span><br><span class="line">        perror(&quot;failed_send&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char text[128] = &quot;&quot;;</span><br><span class="line">    if(recv(sockfd, text, 128, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_recv&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;from server: %s\r\n&quot;,text);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="8-2-2、服务器"><a href="#8-2-2、服务器" class="headerlink" title="8-2-2、服务器"></a>8-2-2、服务器</h3><pre><code>做为TCP服务器需要具备那些条件
1、让操作系统知道是一个服务器，而不是一个客户端。
2、具备一个明知的地址。
3、等待连接的到来。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">     if(argc &lt; 3)</span><br><span class="line">     &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     int sockfd;</span><br><span class="line">     sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">     if(sockfd &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     struct sockaddr_in serveraddr;</span><br><span class="line">     socklen_t socklen;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">     serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">     socklen = sizeof(serveraddr);</span><br><span class="line">     if(bind(sockfd,(struct sockaddr *)&amp;serveraddr,socklen))</span><br><span class="line">     &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     /***将套接字设置为监听状态***/</span><br><span class="line">     /***同一时刻连接的最大数量******/</span><br><span class="line">     if(listen(sockfd,10))</span><br><span class="line">     &#123;</span><br><span class="line">        perror(&quot;failed_listen&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     /****阻塞等待客户端的链接请求****/</span><br><span class="line">     int acceptfd;</span><br><span class="line">     struct sockaddr_in clientaddr;</span><br><span class="line">     acceptfd = accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;socklen);</span><br><span class="line">     if(acceptfd == -1)</span><br><span class="line">     &#123;  </span><br><span class="line">        perror(&quot;failed_accept&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     /***打印连接的客户端信息****/</span><br><span class="line">     printf(&quot;ip:%s, port = %d&quot;,inet_ntoa(clientaddr.sin_addr),htons(clientaddr.sin_port));</span><br><span class="line">     /****进行通讯*******/</span><br><span class="line">     /**tcp服务器与客户端通信时，需要使用accept函数返回值***/</span><br><span class="line">    char buf[128] =  &quot;&quot;;</span><br><span class="line">    if(recv(acceptfd, buf, 128,0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_recv&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    strcat(buf,&quot;__ygc&quot;);</span><br><span class="line">    printf(&quot;from client : %s\r\n&quot;,buf);</span><br><span class="line">    if(send(acceptfd, buf, 128, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_send&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**关闭套接字**/</span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<pre><code>运行是先运行服务器，进入阻塞等待连接等过程。然后在运行客户端。
</code></pre>
<h2 id="8-3、-close关闭套接字"><a href="#8-3、-close关闭套接字" class="headerlink" title="8-3、 close关闭套接字"></a>8-3、 close关闭套接字</h2><p>•1、使用close函数即可关闭套接字<br><code>关闭一个代表已连接套接字将导致另一端接收到一个0长度的数据包（很重要）。</code><br>•2、做服务器时<br>1&gt;关闭监听套接字将导致服务器无法接收新的连接，但不会影响已经建立的连接。<br>（关闭sockfd，并不影响已经建立的连接）<br>2&gt;关闭accept返回的已连接套接字将导致它所代表的连接被关闭，但不会影响服务器的监听<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/close%E5%85%B3%E9%97%AD%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%9B%91%E5%90%AC.png"><br>•3、做客户端时<br>关闭连接就是关闭连接，不意味着其他</p>
<h2 id="8-4、三次握手"><a href="#8-4、三次握手" class="headerlink" title="8-4、三次握手"></a>8-4、三次握手</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p>
<pre><code>相当于客户端向服务器说我要连接，服务器回答可以，	
然后接受连接，问客户端，你连接上了吗？
客户端回答连接上了。
</code></pre>
<h2 id="8-5、四次挥手"><a href="#8-5、四次挥手" class="headerlink" title="8-5、四次挥手"></a>8-5、四次挥手</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<pre><code>（客户端说我要关闭了，服务器说知道了，	
    服务器又发那我也关了，客户端回答好的）
</code></pre>
<h1 id="9、tpc并发服务器"><a href="#9、tpc并发服务器" class="headerlink" title="9、tpc并发服务器"></a>9、tpc并发服务器</h1><pre><code>TCP原本不是并发服务器，
TCP服务器同一时间只能与一个客户端通信
原始代码：
</code></pre>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">//tcp服务器的实现</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line">#define ERR_LOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    int sockfd, acceptfd;</span><br><span class="line">    struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    //第一步：创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将套接字设置为允许重复使用本机地址或者设置为端口复用</span><br><span class="line">    int on = 1;</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二步：填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：将套接字设置为被动监听状态</span><br><span class="line">    if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第五步：阻塞等待客户端的连接请求</span><br><span class="line">    if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印客户端的信息</span><br><span class="line">    printf(&quot;%s -- %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    //第六步：进行通信</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        //注意：tcp中服务器与客户端通信时，一定要用accept函数的返回值来通信</span><br><span class="line">        if((bytes = recv(acceptfd, buf, N, 0)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(bytes == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;The client quited\n&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;from client: %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">        strcat(buf, &quot; ^_^&quot;);</span><br><span class="line">        if(send(acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //第七步：关闭套接字</span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 128  //这里的\是连接符，工作了这么久竟然不知</span><br><span class="line">#define ERR_LOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">    //第一步：创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二步：填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    //第三步：发送客户端连接请求</span><br><span class="line">    if(connect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to connect&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：进行通信</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, N, stdin);</span><br><span class="line">        buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">        if(send(sockfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(recv(sockfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;from server: %s\n&quot;, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：关闭套接字</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>以上，代码可以证明测试。tcp并不是一个并发服务器，一次只能和一个客户端进行通信。
原因：TCP不能实现并发的原因：
由于TCP服务器端有两个读阻塞函数，accept和recv，两个函数需要先后运行，所以导致运
行一个函数的时候另一个函数无法执行，所以无法保证一边连接客户端，一边与其他客户端
通信
如何实现TCP并发服务器：
使用多进程实现TCP并发服务器
使用多线程实现TCP并发服务器
</code></pre>
<h2 id="9-1、使用进程实现并发服务器操作"><a href="#9-1、使用进程实现并发服务器操作" class="headerlink" title="9-1、使用进程实现并发服务器操作"></a>9-1、使用进程实现并发服务器操作</h2><pre><code>我们设想,要实现并发操作，这个进程fork在哪里去实现，将while的循环位置前移，
进入父进程什么都不用去执行，目标只要创建一个子进程就足够。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int sockfd = socket()</span><br><span class="line">bind()</span><br><span class="line">listen()</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line">		 acceptfd = accept() ;</span><br><span class="line">		pid = fork();</span><br><span class="line">		if(pid &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	 else if(pid == 0)</span><br><span class="line">	 &#123;</span><br><span class="line">	 while(1)</span><br><span class="line">	 &#123;</span><br><span class="line">	 recv()/send()</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">这个是基本流程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">//使用多进程实现TCP并发服务器</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line">#define ERR_LOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    wait(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    int sockfd, acceptfd;</span><br><span class="line">    struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    //第一步：创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将套接字设置为允许重复使用本机地址或者为设置为端口复用</span><br><span class="line">    int on = 1;</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二步：填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：将套接字设置为被动监听状态</span><br><span class="line">    if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用信号，异步的方式处理僵尸进程，如果出现子进程断开连接的情况，就进行回收进程资源</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        //第五步：阻塞等待客户端的连接请求</span><br><span class="line">        if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //打印客户端的信息</span><br><span class="line">        printf(&quot;%s -- %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        //使用fork函数创建子进程，父进程继续负责连接，子进程负责与客户端通信</span><br><span class="line">        pid_t pid;</span><br><span class="line">        if((pid = fork()) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to fork&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pid &gt; 0) //父进程负责执行accept，所以if语句结束后继续在accept函数的位置阻塞</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        else //子进程负责跟指定的客户端通信</span><br><span class="line">        &#123;</span><br><span class="line">            char buf[N] = &quot;&quot;;</span><br><span class="line">            ssize_t bytes;</span><br><span class="line">            while (1)</span><br><span class="line">            &#123;</span><br><span class="line">                if((bytes = recv(acceptfd, buf, N, 0)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(bytes == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;The client quited\n&quot;);</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                printf(&quot;from client: %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">                strcat(buf, &quot; ^_^&quot;);</span><br><span class="line">                if(send(acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B9%B6%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
<pre><code>完美实现
</code></pre>
<h2 id="9-2、使用多线程实现并发操作"><a href="#9-2、使用多线程实现并发操作" class="headerlink" title="9-2、使用多线程实现并发操作"></a>9-2、使用多线程实现并发操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    recv() / send()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockfd = socket()</span><br><span class="line"> bind()</span><br><span class="line"> listen()</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    accept()</span><br><span class="line">    //只要有客户端连接上，则创建一个子线程与之通信</span><br><span class="line">    pthread_create(, , thread_fun, );</span><br><span class="line">    pthread_detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"> #include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"> #define N 128</span><br><span class="line"> #define ERR_LOG(errmsg) do&#123;\</span><br><span class="line"> perror(errmsg);\</span><br><span class="line"> exit(1);\</span><br><span class="line"> &#125;while(0)</span><br><span class="line"></span><br><span class="line"> typedef struct&#123;</span><br><span class="line"> struct sockaddr_in addr;</span><br><span class="line"> int acceptfd;</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> void *pthread_fun(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char buf[N] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> MSG msg = *(MSG *)arg;</span><br><span class="line"> while (1)</span><br><span class="line">    &#123;</span><br><span class="line">    if((bytes = recv(msg.acceptfd, buf, N, 0)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    else if(bytes == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;The client quited\n&quot;);</span><br><span class="line">        pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;The client quited\n&quot;);</span><br><span class="line">        pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;[%s - %d]: %s\n&quot;, inet_ntoa(msg.addr.sin_addr), ntohs(msg.addr.sin_port), buf);</span><br><span class="line"></span><br><span class="line">    strcat(buf, &quot; ^_^&quot;);</span><br><span class="line">    if(send(msg.acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> int sockfd, acceptfd;</span><br><span class="line"> struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line"> socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line"> //第一步：创建套接字</span><br><span class="line"> if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //将套接字设置为允许重复使用本机地址或者为设置为端口复用</span><br><span class="line"> int on = 1;</span><br><span class="line"> if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第二步：填充服务器网络信息结构体</span><br><span class="line"> serveraddr.sin_family = AF_INET;</span><br><span class="line"> serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line"> serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line"> //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line"> if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第四步：将套接字设置为被动监听状态</span><br><span class="line"> if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">     //第五步：阻塞等待客户端的连接请求</span><br><span class="line">     if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     //打印客户端的信息</span><br><span class="line">     //printf(&quot;%s -- %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">     //创建子线程与客户端进行通信</span><br><span class="line">     MSG msg;</span><br><span class="line">     msg.addr = clientaddr;</span><br><span class="line">     msg.acceptfd = acceptfd;</span><br><span class="line">     pthread_t thread;</span><br><span class="line">     if(pthread_create(&amp;thread, NULL, pthread_fun, &amp;msg) != 0)</span><br><span class="line">         &#123;</span><br><span class="line">         ERR_LOG(&quot;fail to pthread_create&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     pthread_detach(thread);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="10、Web服务器"><a href="#10、Web服务器" class="headerlink" title="10、Web服务器"></a>10、Web服务器</h1><h2 id="10-1-web服务器简介"><a href="#10-1-web服务器简介" class="headerlink" title="10.1 web服务器简介"></a>10.1 web服务器简介</h2><p>•Web服务器又称WWW服务器、<br>网站服务器等。  </p>
<p>•特点：<br>使用HTTP协议与客户机浏览器进行信息交流不仅能存储信息，<br>还能在用户通过web浏览器提供的信息的基础上运行脚本和程序，<br>该服务器需可安装在UNIX、Linux或Windows等操作系统上，<br>著名的服务器有Apache、Tomcat、 IIS等。</p>
<h2 id="10-2-HTTP协议"><a href="#10-2-HTTP协议" class="headerlink" title="10.2 HTTP协议"></a>10.2 HTTP协议</h2><pre><code>Webserver—HTTP协议（超文本协议）
概念：
一种详细规定了浏览器和万维网服务器之间互相通信的规则，
通过因特网传送万维网文档的数据传送协议
特点：
1、支持C/S架构
2、简单快速：客户向服务器请求服务时，
只需传送请求方法和路径 ，常用方法:GET、POST
3、无连接：限制每次连接只处理一个请求
4、无状态：即如果后续处理需要前面的信息，
它必须重传，这样可能导致每次连接传送的数据量会增大
</code></pre>
<h2 id="10-3-Webserver通信过程"><a href="#10-3-Webserver通信过程" class="headerlink" title="10.3 Webserver通信过程"></a>10.3 Webserver通信过程</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/webserver%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"></p>
<h2 id="10-4-Web编程开发"><a href="#10-4-Web编程开发" class="headerlink" title="10.4 Web编程开发"></a>10.4 Web编程开发</h2><p>•网页浏览（使用GET方式）<br>web服务器的ip地址是192.168.3.103，端口号是9999，要访问的网页是about.html<br>浏览器输入的格式为：<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/web%E7%BC%96%E6%88%90%E5%BC%80%E5%8F%91.png"><br>服务器收到的数据<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/web%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%A4%B4.png"></p>
<pre><code>服务器应答的格式：
服务器接收到浏览器发送的数据之后，
需要判断GET/后面跟的网页是否存在，
如果存在则请求成功，发送指定的指令，
并发送文件内容给浏览器，如果不存在，
则发送请求失败的指令。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成功</span><br><span class="line">1 &quot;HTTP/1.1 200 OK\r\n&quot; \</span><br><span class="line">2 &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line">3 &quot;\r\n&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">失败</span><br><span class="line">1 &quot;HTTP/1.1 404 Not Found\r\n&quot; \</span><br><span class="line">2 &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line">3 &quot;\r\n&quot; \</span><br><span class="line">4 &quot;&lt;HTML&gt;&lt;BODY&gt;File not found&lt;/BODY&gt;&lt;/HTML&gt;&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">案例</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> #include &lt;sys/stat.h&gt;</span><br><span class="line"> #include &lt;fcntl.h&gt;</span><br><span class="line"> #include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"> #define N 1024</span><br><span class="line"> #define ERR_LOG(errmsg) do&#123;\</span><br><span class="line"> perror(errmsg);\</span><br><span class="line"> printf(&quot;%s ‐ %s ‐ %d\n&quot;, __FILE__, __func__, __LINE__);\</span><br><span class="line"> exit(1);\</span><br><span class="line"> &#125;while(0)</span><br><span class="line"></span><br><span class="line"> void *pthread_fun(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> int acceptfd = *(int *)arg;</span><br><span class="line"> char buf[N] = &quot;&quot;;</span><br><span class="line"> char head[]=&quot;HTTP/1.1 200 OK\r\n&quot; \</span><br><span class="line"> &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line"> &quot;\r\n&quot;;</span><br><span class="line"> char err[]= &quot;HTTP/1.1 404 Not Found\r\n&quot; \</span><br><span class="line"> &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line"> &quot;\r\n&quot; \</span><br><span class="line"> &quot;&lt;HTML&gt;&lt;BODY&gt;File not found&lt;/BODY&gt;&lt;/HTML&gt;&quot;;</span><br><span class="line"></span><br><span class="line"> //接收浏览器通过http协议发送的数据包</span><br><span class="line"> if(recv(acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">     ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;*****************************\n\n&quot;);</span><br><span class="line"> printf(&quot;%s\n&quot;, buf);</span><br><span class="line"> // int i;</span><br><span class="line"> // for(i = 0; i &lt; 200; i++)</span><br><span class="line"> // &#123;</span><br><span class="line"> // printf(&quot;[%c] ‐ %d\n&quot;, buf[i], buf[i]);</span><br><span class="line"> // &#125;</span><br><span class="line"> printf(&quot;\n*****************************\n&quot;);</span><br><span class="line"></span><br><span class="line"> //通过获取的数据包中得到浏览器要访问的网页文件名</span><br><span class="line"> //GET /about.html http/1.1</span><br><span class="line"> char filename[128] = &quot;&quot;;</span><br><span class="line"> sscanf(buf, &quot;GET /%s&quot;, filename); //sscanf函数与空格结束，所以直接可以获取文件名</span><br><span class="line"></span><br><span class="line"> if(strncmp(filename, &quot;HTTP/1.1&quot;, strlen(&quot;http/1.1&quot;)) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    strcpy(filename, &quot;about.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> printf(&quot;filename = %s\n&quot;, filename);</span><br><span class="line"></span><br><span class="line"> char path[128] = &quot;./sqlite/&quot;;</span><br><span class="line"> strcat(path, filename);</span><br><span class="line"></span><br><span class="line"> //通过解析出来的网页文件名，查找本地中有没有这个文件</span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(path, O_RDONLY)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    //如果文件不存在，则发送不存在对应的指令</span><br><span class="line">    if(errno == ENOENT)</span><br><span class="line">       &#123;</span><br><span class="line">       if(send(acceptfd, err, strlen(err), 0) &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">       ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       close(acceptfd);</span><br><span class="line">       pthread_exit(NULL);</span><br><span class="line">       &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to open&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //如果文件存在，先发送指令告知浏览器</span><br><span class="line"> if(send(acceptfd, head, strlen(head), 0) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //读取网页文件中的内容并发送给浏览器</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> char text[1024] = &quot;&quot;;</span><br><span class="line"> while((bytes = read(fd, text, 1024)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    if(send(acceptfd, text, bytes, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> pthread_exit(NULL);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0])</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> int sockfd, acceptfd;</span><br><span class="line"> struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line"> socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line"> //第一步：创建套接字</span><br><span class="line"> if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //将套接字设置为允许重复使用本机地址或者为设置为端口复用</span><br><span class="line"> int on = 1;</span><br><span class="line"> if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第二步：填充服务器网络信息结构体</span><br><span class="line"> serveraddr.sin_family = AF_INET;</span><br><span class="line"> serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line"> serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line"> //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line"> if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第四步：将套接字设置为被动监听状态</span><br><span class="line"> if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    //第五步：阻塞等待客户端的连接请求</span><br><span class="line">    if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //打印客户端的信息</span><br><span class="line">    printf(&quot;%s ‐‐ %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    //创建线程接收数据并处理数据</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    if(pthread_create(&amp;thread, NULL, pthread_fun, &amp;acceptfd) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to pthread_create&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="11、网络通信过程"><a href="#11、网络通信过程" class="headerlink" title="11、网络通信过程"></a>11、网络通信过程</h1><h2 id="11-1、网络通信概述"><a href="#11-1、网络通信概述" class="headerlink" title="11-1、网络通信概述"></a>11-1、网络通信概述</h2><p>•网络通信过程分析软件<br>Packet Tracer 是由Cisco公司发布的一个辅助学习工具，提供了设计、配置、<br>排除网络故障网络模拟环境可以直接使用拖曳方法建立网络拓扑，<br>并可提供数据包在网络中行进的详细处理过程，<br>观察网络实时运行情况。  </p>
<h2 id="11-2、通信过程（PC-switch）"><a href="#11-2、通信过程（PC-switch）" class="headerlink" title="11-2、通信过程（PC+switch）"></a>11-2、通信过程（PC+switch）</h2><h3 id="11-2-1、-交换机介绍"><a href="#11-2-1、-交换机介绍" class="headerlink" title="11-2-1、 交换机介绍"></a>11-2-1、 交换机介绍</h3><pre><code>网络交换机（又称“网络交换器”），
是一个扩大网络的器材，可以把更多的计算机等。
网络设备连接到当前的网络中。
具有性价比高、高度灵活、相对简单、易于实现等特点
以太网技术已成为当今最重要的一种局域网组网技术，
网络交换机也就成为了最普及的交换机。
</code></pre>
<h3 id="2-2-交换机功能"><a href="#2-2-交换机功能" class="headerlink" title="2.2 交换机功能"></a>2.2 交换机功能</h3><pre><code>1、转发过滤：
当一个数据帧的目的地址在MAC地址表中有映射时，
它被转发到连接目的节点的端口而不是所有端口
（如该数据帧为广播/组播帧则转发至所有端口）
2、学习功能：
以太网交换机了解每一端口相连设备的MAC地址，
并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中
3、目前交换机还具备了一些新的功能，
如对VLAN（虚拟局域网）的支持、对链路汇聚的支持，
甚至有的还具有防火墙的功能
</code></pre>
<h3 id="2-3-通信过程（PC-switch）"><a href="#2-3-通信过程（PC-switch）" class="headerlink" title="2.3 通信过程（PC+switch）"></a>2.3 通信过程（PC+switch）</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/pc+switch%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<pre><code>总结：
如果PC不知目标IP所对应的MAC，
那么可以看出，PC会先发送ARP广播，
得到对方的MAC然后，
再进行数据的传送，
当switch第一次收到ARP广播数据，
会把ARP广播数据包转发给所有端口（除来源端口）；
如果以后还有PC询问此IP的MAC，
那么只是向目标的端口进行转发数据
每台PC都会有一个ARP缓存表，
用来记录IP所对应的的MAC。 
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/arp%E6%9F%A5%E7%9C%8Bip%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6mac%E5%9C%B0%E5%9D%80.png"></p>
<pre><code>注意：arp表不是永久的，
过一段时间之后就会将没有通信的主机的ip地址以及其mac地址从表中移除
</code></pre>
<h2 id="11-3、通信过程（PC-switch-router）"><a href="#11-3、通信过程（PC-switch-router）" class="headerlink" title="11-3、通信过程（PC+switch+router）"></a>11-3、通信过程（PC+switch+router）</h2><h3 id="11-3-1、-路由器介绍"><a href="#11-3-1、-路由器介绍" class="headerlink" title="11-3-1、 路由器介绍"></a>11-3-1、 路由器介绍</h3><pre><code>路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络
所谓逻辑网络是代表一个单独的网络或者一个子网。
当数据从一个子网传输到另一个子网时，
可通过路由器的路由功能来完成具有判断网络地址和选择IP路径的功能。
路由器工作在网络层，可以实现不同网段的主机之间进行通信。
</code></pre>
<h3 id="11-3-2、-通信过程（PC-switch-router）"><a href="#11-3-2、-通信过程（PC-switch-router）" class="headerlink" title="11-3-2、 通信过程（PC+switch+router）"></a>11-3-2、 通信过程（PC+switch+router）</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/pc+switch+router.png"></p>
<pre><code>总结：
不在同一网段的PC，
需要设置默认网关才能把数据传送过去,通常情况下
都会把路由器设为默认网关,当路由器收到一个其它网段的数据包时，
会根据“路由表”来决定把此数据包发送到哪个端口；
路由表的设定有静态和动态方法
设置路由表就是设置下一跳，
指定当前网段的主机与另一个网段主机通信是数据报应该交给那个路由器。
</code></pre>
<h2 id="11-4、通信过程（浏览器跨网访问Web服务器）"><a href="#11-4、通信过程（浏览器跨网访问Web服务器）" class="headerlink" title="11-4、通信过程（浏览器跨网访问Web服务器）"></a>11-4、通信过程（浏览器跨网访问Web服务器）</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E7%BD%91%E8%AE%BF%E9%97%AEweb%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p>
<pre><code>总结
1、DNS服务器的作用是解析出IP
2、DFGATEWAY指定发往其它网段的数据包转发的路径
3、在路由器中路由表指定数据包的“下一跳”的地址
4、公有IP、私有IP
</code></pre>
<h1 id="12、原始套接字"><a href="#12、原始套接字" class="headerlink" title="12、原始套接字"></a>12、原始套接字</h1><h2 id="12-1、TCP、UDP开发回顾"><a href="#12-1、TCP、UDP开发回顾" class="headerlink" title="12-1、TCP、UDP开发回顾"></a>12-1、TCP、UDP开发回顾</h2><pre><code>数据报式套接字（SOCK_DGRAM）
1、无连接的socket,针对无连接的 UDP 服务
2、可通过邮件模型来进行对比
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E9%82%AE%E4%BB%B6%E6%A8%A1%E5%9E%8B.png"></p>
<pre><code>流式套接字（SOCK_STREAM）
1、面向连接的socket,针对面向连接的 TCP 服务
2、可通过电话模型来进行对比
这两类套接字似乎涵盖了TCP/IP 应用的全部

TCP与UDP各自有独立的port互不影响
一个进程可同时拥有多个port
不必关心tcp/ip协议实现的过程
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png"></p>
<h3 id="12-1-1、-UDP-编程回顾"><a href="#12-1-1、-UDP-编程回顾" class="headerlink" title="12-1-1、 UDP 编程回顾"></a>12-1-1、 UDP 编程回顾</h3><pre><code>client
1、创建socket接口
2、定义sockaddr_in变量，其中ip、port为目的主机的信息
3、可发送0长度的数据包
server
1、bind本地主机的ip、port等信息
2、接收到的数据包中包含来源主机的ip、port信息
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/udp%E7%BC%96%E6%88%90%E5%9B%9E%E9%A1%BE.png"></p>
<h3 id="12-1-2、-TCP编程回顾"><a href="#12-1-2、-TCP编程回顾" class="headerlink" title="12-1-2、 TCP编程回顾"></a>12-1-2、 TCP编程回顾</h3><pre><code>client
connect来建立连接
send、recv收发数据
不可发送0长度的数据
server
bind本地主机的ip、port等信息
listen把主动套接字变为被动
accept会有新的返回值
多进程、线程完成并发
</code></pre>
<p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcp%E7%BC%96%E7%A8%8B%E5%9B%9E%E9%A1%BE.png"></p>
<h2 id="12-2、原始套接字概述、创建"><a href="#12-2、原始套接字概述、创建" class="headerlink" title="12-2、原始套接字概述、创建"></a>12-2、原始套接字概述、创建</h2><pre><code>2.1 原始套接字概述
原始套接字（SOCK_RAW）
1、一种不同于SOCK_STREAM、SOCK_DGRAM的套接字，
它实现于系统核心
2、可以接收本机网卡上所有的数据帧（数据包）,
对于监听网络流量和分析网络数据很有作用
3、开发人员可发送自己组装的数据包到网络上
4、广泛应用于高级网络编程
5、网络专家、黑客通常会用此来编写奇特的网络程序
</code></pre>
<p><code>流式套接字只能收发</code><br><code>TCP协议的数据</code><br><code>数据报套接字只能收发</code><br><code>UDP协议的数据</code><br><code>原始套接字可以收发</code><br><code>1、内核没有处理的数据包，因此要访问其他协议</code><br><code>2、发送的数据需要使用，原始套接字(SOCK_RAW)</code></p>
<h1 id="重要补充"><a href="#重要补充" class="headerlink" title="重要补充"></a>重要补充</h1><p>udp在通讯结束后也需要用close关闭描述符。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://naro-ygc.cn">naro-ygc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://naro-ygc.cn/posts/50daec4.html">https://naro-ygc.cn/posts/50daec4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://naro-ygc.cn" target="_blank">naro</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a100fb72.html" title="mqtt"><img class="cover" src="/./../../../../img/4_%E7%BD%91%E7%BB%9C/mqtt/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mqtt</div></div></a></div><div class="next-post pull-right"><a href="/posts/2ffce39e.html" title="ffmpeg"><img class="cover" src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/ffmpeg/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ffmpeg</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/log.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">naro-ygc</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">74</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95"><span class="toc-number">1.</span> <span class="toc-text">1、计算机网络发展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">1-1、数据交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1-2、交换方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">1-2-3、特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1-3、发展过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E8%8B%B1%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2、英特网的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E4%B8%89%E7%BA%A7%E7%BB%93%E6%9E%84%E8%8B%B1%E7%89%B9%E7%BD%91"><span class="toc-number">2.1.</span> <span class="toc-text">2-1、三级结构英特网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E5%A4%9A%E7%BA%A7%E8%8B%B1%E7%89%B9%E7%BD%91"><span class="toc-number">2.2.</span> <span class="toc-text">2-2、多级英特网</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">3.</span> <span class="toc-text">3、TCP&#x2F;IP协议族</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3-1、分层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">3-2、 IP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81tcp%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3-3、tcp协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81udp%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3-4、udp协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81mac%E5%9C%B0%E5%9D%80"><span class="toc-number">3.5.</span> <span class="toc-text">3-5、mac地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81ip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.</span> <span class="toc-text">3-6、ip地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">3-6-1、IP地址的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-1%E3%80%81ipv4%E7%BB%84%E6%88%90"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">3-6-1-1、ipv4组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2%E3%80%81ip%E7%BB%84%E6%88%90"><span class="toc-number">3.6.2.</span> <span class="toc-text">3-6-2、ip组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3%E3%80%81ipv4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%EF%BC%88%E4%BE%9D%E6%8D%AE%E5%89%8D8%E4%BD%8D%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%EF%BC%89"><span class="toc-number">3.6.3.</span> <span class="toc-text">3-6-3、ipv4的地址分类（依据前8位进行区分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4%E3%80%81%E7%A7%81%E6%9C%89ip"><span class="toc-number">3.6.4.</span> <span class="toc-text">3-6-4、私有ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-5%E3%80%81%E5%9B%9E%E7%8E%AFip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.5.</span> <span class="toc-text">3-6-5、回环ip地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">3.6.6.</span> <span class="toc-text">3-6-6、子网掩码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7%E3%80%81%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.7.</span> <span class="toc-text">3-7、端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1%E3%80%81%E7%AB%AF%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">3-7-1、端口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2%E3%80%81%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">3.7.2.</span> <span class="toc-text">3-7-2、端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3%E3%80%81%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B0%81%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.7.3.</span> <span class="toc-text">3-7-3、链路层封包格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-4%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%B0%81%E8%A3%85"><span class="toc-number">3.7.4.</span> <span class="toc-text">3-7-4、网络层的数据报封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8%E3%80%81c-s%E6%9E%B6%E6%9E%84"><span class="toc-number">3.8.</span> <span class="toc-text">3-8、c&#x2F;s架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E8%8A%82%E5%BA%8F%E3%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">4、字节序、地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E5%AD%97%E5%BA%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.</span> <span class="toc-text">4-1、字序转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">4-2、地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E3%80%81%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B01"><span class="toc-number">4.2.1.</span> <span class="toc-text">4-2-1、转换函数1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">地址转换：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inet-ntop"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">inet_ntop()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2%E3%80%81%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B02"><span class="toc-number">4.2.2.</span> <span class="toc-text">4-2-2、转换函数2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81udp"><span class="toc-number">5.</span> <span class="toc-text">5、udp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3socket"><span class="toc-number">5.1.</span> <span class="toc-text">5-1、网络编程接口socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%88%9B%E5%BB%BAsocket%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">5.1.1.</span> <span class="toc-text">5-1-1 创建socket套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81ipv4%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">5-2、ipv4套接字的地址结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%9C%B0%E5%9D%80%E7%BB%93%E5%90%88"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">两种地址结合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.</span> <span class="toc-text">5-3、服务器向客户端发送数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">常用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E2%80%94sendto%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.0.1.0.1.</span> <span class="toc-text">1、发送数据—sendto函数</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E7%BB%91%E5%AE%9A%E2%80%93bind%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">5-4、绑定–bind函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE-recvfrom"><span class="toc-number">5.5.</span> <span class="toc-text">5-5、接收数据-recvfrom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">5.6.</span> <span class="toc-text">5-6、客户端向服务器发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7%E3%80%81c-s%E6%9E%B6%E6%9E%84"><span class="toc-number">5.7.</span> <span class="toc-text">5-7、c&#x2F;s架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8%E3%80%81udp%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">5.8.</span> <span class="toc-text">5-8、udp客户端注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">5.9.</span> <span class="toc-text">5-9、服务器注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10%E3%80%81TFTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.10.</span> <span class="toc-text">5-10、TFTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11%E3%80%81%E4%BD%BF%E7%94%A8TFTP%E4%B8%8B%E8%BD%BD"><span class="toc-number">5.11.</span> <span class="toc-text">5-11、使用TFTP下载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81udp%E5%B9%BF%E6%92%AD"><span class="toc-number">6.</span> <span class="toc-text">6、udp广播</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E5%8D%95%E6%92%AD"><span class="toc-number">6.1.</span> <span class="toc-text">6-1、单播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E5%B9%BF%E6%92%AD"><span class="toc-number">6.2.</span> <span class="toc-text">6-2、广播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E5%B9%BF%E6%92%AD%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">6-3、广播流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1%E3%80%81%E5%8F%91%E9%80%81%E8%80%85"><span class="toc-number">6.3.1.</span> <span class="toc-text">6-3-1、发送者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2%E3%80%81%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">6.3.2.</span> <span class="toc-text">6-3-2、接收者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%A4%9A%E6%92%AD"><span class="toc-number">7.</span> <span class="toc-text">7、多播</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">7-1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">7.2.</span> <span class="toc-text">7-1、多播地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E5%A4%9A%E6%92%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">7-2、多播的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-0%E3%80%81-%E5%A4%9A%E6%92%AD%E5%A5%97%E6%8E%A5%E5%8F%A3%E9%80%89%E9%A1%B9"><span class="toc-number">7.3.1.</span> <span class="toc-text">7-2-0、 多播套接口选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E3%80%81%E5%8F%91%E9%80%81%E8%80%85"><span class="toc-number">7.3.2.</span> <span class="toc-text">7-2-1、发送者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E3%80%81%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">7.3.3.</span> <span class="toc-text">7-2-2、接收者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81tcp"><span class="toc-number">8.</span> <span class="toc-text">8、tcp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81tcp%E4%B8%8Eudp%E5%AF%B9%E6%AF%94"><span class="toc-number">8.1.</span> <span class="toc-text">8-1、tcp与udp对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">8-2、流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">8.2.1.</span> <span class="toc-text">8-2-1、客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">8-2-2、服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E3%80%81-close%E5%85%B3%E9%97%AD%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">8.3.</span> <span class="toc-text">8-3、 close关闭套接字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">8.4.</span> <span class="toc-text">8-4、三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">8.5.</span> <span class="toc-text">8-5、四次挥手</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81tpc%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">9、tpc并发服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">9.0.1.</span> <span class="toc-text">服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">9.0.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">9.1.</span> <span class="toc-text">9-1、使用进程实现并发服务器操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.</span> <span class="toc-text">9-2、使用多线程实现并发操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">10、Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 web服务器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-HTTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-Webserver%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 Webserver通信过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-Web%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 Web编程开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">11、网络通信过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1%E3%80%81%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">11.1.</span> <span class="toc-text">11-1、网络通信概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2%E3%80%81%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%88PC-switch%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">11-2、通信过程（PC+switch）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1%E3%80%81-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.2.1.</span> <span class="toc-text">11-2-1、 交换机介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2 交换机功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%88PC-switch%EF%BC%89"><span class="toc-number">11.2.3.</span> <span class="toc-text">2.3 通信过程（PC+switch）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3%E3%80%81%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%88PC-switch-router%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">11-3、通信过程（PC+switch+router）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-1%E3%80%81-%E8%B7%AF%E7%94%B1%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.3.1.</span> <span class="toc-text">11-3-1、 路由器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-2%E3%80%81-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%88PC-switch-router%EF%BC%89"><span class="toc-number">11.3.2.</span> <span class="toc-text">11-3-2、 通信过程（PC+switch+router）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4%E3%80%81%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E7%BD%91%E8%AE%BF%E9%97%AEWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89"><span class="toc-number">11.4.</span> <span class="toc-text">11-4、通信过程（浏览器跨网访问Web服务器）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">12.</span> <span class="toc-text">12、原始套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1%E3%80%81TCP%E3%80%81UDP%E5%BC%80%E5%8F%91%E5%9B%9E%E9%A1%BE"><span class="toc-number">12.1.</span> <span class="toc-text">12-1、TCP、UDP开发回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-1%E3%80%81-UDP-%E7%BC%96%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="toc-number">12.1.1.</span> <span class="toc-text">12-1-1、 UDP 编程回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-2%E3%80%81-TCP%E7%BC%96%E7%A8%8B%E5%9B%9E%E9%A1%BE"><span class="toc-number">12.1.2.</span> <span class="toc-text">12-1-2、 TCP编程回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2%E3%80%81%E5%8E%9F%E5%A7%8B%E5%A5%97%E6%8E%A5%E5%AD%97%E6%A6%82%E8%BF%B0%E3%80%81%E5%88%9B%E5%BB%BA"><span class="toc-number">12.2.</span> <span class="toc-text">12-2、原始套接字概述、创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E8%A1%A5%E5%85%85"><span class="toc-number">13.</span> <span class="toc-text">重要补充</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/0.html" title="无题">无题</a><time datetime="2025-07-02T21:47:56.079Z" title="发表于 2025-07-03 05:47:56">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f2e2a688.html" title="音视频原理入门"><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/ffmpeg/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="音视频原理入门"/></a><div class="content"><a class="title" href="/posts/f2e2a688.html" title="音视频原理入门">音视频原理入门</a><time datetime="2025-07-02T21:44:22.579Z" title="发表于 2025-07-03 05:44:22">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/96a84f26.html" title="计算机是怎么跑起来的"><img src="/img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机是怎么跑起来的"/></a><div class="content"><a class="title" href="/posts/96a84f26.html" title="计算机是怎么跑起来的">计算机是怎么跑起来的</a><time datetime="2025-07-02T17:42:15.661Z" title="发表于 2025-07-03 01:42:15">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a003dbfe.html" title="openssl和unzip和zip移植"><img src="/img/7_linux%E5%BC%80%E5%8F%91/%E5%AF%8C%E7%80%9A%E5%B9%B3%E5%8F%B0/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="openssl和unzip和zip移植"/></a><div class="content"><a class="title" href="/posts/a003dbfe.html" title="openssl和unzip和zip移植">openssl和unzip和zip移植</a><time datetime="2025-07-02T09:39:47.737Z" title="发表于 2025-07-02 17:39:47">2025-07-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fc7f7e68.html" title="x264和x265 移植"><img src="/img/7_linux%E5%BC%80%E5%8F%91/%E5%AF%8C%E7%80%9A%E5%B9%B3%E5%8F%B0/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="x264和x265 移植"/></a><div class="content"><a class="title" href="/posts/fc7f7e68.html" title="x264和x265 移植">x264和x265 移植</a><time datetime="2025-07-02T09:36:36.770Z" title="发表于 2025-07-02 17:36:36">2025-07-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By naro-ygc</div><div class="footer_custom_text">未经本人同意不得作于其他用途</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 网络 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/驱动、bootleader、文件系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 驱动、bootleader、文件系统 (21)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/Linux开发/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Linux开发 (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/问题总结/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 问题总结 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/开发方法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 开发方法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/AI-深度学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 AI-深度学习 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/音视频协议/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 音视频协议 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://naro-ygc.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>