<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta name="referrer" content="no-referrer"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>linuxC | naro</title><meta name="author" content="naro-ygc,862450734@qq.com"><meta name="copyright" content="naro-ygc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="学习linux 开发的笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="linuxC">
<meta property="og:url" content="https://naro-ygc.cn/posts/69453faf.html">
<meta property="og:site_name" content="naro">
<meta property="og:description" content="学习linux 开发的笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://naro-ygc.cn/img/7_linux%E5%BC%80%E5%8F%91/c/%E5%B0%81%E9%9D%A2.png">
<meta property="article:published_time" content="2025-02-21T19:27:28.683Z">
<meta property="article:modified_time" content="2025-07-02T09:16:17.482Z">
<meta property="article:author" content="naro-ygc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://naro-ygc.cn/img/7_linux%E5%BC%80%E5%8F%91/c/%E5%B0%81%E9%9D%A2.png"><link rel="shortcut icon" href="/img/log.png"><link rel="canonical" href="https://naro-ygc.cn/posts/69453faf.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linuxC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-02 17:16:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/log.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../../../img/7_linux%E5%BC%80%E5%8F%91/c/%E5%B0%81%E9%9D%A2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="naro"><span class="site-name">naro</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">linuxC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-21T19:27:28.683Z" title="发表于 2025-02-22 03:27:28">2025-02-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-02T09:16:17.482Z" title="更新于 2025-07-02 17:16:17">2025-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux%E5%BC%80%E5%8F%91/">Linux开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="linuxC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-、系统调用和库函数"><a href="#1-、系统调用和库函数" class="headerlink" title="1 、系统调用和库函数"></a>1 、系统调用和库函数</h1><h2 id="1-1-、库函数由两类函数组成"><a href="#1-1-、库函数由两类函数组成" class="headerlink" title="1-1 、库函数由两类函数组成"></a>1-1 、库函数由两类函数组成</h2><ul>
<li><p>1、不需要调用系统调用,不需要切换到内核空间即可完成函数的全部功能，并且将结果反馈给应用程序，如strcpy、bzero等字符串操作函数。</p>
</li>
<li><p>2、需要调用系统调用,需要切换到内核空间,这类函数通过封装的系统调用去实现相应的功能,如printf、fread等</p>
</li>
</ul>
<pre><code>          	
</code></pre>
<h2 id="1-2、系统调用与库函数的关系"><a href="#1-2、系统调用与库函数的关系" class="headerlink" title="1-2、系统调用与库函数的关系"></a>1-2、系统调用与库函数的关系</h2><ul>
<li>并不是所有系统调用都被封装成为库函数，</li>
<li>系统提供的很多功能必须通过系统调用才能实现。</li>
<li>也就是大部分的库函数都是由系统调用封装而来。</li>
<li>只不过库函数拥有缓冲区，</li>
<li>减少了系统调用的次数</li>
</ul>
<h3 id="1-2-1、系统调用特点"><a href="#1-2-1、系统调用特点" class="headerlink" title="1-2-1、系统调用特点"></a>1-2-1、系统调用特点</h3><ul>
<li>系统调用是需要时间的，</li>
<li>频繁的系统调用会降低程序的运行效率。</li>
<li>当运行内核代码时，</li>
<li>cpu工作在内核态，</li>
<li>在系统调用发生前需要保存用户态的栈和内存环境，</li>
<li>然后转入内核态工作。</li>
<li>结束调用后又返回用户态。</li>
</ul>
<h3 id="1-2-2、库函数的好处"><a href="#1-2-2、库函数的好处" class="headerlink" title="1-2-2、库函数的好处"></a>1-2-2、库函数的好处</h3><ul>
<li>库函数访问文件的时候需要根据需要设置不同类型的缓存区，</li>
<li>从而减少了直接调用io系统调用</li>
<li>的次数，</li>
<li>提高了访问的效率。<br><img src="../../../../img/7_linux%E5%BC%80%E5%8F%91/c/1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0.png"></li>
</ul>
<p>如：应用程序调用printf时，如下图<br><img src="../../../../img/7_linux%E5%BC%80%E5%8F%91/c/1-2-2%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0.png"></p>
<h1 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h1><p>当一个系统启动后，会先后创建3个文件描述符。0、1、2，也就是终端输出，终端输入，错误输出。</p>
<h2 id="1-1、进程的定义"><a href="#1-1、进程的定义" class="headerlink" title="1-1、进程的定义"></a>1-1、进程的定义</h2><ul>
<li>程序和进程的区别：<br>程序：是静态的，存放在磁盘上的可执行文件<br>进程：是动态的，是运行在内存中的程序的执行实例</li>
</ul>
<p>程序是一些指令的有序集合，而进程是执行程序的过程。进程的状态是变化的。<br>只要程序运行，此时就是进程，程序每运行一次，就会创建一个进程。</p>
<p>在linux系统中，进程是管理事务的基本单元。进程拥有自己独立的处理环境和系统资源<br> （处理器、存储器、io设备、数据、程序）。<br>##	1-2、进程的状态及转换<br>进程可以划分为三中状态：</p>
<ul>
<li>就绪态：进程已经具备执行的一切条件，正在等待分配cpu的处理时间。</li>
<li>执行态：该进程正在占用cpu运行。</li>
<li>等待态：进程因不具备某些执行条件而暂时无法继续执行的状态。比如scanf输入，在没有输入时就是等待态。</li>
</ul>
<h2 id="1-3、进程的调度机制"><a href="#1-3、进程的调度机制" class="headerlink" title="1-3、进程的调度机制"></a>1-3、进程的调度机制</h2><p>时间片轮转：如单核cpu，同一时间段内只能运行一个进程，下一个时间段运行第二个进程。上下文切换：<br>就是比如上部分程序运行了，下部分程序还没有运行被切换到另一个进程中去了。<br><img src="https://img-blog.csdnimg.cn/89171d8fa7304322a662eac554d08124.png"></p>
<h2 id="1-4、进程控制块"><a href="#1-4、进程控制块" class="headerlink" title="1-4、进程控制块"></a>1-4、进程控制块</h2><p>进程控制块就是用于保存一个进程信息的结构体，又称之为PCB。进程控制块就是一个保存进程信息&#x3D;结构体，存放在task_struct结构体中。</p>
<p>PCB结构体中的部分数据<br>    调度数据<br>        进程的状态、标志、优先级、调度策略等。<br>    时间数据<br>        创建该进程的时间、<br>        在用户态的运行时间<br>        、在内核态的运行时间等。<br>    文件系统数据<br>        umask掩码、文件描述符表等。<br>        内存数据、进程上下文、进程标识（进程号）</p>
<h2 id="1-5、进程号"><a href="#1-5、进程号" class="headerlink" title="1-5、进程号"></a>1-5、进程号</h2><pre><code>    每一个进程都由一个进程号来标识，
    类型为pid_t，凡时下划线为_t的数据类型都称为类整型。
    进程号是唯一的，
    但是在一个进程终止后可以重复使用。
    进程号是由操作系统随机给程序分配的。
    
</code></pre>
<p><code>凡时下划线为_t的数据类型都称为类整型.</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5ead530fd35a45e786ec14387c221718.png"></p>
<pre><code>    PPID：当前进程的父进程的进程号
    PID：当前进程的进程号
    PGID：当前进程组所在的进程组ID，进程组是一个或者多个进程的集合，相互关联，
        进程组可以接收同一个终端信号。
    COMMAND：当前进程的名字
    
    特殊的进程号：
            在linux系统中进程号由0开始。
            进程号0和1由进程创建。
            进程号0通常称之为调度进程，交换进程。
            进程号为1的进程通常是init进程。init是所有进程的祖先。
            除了调度进程外，所有进程都由init进程直接或间接创建。
    
    父子进程的关系就是由谁创建了谁的关系。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Linux操作系统提供了三个获得进程号的函数</span><br><span class="line">getpid()、getppid()、getpgid()。</span><br><span class="line"></span><br><span class="line">linux下提供三个获得进程号的函数 </span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"> pid_t getpid(void);</span><br><span class="line"> 功能：获取当前进程的进程号</span><br><span class="line"> pid_t getppid(void);</span><br><span class="line"> 功能：获取当前进程的父进程的进程号</span><br><span class="line"> pid_t getpgid(pid_t pid);</span><br><span class="line"> 功能：获取当前进程所在进程组的id</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/******* 示例 *********/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">/********* 获取当前进程的进程号  **********/</span><br><span class="line">printf(&quot;pid = %d\n&quot;,getpid());</span><br><span class="line">/************ 获取当前进程的父进程id *************/</span><br><span class="line">printf(&quot;ppid = %d\n&quot;,getppid());</span><br><span class="line">/************ 获取当前进程所在组的id  *************/</span><br><span class="line">printf(&quot;pgid = %d\n&quot;,getpgid(getpid()));</span><br><span class="line">while(1)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-6、进程的创建fork函数"><a href="#2-6、进程的创建fork函数" class="headerlink" title="2-6、进程的创建fork函数"></a>2-6、进程的创建fork函数</h2><pre><code>    创建进程的方法主要是调用一下两个函数：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">功能：在已有的进程基础上有创建一个子进程</span><br><span class="line">参数：</span><br><span class="line">无</span><br><span class="line">返回值：</span><br><span class="line">成功：</span><br><span class="line">&gt;0 子进程的进程号，标识父进程的代码区</span><br><span class="line">0 子进程的代码区</span><br><span class="line"> 失败：</span><br><span class="line"> ‐1 返回给父进程，子进程不会创建</span><br></pre></td></tr></table></figure>
<pre><code>使用fork函数得到的子进程是父进程的一个复制品，
它从父进程处继承了整个进程的地址空间
地址空间:
    包括进程上下文、
    进程堆栈、
    打开的文件描述符、
    信号控制设定、
    进程优先级、
    进程组号等。
    子进程所独有的只有它的进程号，
计时器等。
因此，
使用fork函数的代价是很大的。
fork函数执行完毕后父子进程的空间示意图：
    使用fork函数后：
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/7f766c609fb54de3b78cf29a746de36e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    /******  通过fork函数创建一个子进程 *******/</span><br><span class="line">     /***********     **************/</span><br><span class="line"> #if 0   </span><br><span class="line"> fork();</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line"> #endif</span><br><span class="line"> /****** 通过fork函数的返回值来确定父子进程的独立区代码 ********/</span><br><span class="line"> /********  父子进程是来回交替运行的，谁先允许，后允许，这个是不确定的   **************/</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;parent :pid = %d,ppid = %d\r\n&quot;,getpid(),getppid());    </span><br><span class="line">        printf(&quot;pid = %d\r\n&quot;,pid);</span><br><span class="line">        printf(&quot;this is parent\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;**********************************&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     while (1)</span><br><span class="line">     &#123;</span><br><span class="line">        printf(&quot;son :pid = %d,ppid = %d\r\n&quot;,getpid(),getppid());   </span><br><span class="line">        printf(&quot;this is child\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;**********************************&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int a = 1;</span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    /******  通过fork函数创建一个子进程 *******/</span><br><span class="line">     /***********     **************/</span><br><span class="line"> #if 0   </span><br><span class="line"> fork();</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line"> #endif</span><br><span class="line"> /****** 通过fork函数的返回值来确定父子进程的独立区代码 ********/</span><br><span class="line"> /********  父子进程是来回交替运行的，谁先允许，后允许，这个是不确定的   **************/</span><br><span class="line">    int b = 2;</span><br><span class="line">    static int c = 3;</span><br><span class="line">    /************** 同时，在fork之前的数据，子进程都会保留，后面无论父进程怎么变（</span><br><span class="line">      堆区栈区数据区），都不会影响子进程***************/</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        c++;</span><br><span class="line">        printf(&quot;this is parent a = %d ,b = %d ,c = %d\r\n&quot;, a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">     &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">     printf(&quot;this is son a = %d ,b = %d ,c = %d\r\n&quot;,a, b, c);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果</span><br><span class="line">ygc@ygc:~/network/07_fork2$ ./a.out </span><br><span class="line">this is parent a = 2 ,b = 3 ,c = 4</span><br><span class="line">this is son a = 1 ,b = 2 ,c = 3</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<pre><code>    从上面可以看出，子进程会在fork之前做数据的继承
    而有内核空间，磁盘空间是进程所共有的，改变偏移量，
    会将偏移指针保存在内核中，所以父进程改变的偏移量会继承到子进程中。
    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(&quot;file.txt&quot;,O_RDONLY)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open file.txt&quot;);</span><br><span class="line">        goto filed_open;</span><br><span class="line">    &#125; </span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;filed_fork&quot;);</span><br><span class="line">        goto filed_fork;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[32] = &quot; &quot;;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        printf(&quot;this is parent\r\n&quot;);</span><br><span class="line">        if(read(fd,buf,30) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;filed_read\r\n&quot;);</span><br><span class="line">            goto filed_read;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;buf = [%s]\r\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line"></span><br><span class="line">        printf(&quot;this is son\r\n&quot;);    </span><br><span class="line"></span><br><span class="line">         char buf[32] = &quot; &quot;;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        printf(&quot;this is parent\r\n&quot;);</span><br><span class="line">        if(read(fd,buf,30) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;filed_read\r\n&quot;);</span><br><span class="line">            goto filed_read;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;buf = [%s]\r\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line">    filed_read:</span><br><span class="line">    close(fd);</span><br><span class="line">    filed_fork:</span><br><span class="line">    filed_open:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-7、进程的挂起"><a href="#1-7、进程的挂起" class="headerlink" title="1-7、进程的挂起"></a>1-7、进程的挂起</h2><pre><code>    进程在一段时间内没有任何的动作，称为进程的挂起。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line">unsigned int sleep(unsigned int seconds);</span><br><span class="line"> 功能：进程在一定的时间内没有任何动作，称为进程的挂起（进程处于等待态）</span><br><span class="line">参数：</span><br><span class="line"> seconds：指定要挂起的秒数</span><br><span class="line"> 返回值：</span><br><span class="line"> 若进程挂起到sec指定的时间则返回0，若有信号中断则返回剩余秒数</span><br><span class="line"> 注意：</span><br><span class="line"> 进程挂起指定的秒数后程序并不会立即执行，系统只是将此进程切换到就绪态</span><br></pre></td></tr></table></figure>

<h2 id="1-8、进程的等待"><a href="#1-8、进程的等待" class="headerlink" title="1-8、进程的等待"></a>1-8、进程的等待</h2><pre><code>Linux进程有时候需要简单的进程之间的同步，如父进程等待子进程的结束。
</code></pre>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/wait.h&gt;</span><br><span class="line"> pid_t wait(int *status);</span><br><span class="line"> 功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line"> 调用wait函数的进程会挂起，直到它的一个子进程退出或收到一个不能被忽视的信号时才</span><br><span class="line">被唤醒。</span><br><span class="line">若调用进程没有子进程或它的子进程已经结束，该函数立即返回。</span><br><span class="line">参数：</span><br><span class="line">status：函数返回时，参数status中包含子进程退出时的状态信息。</span><br><span class="line">子进程的退出信息在一个int中包含了多个字段，</span><br><span class="line"> 用宏定义可以取出其中的每个字段</span><br><span class="line"> 子进程可以通过exit或者_exit函数发送退出状态</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：子进程的进程号。</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>取出子进程的退出信息
WIFEXITED(status)
如果子进程是正常终止的，
取出的字段值非零。
WEXITSTATUS(status)
返回子进程的退出状态，
退出状态保存在status变量的8~16位。
在用此宏前应先用宏WIFEXITED判断子进程是否正常退出，
正常退出才可以使用此宏。
注意：
此status是个wait的参数指向的整型变量。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    pid=fork();</span><br><span class="line">    if(pid&lt;0)</span><br><span class="line">     &#123;</span><br><span class="line">    perror(&quot;fail to fork&quot;);</span><br><span class="line">    return ‐1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i=0;i&lt;5;i++)</span><br><span class="line">         &#123;</span><br><span class="line">          printf(&quot;this is son process\n&quot;);</span><br><span class="line">         sleep(1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         //使用exit退出当前进程并设置退出状态</span><br><span class="line">         exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">//使用wait在父进程中阻塞等待子进程的退出</span><br><span class="line"> //不接收子进程的退出状态</span><br><span class="line"> //wait(NULL);</span><br><span class="line"></span><br><span class="line"> //接收子进程的退出状态，子进程中必须使用exit或者_exit函数退出进程是发送退出状态</span><br><span class="line">    int status = 0;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line"></span><br><span class="line">    if(WIFEXITED(status) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">     printf(&quot;The son process return status: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;this is father process\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/wait.h&gt;</span><br><span class="line"> pid_t waitpid(pid_t pid, int *status,int options)</span><br><span class="line"> 功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line"> 参数：</span><br><span class="line"> pid：指定的进程或者进程组</span><br><span class="line"> pid&gt;0：等待进程ID等于pid的子进程。</span><br><span class="line"> pid=0：等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid</span><br><span class="line">不会等待它。</span><br><span class="line">pid=‐1：等待任一子进程，此时waitpid和wait作用一样。</span><br><span class="line"> pid&lt;‐1：等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值</span><br><span class="line"> status：保存子进程退出时的状态信息</span><br><span class="line"> options：选项</span><br><span class="line"> 0：同wait，阻塞父进程，等待子进程退出。</span><br><span class="line"> WNOHANG：没有任何已经结束的子进程，则立即返回。</span><br><span class="line"> WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。</span><br><span class="line">（跟踪调试，很少用到）</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回状态改变了的子进程的进程号；如果设置了选项WNOHANG并且pid指定的进程存</span><br><span class="line">在则返回0。</span><br><span class="line"> 失败：返回‐1。当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进</span><br><span class="line">程，waitpid就会出错返回，这时errno被设置为ECHILD。</span><br><span class="line"></span><br><span class="line"> wait(status) &lt;==&gt; waitpid(‐1, status, 0)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">     pid=fork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        return ‐1;</span><br><span class="line">        &#125;</span><br><span class="line">     if(pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i=0;i&lt;5;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;this is son process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">        exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">     else</span><br><span class="line">        &#123;</span><br><span class="line">        waitpid(pid, NULL, 0);</span><br><span class="line">        printf(&quot;this is father process\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">两个函数</span><br><span class="line">wait（）、waitpid（）</span><br><span class="line">如果父进程先结束，会打印终端提示符</span><br><span class="line">有返回值。</span><br><span class="line">子进程可以通过exit和_exit发送退出状态。</span><br><span class="line">也可以用宏来取出子进程的退出信息</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">如果子进程是正常终止的，取出的字段值非零。</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">返回子进程的退出状态，退出状态保存在status变量8~16位。在</span><br><span class="line">使用前先用宏判断WIFEXITED判断子进程是否正常退出，正常退</span><br><span class="line">出才能使用此宏</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code>两个函数都可以回收子进程的资源
</code></pre>
<h4 id="特殊进程"><a href="#特殊进程" class="headerlink" title="特殊进程"></a>特殊进程</h4><pre><code>僵尸进程
    子进程已经运行结束，
    父进程没有wait或者waitpid。
    进行子进程资源的回收，就称为僵尸进程。
孤儿进程
    父进程运行结束，但子进程未运行结束的进程。
守护进程（精灵进程）
    守护进程是个特殊的孤儿进程，这种进程脱离了终端，在后台运行。
</code></pre>
<h2 id="1-9、进程的终止"><a href="#1-9、进程的终止" class="headerlink" title="1-9、进程的终止"></a>1-9、进程的终止</h2><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">一般失败退出设置为非0</span><br><span class="line">一般成功退出设置为0</span><br><span class="line">返回值：</span><br><span class="line">无</span><br></pre></td></tr></table></figure>
<h3 id="exit函数-1"><a href="#exit函数-1" class="headerlink" title="_exit函数"></a>_exit函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">一般失败退出设置为非0</span><br><span class="line">一般成功退出设置为0</span><br><span class="line">返回值：</span><br><span class="line">无</span><br></pre></td></tr></table></figure>
<h3 id="exit和-exit函数的区别："><a href="#exit和-exit函数的区别：" class="headerlink" title="exit和_exit函数的区别："></a>exit和_exit函数的区别：</h3><pre><code>exit为库函数，而_exit为系统调用
exit会刷新缓冲区，但是_exit不会刷新缓冲区
一般会使用exit
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/a4d7e16325c34ebc9b04e7c95b59f99a.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void myfun()</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;nihao beijing&quot;);</span><br><span class="line"></span><br><span class="line">   //使用return</span><br><span class="line">   //return除了可以返回值以外，在主函数中使用可以退出进程，但是在子函数中使用只能退出当前函数</span><br><span class="line">   //return ;</span><br><span class="line"></span><br><span class="line">   //使用exit</span><br><span class="line">   //exit可以退出一个进程并且可以刷新缓冲区</span><br><span class="line">   //exit(0);</span><br><span class="line"></span><br><span class="line">   //使用_exit</span><br><span class="line">   //_exit可以退出一个进程，但是不会刷新缓冲区</span><br><span class="line">   _exit(0);</span><br><span class="line"></span><br><span class="line">   printf(&quot;welcome to 1000phone\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;hello world\n&quot;);</span><br><span class="line">   </span><br><span class="line">   myfun();</span><br><span class="line">   </span><br><span class="line">   printf(&quot;hello kitty\n&quot;);</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>return是退出函数，并不是退出进程</code><br><code>exit为退出当前的进程</code></p>
<pre><code>Linux下可以通过 ：void  exit(int value)
void _exit(int value)

区别在于：exit为库函数，exit为系统调用
在文章《进程的退出及错误打印》中有具体用法。
</code></pre>
<h2 id="1-10、进程退出清理"><a href="#1-10、进程退出清理" class="headerlink" title="1-10、进程退出清理"></a>1-10、进程退出清理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atexit(void (*function)(void));\</span><br><span class="line">功能：注册进程正常结束前调用的函数，进程退出执行注册函数</span><br><span class="line">参数：</span><br><span class="line">function：进程结束前，调用函数的入口地址。</span><br><span class="line">一个进程中可以多次调用atexit函数注册清理函数，</span><br><span class="line">正常结束前调用函数的顺序和注册时的顺序相反</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void clear_fun1(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;perform clear fun1 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_fun2(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;perform clear fun2 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_fun3(void)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;perform clear fun3 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //atexit函数在进程结束时才会去执行参数对应的回调函数</span><br><span class="line">    //atexit多次调用后，执行顺序与调用顺序相反</span><br><span class="line">	atexit(clear_fun1);</span><br><span class="line">	atexit(clear_fun2);</span><br><span class="line">	atexit(clear_fun3);</span><br><span class="line">	printf(&quot;process exit 3 sec later!!!\n&quot;);</span><br><span class="line">	sleep(3);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/b68814f5f5eb4ec39f9080f0fb46e9ad.png"></p>
<h2 id="1-11、进程的创建—vfork"><a href="#1-11、进程的创建—vfork" class="headerlink" title="1-11、进程的创建—vfork"></a>1-11、进程的创建—vfork</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"> pid_t vfork(void);</span><br><span class="line"> 功能：vfork函数和fork函数一样都是在已有的进程中创建一个新的进程，但它们创建的子</span><br><span class="line">进程是有区别的。</span><br><span class="line"> 参数：</span><br><span class="line"> 无</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功：子进程中返回0,父进程中返回子进程ID</span><br><span class="line"> 失败：‐1。</span><br></pre></td></tr></table></figure>
<p>fork和vfork函数的区别：<br>vfork保证子进程先运行，<br>在它调用exec或exit之后，<br>父进程才可能被调度运行。<br>vfork和fork一样都创建一个子进程，<br>但它并不将父进程的地址空间完全复制到子进程中，<br>因为子进程会立即调用exec(或exit)，<br>于是也就不访问该地址空间。<br>相反，<br>在子进程中调用exec或exit之前，<br>它在父进程的地址空间中运行，<br>在exec之后子进程会有自己的进程空间。</p>
<h3 id="1-11-1、子进程在父进程之前运行"><a href="#1-11-1、子进程在父进程之前运行" class="headerlink" title="1-11-1、子进程在父进程之前运行"></a>1-11-1、子进程在父进程之前运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    //使用vfork函数创建完子进程后</span><br><span class="line">    //子进程会先执行，直到子进程执行exit或者exec后，父进程才会执行</span><br><span class="line">     pid = vfork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">         &#123;</span><br><span class="line">         perror(&quot;fail to vfork&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">         &#125;</span><br><span class="line">     if(pid == 0) //子进程的代码区</span><br><span class="line">         &#123;</span><br><span class="line">         int i = 0;</span><br><span class="line">         for(i=0;i&lt;5;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;this is son process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">         exit(0);</span><br><span class="line">         &#125;</span><br><span class="line">     else //父进程代码区</span><br><span class="line">         &#123;</span><br><span class="line">         while(1)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;this is father process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/d67846d880bc49958dcdd70667455a9e.png"></p>
<h3 id="1-11-2、子进程和父进程共享同一块空间"><a href="#1-11-2、子进程和父进程共享同一块空间" class="headerlink" title="1-11-2、子进程和父进程共享同一块空间"></a>1-11-2、子进程和父进程共享同一块空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int a = 10;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int b = 9;</span><br><span class="line"></span><br><span class="line">     //使用vfork创建完子进程</span><br><span class="line">     //在子进程执行exit或者exec之前，父子进程共有同一块地址空间</span><br><span class="line">     pid = vfork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to vfork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">     if(pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        printf(&quot;in son process a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">        exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">     else</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;in father process a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">         &#125;</span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0e1498bfe5ac4f01a31dab82088fb695.png"></p>
<h3 id="1-12、-进程的替换"><a href="#1-12、-进程的替换" class="headerlink" title="1-12、 进程的替换"></a>1-12、 进程的替换</h3><pre><code>进程的替换：
exec函数族，
是由六个exec函数组成的。
1、exec函数族提供了六种在进程中启动另一个程序的方法。
2、exec函数族可以根据指定的文件名或目录名找到可执行文件。
3、调用exec函数的进程并不创建新的进程，
故调用exec前后，进程的进程号并不会改变，
其执行的程序完全由新的程序替换，
而新程序则从其main函数开始执行。
exec函数族取代调用进程的数据段、
代码段和堆栈段。
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/973727ddf1a7421f986e2596b3f6a774.png"></p>
<pre><code>一个进程调用exec后，除了进程ID，进程还保留了下列特征不变：
父进程号
进程组号
控制终端
根目录
当前工作目录
进程信号屏蔽集
未处理信号
...
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">exec函数族</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">int execlp(const char *file, const char *arg, .../* (char *) NULL */);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL*/, cha</span><br><span class="line">* const envp[] );</span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line">功能：在一个进程里面执行另一个程序，主要用于执行命令</span><br><span class="line"> 参数：</span><br><span class="line"> path：命令或者程序的路径</span><br><span class="line"> l：如果是带l的函数，对应的命令或者程序是通过每一个参数进行传</span><br><span class="line"> 递的，最后一个为NULL表示结束</span><br><span class="line"> 例如：&quot;ls&quot;, &quot;‐l&quot;, NULL</span><br><span class="line"> v:如果是带v的函数，对应的命令或者程序是通过一个指针数组来传递的，</span><br><span class="line"> 指针数组的最后一个元素为NULL标识结束</span><br><span class="line"> char *str[] = &#123;&quot;ls&quot;, &quot;‐l&quot;, NULL&#125;;</span><br><span class="line"> p：如果是不带p的函数，第一个参数必须传当前命令或者程序的绝对路径，</span><br><span class="line"> 如果是带p的函数，第一个参数既可以是绝对路径，也可以是相对路径</span><br><span class="line"> 返回值：</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<pre><code>案例：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">   &#123;</span><br><span class="line">   pid_t pid;</span><br><span class="line">    if((pid = fork()) &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">       perror(&quot;fail to fork&quot;);</span><br><span class="line">       exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    else if(pid &gt; 0) //父进程</span><br><span class="line">       &#123;</span><br><span class="line">       printf(&quot;This is parent process\n&quot;);</span><br><span class="line"></span><br><span class="line">       wait(NULL);</span><br><span class="line">       printf(&quot;The child process has quited\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    else //子进程</span><br><span class="line">       &#123;</span><br><span class="line">       printf(&quot;This is child process\n&quot;);</span><br><span class="line"></span><br><span class="line">       //调用exec函数族中的函数，执行其他命令或者程序</span><br><span class="line">       //查看命令的路径：whereis 命令或者which 命令</span><br><span class="line"></span><br><span class="line">       //***************exec函数族调用shell命令******************</span><br><span class="line">       //不带p的函数，命令的路径一定要用绝对路径</span><br><span class="line">       #if 0</span><br><span class="line">       if(execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execl&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       //带p的函数，第一个参数既可以是相对路径，也可以是绝对路径</span><br><span class="line">       #if 0</span><br><span class="line">       if(execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execlp&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       //带v的函数需要使用指针数组来传递</span><br><span class="line">       #if 0</span><br><span class="line">       char *str[] = &#123;&quot;ls&quot;, &quot;-l&quot;, NULL&#125;;</span><br><span class="line">       if(execv(&quot;/bin/ls&quot;, str) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execv&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line">       //***************exec函数族调用可执行文件******************</span><br><span class="line">       #if 0</span><br><span class="line">       if(execlp(&quot;./hello&quot;, &quot;./hello&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execlp&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       #if 0</span><br><span class="line">       if(execl(&quot;./hello&quot;, &quot;./hello&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execl&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       //***************exec函数族调用shell脚本******************</span><br><span class="line">       #if 1</span><br><span class="line">       if(execlp(&quot;./myshell.sh&quot;, &quot;./myshell.sh&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execl&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line">       //exec函数族取代调用进程的数据段、代码段和堆栈段</span><br><span class="line">       //所以当exec函数执行完毕后，当前进程就结束了，所以原本进程中的代码不会再执行</span><br><span class="line">       printf(&quot;hello world\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-13、system函数"><a href="#1-13、system函数" class="headerlink" title="1-13、system函数"></a>1-13、system函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int system(const char *command);</span><br><span class="line">功能：执行一个shell命令（shell命令、可执行文件、shell脚本）</span><br><span class="line">system会调用fork函数产生子进程，</span><br><span class="line">子进程调用exec启动/bin/sh ‐c string</span><br><span class="line">来执行参数string字符串所代表的命令，</span><br><span class="line">此命令执行完后返回原调用进程</span><br><span class="line">参数：</span><br><span class="line">command：要执行的命令的字符串</span><br><span class="line">返回值：</span><br><span class="line">如果command为NULL，则system()函数返回非0，一般为1。</span><br><span class="line">如果system()在调用/bin/sh时失败则返回127，其它失败原因返回‐1</span><br></pre></td></tr></table></figure>
<p><code> 此命令执行完后返回原调用进程</code><br><code>与exec区别</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用system执行shell命令</span><br><span class="line">system(&quot;clear&quot;);</span><br><span class="line">system(&quot;ls -l&quot;);</span><br><span class="line"></span><br><span class="line"> system(&quot;./hello&quot;);</span><br><span class="line"></span><br><span class="line"> system(&quot;./myshell.sh&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2、进程之间的通信"><a href="#2、进程之间的通信" class="headerlink" title="2、进程之间的通信"></a>2、进程之间的通信</h1><pre><code>进程间通信(IPC:Inter Processes Communication)
进程是一个独立的资源分配单元，
不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，
没有关联，
不能在一个进程中直接访问另一个进程的资源
（例如打开的文件描述符）。
进程不是孤立的，
不同的进程需要进行信息的交互和状态的传递等，
因此需要进程间通信。


进程间通信功能：
数据传输：一个进程需要将它的数据发送给另一个进程。
资源共享：多个进程之间共享同样的资源。
通知事件：一个进程需要向另一个或一组进程发送消息，
通知它们发生了某种事件。
进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），
此时控制进程。
希望能够拦截另一个进程的所有操作，
并能够及时知道它的状态改变。

Linux操作系统支持的主要进程间通信的通信机制
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/8adbe4a0ff9448c292b9ab5c01444216.png"></p>
<pre><code>进程间通信的实质：
系统只要创建一个进程，
就会给当前进程分配4G的虚拟内存（32位操作系统），
虚拟内存不是常说的内存条的空间，
内存条的空间称之为物理内存，
虚拟内存和物理内存之间存在映射关系
4G的虚拟内存分为3G的用户空间
（0~3G）和1G（3~4G）的内核空间，
用户空间是进程所私有的，
每一个进程的用户空间只能自己访问和使用，
我们之前说的栈区、堆区、数据区、
代码区等都是用户空间的区域内核空间是所有进程所公有的，
也就意味着绝大多数进程间通信方式，
本质就是对内核空间的操作
特殊的进程间通信方式：
socket通信可以实现不同主机的进程间通信，
其他六个只能在一台主机的多个进程间通信
信号通信是唯一的一种异步通信机制
共享内存是所有进程间通信方式中效率最高的，
他是直接对物理内存进行操作。
</code></pre>
<h2 id="2-1、信号"><a href="#2-1、信号" class="headerlink" title="2-1、信号"></a>2-1、信号</h2><h3 id="2-1-1、信号的概念："><a href="#2-1-1、信号的概念：" class="headerlink" title="2-1-1、信号的概念："></a>2-1-1、信号的概念：</h3><pre><code>信号是软件中断，
    它是在软件层次上对中断机制的一种模拟。
信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，
转而处理某一个突发事件。
信号是一种异步通信方式。
进程不必等待信号的到达，
进程也不知道信号什么时候到达。
信号可以直接进行用户空间进程和内核空间进程的交互，
内核进程可以利用它来通知用户空间进程发生了哪些系统事件。
每个信号的名字都以字符SIG开头。
每个信号和一个数字编码相对应，
在头文件signum.h中，
这些信号都被定义为正整数。
信号名定义路径：
/usr/include/i386-linux-gnu/bits/signum.h （ubuntu12.04）
/usr/include/x86_64-linux-gnu/bits/signum.h （ubuntu16.04）

在Linux下，要想查看这些信号和编码的对应关系，可使用命令：kill ­l
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/e269e821a6e8410ab1acd346462fdd12.png"></p>
<pre><code>信号是由当前系统已经定义好的一些标识，
每一个标识都会在特定的场合使用
并且都会对进程有一定的影响，
当信号产生时，
会让当前信号做出相应的操作
这些信号都是已经定义好的，
我们不能自己再去创造，
直接使用这些就可以。
</code></pre>
<h3 id="2-1-2-产生信号的方式"><a href="#2-1-2-产生信号的方式" class="headerlink" title="2.1.2 产生信号的方式"></a>2.1.2 产生信号的方式</h3><pre><code>1、当用户按某些终端键时，
将产生信号
例如：终端上按“Ctrl+c”组合键通常产生中断信号SIGINT、
终端上按&quot;Ctrl+\&quot;键通常产生中断信号SIGQUIT、
终端上按&quot;Ctrl+z&quot;键通常产生中断信号SIGSTOP。
2、硬件异常将产生信号除数为0，
无效的内存访问等。
这些情况通常由硬件检测到，
并通知内核,然后内核产生
适当的信号发送给相应的进程。
3、软件异常将产生信号。
当检测到某种软件条件已发生，
并将其通知有关进程时，
产生信号。
4、调用kill函数将发送信号。
注意：接收信号进程和发送信号进程的所有者必须相同，
或发送信号进程的所有者必须是超级用户。
5、运行kill命令将发送信号。
此程序实际上是使用kill函数来发送信号。
也常用此命令终止一个失控的后台进程。
</code></pre>
<h3 id="2-1-3-信号的默认（缺省）处理方式"><a href="#2-1-3-信号的默认（缺省）处理方式" class="headerlink" title="2-1-3 信号的默认（缺省）处理方式"></a>2-1-3 信号的默认（缺省）处理方式</h3><pre><code>当进程中产生了一个信号，
就会让当前进程做出一定的反应，
默认处理进程的方式如下
1、终止进程：当信号产生后，
当前进程就会立即结束。
2、缺省处理：当信号产生后，
当前进程不做任何处理。
3、停止进程：当信号产生后，
使得当前进程停止。
4、让停止的进程回复运行：当信号产生后，
停止的进程会回复执行（后台进程）。
注意：每一个信号只有一个默认的处理方式
</code></pre>
<h3 id="2-1-4-进程接收到信号后的处理方式"><a href="#2-1-4-进程接收到信号后的处理方式" class="headerlink" title="2-1-4 进程接收到信号后的处理方式"></a>2-1-4 进程接收到信号后的处理方式</h3><pre><code>1、执行系统默认动作
对大多数信号来说，
系统默认动作是用来终止该进程。
2、忽略此信号
接收到此信号后没有任何动作。
3、执行自定义信号处理函数
用用户定义的信号处理函数处理该信号。
注意：	
SIGKILL和SIGSTOP这两个信号只能以默认的处理方式执行，
不能忽略也不能自定义
</code></pre>
<h3 id="2-1-5-常见的信号"><a href="#2-1-5-常见的信号" class="headerlink" title="2-1-5 常见的信号"></a>2-1-5 常见的信号</h3><pre><code>信号 		值 			性质 												默认处理方式
SIGKILL 	9		 当产生这个信号后，当前进程会退出，不能被缺省和捕捉		退出进程
SIGSTOP 	19		 当产生这个信号后，当前进程会停止，不能被缺省和捕捉		停止进程
SIGINT		 2		 键盘输入ctrl+c时产生信号 								退出进程
SIGQUIT		 3 		 键盘输入ctrl+\时产生信号 								退出进程
SIGTSTP		 20		 键盘输入ctrl+z时产生信号 								停止进程
SIGCONT		 18		 当产生当前信号后，当前停止的进程会恢复运行				停止的进程恢复运行
SIGALRM 	14		 当调用alarm函数设置的时间到达时会产生当前信号				退出进程
SIGPIPE		 13 	当管道破裂时，会产生当前信号 								退出进程
SIGABRT 	6		 当调用abort函数时会产生当前信号 							退出进程
SIGCHLD 	17		当使用fork创建一个子进程时，如果子进程状态改变（退出），
会产生当前信号																缺省
SIGUSR1 	10		用户自定义信号，不会自动产生，只能
使用kill函数或者命令给指定的进程发送当前信号									缺省
SIGUSR2 	12		用户自定义信号，不会自动产生，
只能使用kill函数或者命令给指定的进程发送当前信号								缺省
</code></pre>
<h2 id="2-2、-kill函数"><a href="#2-2、-kill函数" class="headerlink" title="2-2、 kill函数"></a>2-2、 kill函数</h2><pre><code>kill并不是杀死的意思，
是表示对进程发送一个信号。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">功能：给指定的进程或者进程组发送信号</span><br><span class="line">参数：</span><br><span class="line">pid：</span><br><span class="line">pid&gt;0: 将信号传送给进程ID为pid的进程。</span><br><span class="line">pid=0: 将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">pid=‐1: 将信号传送给系统内所有的进程，除了init进程</span><br><span class="line"> pid&lt;‐1: 将信号传给指定进程组的所有进程。这个进程组号等于pid的绝对值。</span><br><span class="line"> sig：指定的信号</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">     pid = fork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">     else if(pid &gt; 0) //父进程的代码区</span><br><span class="line">        &#123;</span><br><span class="line">        while(1)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;This is parent peocess\n&quot;);</span><br><span class="line"></span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     else //子进程的代码区</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;This is son process\n&quot;);</span><br><span class="line"></span><br><span class="line">         //子进程在3秒之后，让父进程退出</span><br><span class="line">         sleep(3);</span><br><span class="line"></span><br><span class="line">         //使用kill给父进程发送信号，然后父进程接收到信号后直接退出就可以了</span><br><span class="line">         kill(getppid(), SIGINT);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/795cc297eb924527a0d4b55d98a7f663.png"></p>
<h2 id="2-3、alarm函数"><a href="#2-3、alarm函数" class="headerlink" title="2-3、alarm函数"></a>2-3、alarm函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">功能：定时器，闹钟，当设定的时间到达时，会产生SIGALRM信号</span><br><span class="line">参数：</span><br><span class="line">seconds：设定的秒数</span><br><span class="line">返回值：</span><br><span class="line">如果alarm函数之前没有alarm设置，则返回0</span><br><span class="line">如果有，则返回上一个alarm剩余的时间</span><br></pre></td></tr></table></figure>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    unsigned int sec;</span><br><span class="line">    //当执行到alarm之后，代码会接着往下执行，当设定的时间到后，会产生SIGALRM信号</span><br><span class="line"></span><br><span class="line">    //如果alarm之前没有设置其他闹钟，则返回0，如果之前设置了，则返回之前剩余的秒数</span><br><span class="line">    //如果一个程序中出现多个alarm闹钟，第一个如果没有到达指定的时间就遇到第二个</span><br><span class="line">    //则第一个的闹钟时间清除，按照第二个alarm闹钟的时间继续向下运行</span><br><span class="line"></span><br><span class="line">    sec = alarm(5);</span><br><span class="line">    printf(&quot;sec = %d\n&quot;, sec);</span><br><span class="line"></span><br><span class="line">    sleep(3);</span><br><span class="line"></span><br><span class="line">    sec = alarm(6);</span><br><span class="line">    printf(&quot;sec = %d\n&quot;, sec);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/11e68407338a438dadc496a5c0a27840.png"></p>
<pre><code>第二个定时被重重了，
剩余时间被清楚，
按照第二个的时间进行。
</code></pre>
<h2 id="2-4、-raise函数"><a href="#2-4、-raise函数" class="headerlink" title="2-4、 raise函数"></a>2-4、 raise函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int raise(int sig);</span><br><span class="line">功能：给调用进程本身发送信号</span><br><span class="line">参数：</span><br><span class="line">sig：指定的信号</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br><span class="line"> raise(sig) &lt;==&gt; kill(getpid(), sig)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;  </span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    num++;</span><br><span class="line">    </span><br><span class="line">    //当循环执行5秒后，进程退出</span><br><span class="line">    if(num == 5)</span><br><span class="line">        &#123;</span><br><span class="line">        //使用raise给当前进程本身发送信号</span><br><span class="line">        raise(SIGALRM);</span><br><span class="line">        //kill(getpid(), SIGALRM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/89c4cd241f1a49c3a20ee6f8bfead789.png"></p>
<h2 id="2-5、-abort函数"><a href="#2-5、-abort函数" class="headerlink" title="2-5、 abort函数"></a>2-5、 abort函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line">void abort(void);</span><br><span class="line">功能：向进程发送一个SIGABRT信号，默认情况下进程会退出。</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<pre><code>注意：
即使SIGABRT信号被加入阻塞集，一旦进程调用了abort函数，进程也还是会被终止，
且在终止前会刷新缓冲区，关闭文件描述符。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> sleep(1);</span><br><span class="line"> num++;</span><br><span class="line"></span><br><span class="line"> //当循环执行5秒后，进程退出</span><br><span class="line"> if(num == 5)</span><br><span class="line"> &#123;</span><br><span class="line"> abort();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/de5d4268dab149dd9d345800bbebe841.png"></p>
<h2 id="2-6、-pause函数"><a href="#2-6、-pause函数" class="headerlink" title="2-6、 pause函数"></a>2-6、 pause函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pause(void);</span><br><span class="line">功能：阻塞等待一个信号的产生</span><br><span class="line">参数：</span><br><span class="line">无</span><br><span class="line">返回值：</span><br><span class="line">当有信号产生时，函数返回‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">     pid = fork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">     else if(pid &gt; 0) //父进程的代码区</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;This is parent peocess\n&quot;);</span><br><span class="line"></span><br><span class="line">        //使用pause阻塞等待捕捉信号</span><br><span class="line">        pause();</span><br><span class="line">        &#125;</span><br><span class="line">     else //子进程的代码区</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;This is son process\n&quot;);</span><br><span class="line"></span><br><span class="line">         sleep(3);</span><br><span class="line"></span><br><span class="line">         kill(getppid(), SIGINT);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c8ee20ea2daf42269e0a729f4d209956.png"></p>
<h2 id="2-7、-signal函数"><a href="#2-7、-signal函数" class="headerlink" title="2-7、 signal函数"></a>2-7、 signal函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void (*signal(int sig, void (*func)(int)))(int);</span><br><span class="line">‐‐&gt;</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">功能：当进程中产生某一个信号时，对当前信号进行处理</span><br><span class="line">参数：</span><br><span class="line">sig：指定要处理的信号                                                                                                                                                                                                                                                                                                                                                                                                                                                </span><br><span class="line">handler：处理方式</span><br><span class="line"> SIG_IGN 当信号产生时，以缺省（忽略）的方式处理</span><br><span class="line"> SIG_DFL 当信号产生时，以当前信号默认的方式处理</span><br><span class="line"> void handler(int sig)：当信号产生时，通过信号处</span><br><span class="line"> 理函数自定义方式处理，函数名可以随便写，</span><br><span class="line"> 参数表示当前的信号</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回函数地址，该地址为此信号上一次注册的信号处理函数的地址</span><br><span class="line"> 失败：SIG_ERR</span><br></pre></td></tr></table></figure>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void handler(int sig);</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //以默认的方式处理信号</span><br><span class="line"> #if 0</span><br><span class="line"> if(signal(SIGINT, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGTSTP, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //以忽略的方式来处理信号</span><br><span class="line"> #if 0</span><br><span class="line"> if(signal(SIGINT, SIG_IGN) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGQUIT, SIG_IGN) == SIG_ERR)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to signal&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> if(signal(SIGTSTP, SIG_IGN) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //注意：SIGKILL和SIGSTOP这两个信号只能以默认的方式处理，不能忽略或者捕捉</span><br><span class="line"> // if(signal(SIGKILL, SIG_IGN) == SIG_ERR)</span><br><span class="line"> // &#123;</span><br><span class="line"> // perror(&quot;fail to signal&quot;);</span><br><span class="line"> // exit(1);</span><br><span class="line"> // &#125;</span><br><span class="line"></span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //以用户自定义方式处理信号</span><br><span class="line"> #if 1</span><br><span class="line"> if(signal(SIGINT, handler) == SIG_ERR)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to signal&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> if(signal(SIGQUIT, handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGTSTP, handler) == SIG_ERR)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to signal&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> #endif</span><br><span class="line"> while(1)</span><br><span class="line">     &#123;</span><br><span class="line">     printf(&quot;hello world\n&quot;);</span><br><span class="line">     sleep(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void handler(int sig)</span><br><span class="line"> &#123;</span><br><span class="line"> if(sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;SIGINT正在处理\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> if(sig == SIGQUIT)</span><br><span class="line">     &#123;</span><br><span class="line">     printf(&quot;SIGQUIT正在处理\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> if(sig == SIGTSTP)</span><br><span class="line">     &#123;</span><br><span class="line">     printf(&quot;SIGTSTP正在处理\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<pre><code>返回值
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *ret_handler;</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;**********************\n&quot;);</span><br><span class="line">    printf(&quot;nihao beijing\n&quot;);</span><br><span class="line">     printf(&quot;welcome to 1000phone\n&quot;);</span><br><span class="line">     printf(&quot;**********************\n&quot;);</span><br><span class="line"></span><br><span class="line">     if(signal(SIGINT, ret_handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if((ret_handler = signal(SIGINT, handler)) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>	signal的返回值返回的是当前处理方式的上一次处理的方式</code></p>
<p><img src="https://img-blog.csdnimg.cn/904ada98e3c446d38cbdc8f4815180d9.png"></p>
<h2 id="2-8、-可重入函数"><a href="#2-8、-可重入函数" class="headerlink" title="2-8、 可重入函数"></a>2-8、 可重入函数</h2><pre><code>可重入函数是指函数可以由多个任务并发使用，
而不必担心数据错误。
可重入函数就是可以被中断的函数，
当前函数可以在任何时刻中断它，
并执行另一块代码，
当执行完毕后，
回到原本的代码还可以正常继续运行。

编写可重入函数：
1、不使用（返回）静态的数据、全局变量（除非用信号量互斥）。
2、不调用动态内存分配、释放的函数。
3、不调用任何不可重入的函数（如标准I/O函数）。
注：
    即使信号处理函数使用的都是可重入函数（常见的可重入函数），也要注意进入处理函
数时，首先要保存errno的值，结束时，再恢复原值。因为，信号处理过程中，errno值随
时可能被改变。
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/e51ee614616843a9b2cd90b4b117b20f.png"></p>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void handler(int sig)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;SIGINT\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line"> //案例1：</span><br><span class="line"> #if 0</span><br><span class="line"> //sleep是一个可重入函数，但是当执行信号处理函数之后，不会回到原本的位置继续睡眠</span><br><span class="line"> //sleep(10);</span><br><span class="line"></span><br><span class="line"> //alarm函数是一个可重入函数，当他执行时，如果有信号产生并执行信号处理函数，执行完毕后，会继续运行</span><br><span class="line"> alarm(10);</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //案例2：</span><br><span class="line"> #if 1</span><br><span class="line"> char buf[32] = &quot;&quot;;</span><br><span class="line"></span><br><span class="line"> //read也是一个可重入函数，在等待终端输入时，如果产生信号并执行信号处理函数，信号处理</span><br><span class="line"> //函数执行完毕后，可以继续输入数据，read可以读取到信号处理函数之后的数据</span><br><span class="line"> if(read(0, buf, 20) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to read&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> #endif</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f62086f379844a1f8c3522109488117c.png"></p>
<h2 id="2-9、-信号集"><a href="#2-9、-信号集" class="headerlink" title="2-9、 信号集"></a>2-9、 信号集</h2><pre><code>信号集概述
一个用户进程常常需要对多个信号做出处理。
为了方便对多个信号进行处理，
在Linux系统中引入了信号集。
信号集是用来表示多个信号的数据类型。

信号集数据类型
sigset_t
定义路径：
/usr/include/i386-linux-gnu/bits/sigset.h (ubuntu 12.04)
/usr/include/x86_64-linux-gnu/bits/sigset.h (ubuntu16.04)
</code></pre>
<p>信号集相关的操作主要有如下几个函数：<br><code>sigemptyset</code><br><code>sigfillset</code><br><code>sigismember</code><br><code>sigaddset</code><br><code>sigdelset</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1 ‐‐ sigemptyset()</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigemptyset(sigset_t *set)；</span><br><span class="line">功能：</span><br><span class="line">初始化由set指向的信号集，清除其中所有的信号即初始化一个空信号集。</span><br><span class="line">参数：</span><br><span class="line">set：信号集标识的地址，以后操作此信号集，对set进行操作就可以了。</span><br><span class="line">返回值:</span><br><span class="line">成功返回 0</span><br><span class="line"> 失败返回 ‐1</span><br><span class="line"></span><br><span class="line"> 2 ‐‐ sigfillset()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigfillset(sigset_t *set)；</span><br><span class="line"> 功能：</span><br><span class="line"> 初始化信号集合set, 将信号集合设置为所有信号的集合。</span><br><span class="line"> 参数：</span><br><span class="line"> 信号集标识的地址，以后操作此信号集，对set进行操作就可以了。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功返回 0</span><br><span class="line"> 失败返回 ‐1</span><br><span class="line"></span><br><span class="line"> 3 ‐‐ sigismember()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigismember(const sigset_t *set,int signum);</span><br><span class="line"> 功能：</span><br><span class="line"> 查询signum标识的信号是否在信号集合set之中。</span><br><span class="line"> 参数：</span><br><span class="line"> set：信号集标识符号的地址。</span><br><span class="line"> signum：信号的编号。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功：在信号集中返回 1，不在信号集中返回 0</span><br><span class="line"> 错误：返回 ‐1</span><br><span class="line"></span><br><span class="line"> 4 ‐‐ sigaddset()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigaddset(sigset_t *set, int signum);</span><br><span class="line"> 功能：</span><br><span class="line"> 将信号signum加入到信号集合set之中。</span><br><span class="line"> 参数：</span><br><span class="line"> set：信号集标识的地址。</span><br><span class="line"> signum：信号的编号。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功返回 0</span><br><span class="line"> 失败返回 ‐1</span><br><span class="line"></span><br><span class="line"> 5 ‐‐ sigdelset()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigdelset(sigset_t *set, int signum);</span><br><span class="line"> 功能：</span><br><span class="line"> 将signum所标识的信号从信号集合set中删除。</span><br><span class="line"> 参数：</span><br><span class="line"> set：信号集标识的地址。</span><br><span class="line"> signum：信号的编号。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功：返回 0</span><br><span class="line"> 失败：返回 ‐1</span><br></pre></td></tr></table></figure>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//创建一个信号集</span><br><span class="line">sigset_t set;</span><br><span class="line">int ret = 0;</span><br><span class="line"> //初始化一个空的信号集</span><br><span class="line"> sigemptyset(&amp;set);</span><br><span class="line"></span><br><span class="line"> //判断SIGINT信号是否在信号集中</span><br><span class="line"> ret = sigismember(&amp;set, SIGINT);</span><br><span class="line"> if(ret == 0)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;SIGINT is not a member of sigprocmask \nret = %d\n&quot;, ret);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //将指定的信号添加到信号集中</span><br><span class="line"> sigaddset(&amp;set, SIGINT);</span><br><span class="line"> sigaddset(&amp;set, SIGQUIT);</span><br><span class="line"></span><br><span class="line"> ret = sigismember(&amp;set, SIGINT);</span><br><span class="line"> if(ret == 1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;SIGINT is a member of sigprocmask \nret = %d\n&quot;, ret);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/cb2ac531866940e89756cea0449adbe6.png"></p>
<h2 id="2-10、-信号阻塞集"><a href="#2-10、-信号阻塞集" class="headerlink" title="2-10、 信号阻塞集"></a>2-10、 信号阻塞集</h2><pre><code>每个进程都有一个阻塞集，
它用来描述哪些信号递送到该进程的时候被阻塞(在信号发生时记住它，
直到进程准备好时再将信号通知进程)。
所谓阻塞并不是禁止传送信号, 
而是暂缓信号的传送。
若将被阻塞的信号从信号阻塞集中删除，
且对应的信号在被阻塞时发生了，
进程将会收到相应的信号。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)；</span><br><span class="line">功能：检查或修改信号阻塞集，根据how指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由set指定，而原先的信号阻塞集合由oldset保存。</span><br><span class="line">参数：</span><br><span class="line">how：信号阻塞集合的修改方法。</span><br><span class="line">SIG_BLOCK：向信号阻塞集合中添加set信号集</span><br><span class="line">SIG_UNBLOCK：从信号阻塞集合中删除set集合</span><br><span class="line">SIG_SETMASK：将信号阻塞集合设为set集合</span><br><span class="line">set：要操作的信号集地址。</span><br><span class="line">oldset：保存原先信号集地址。</span><br><span class="line">注：若set为NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。</span><br><span class="line">返回值:</span><br><span class="line">成功：返回 0</span><br><span class="line">失败：返回 ‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line"> //创建信号集并在信号集中添加信号</span><br><span class="line"> sigset_t set;</span><br><span class="line"> sigemptyset(&amp;set);</span><br><span class="line"> sigaddset(&amp;set, SIGINT);</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    //将set信号集添加到信号阻塞集中</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line">    for(i=0; i&lt;5; i++)</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;SIGINT signal is blocked\n&quot;);</span><br><span class="line">         sleep(1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    //将set信号集从信号阻塞集中删除</span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">    for(i=0; i&lt;5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;SIGINT signal unblocked\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/27abd170ad49469bbee0fe5abfa45a06.png"></p>
<h1 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h1><h2 id="3-1、无名管道概述"><a href="#3-1、无名管道概述" class="headerlink" title="3-1、无名管道概述"></a>3-1、无名管道概述</h2><pre><code>管道(pipe)又称无名管道。
无名管道是一种特殊类型的文件，
在应用层体现为两个打开的文件描述符。
任何一个进程在创建的时候，
系统都会 给他分配4G的虚拟内存，分为3G的用户空间和1G
的内核空间，内核空间是所有进程公有的，
</code></pre>
<p><code>无名管道就是创建在内核空间的</code>,</p>
<pre><code>多个进程知道同一个无名管道的空间，
就可以利用他来进行通信
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2b9b0d0acc504faeadb848c73a0b91b1.png"></p>
<pre><code>无名管道虽然是在内核空间创建的，
但是会给当前用户进程两个文件描述符，
一个负责执行读操作，
一个负责执行写操作。
</code></pre>
<p>管道是最古老的UNIX IPC方式，其特点是:<br>1、半双工，数据在同一时刻只能在一个方向上流动。<br><code>2、数据只能从管道的一端写入，从另一端读出。</code><br>3、写入管道中的数据遵循先入先出的规则。<br>4、管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格<br>式，如多少字节算一个消息等。<br><code>5、管道不是普通的文件，不属于某个文件系统，其只存在于内存中。</code><br>6、管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。<br>7、从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写<br>更多的数据。<br><code>8、管道没有名字，只能在具有公共祖先的进程之间使用</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;unistd.h&gt;</span><br><span class="line">2 int pipe(int pipefd[2]);</span><br><span class="line">3 功能：创建一个有名管道，返回两个文件描述符负责对管道进行读写操作</span><br><span class="line">4 参数：</span><br><span class="line">5 pipefd：int型数组的首地址，里面有两个元素</span><br><span class="line">6 pipefd[0] 负责对管道执行读操作</span><br><span class="line">7 pipefd[1] 负责对管道执行写操作</span><br><span class="line">8 返回值：</span><br><span class="line">9 成功：0</span><br><span class="line">10 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>案例
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用pipe创建一个无名管道</span><br><span class="line">int fd_pipe[2];</span><br><span class="line"> if(pipe(fd_pipe) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to pipe&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;fd_pipe[0] = %d\n&quot;, fd_pipe[0]);</span><br><span class="line"> printf(&quot;fd_pipe[1] = %d\n&quot;, fd_pipe[1]);</span><br><span class="line"></span><br><span class="line"> //对无名管道执行读写操作</span><br><span class="line"> //由于无名管道给当前用户进程两个文件描述符，所以只要操作这两个文件</span><br><span class="line"> //描述符就可以操作无名管道，所以通过文件IO中的read和write函数对无名管道进行操作</span><br><span class="line"></span><br><span class="line"> //通过write函数向无名管道中写入数据</span><br><span class="line"> //fd_pipe[1]负责执行写操作</span><br><span class="line"> //如果管道中有数据，再次写入的数据会放在之前数据的后面，不会把之前的数据替换</span><br><span class="line"> if(write(fd_pipe[1], &quot;hello world&quot;, 11) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to write&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> write(fd_pipe[1], &quot;nihao beijing&quot;, strlen(&quot;nihao beijing&quot;)+1);</span><br><span class="line"></span><br><span class="line"> //通过read函数从无名管道中读取数据</span><br><span class="line"> //fd_pipe[0]负责执行读操作</span><br><span class="line"> //读取数据时，直接从管道中读取指定个数的数据，如果管道中没有数据了，则read函数会阻塞等待</span><br><span class="line"> char buf[32] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> if((bytes = read(fd_pipe[0], buf, 20)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to read&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes); </span><br><span class="line"></span><br><span class="line"> bytes = read(fd_pipe[0], buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"></span><br><span class="line"> bytes = read(fd_pipe[0], buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-2、-无名管道实现进程间通信"><a href="#3-2、-无名管道实现进程间通信" class="headerlink" title="3-2、 无名管道实现进程间通信"></a>3-2、 无名管道实现进程间通信</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//使用无名管道实现父子进程间的通信</span><br><span class="line">//由于无名管道创建之后给当前进程两个文件描述符，所以如果是完全不相关的进程</span><br><span class="line">//无法获取同一个无名管道的文件描述符，所以无名管道只能在具有亲缘关系的进程间通信</span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //创建一个无名管道</span><br><span class="line"> int pipefd[2];</span><br><span class="line"> if(pipe(pipefd) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pipe&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //使用fork函数创建子进程</span><br><span class="line"> pid_t pid;</span><br><span class="line"> if((pid = fork()) &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to fork&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> else if(pid &gt; 0) // 父进程</span><br><span class="line">     &#123;</span><br><span class="line">     //父进程负责给子进程发送数据</span><br><span class="line">     char buf[128] = &#123;&#125;;</span><br><span class="line">     while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         fgets(buf, sizeof(buf), stdin);</span><br><span class="line">         buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">        </span><br><span class="line">         if(write(pipefd[1], buf, sizeof(buf)) == -1)</span><br><span class="line">             &#123;</span><br><span class="line">             perror(&quot;fail to write&quot;);</span><br><span class="line">             exit(1);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> else //子进程</span><br><span class="line">     &#123;</span><br><span class="line">     //子进程接收父进程的数据</span><br><span class="line">     char buf[128] = &quot;&quot;;</span><br><span class="line">     while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         if(read(pipefd[0], buf, sizeof(buf)) == -1)</span><br><span class="line">            &#123;</span><br><span class="line">            perror(&quot;fail to read&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         printf(&quot;from parent: %s\n&quot;, buf);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/8159d6d1ccf748bfa9e00c3fda9d6b2a.png"></p>
<pre><code>可以在上面的基础上再创建一个无名管道，
两个进程之间进行互相读写操作。
注意：
利用无名管道实现进程间的通信，
都是父进程创建无名管道，
然后再创建子进程，
子进程继承父进程的无名管道的文件描述符，
然后父子进程通过读写无名管道实现通信。
</code></pre>
<h2 id="3-3、无名管道的读写规律"><a href="#3-3、无名管道的读写规律" class="headerlink" title="3-3、无名管道的读写规律"></a>3-3、无名管道的读写规律</h2><h3 id="3-3-1、读写端都存在，只读不写"><a href="#3-3-1、读写端都存在，只读不写" class="headerlink" title="3-3-1、读写端都存在，只读不写"></a>3-3-1、读写端都存在，只读不写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">if(pipe(pipefd) == -1)</span><br><span class="line">&#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只读不写</span><br><span class="line"> //如果管道中有数据，会正常读取数据</span><br><span class="line"> //如果管道中没有数据，则读操作会阻塞等待，直到有数据为止</span><br><span class="line"></span><br><span class="line"> write(pipefd[1], &quot;hello world&quot;, 11);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> if(read(pipefd[0], buf, sizeof(buf)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> if(read(pipefd[0], buf, sizeof(buf)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2eba9664db524c6293fdd0d0a0c186af.png"></p>
<pre><code>读完之后会阻塞
</code></pre>
<h3 id="3-3-2、读写端都存在，只写不读"><a href="#3-3-2、读写端都存在，只写不读" class="headerlink" title="3-3-2、读写端都存在，只写不读"></a>3-3-2、读写端都存在，只写不读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">if(pipe(pipefd) == -1)</span><br><span class="line">&#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只写不读</span><br><span class="line"> //如果一直执行写操作，则无名管道对应的缓冲区会被写满，写满之后，write函数会阻塞等待</span><br><span class="line"> //默认无名管道的缓冲区64K字节</span><br><span class="line"></span><br><span class="line"> int num = 0;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(write(pipefd[1], &quot;6666&quot;, 1024) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to write&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> printf(&quot;num = %d\n&quot;, num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/bace39d7e97d49dc99a7ac0ccafb71e4.png"></p>
<h3 id="3-3-3、只有读端，没有写端"><a href="#3-3-3、只有读端，没有写端" class="headerlink" title="3-3-3、只有读端，没有写端"></a>3-3-3、只有读端，没有写端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">if(pipe(pipefd) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> write(pipefd[1], &quot;hello world&quot;,11);</span><br><span class="line"></span><br><span class="line"> //关闭写文件描述符，只有读端</span><br><span class="line"> //如果原本管道中有数据，则读操作正常读取数据</span><br><span class="line"> //如果管道中没有数据，则read函数会返回0</span><br><span class="line"> close(pipefd[1]);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> if((bytes = read(pipefd[0], buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> //清除字符串中的内容，用来清除内存的函数</span><br><span class="line"> memset(buf, 0, sizeof(buf));</span><br><span class="line"></span><br><span class="line"> if((bytes = read(pipefd[0], buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/877a80aa17c84936ac8eca7aa35df182.png"></p>
<h3 id="3-3-4、只有写端，没有读端"><a href="#3-3-4、只有写端，没有读端" class="headerlink" title="3-3-4、只有写端，没有读端"></a>3-3-4、只有写端，没有读端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;SIGPIPE信号产生了，管道破裂了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> signal(SIGPIPE, handler);</span><br><span class="line"></span><br><span class="line"> int pipefd[2];</span><br><span class="line"> if(pipe(pipefd) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //关闭写操作文件描述符，只有写端</span><br><span class="line"> //如果关闭读端，一旦执行写操作，就会产生一个信号SIGPIPE（管道破裂），</span><br><span class="line"> //这个信号的默认处理方式是退出进程</span><br><span class="line"> close(pipefd[0]);</span><br><span class="line"></span><br><span class="line"> int num = 0;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(write(pipefd[1], &quot;hello world&quot;, 1024) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to write&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> printf(&quot;num = %d\n&quot;, num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4d96bf1bc95040778a9717807c935cd4.png"></p>
<h2 id="3-4、通过fcntl函数设置文件的阻塞特性"><a href="#3-4、通过fcntl函数设置文件的阻塞特性" class="headerlink" title="3-4、通过fcntl函数设置文件的阻塞特性"></a>3-4、通过fcntl函数设置文件的阻塞特性</h2><pre><code>设置为阻塞：
fcntl(fd, F_SETFL, 0);
设置为非阻塞：
fcntl(fd, F_SETFL, O_NONBLOCK);
非阻塞：
如果是阻塞，
管道中没有数据，read会一直等待，
直到有数据才会继续运行，
否则一直等待.
如果是非阻塞，
read函数运行时，
会先看一下管道中是否有数据，
如果有数据，
则正常运行读取数据，
如果管道中没有数据，
则read函数会立即返回，
继续下面的代码运行
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> int fd_pipe[2];</span><br><span class="line"> char buf[] = &quot;hello world&quot;;</span><br><span class="line"> pid_t pid;</span><br><span class="line"></span><br><span class="line"> if (pipe(fd_pipe) &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to pipe&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> pid = fork();</span><br><span class="line"> if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to fork&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"> if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        sleep(5);</span><br><span class="line">        write(fd_pipe[1], buf, strlen(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> else</span><br><span class="line">     &#123;</span><br><span class="line">     //将fd_pipe[0]设置为阻塞</span><br><span class="line">     //fcntl(fd_pipe[0], F_SETFL, 0);</span><br><span class="line">     //将fd_pipe[0]设置为非阻塞</span><br><span class="line">     fcntl(fd_pipe[0], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">     while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         memset(buf, 0, sizeof(buf));</span><br><span class="line">         read(fd_pipe[0], buf, sizeof(buf));</span><br><span class="line">         printf(&quot;buf=[%s]\n&quot;, buf);</span><br><span class="line">         sleep(1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/26e2f1945fc64919bde9ffa438e8d222.png"></p>
<h1 id="4、文件描述符概述"><a href="#4、文件描述符概述" class="headerlink" title="4、文件描述符概述"></a>4、文件描述符概述</h1><pre><code>文件描述符是非负整数，
是文件的标识。
用户使用文件描述符（file descriptor）来访问文件。
利用open打开一个文件时，
内核会返回一个文件描述符。
每个进程都有一张文件描述符的表，
进程刚被创建时，标准输入、
标准输出、标准错误输出。
设备文件被打开，
对应的文件描述符0、1、2 记录在表中。
在进程中打开其他文件时，
系统会返回文件描述符表中最小可用的文件描述符，
并将此文件描述符记录在表中。
注意：
Linux中一个进程最多只能打开NR_OPEN_DEFAULT
（即1024）个文件，
故当文件不再使用时应及时调用close函数关闭文件。

echo log &gt; /dev/null 2&gt;&amp;1
&gt;  ：表示将输出结果重定向到哪里，
例如：echo &quot;123&quot; &gt; /home/123.txt
/dev/null ：表示空设备文件
所以 echo log &gt; /dev/null 表示把日志输出到空文件设备，
也就是将打印信息丢弃掉，屏幕上什么也不显示。

1  ：表示stdout标准输出
2  ：表示stderr标准错误
&amp;  ：表示等同于的意思
所以  2&gt;&amp;1 表示2的输出重定向等同于1，
也就是标准错误输出重定向到标准输出。
因为前面标准输出已经重定向到了空设备文件，
所以标准错误输出也重定向到空设备文件。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //在进程中打开其他文件时，</span><br><span class="line"> //系统会返回文件描述符表中最小可用的文件描述符，</span><br><span class="line"> //并将此文件描述符记录在进程的文件描述符表中。</span><br><span class="line"> //注意：新创建的文件描述符的值不一定是最大的</span><br><span class="line"> #if 0</span><br><span class="line"> close(0);</span><br><span class="line"></span><br><span class="line"> int fd1, fd2, fd3;</span><br><span class="line"> fd1 = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664);</span><br><span class="line"> fd2 = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664);</span><br><span class="line"> fd3 = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664);</span><br><span class="line"></span><br><span class="line"> printf(&quot;fd1 = %d\n&quot;, fd1);</span><br><span class="line"> printf(&quot;fd2 = %d\n&quot;, fd2);</span><br><span class="line"> printf(&quot;fd3 = %d\n&quot;, fd3);</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //Linux中一个进程最多只能打开NR_OPEN_DEFAULT（即1024）个文件，</span><br><span class="line"> //故当文件不再使用时应及时调用close函数关闭文件</span><br><span class="line"> int fd;</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if((fd = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to open&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;fd = %d\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-1、dup函数"><a href="#4-1、dup函数" class="headerlink" title="4-1、dup函数"></a>4-1、dup函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dup函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br><span class="line">功能：复制oldfd文件描述符，并分配一个新的文件描述符，新的文件描述符是调用进程文件描述符表中最小可用的文件描述符。</span><br><span class="line">参数：</span><br><span class="line">要复制的文件描述符oldfd。</span><br><span class="line">返回值：</span><br><span class="line">成功：新文件描述符。</span><br><span class="line">失败：返回－1，错误代码存于errno中。</span><br></pre></td></tr></table></figure>
<h3 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line"> &#123;</span><br><span class="line"> //通过dup函数复制一个文件描述符</span><br><span class="line"> int fd;</span><br><span class="line"> //dup执行后给返回值文件描述符分配的值是文件描述符表中最小可用的文件描述符</span><br><span class="line"> fd = dup(1);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd);</span><br><span class="line"> //由于通过dup函数将1这个文件描述符复制了一份为fd，所以fd现在就相当于1，所以写数据就是想终端写入数据</span><br><span class="line"> write(fd, &quot;nihao beijing\n&quot;, strlen(&quot;nihao beijing\n&quot;));</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4e360e4f6f664295b40ce00a355ef284.png"></p>
<h3 id="案例2：实现输出重定向的功能"><a href="#案例2：实现输出重定向的功能" class="headerlink" title="案例2：实现输出重定向的功能"></a>案例2：实现输出重定向的功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //如果需要实现输出重定向的功能</span><br><span class="line"> //首先像printf函数是操作文件描述符1所对应的文件，</span><br><span class="line"> //默认是操作终端，只要能够把1对应标识的文件改变，就可以实现输出重定向</span><br><span class="line"> //所以实现创建好文件对应的文件描述符之后，将1文件描述符关闭，接着通过dup</span><br><span class="line"> //函数复制的新的文件描述符就是1，这样printf函数对1操作，就写到了文件中</span><br><span class="line"> int fd_file;</span><br><span class="line"> fd_file = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0664);</span><br><span class="line"> if(fd_file == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(1);</span><br><span class="line"></span><br><span class="line"> int fd = dup(fd_file);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="案例3：实现输出重定向后，还想标准输出，如何实现"><a href="#案例3：实现输出重定向后，还想标准输出，如何实现" class="headerlink" title="案例3：实现输出重定向后，还想标准输出，如何实现"></a>案例3：实现输出重定向后，还想标准输出，如何实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int fd1;</span><br><span class="line"> int fd2;</span><br><span class="line"> fd2 = dup(1);</span><br><span class="line"> printf(&quot;new:fd2 = %d\n&quot;,fd2);</span><br><span class="line"></span><br><span class="line"> fd1 = open(&quot;test.txt&quot;, O_RDWR | O_CREAT, 0664);</span><br><span class="line"></span><br><span class="line"> close(1);</span><br><span class="line"> int fd3 = dup(fd1);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd3);</span><br><span class="line"></span><br><span class="line"> close(1);</span><br><span class="line"> int fd4 = dup(fd2);</span><br><span class="line"> printf(&quot;nihao beijing\n&quot;);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd4);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2、dup2函数"><a href="#4-2、dup2函数" class="headerlink" title="4-2、dup2函数"></a>4-2、dup2函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd, int newfd)</span><br><span class="line">功能：复制一份打开的文件描述符oldfd，</span><br><span class="line">并分配新的文件描述符newfd，newfd也标识oldfd所标识的文件。</span><br><span class="line">注意：</span><br><span class="line">newfd是小于文件描述符最大允许值的非负整数，</span><br><span class="line">如果newfd是一个已经打开的文件描述符，则首先关闭该文件，然后再复制。</span><br><span class="line">参数：</span><br><span class="line">oldfd：要复制的文件描述符</span><br><span class="line"> newfd：分配的新的文件描述符</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回newfd</span><br><span class="line"> 失败：返回‐1，错误代码存于errno中</span><br></pre></td></tr></table></figure>
<h3 id="实现输出重定向"><a href="#实现输出重定向" class="headerlink" title="实现输出重定向"></a>实现输出重定向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> int fd1;</span><br><span class="line"> int fd2;</span><br><span class="line"></span><br><span class="line"> fd1 = open(&quot;test.txt&quot;, O_CREAT | O_WRONLY, 0664);</span><br><span class="line"> if (fd1 &lt; 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //首先关闭1文件描述符，然后将fd1复制给1，意味着1和fd1都标识test.txt文件,返回值跟1是一样的</span><br><span class="line"> fd2 = dup2(fd1, 1);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> printf(&quot;fd2 = %d\n&quot;, fd2);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现输出重定向后，再恢复标准输出"><a href="#实现输出重定向后，再恢复标准输出" class="headerlink" title="实现输出重定向后，再恢复标准输出"></a>实现输出重定向后，再恢复标准输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int fd1;</span><br><span class="line"> //如果使用dup2，则需要实现给第二个参数对应的变量赋一个初始值</span><br><span class="line"> int fd2 = 3;</span><br><span class="line"></span><br><span class="line"> //将1复制一份为fd2，所以fd2标识的是标准输出</span><br><span class="line"> dup2(1, fd2);</span><br><span class="line"> printf(&quot;fd2 = %d\n&quot;, fd2);</span><br><span class="line"></span><br><span class="line"> fd1 = open(&quot;test.txt&quot;, O_CREAT | O_RDWR, 0664);</span><br><span class="line"></span><br><span class="line"> //输出重定向：关闭文件描述符1，将fd1复制一份为1，所以1此时标识的是test.txt文件</span><br><span class="line"> dup2(fd1, 1);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"></span><br><span class="line"> //再次实现标准输出：关闭文件描述符1，将fd2复制一份为1，所以1此时标识的是标准输出</span><br><span class="line"> dup2(fd2, 1);</span><br><span class="line"> printf(&quot;你好北京\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="5、有名管道"><a href="#5、有名管道" class="headerlink" title="5、有名管道"></a>5、有名管道</h1><h2 id="5-1、有名管道概述"><a href="#5-1、有名管道概述" class="headerlink" title="5-1、有名管道概述"></a>5-1、有名管道概述</h2><pre><code>命名管道(FIFO)和管道(pipe)基本相同，
但也有一些显著的不同，
其特点是:
1、半双工，数据在同一时刻只能在一个方向上流动。
2、写入FIFO中的数据遵循先入先出的规则。
3、FIFO所传送的数据是无格式的，
    这要求FIFO的读出方与写入方必须事先约定好数据的格式，
    如多少字节算一个消息等。
4、FIFO在文件系统中作为一个特殊的文件而存在并且在文件系统中可见，
    所以有名管道可以实现不相关进程间通信，
    但FIFO中的内容却存放在内存中。
5、管道在内存中对应一个缓冲区。
    不同的系统其大小不一定相同。
6、从FIFO读数据是一次性操作，
    数据一旦被读，
    它就从FIFO中被抛弃，
    释放空间以便写更多的数据。
7、当使用FIFO的进程退出后，
    FIFO文件将继续保存在文件系统中以便以后使用。
8、FIFO有名字，
    不相关的进程可以通过打开命名管道进行通信。
</code></pre>
<p><code>linux中有7种文件类型</code></p>
<p><img src="https://img-blog.csdnimg.cn/cc023d405c604fbf80e6e5883103579f.png"></p>
<h2 id="5-2、有名管道的创建"><a href="#5-2、有名管道的创建" class="headerlink" title="5-2、有名管道的创建"></a>5-2、有名管道的创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法1：用过shell命令mkfifo创建有名管道</span><br><span class="line">mkfifo 文件名</span><br><span class="line">方法2：使用函数mkfifo</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">功能：创建一个有名管道，产生一个本地文件系统可见的文件pathname</span><br><span class="line">参数：</span><br><span class="line">pathname：有名管道创建后生成的文件，可以带路径</span><br><span class="line">mode：管道文件的权限，一般通过八进制数设置即可，例如0664</span><br><span class="line">返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //通过mkfifo函数创建有名管道</span><br><span class="line"> if(mkfifo(&quot;fifo_file&quot;, 0664) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    //printf(&quot;errno = %d\n&quot;, errno);</span><br><span class="line">    //如果管道文件已经存在，不需要报错退出，直接使用即可，所以需要在错误输之前把</span><br><span class="line">    //因为文件存在的错误排除</span><br><span class="line">    if(errno != EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to mkfifo&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3、有名管道的基本读写操作"><a href="#5-3、有名管道的基本读写操作" class="headerlink" title="5-3、有名管道的基本读写操作"></a>5-3、有名管道的基本读写操作</h2><p>由于有名管道在本地创建了一个管道文件，<br>所以系统调用的IO函数基本都可以对有名管道进行操作，<br>但是不能使用lseek修改管道文件的偏移量<br>注意：有名管道创建的本地的文件只是起到标识作用，<br>真正有名管道实现进程间通信还是在内核空间开辟内存，<br>所以本地产生的文件只是一个标识，<br>没有其他作用，<br>对本地管道文件的操作实质就是对内核空间的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> #define FIFONAME &quot;fifo_file&quot;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //通过mkfifo函数创建有名管道</span><br><span class="line"> if(mkfifo(FIFONAME, 0664) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(errno != EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to mkfifo&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //对有名管道进行操作</span><br><span class="line"> //管道后写入的数据会保存在之前写入数据的后面，不会替换</span><br><span class="line"> //如果管道中没有数据了，读操作会阻塞</span><br><span class="line"></span><br><span class="line"> //通过open函数打开管道文件并得到文件描述符</span><br><span class="line"> int fd;</span><br><span class="line"> fd = open(FIFONAME, O_RDWR);</span><br><span class="line"> if(fd == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to open&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //通过write函数向管道中写入数据</span><br><span class="line"> if(write(fd, &quot;hello world&quot;, strlen(&quot;hello world&quot;)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to write&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> write(fd, &quot;nihao beijing&quot;, strlen(&quot;nihao beijing&quot;));</span><br><span class="line"></span><br><span class="line"> //通过read函数读取管道中的数据</span><br><span class="line"> char buf[32] = &quot;&quot;;</span><br><span class="line"> if(read(fd, buf, sizeof(buf)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to read&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> if(read(fd, buf, sizeof(buf)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to read&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> //使用close函数关闭文件描述符</span><br><span class="line"> close(fd);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4、有名管道实现进程间通信"><a href="#5-4、有名管道实现进程间通信" class="headerlink" title="5-4、有名管道实现进程间通信"></a>5-4、有名管道实现进程间通信</h2><pre><code>由于有名管道在本地创建了一个管道文件，
所以不相关的进程间也可以实现通信。
</code></pre>
<h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //如果没有创建有名管道，则创建有名管道</span><br><span class="line"> //为了实现两个进程都可以收发数据，所以需要创建两个有名管道</span><br><span class="line"> if(mkfifo(&quot;myfifo1&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if(mkfifo(&quot;myfifo2&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //打开两个有名管道并得到文件描述符</span><br><span class="line"> int fd_w, fd_r;</span><br><span class="line"> if((fd_w = open(&quot;myfifo1&quot;, O_WRONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if((fd_r = open(&quot;myfifo2&quot;, O_RDONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> fgets(buf, sizeof(buf), stdin);</span><br><span class="line"> buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line"> //send进程负责将数据写入myfifo1，接着从myfifo2中读取数据</span><br><span class="line"> if((bytes = write(fd_w, buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to write&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if((bytes = read(fd_r, buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;from recv: %s\n&quot;, buf);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo1&quot;, 0664) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if(mkfifo(&quot;myfifo2&quot;, 0664) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int fd_w, fd_r;</span><br><span class="line"></span><br><span class="line"> if((fd_r = open(&quot;myfifo1&quot;, O_RDONLY)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if((fd_w = open(&quot;myfifo2&quot;, O_WRONLY)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if((bytes = read(fd_r, buf, sizeof(buf))) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;from send: %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> fgets(buf, sizeof(buf), stdin);</span><br><span class="line"> buf[strlen(buf) ‐ 1] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line"> write(fd_w, buf, sizeof(buf));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5、有名管道的读写规律（阻塞）"><a href="#5-5、有名管道的读写规律（阻塞）" class="headerlink" title="5-5、有名管道的读写规律（阻塞）"></a>5-5、有名管道的读写规律（阻塞）</h2><h3 id="5-5-1、读写端都存在，只读不写"><a href="#5-5-1、读写端都存在，只读不写" class="headerlink" title="5-5-1、读写端都存在，只读不写"></a>5-5-1、读写端都存在，只读不写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只读不写</span><br><span class="line"> //如果原本管道中有数据，则正常读取</span><br><span class="line"> //如果管道中没有数据，则read函数会阻塞等待</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_RDWR)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> write(fd, &quot;hello world&quot;, 11);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> read(fd, buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> read(fd, buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7117b44f47f74ecca90c99321b4dc8e7.png"></p>
<h3 id="5-5-2、读写端都存在，只写不读"><a href="#5-5-2、读写端都存在，只写不读" class="headerlink" title="5-5-2、读写端都存在，只写不读"></a>5-5-2、读写端都存在，只写不读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只写不读</span><br><span class="line"> //当有名管道的缓冲区写满后，write函数会发生阻塞</span><br><span class="line"> //默认有名管道的缓冲区为64K字节</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_RDWR)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int num = 0;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> write(fd, &quot;&quot;, 1024);</span><br><span class="line"> num++;</span><br><span class="line"> printf(&quot;num = %d\n&quot;, num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/fa500384f5c74afeaae1b51c1f26eb45.png" alt="在这里插入图片描述"></p>
<h3 id="5-5-3、在一个进程中，只有读端，没有写端"><a href="#5-5-3、在一个进程中，只有读端，没有写端" class="headerlink" title="5-5-3、在一个进程中，只有读端，没有写端"></a>5-5-3、在一个进程中，只有读端，没有写端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //在一个进程中，只有读端，没有写端</span><br><span class="line"> //会在open函数的位置阻塞</span><br><span class="line"></span><br><span class="line"> printf(&quot;***********************\n&quot;);</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_RDONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if((bytes = read(fd, buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/c4e59bc08d5b4d168372c894caff590b.png"></p>
<h3 id="5-5-4、在一个进程中，只有写端，没有读端"><a href="#5-5-4、在一个进程中，只有写端，没有读端" class="headerlink" title="5-5-4、在一个进程中，只有写端，没有读端"></a>5-5-4、在一个进程中，只有写端，没有读端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //在一个进程中，只有写端，没有读端</span><br><span class="line"> //会在open函数的位置阻塞</span><br><span class="line"></span><br><span class="line"> printf(&quot;*****************************\n&quot;);</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_WRONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;-----------------------------\n&quot;);</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> write(fd, &quot;hello world&quot;, 11);</span><br><span class="line"> printf(&quot;666\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-5、-一个进程只读，一个进程只写"><a href="#5-5-5、-一个进程只读，一个进程只写" class="headerlink" title="5-5-5、 一个进程只读，一个进程只写"></a>5-5-5、 一个进程只读，一个进程只写</h3><pre><code>将上面5-5-3和5-5-4两个代码一起运行，
保证有名管道读写端都存在
规律：
只要保证有名管道的读写端都存在，
不管是几个进程，都不会再open这阻塞了
如果一个进程只读，
一个进程只写，都运行后，
如果关闭写端，读端read会返回0
如果一个进程只读，
一个进程只写，都运行后，
如果关闭读端，写端会立即产生
SIGPIPE信号，默认的处理方式是退出进程
</code></pre>
<h3 id="5-5-6、有名管道的读写规律（非阻塞）"><a href="#5-5-6、有名管道的读写规律（非阻塞）" class="headerlink" title="5-5-6、有名管道的读写规律（非阻塞）"></a>5-5-6、有名管道的读写规律（非阻塞）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> int fd;</span><br><span class="line"></span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line">    if(errno != EEXIST)</span><br><span class="line">         &#123;</span><br><span class="line">         perror(&quot;fail to mkfifo&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> #if 0</span><br><span class="line"> //如果open标志位设置为非阻塞，并且以只读的方式打开管道文件</span><br><span class="line"> //open函数和read函数都不会阻塞</span><br><span class="line"> fd = open(&quot;myfifo&quot;, O_RDONLY | O_NONBLOCK);</span><br><span class="line"> if(fd &lt; 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;open fifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> char recv[100];</span><br><span class="line"></span><br><span class="line"> bzero(recv, sizeof(recv));</span><br><span class="line"> read(fd, recv, sizeof(recv));</span><br><span class="line"> printf(&quot;read from my_fifo buf=[%s]\n&quot;,recv);</span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> #if 1</span><br><span class="line"> //如果open标志位设置为非阻塞，并且以只写的方式打开管道文件</span><br><span class="line"> //open函数会直接报错</span><br><span class="line"> //如果open设置为可读可写，那么跟阻塞是一样的效果</span><br><span class="line"> char send[100] = &quot;Hello I love you&quot;;</span><br><span class="line"></span><br><span class="line"> fd = open(&quot;myfifo&quot;, O_WRONLY | O_NONBLOCK);</span><br><span class="line"> //fd = open(&quot;myfifo&quot;, O_RDWR | O_NONBLOCK);</span><br><span class="line"> if(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;open fifo&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> write(fd, send, strlen(send));</span><br><span class="line"></span><br><span class="line"> char recv[100];</span><br><span class="line"> read(fd, recv, sizeof(recv));</span><br><span class="line"> printf(&quot;read from my_fifo buf=[%s]\n&quot;,recv);</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h1 id="6、消息队列"><a href="#6、消息队列" class="headerlink" title="6、消息队列"></a>6、消息队列</h1><pre><code>除了最原始的进程间通信方式信号、
无名管道和有名管道外，
还有三种进程间通信方式，
这三种方式称之为IPC对象。
IPC对象分类：消息队列、共享内存、信号灯集
IPC对象也是在内核空间开辟区域，
每一种IPC对象创建好之后都会将其设置为全局，
并且会给其分配一个编号，
只要找到唯一的这个编号就可以进行通信，
所以不相关的进程可以通过IPC对象通信
IPC对象创建好之后，
会在当前系统中可见，
只要不删除或者不关闭系统，
就会一直存在。



查看已经创建的IPC对象：	
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ipcs 查看当前系统中所有创建的IPC对象</span><br><span class="line">ipcs ‐q 查看创建的消息队列</span><br><span class="line">ipcs ‐m 查看创建的共享内存</span><br><span class="line">ipcs ‐s 查看信号量</span><br><span class="line"></span><br><span class="line">ipcrm 删除IPC对象</span><br><span class="line">例如：ipcrm ‐q msqid 删除标号为msqid的消息队列</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/b67fd96af7f9415a82870579cb40e183.png"></p>
<h3 id="6-1、消息队列概述"><a href="#6-1、消息队列概述" class="headerlink" title="6-1、消息队列概述"></a>6-1、消息队列概述</h3><pre><code>消息队列是消息的链表，
存放在内存中，
由内核维护。

消息队列的特点
1、消息队列中的消息是有类型的。
2、消息队列中的消息是有格式的。
3、消息队列可以实现消息的随机查询。
    消息不一定要以先进先出的次序读取，
    编程时可以按消息的类型读取。
4、消息队列允许一个或多个进程向它写入或者读取消息。
5、与无名管道、命名管道一样，从消息队列中读出消息，
    消息队列中对应的数据都会被删除。
6、每个消息队列都有消息队列标识符，
    消息队列的标识符在整个系统中是唯一的。
7、只有内核重启或人工删除消息队列时，
    该消息队列才会被删除。
    若不人工删除消息队列，
    消息队列会一直存在于系统中。

在ubuntu 12.04中消息队列限制值如下:
每个消息内容最多为8K字节
每个消息队列容量最多为16K字节
系统中消息队列个数最多为1609个
系统中消息个数最多为16384个
System V提供的IPC通信机制需要一个key值，
通过key值就可在系统内获得一个唯一的消息队列标识符。
key值可以是人为指定的，也可以通过ftok函数获得。
如果多个进程想通过IPC对象通信，则必须找到唯一的标识，
而唯一的标识是由key决定的，
所以只要key知道，则就可以实现多个进程通信.
</code></pre>
<h3 id="6-2、ftok函数"><a href="#6-2、ftok函数" class="headerlink" title="6-2、ftok函数"></a>6-2、ftok函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">功能：通过文件名和目标值共同创造一个键值并返回值</span><br><span class="line">参数：</span><br><span class="line">pathname：任意一个文件名（文件名或者目录名）</span><br><span class="line">proj_id：目标值，范围一般是0~127</span><br><span class="line">返回值：</span><br><span class="line">成功：键值</span><br><span class="line"> 失败：‐1</span><br><span class="line"></span><br><span class="line"> 如果使用ftok函数获取键值，得到的键值是由ftok的第一个</span><br><span class="line"> 参数对应文件的信息和第二个参数一起决定的</span><br></pre></td></tr></table></figure>
<h3 id="6-3、消息队列的操作"><a href="#6-3、消息队列的操作" class="headerlink" title="6-3、消息队列的操作"></a>6-3、消息队列的操作</h3><h4 id="6-3-1、创建消息队列-–-msgget"><a href="#6-3-1、创建消息队列-–-msgget" class="headerlink" title="6-3-1、创建消息队列 – msgget( )"></a>6-3-1、创建消息队列 – msgget( )</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">功能：创建一个消息队列，得到消息队列的id</span><br><span class="line">参数：</span><br><span class="line">key：键值，唯一的键值确定唯一的消息队列</span><br><span class="line">方法1：任意指定一个数</span><br><span class="line">方法2：使用ftok函数获取键值</span><br><span class="line"> msgflg：消息队列的访问权限，</span><br><span class="line"> 一般设置为 IPC_CREAT | IPC_EXCL | 0777 或者 IPC_CREAT | 0777</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：消息队列的id</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //通过ftok函数获取ipc键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to ftok&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;mykey = %#x\n&quot;, mykey);</span><br><span class="line"></span><br><span class="line"> //通过msgget函数创建一个消息队列</span><br><span class="line"> int msqid;</span><br><span class="line"> if((msqid = msgget(mykey, IPC_CREAT | 0666)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to msgget&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;msqid = %d\n&quot;, msqid);</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-2、发送消息-–-msgsnd"><a href="#6-3-2、发送消息-–-msgsnd" class="headerlink" title="6-3-2、发送消息 – msgsnd( )"></a>6-3-2、发送消息 – msgsnd( )</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span><br><span class="line">功能：向指定的消息队列发送数据（写操作）</span><br><span class="line">参数：</span><br><span class="line">msqid：消息队列的id</span><br><span class="line">msgp：要写入的数据，需要自己定义结构体</span><br><span class="line">struct struct_name&#123;</span><br><span class="line"> long mtype; //消息的编号，必须大于0</span><br><span class="line"> char mtext[128]; //消息正文，可以定义多个成员</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> msgsz：消息正文的大小，不包括消息的编号长度</span><br><span class="line"> msgflg：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> IPC_NOWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">#define N 128</span><br><span class="line"> typedef struct&#123;</span><br><span class="line"> long msg_type; //消息类型，必须在结构体的第一个位置并且类型必须是long</span><br><span class="line"> char msg_text[N]; //消息正文，也可以有多个成员并且类型也可以是任意</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> #define MSGTEXT_SIZE (sizeof(MSG) - sizeof(long))</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //使用ftok函数获取键值</span><br><span class="line"> key_t key;</span><br><span class="line"> if((key = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to ftok&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //使用msgget函数创建一个消息队列</span><br><span class="line"> int msgid;</span><br><span class="line"> if((msgid = msgget(key, IPC_CREAT | 0777)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgget&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -q&quot;);</span><br><span class="line"></span><br><span class="line"> //使用msgsnd函数向消息队列中发送数据（写操作）</span><br><span class="line"> MSG msg1 = &#123;1, &quot;hello world&quot;&#125;;</span><br><span class="line"> MSG msg2 = &#123;4, &quot;nihao beijing&quot;&#125;;</span><br><span class="line"> MSG msg3 = &#123;2, &quot;hello kitty&quot;&#125;;</span><br><span class="line"> MSG msg4 = &#123;3, &quot;welcome to 1000phone&quot;&#125;;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg1, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg2, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg3, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg4, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> system(&quot;ipcs -q&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-3、接收消息-–-msgrcv"><a href="#6-3-3、接收消息-–-msgrcv" class="headerlink" title="6-3-3、接收消息 – msgrcv( )"></a>6-3-3、接收消息 – msgrcv( )</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz,</span><br><span class="line">long msgtyp, int msgflg);</span><br><span class="line">功能：从消息队列中接收数据（读操作），接收的数据会从消息队列中删除</span><br><span class="line">参数：</span><br><span class="line">msqid：消息队列id</span><br><span class="line">msgp：保存接收到的数据的结构体</span><br><span class="line"> struct struct_name&#123;</span><br><span class="line"> long mtype; //消息的编号，必须大于0</span><br><span class="line"> char mtext[128]; //消息正文，可以定义多个成员</span><br><span class="line"> &#125;</span><br><span class="line"> msgsz：消息正文的大小</span><br><span class="line"> msgtyp：设置要接收哪个消息</span><br><span class="line"> 0 按照写入消息队列的顺序依次读取</span><br><span class="line"> &gt;0 只读取消息队列中消息编号为当前参数的第一个消息</span><br><span class="line"> &lt;0 只读取消息队列中小于等于当前参数的绝对中内最小的第一个消息</span><br><span class="line"> msgflg：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> IPC_NOWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：接收到的消息正文的长度</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<h1 id="7、共享内存"><a href="#7、共享内存" class="headerlink" title="7、共享内存"></a>7、共享内存</h1><pre><code>共享内存允许两个或者多个进程共享给定的存储区域。
共享内存的特点
1、 共享内存是进程间共享数据的一种最快的方法。
    一个进程向共享的内存区域写入了数据，
    共享这个内存区域的所有进程就可以立刻看到其中的内容。
2、使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。
    若一个进程正在向共享内存区写数据，
    则在它做完这一步操作前，
    别的进程不应当去读、写这些数据。
</code></pre>
<p>共享内存示意图<br><img src="https://img-blog.csdnimg.cn/1f9d75c83e934f85880357dacf416fdf.png"><br>    总结：共享内存是进程间通信方式中效率最高的，<br>    原因在于进程是直接在物理内存上进行操作，<br>    将物理地址映射到用户进程这，<br>    所以只要对其地址进行操作，<br>    就是直接对物理地址操作。</p>
<pre><code>在ubuntu 12.04中共享内存限制值如下
1、共享存储区的最小字节数：1
2、共享存储区的最大字节数：32M
3、共享存储区的最大个数：4096
4、每个进程最多能映射的共享存储区的个数：4096
</code></pre>
<h2 id="7-1、-获得一个共享存储标识符"><a href="#7-1、-获得一个共享存储标识符" class="headerlink" title="7-1、 获得一个共享存储标识符"></a>7-1、 获得一个共享存储标识符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">功能：创建一个共享内存</span><br><span class="line">参数：</span><br><span class="line">key：键值，唯一的键值确定唯一的共享内存</span><br><span class="line">size：创建的共享内存的大小</span><br><span class="line">shmflg：共享内存的访问权限，</span><br><span class="line">一般为 IPC_CREAT | 0777</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：共享内存的id</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>使用shell命令操作共享内存:
 查看共享内存
 ipcs ‐m
 删除共享内存
 ipcrm ‐m shmid
 
</code></pre>
<p>案例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">   perror(&quot;fail to ftok&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == -1)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to shmget&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;shmid = %d\n&quot;, shmid);</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-2、-共享内存映射-attach"><a href="#7-2、-共享内存映射-attach" class="headerlink" title="7-2、 共享内存映射(attach)"></a>7-2、 共享内存映射(attach)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">功能：映射共享内存</span><br><span class="line">参数</span><br><span class="line">shmid：共享内存的id</span><br><span class="line">shmaddr：映射的地址，设置为NULL为系统自动分配</span><br><span class="line">shmflg：标志位</span><br><span class="line">0：共享内存具有可读可写权限。</span><br><span class="line"> SHM_RDONLY：只读。</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：映射的地址</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<pre><code>注意：
    shmat函数使用的时候第二个和第三个参数一般设为NULL和0，
    即系统自动指定共享内存地址，
    并且共享内存可读可写。
</code></pre>
<h2 id="7-3、解除共享内存映射-detach"><a href="#7-3、解除共享内存映射-detach" class="headerlink" title="7-3、解除共享内存映射(detach)"></a>7-3、解除共享内存映射(detach)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">功能：解除共享内存的映射</span><br><span class="line">参数：</span><br><span class="line">shmaddr：映射的地址，shmat的返回值</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br></pre></td></tr></table></figure>
<h2 id="7-4、案例：使用共享内存实现读写操作"><a href="#7-4、案例：使用共享内存实现读写操作" class="headerlink" title="7-4、案例：使用共享内存实现读写操作"></a>7-4、案例：使用共享内存实现读写操作</h2><p>写入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int a;</span><br><span class="line"> char b;</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to ftok&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmget&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> //使用shmat函数映射共享内存的地址</span><br><span class="line"> //char *text;</span><br><span class="line"> MSG *text;</span><br><span class="line"> if((text = shmat(shmid, NULL, 0)) == (void *)-1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmat&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmat的返回值对共享内存操作</span><br><span class="line"> //strcpy(text, &quot;hello world&quot;);</span><br><span class="line"> text-&gt;a = 100;</span><br><span class="line"> text-&gt;b = &#x27;w&#x27;;</span><br><span class="line"></span><br><span class="line"> //操作完毕后要结束共享内存的映射</span><br><span class="line"> if(shmdt(text) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmdt&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>读出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to ftok&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to shmget&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> //映射共享内存的地址</span><br><span class="line"> //char *text;</span><br><span class="line"> MSG *text;</span><br><span class="line"> if((text = shmat(shmid, NULL, 0)) == (void *)-1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to shmat&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> //获取共享内存中的数据</span><br><span class="line"> //printf(&quot;text = %s\n&quot;, text);</span><br><span class="line"> printf(&quot;a = %d, b = %c\n&quot;, text-&gt;a, text-&gt;b);</span><br><span class="line"></span><br><span class="line"> //解除共享内存映射</span><br><span class="line"> if(shmdt(text) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to shmdt&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-5、共享内存控制"><a href="#7-5、共享内存控制" class="headerlink" title="7-5、共享内存控制"></a>7-5、共享内存控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">功能：设置或者获取共享内存你的属性</span><br><span class="line">参数：</span><br><span class="line">shmid：共享内存的id</span><br><span class="line">cmd：执行操作的命令</span><br><span class="line">IPC_STAT 获取共享内存的属性</span><br><span class="line">IPC_SET 设置共享内存的属性</span><br><span class="line"> IPC_RMID 删除共享内存</span><br><span class="line"> shmid_ds：共享内存的属性结构体</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<p>例程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to ftok&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmget&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;shmid = %d\n&quot;, shmid);</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs ‐m&quot;);</span><br><span class="line"></span><br><span class="line"> //通过shmctl函数删除共享内存</span><br><span class="line"> if(shmctl(shmid, IPC_RMID, NULL) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmctl&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs ‐m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="8、线程"><a href="#8、线程" class="headerlink" title="8、线程"></a>8、线程</h1><pre><code>每个进程都拥有自己的数据段、
代码段和堆栈段，
这就造成进程在进行创建、切换、撤销操作时，
需要较大的系统开销。
为了减少系统开销，从进程中演化出了线程。
线程存在于进程中，共享进程的资源。
线程是进程中的独立控制流，
由环境（包括寄存器组和程序计数器）和一系列的执行指
令组成。
每个进程有一个地址空间和一个控制线程。
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/b72659b36b374e72a9b828675e4ecb8f.png"></p>
<h2 id="8-1、线程和进程的比较"><a href="#8-1、线程和进程的比较" class="headerlink" title="8-1、线程和进程的比较"></a>8-1、线程和进程的比较</h2><pre><code>调度：
线程是CPU调度和分派的基本单位。
拥有资源：
进程是系统中程序执行和资源分配的基本单位。
线程自己一般不拥有资源（除了必不可少的程序计数器，
一组寄存器和栈），但它可以去访问其所属进程的资源，
如进程代码段，数据段以及系统资源（已打开的文件，
I/O设备等）。
系统开销：
同一个进程中的多个线程可共享同一地址空间，
因此它们之间的同步和通信的实现也变得比较容易。

在进程切换时候，
    涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置；
    而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作，
    从而能更有效地使用系统资源和提高系统的吞吐量。
并发性：
    不仅进程间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行。
总结：
    一般把线程称之为轻量级的进程
    一个进程可以创建多个线程，
    多个线程共享一个进程的资源，
    每一个进程创建的时候系统会给其4G虚拟内存，
    3G用户空间是私有的，所以进程切换时，
    用户空间也会切换，所以会增加系统开销，
    而一个进程中的多个线程共享一个进程的资源，
    所以线程切换时不用切换这些资源，效率会更高，
    线程的调度机制跟进程是一样的，多个线程来回切换运行。
</code></pre>
<h2 id="8-2、多线程的用处"><a href="#8-2、多线程的用处" class="headerlink" title="8-2、多线程的用处"></a>8-2、多线程的用处</h2><pre><code>使用多线程的目的主要有以下几点：
多任务程序的设计
    一个程序可能要处理不同应用，要处理多种任务，
    如果开发不同的进程来处理，系统开销很大，
    数据共享，程序结构都不方便，
    这时可使用多线程编程方法。
并发程序设计
    一个任务可能分成不同的步骤去完成，
    这些不同的步骤之间可能是松散耦合，
    可能通过线程的互斥，同步并发完成。
    这样可以为不同的任务步骤建立线程。
网络程序设计
    为提高网络的利用效率，
    我们可能使用多线程，
    对每个连接用一个线程去处理。
数据共享
    同一个进程中的不同线程共享进程的数据空间，
    方便不同线程间的数据共享。
在多CPU系统中，实现真正的并行。
</code></pre>
<h2 id="8-3、线程的基本操作"><a href="#8-3、线程的基本操作" class="headerlink" title="8-3、线程的基本操作"></a>8-3、线程的基本操作</h2><h3 id="8-3-1、线程的创建"><a href="#8-3-1、线程的创建" class="headerlink" title="8-3-1、线程的创建"></a>8-3-1、线程的创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class="line">void *(*start_routine) (void *), void *arg);</span><br><span class="line">功能：创建一个新的子线程</span><br><span class="line">参数：</span><br><span class="line">thread：当前创建的线程id</span><br><span class="line">attr：线程的属性，设置为NULL表示以默认的属性创建</span><br><span class="line">start_routine：线程处理函数，如果当前函数执行完毕，则子线程也执行完毕</span><br><span class="line">arg：给线程处理函数传参用的</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure>
<pre><code>注意事项：
与fork不同的是pthread_create创建的线程不与父线程在同一点开始运行，
而是从指定的函数开始运行，
该函数运行完后，该线程也就退出了。
线程依赖进程存在的，
如果创建线程的进程结束了，线程也就结束了。
线程函数的程序在pthread库中，
故链接时要加上参数-lpthread。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">//由于线程库原本不是系统本身的，所以在链接时需要手动链接库文件 gcc *.c ‐lpthread</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> //通过pthread_create函数创建子线程</span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //由于进程结束后，进程中所有的线程都会强制退出，所以现阶段不要让进程退出</span><br><span class="line"> while(1);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-2、线程调度机制的验证"><a href="#8-3-2、线程调度机制的验证" class="headerlink" title="8-3-2、线程调度机制的验证"></a>8-3-2、线程调度机制的验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">//一个进程中的多个线程执行顺序是不确定的，没有先后顺序可言</span><br><span class="line">//多线程执行时跟进程一样，是来回切换运行的，跟进程的调度机制一样</span><br><span class="line">void *pthread_fun1(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程1正在运行\n&quot;);</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;**********************\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *pthread_fun2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程2正在运行\n&quot;);</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;-----------------------\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread1, thread2;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread1, NULL, pthread_fun1, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> if(pthread_create(&amp;thread2, NULL, pthread_fun2, NULL) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-3、线程处理函数传参"><a href="#8-3-3、线程处理函数传参" class="headerlink" title="8-3-3、线程处理函数传参"></a>8-3-3、线程处理函数传参</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int num = 100;</span><br><span class="line">//线程处理函数可以认为就是一个普通的全局函数，只不过与普通函数最大的区别</span><br><span class="line">//在于，线程处理函数是并行执行，来回交替执行，但是普通函数一定是按照顺序一个一个执行</span><br><span class="line"> void *pthread_fun1(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程1：num = %d\n&quot;, num);</span><br><span class="line"> num++;</span><br><span class="line"></span><br><span class="line"> int n = *(int *)arg;</span><br><span class="line"> printf(&quot;1 n = %d\n&quot;, n);</span><br><span class="line"> *(int *)arg = 111;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *pthread_fun2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;子线程2：num = %d\n&quot;, num);</span><br><span class="line"></span><br><span class="line"> int n = *(int *)arg;</span><br><span class="line"> printf(&quot;2 n = %d\n&quot;, n);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread1, thread2;</span><br><span class="line"></span><br><span class="line"> int a = 666;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread1, NULL, pthread_fun1, (void *)&amp;a) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread2, NULL, pthread_fun2, (void *)&amp;a) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> while(1);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-4、线程等待"><a href="#8-3-4、线程等待" class="headerlink" title="8-3-4、线程等待"></a>8-3-4、线程等待</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">功能：阻塞等待一个子线程的退出，</span><br><span class="line">可以接收到某一个子线程调用pthread_exit时设置的退出状态值</span><br><span class="line">参数：</span><br><span class="line">thread：指定线程的id</span><br><span class="line">retval：保存子线程的退出状态值，如果不接受则设置为NULL</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> sleep(3);</span><br><span class="line"></span><br><span class="line"> printf(&quot;子线程要退出了\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //通过调用pthread_join函数阻塞等待子线程退出</span><br><span class="line"> if(pthread_join(thread, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_join&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;进程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-5、线程的返回值"><a href="#8-3-5、线程的返回值" class="headerlink" title="8-3-5、线程的返回值"></a>8-3-5、线程的返回值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">static int num = 666;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"></span><br><span class="line"> printf(&quot;子线程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> //子线程如果要返回退出状态，可以通过返回值或者通过pthread_exit函数</span><br><span class="line"> return (void *)&amp;num;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int *num;</span><br><span class="line"> if(pthread_join(thread, (void **)&amp;num) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_join&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;ret_val = %d\n&quot;, *num);</span><br><span class="line"> printf(&quot;进程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-6、线程分离"><a href="#8-3-6、线程分离" class="headerlink" title="8-3-6、线程分离"></a>8-3-6、线程分离</h3><pre><code>线程的结合态和分离态
linux线程执行和windows不同，pthread有两种状态：
可结合的（joinable）或者是分离的（detached），
线程默认创建为可结合态。
如果线程是joinable状态，
当线程函数自己返回退出时或pthread_exit时都不会
释放线程所占用堆栈和线程描述符（总计8K多）。
只有当你调用了pthread_join之后这些资源才会被释放。
若是detached状态的线程，
这些资源在线程函数退出时或pthread_exit时自动会被释放，
使用pthread_detach函数将线程设置为分离态。
创建一个线程后应回收其资源，
但使用pthread_join函数会使调用者阻塞，
故Linux提供了线程分离函数：pthread_detach
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_detach(pthread_t thread);</span><br><span class="line">功能：使调用线程与当前进程分离，使其成为一个独立的线程，</span><br><span class="line">该线程终止时，系统将自动回收它的资源。</span><br><span class="line">参数：</span><br><span class="line">thread：指定的子线程的id</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> sleep(3);</span><br><span class="line"></span><br><span class="line"> printf(&quot;子线程要退出了\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> //通过pthread_detach函数将子线程设置为分离态，既不用阻塞，也可以自动回收子线程退出的资源</span><br><span class="line"> if(pthread_detach(thread) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_detach&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //如果原本子线程是结合态，需要通过pthrad_join函数回收子线程退出的资源，</span><br><span class="line"> //但是这个函数是一个阻塞函数，如果子线程不退出，就会导致当前进程（主控线程）</span><br><span class="line"> //无法继续执行，大大的限制了代码的运行效率</span><br><span class="line"> //如果子线程已经设置为分离态，就不需要再使用pthread_join了</span><br><span class="line"> #if 0</span><br><span class="line"> if(pthread_join(thread, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_join&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;hello world\n&quot;);</span><br><span class="line">   sleep(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-7、线程的退出"><a href="#8-3-7、线程的退出" class="headerlink" title="8-3-7、线程的退出"></a>8-3-7、线程的退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_exit(void *retval);</span><br><span class="line">功能：退出正在执行的线程</span><br><span class="line">参数：</span><br><span class="line">retval：当前线程的退出状态值，</span><br><span class="line">这个值可以被调用pthread_join函数的线程接收到</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>
<pre><code>注：
    一个进程中的多个线程是共享该进程的数据段，
因此，通常线程退出后所占用的资源并不会释放。
如果要释放资源，结合态需要通过pthread_join函数，
分离态则自动释放。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> static char buf[] = &quot;This thread has quited&quot;;</span><br><span class="line"></span><br><span class="line"> int i;</span><br><span class="line"> for(int i = 0; i &lt; 10; i++)</span><br><span class="line">   &#123;</span><br><span class="line">   if(i == 5)</span><br><span class="line">      &#123;</span><br><span class="line">      //通过pthread_exit函数退出当前线程</span><br><span class="line">      //pthread_exit(NULL);</span><br><span class="line">      pthread_exit(buf);</span><br><span class="line">      &#125;</span><br><span class="line">   printf(&quot;*******************\n&quot;);</span><br><span class="line">   sleep(1);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> //pthread_join(thread, NULL);</span><br><span class="line"> char *str;</span><br><span class="line"> pthread_join(thread, (void **)&amp;str);</span><br><span class="line"> printf(&quot;str = %s\n&quot;, str);</span><br><span class="line"></span><br><span class="line"> printf(&quot;进程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-8、线程的取消"><a href="#8-3-8、线程的取消" class="headerlink" title="8-3-8、线程的取消"></a>8-3-8、线程的取消</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line">功能：取消线程</span><br><span class="line">参数：</span><br><span class="line">thread：要销毁的线程的id</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure>

<pre><code>pthread_cancel函数的实质是发信号给目标线程thread，
使目标线程退出。
    此函数只是发送终止信号给目标线程，
    不会等待取消目标线程执行完才返回。
然而发送成功并不意味着目标线程一定就会终止，
线程被取消时，
    线程的取消属性会决定线程能否被取消以及何时被取消。
线程的取消状态
    即线程能不能被取消。
线程取消点
    即线程被取消的地方。
线程的取消类型
    在线程能被取消的状态下，
    是立马被取消结束还是执行到取消点的时候被取消结束。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过调用pthread_cancel函数取消另一个线程</span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-8-1、设置线程是否可以被取消pthread-setcancelstate"><a href="#8-3-8-1、设置线程是否可以被取消pthread-setcancelstate" class="headerlink" title="8-3-8-1、设置线程是否可以被取消pthread_setcancelstate()"></a>8-3-8-1、设置线程是否可以被取消pthread_setcancelstate()</h4><p>线程的取消状态<br>在Linux系统下，线程默认可以被取消。<br>编程时可以通过pthread_setcancelstate函数<br>设置线程是否可以被取消。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_setcancelstate(int state, int *oldstate);</span><br><span class="line">功能：设置线程是否被取消</span><br><span class="line">参数：</span><br><span class="line">state：新的状态</span><br><span class="line">PTHREAD_CANCEL_DISABLE：不可以被取消</span><br><span class="line">PTHREAD_CANCEL_ENABLE：可以被取消</span><br><span class="line">oldstate：保存调用线程原来的可取消状态的内存地址</span><br><span class="line">返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">//通过pthread_setcancelstate设置取消的状态</span><br><span class="line">//设置为可以取消</span><br><span class="line"> //pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);</span><br><span class="line"> //设置为不可取消</span><br><span class="line"> pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-8-2、设置线程的取消点pthread-testcancel"><a href="#8-3-8-2、设置线程的取消点pthread-testcancel" class="headerlink" title="8-3-8-2、设置线程的取消点pthread_testcancel()"></a>8-3-8-2、设置线程的取消点pthread_testcancel()</h4><pre><code>线程的取消点
线程被取消后，
该线程并不是马上终止，
默认情况下线程执行到消点时才能被终止。
编程时可以通过pthread_testcancel函数设置线程的取消点。
void pthread_testcancel(void);
当别的线程取消调用此函数的线程时候，
被取消的线程执行到此函数时结束。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_testcancel(void);</span><br><span class="line">功能：设置线程的取消点</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;子线程从循环开始正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"></span><br><span class="line"> pthread_testcancel();</span><br><span class="line"> printf(&quot;子线程从循环末尾正在运行\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-8-3、设置线程是否可以被立即取消-pthread-setcanceltype"><a href="#8-3-8-3、设置线程是否可以被立即取消-pthread-setcanceltype" class="headerlink" title="8-3-8-3、设置线程是否可以被立即取消 pthread_setcanceltype()"></a>8-3-8-3、设置线程是否可以被立即取消 pthread_setcanceltype()</h4><pre><code>线程被取消后，该线程并不是马上终止，
默认情况下线程执行到消点时才能被终止。
编程时可以通过pthread_setcanceltype函数设置线程是否可以立即被取消。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_setcanceltype(int type, int *oldtype);</span><br><span class="line">功能：设置线程是否可以立即被取消</span><br><span class="line">参数：</span><br><span class="line">type：类型</span><br><span class="line">PTHREAD_CANCEL_ASYNCHRONOUS：立即取消、</span><br><span class="line">PTHREAD_CANCEL_DEFERRED：不立即被取消</span><br><span class="line">oldtype：保存调用线程原来的可取消类型的内存地址</span><br><span class="line">返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);</span><br><span class="line"> //设置线程取消的类型</span><br><span class="line"> //设置为立即取消</span><br><span class="line"> //pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);</span><br><span class="line"> //设置为不立即取消</span><br><span class="line"> pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-9、线程的退出pthread-cleanup-push"><a href="#8-3-9、线程的退出pthread-cleanup-push" class="headerlink" title="8-3-9、线程的退出pthread_cleanup_push()"></a>8-3-9、线程的退出pthread_cleanup_push()</h3><pre><code>和进程的退出清理一样，
线程也可以注册它退出时要调用的函数，
这样的函数称为线程清理处理程序(thread cleanup handler)。
注意:
    线程可以建立多个清理处理程序。
    处理程序在栈中，故它们的执行顺序与它们注册时的顺序相反。
    当线程执行以下动作时会调用清理函数：
    1、调用pthread_exit退出线程。
    2、响应其它线程的取消请求。
    3、用非零execute调用pthread_cleanup_pop。
</code></pre>
<h4 id="8-3-9-1、pthread-cleanup-push"><a href="#8-3-9-1、pthread-cleanup-push" class="headerlink" title="8-3-9-1、pthread_cleanup_push()"></a>8-3-9-1、pthread_cleanup_push()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_cleanup_push(void (* routine)(void *), void *arg);</span><br><span class="line">功能:将清除函数压栈。即注册清理函数。</span><br><span class="line">参数:</span><br><span class="line">routine：线程清理函数的指针。</span><br><span class="line">arg：传给线程清理函数的参数。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>
<h4 id="8-3-9-2、pthread-cleanup-pop"><a href="#8-3-9-2、pthread-cleanup-pop" class="headerlink" title="8-3-9-2、pthread_cleanup_pop()"></a>8-3-9-2、pthread_cleanup_pop()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_cleanup_pop(int execute);</span><br><span class="line">功能：将清除函数弹栈，即删除清理函数。</span><br><span class="line">参数：</span><br><span class="line">execute:线程清理函数执行标志位。</span><br><span class="line">非0，弹出清理函数，执行清理函数。</span><br><span class="line">0，弹出清理函数，不执行清理函数。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure>
<h4 id="8-3-9-3、案例：验证线程调用pthread-exit函数时，系统自动调用线程清理函数"><a href="#8-3-9-3、案例：验证线程调用pthread-exit函数时，系统自动调用线程清理函数" class="headerlink" title="8-3-9-3、案例：验证线程调用pthread_exit函数时，系统自动调用线程清理函数"></a>8-3-9-3、案例：验证线程调用pthread_exit函数时，系统自动调用线程清理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void mycleanup(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;clean up ptr = %s\n&quot;, (char *)arg);</span><br><span class="line"> free((char *)arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> /*建立线程清理程序*/</span><br><span class="line"> printf(&quot;this is new thread\n&quot;);</span><br><span class="line"></span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"> ptr = (char*)malloc(100);</span><br><span class="line"> pthread_cleanup_push(mycleanup, (void*)(ptr));</span><br><span class="line"> bzero(ptr, 100);//内存清除与memset的区别是，memset可以设置为设置为其他数，不一定为0</span><br><span class="line"> strcpy(ptr, &quot;memory from malloc&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> printf(&quot;before exit\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line"> /*注意push与pop必须配对使用，即使pop执行不到*/</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t tid;</span><br><span class="line"> pthread_create(&amp;tid, NULL, thread, NULL); // 创建一个线程</span><br><span class="line"> pthread_join(tid,NULL);</span><br><span class="line"> printf(&quot;process is dying\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数"><a href="#8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数" class="headerlink" title="8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数"></a>8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void cleanup(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;clean up ptr = %s\n&quot;, (char *)arg);</span><br><span class="line"> free((char *)arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"></span><br><span class="line"> /*建立线程清理程序*/</span><br><span class="line"> printf(&quot;this is new thread\n&quot;);</span><br><span class="line"> ptr = (char*)malloc(100);</span><br><span class="line"> pthread_cleanup_push(cleanup, (void*)(ptr));</span><br><span class="line"> bzero(ptr, 100);</span><br><span class="line"> strcpy(ptr, &quot;memory from malloc&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(10);</span><br><span class="line"></span><br><span class="line"> /*注意push与pop必须配对使用，即使pop执行不到*/</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t tid;</span><br><span class="line"> pthread_create(&amp;tid, NULL, thread, NULL); // 创建一个线程</span><br><span class="line"> sleep(5);</span><br><span class="line"> printf(&quot;before cancel\n&quot;);</span><br><span class="line"> /*子线程响应pthread_cancel后，会执行线程处理函数*/</span><br><span class="line"> pthread_cancel(tid);</span><br><span class="line"> pthread_join(tid,NULL);</span><br><span class="line"> printf(&quot;process is dying\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-3-9-5、案例：验证调用pthread-cleanup-pop函数时，系统自动调用线程清理函数"><a href="#8-3-9-5、案例：验证调用pthread-cleanup-pop函数时，系统自动调用线程清理函数" class="headerlink" title="8-3-9-5、案例：验证调用pthread_cleanup_pop函数时，系统自动调用线程清理函数"></a>8-3-9-5、案例：验证调用pthread_cleanup_pop函数时，系统自动调用线程清理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void cleanup_func1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;in cleanup func1\n&quot;);</span><br><span class="line"> printf(&quot;clean up ptr = %s\n&quot;, (char *)arg);</span><br><span class="line"> free((char *)arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void cleanup_func2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;in cleanup func2\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"></span><br><span class="line"> /*建立线程清理程序*/</span><br><span class="line"> printf(&quot;this is new thread\n&quot;);</span><br><span class="line"> ptr = (char*)malloc(100);</span><br><span class="line"> pthread_cleanup_push(cleanup_func1, (void*)(ptr));</span><br><span class="line"> pthread_cleanup_push(cleanup_func2, NULL);</span><br><span class="line"> bzero(ptr, 100);</span><br><span class="line"> strcpy(ptr, &quot;memory from malloc&quot;);</span><br><span class="line"> /*注意push与pop必须配对使用，即使pop执行不到*/</span><br><span class="line"> sleep(3);</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t tid;</span><br><span class="line"> pthread_create(&amp;tid, NULL, thread, NULL); // 创建一个线程</span><br><span class="line"> pthread_join(tid,NULL);</span><br><span class="line"> printf(&quot;process is dying\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="9、多任务同步与互斥"><a href="#9、多任务同步与互斥" class="headerlink" title="9、多任务同步与互斥"></a>9、多任务同步与互斥</h1><pre><code>在多任务操作系统中，
同时运行的多个任务可能都需要访问/使用同一种资源。
多个任务之间有依赖关系，
某个任务的运行依赖于另一个任务。
同步和互斥就是用于解决这两个问题的。
互斥:
一个公共资源同一时刻只能被一个进程或线程使用，
多个进程或线程不能同时使用公共资源。
POSIX标准中进程和线程同步和互斥的方法,主要有信号量和互斥锁两种方式。
同步:
两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。
同步就是在互斥的基础上有顺序。
</code></pre>
<h2 id="9-1、互斥锁"><a href="#9-1、互斥锁" class="headerlink" title="9-1、互斥锁"></a>9-1、互斥锁</h2><h3 id="9-1-1-互斥锁的概念"><a href="#9-1-1-互斥锁的概念" class="headerlink" title="9-1-1 互斥锁的概念"></a>9-1-1 互斥锁的概念</h3><pre><code>mutex是一种简单的加锁的方法来控制对共享资源的访问，
mutex只有两种状态,
即上锁(lock)和解锁(unlock)。
在访问该资源前，
首先应申请mutex，
如果mutex处于unlock状态，
则会申请到mutex并立即lock；
如果mutex处于lock状态，
则默认阻塞申请者。
unlock操作应该由lock者进行。
</code></pre>
<h3 id="9-1-2、-互斥锁的操作"><a href="#9-1-2、-互斥锁的操作" class="headerlink" title="9-1-2、 互斥锁的操作"></a>9-1-2、 互斥锁的操作</h3><h4 id="9-1-2-1、-初始化互斥锁"><a href="#9-1-2-1、-初始化互斥锁" class="headerlink" title="9-1-2-1、 初始化互斥锁"></a>9-1-2-1、 初始化互斥锁</h4><pre><code>mutex用pthread_mutex_t数据类型表示，
在使用互斥锁前,必须先对它进行初始化。
静态分配的互斥锁：
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
动态分配互斥锁:
pthread_mutex_t mutex;
pthread_mutex_init(&amp;mutex, NULL);
在所有使用过此互斥锁的线程都不再需要使用时候，
应调用pthread_mutex_destroy销毁互斥锁。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t*mutexattr);</span><br><span class="line">功能：初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">mutex：指定的互斥锁</span><br><span class="line">mutexattr：互斥锁的属性，为NULL表示默认属性</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-2、互斥锁上锁"><a href="#9-1-2-2、互斥锁上锁" class="headerlink" title="9-1-2-2、互斥锁上锁"></a>9-1-2-2、互斥锁上锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line">功能：对互斥锁上锁，若已经上锁，则调用者一直阻塞到互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">mutex：指定的互斥锁</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br><span class="line"> #include &lt;pthread.h&gt;</span><br><span class="line"> int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br><span class="line"> 功能：对互斥锁上锁，若已经上锁，则上锁失败，函数立即返回。</span><br><span class="line"> 参数：</span><br><span class="line"> mutex：互斥锁地址。</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0。</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-3、互斥锁解锁"><a href="#9-1-2-3、互斥锁解锁" class="headerlink" title="9-1-2-3、互斥锁解锁"></a>9-1-2-3、互斥锁解锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t * mutex);</span><br><span class="line">功能：对指定的互斥锁解锁。</span><br><span class="line">参数：</span><br><span class="line">mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-4、销毁互斥锁"><a href="#9-1-2-4、销毁互斥锁" class="headerlink" title="9-1-2-4、销毁互斥锁"></a>9-1-2-4、销毁互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="number">3</span> 功能：销毁指定的一个互斥锁。</span><br><span class="line"><span class="number">4</span> 参数：</span><br><span class="line"><span class="number">5</span> mutex：互斥锁地址。</span><br><span class="line"><span class="number">6</span> 返回值：</span><br><span class="line"><span class="number">7</span> 成功：<span class="number">0</span></span><br><span class="line"><span class="number">8</span> 失败：非<span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>若不上锁
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> money = <span class="number">10000</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_fun1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">   &#123;</span><br><span class="line">   shiji = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  shiji = get;</span><br><span class="line">  yu = yu - get;</span><br><span class="line">  money = yu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">pthread_fun2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">   &#123;</span><br><span class="line">   shiji = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   shiji = get;</span><br><span class="line">   yu = yu - get;</span><br><span class="line">   money = yu;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread1, <span class="literal">NULL</span>, pthread_fun1, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread2, <span class="literal">NULL</span>, pthread_fun2, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line"> pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ef03ed82811e46d1adc0009a7e37a47e.png"></p>
<pre><code>使用了互斥锁
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//通过互斥锁解决线程间互斥问题</span></span><br><span class="line"><span class="type">int</span> money = <span class="number">10000</span>;</span><br><span class="line"> <span class="comment">//第一步：创建互斥锁(由于两个线程操作同一个互斥锁，所以定义在全局更加方便一点)</span></span><br><span class="line"> <span class="type">pthread_mutex_t</span> mymutex;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">pthread_fun1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第三步：对共享资源的操作进行上锁</span></span><br><span class="line"> pthread_mutex_lock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">  &#123;</span><br><span class="line">  shiji = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  shiji = get;</span><br><span class="line">  yu = yu - get;</span><br><span class="line">  money = yu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第四步：当共享资源的操作执行完毕后，对互斥锁执行解锁操作</span></span><br><span class="line"> pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">pthread_fun2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第三步：对共享资源的操作进行上锁</span></span><br><span class="line"> pthread_mutex_lock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">   &#123;</span><br><span class="line">   shiji = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  shiji = get;</span><br><span class="line">  yu = yu - get;</span><br><span class="line">  money = yu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第四步：当共享资源的操作执行完毕后，对互斥锁执行解锁操作</span></span><br><span class="line"> pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//第二步：初始化互斥锁</span></span><br><span class="line"> pthread_mutex_init(&amp;mymutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread1, <span class="literal">NULL</span>, pthread_fun1, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread2, <span class="literal">NULL</span>, pthread_fun2, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line"> pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：当互斥锁使用完毕后，要销毁</span></span><br><span class="line"> pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0480297b4cf8424bb965e5bc9cd3a374.png"></p>
<h2 id="9-2、信号量"><a href="#9-2、信号量" class="headerlink" title="9-2、信号量"></a>9-2、信号量</h2><h3 id="9-2-1、信号量的概念"><a href="#9-2-1、信号量的概念" class="headerlink" title="9-2-1、信号量的概念"></a>9-2-1、信号量的概念</h3><pre><code>信号量广泛用于进程或线程间的同步和互斥，
信号量本质上是一个非负的整数计数器，
它被用来控制对公共资源的访问。
编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，
当信号量值大于０时，则可以访问，否则将阻塞。
信号量又称之为PV操作，
ＰＶ原语是对信号量的操作，
一次Ｐ操作使信号量sem减１，
一次Ｖ操作使信号量sem加１，
对于P操作，如果信号量的sem值为小于等于0，
则P操作就会阻塞，如果信号量的值大于0，才可以执行P操作进行减1
信号量主要用于进程或线程间的同步和互斥这两种典型情况。
1、若用于互斥，几个进程（或线程）往往只设置一个信号量。
2、若用于同步操作，往往会设置多个信号量，
并且安排不同的初始值，来实现它们之间的执行顺序。
</code></pre>
<p>信号量用于互斥<br><img src="https://img-blog.csdnimg.cn/ba6ef89e6784407385d7cd5750323559.png"></p>
<p>信号量用于同步<br><img src="https://img-blog.csdnimg.cn/956825e64a504b3d98fa553a0c427ae4.png"></p>
<h3 id="9-2-2、信号量的操作"><a href="#9-2-2、信号量的操作" class="headerlink" title="9-2-2、信号量的操作"></a>9-2-2、信号量的操作</h3><h4 id="9-2-2-1、信号量的初始化"><a href="#9-2-2-1、信号量的初始化" class="headerlink" title="9-2-2-1、信号量的初始化"></a>9-2-2-1、信号量的初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">功能：初始化一个信号量</span><br><span class="line">参数：</span><br><span class="line">sem：指定的信号量</span><br><span class="line">pshared：是否在线程间或者进程间共享</span><br><span class="line">0 线程间共享</span><br><span class="line">1 进程间共享</span><br><span class="line">value：信号量的初始值</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-2、信号量的p操作"><a href="#9-2-2-2、信号量的p操作" class="headerlink" title="9-2-2-2、信号量的p操作"></a>9-2-2-2、信号量的p操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">功能：将信号量的值减1，若信号量的值小于等于0，此函数会引起调用者阻塞</span><br><span class="line">参数：</span><br><span class="line">sem：指定的信号量</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br><span class="line"> #include &lt;semaphore.h&gt;</span><br><span class="line"> int sem_trywait(sem_t *sem);</span><br><span class="line"> 功能：将信号量的值减1，若信号量的值小于0，则对信号量的操作失败，函数立即返回。</span><br><span class="line"> 参数：</span><br><span class="line"> sem：信号量地址。</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-3、信号量的v操作"><a href="#9-2-2-3、信号量的v操作" class="headerlink" title="9-2-2-3、信号量的v操作"></a>9-2-2-3、信号量的v操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_post(sem_t *sem);</span><br><span class="line">功能：执行V操作，执行一次，信号量的值加1</span><br><span class="line">参数：</span><br><span class="line">sem：指定的信号量</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-3、获取信号量的计数"><a href="#9-2-2-3、获取信号量的计数" class="headerlink" title="9-2-2-3、获取信号量的计数"></a>9-2-2-3、获取信号量的计数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="line">功能：获取sem标识的信号量的值，保存在sval中。</span><br><span class="line">参数：</span><br><span class="line">sem：信号量地址。</span><br><span class="line">sval：保存信号量值的地址。</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1。</span><br></pre></td></tr></table></figure>
<h4 id="9-2-2-4、信号量的销毁"><a href="#9-2-2-4、信号量的销毁" class="headerlink" title="9-2-2-4、信号量的销毁"></a>9-2-2-4、信号量的销毁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_destroy(sem_t *sem);</span><br><span class="line">功能：</span><br><span class="line">删除sem标识的信号量。</span><br><span class="line">参数：</span><br><span class="line">sem：信号量地址。</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1。</span><br></pre></td></tr></table></figure>
<h3 id="9-2-3、信号量的使用"><a href="#9-2-3、信号量的使用" class="headerlink" title="9-2-3、信号量的使用"></a>9-2-3、信号量的使用</h3><h4 id="信号量实现互斥功能"><a href="#信号量实现互斥功能" class="headerlink" title="信号量实现互斥功能"></a>信号量实现互斥功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">//通过信号量实现互斥操作</span><br><span class="line">//第一步：创建一个信号量</span><br><span class="line">sem_t sem;</span><br><span class="line"></span><br><span class="line"> void printer(char *str)</span><br><span class="line"> &#123;</span><br><span class="line"> //第三步：执行P操作</span><br><span class="line"> //由于使用信号量实现互斥，信号量的初始值设置为1，则两个线程执行P操作，</span><br><span class="line"> //先执行P操作的线程继续执行，后执行P操作的先阻塞等待</span><br><span class="line"> sem_wait(&amp;sem);</span><br><span class="line"> while(*str)</span><br><span class="line"> &#123;</span><br><span class="line"> putchar(*str);</span><br><span class="line"> fflush(stdout);</span><br><span class="line"> str++;</span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> //第四步：执行V操作</span><br><span class="line"> sem_post(&amp;sem);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread_fun1(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *str1 = &quot;hello&quot;;</span><br><span class="line"> printer(str1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread_fun2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *str2 = &quot;world&quot;;</span><br><span class="line"> printer(str2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(void)</span><br><span class="line"> &#123;</span><br><span class="line"> //第二步：初始化信号量</span><br><span class="line"> sem_init(&amp;sem, 0, 1);</span><br><span class="line"></span><br><span class="line"> pthread_t tid1, tid2;</span><br><span class="line"></span><br><span class="line"> pthread_create(&amp;tid1, NULL, thread_fun1, NULL);</span><br><span class="line"> pthread_create(&amp;tid2, NULL, thread_fun2, NULL);</span><br><span class="line"></span><br><span class="line"> pthread_join(tid1, NULL);</span><br><span class="line"> pthread_join(tid2, NULL);</span><br><span class="line"></span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"> //第五步：使用完毕后销毁信号量</span><br><span class="line"> sem_destroy(&amp;sem);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">//使用信号量实现同步功能，如果两个线程实现同步，需要通过两个信号量</span><br><span class="line">char ch = &#x27;A&#x27;;</span><br><span class="line"> //第一步：创建两个信号量</span><br><span class="line"> sem_t sem_g, sem_p;</span><br><span class="line"></span><br><span class="line"> void * pthread_g(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> //第四步：后执行的线程中，信号量的初始值设置为0的信号量执行P操作</span><br><span class="line"> sem_wait(&amp;sem_g);</span><br><span class="line"></span><br><span class="line"> ch++;</span><br><span class="line"> sleep(1);</span><br><span class="line"></span><br><span class="line"> //第六步：后执行的线程执行完毕后，信号量初始值为1的信号量执行V操作</span><br><span class="line"> sem_post(&amp;sem_p);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> void * pthread_p(void *arg) //此线程打印ch的值</span><br><span class="line"> &#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> //第三步：先执行的线程中，信号量初始值设置为1的信号量执行P操作</span><br><span class="line"> sem_wait(&amp;sem_p);</span><br><span class="line"></span><br><span class="line"> printf(&quot;%c&quot;,ch);</span><br><span class="line"> fflush(stdout);</span><br><span class="line"></span><br><span class="line"> //第五步：当先执行的线程执行完毕后，信号量初始值为0的信号量执行V操作</span><br><span class="line"> sem_post(&amp;sem_g);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //初始化信号量</span><br><span class="line"> sem_init(&amp;sem_g, 0, 0);</span><br><span class="line"> sem_init(&amp;sem_p, 0, 1);</span><br><span class="line"></span><br><span class="line"> pthread_t tid1,tid2;</span><br><span class="line"></span><br><span class="line"> pthread_create(&amp;tid1,NULL,pthread_g,NULL);</span><br><span class="line"> pthread_create(&amp;tid2,NULL,pthread_p,NULL);</span><br><span class="line"></span><br><span class="line"> pthread_join(tid1,NULL);</span><br><span class="line"> pthread_join(tid2,NULL);</span><br><span class="line"></span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"> //第七步：使用完毕后销毁信号量</span><br><span class="line"> sem_destroy(&amp;sem_g);</span><br><span class="line"> sem_destroy(&amp;sem_p);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://naro-ygc.cn">naro-ygc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://naro-ygc.cn/posts/69453faf.html">https://naro-ygc.cn/posts/69453faf.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://naro-ygc.cn" target="_blank">naro</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/../../../img/7_linux%E5%BC%80%E5%8F%91/c/%E5%B0%81%E9%9D%A2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/6f1ca842.html" title="linuxCpp"><img class="cover" src="/img/7_linux%E5%BC%80%E5%8F%91/cpp/linuxCpp/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">linuxCpp</div></div></a></div><div class="next-post pull-right"><a href="/posts/6d5e5a8.html" title="rootfs移植-详细"><img class="cover" src="/img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/mx6ull/%E5%B0%81%E9%9D%A2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">rootfs移植-详细</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/log.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">naro-ygc</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">76</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">1 、系统调用和库函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E7%94%B1%E4%B8%A4%E7%B1%BB%E5%87%BD%E6%95%B0%E7%BB%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">1-1 、库函数由两类函数组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">1-2、系统调用与库函数的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">1-2-1、系统调用特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">1-2-2、库函数的好处</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">1、进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">1-1、进程的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">1-3、进程的调度机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4%E3%80%81%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.3.</span> <span class="toc-text">1-4、进程控制块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5%E3%80%81%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">2.4.</span> <span class="toc-text">1-5、进程号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BAfork%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">2-6、进程的创建fork函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7"><span class="toc-number">2.6.</span> <span class="toc-text">1-7、进程的挂起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AD%89%E5%BE%85"><span class="toc-number">2.7.</span> <span class="toc-text">1-8、进程的等待</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">wait函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waitpid%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.2.</span> <span class="toc-text">waitpid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.7.3.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">特殊进程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.8.</span> <span class="toc-text">1-9、进程的终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#exit%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">exit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.8.2.</span> <span class="toc-text">_exit函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit%E5%92%8C-exit%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">2.8.3.</span> <span class="toc-text">exit和_exit函数的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10%E3%80%81%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E6%B8%85%E7%90%86"><span class="toc-number">2.9.</span> <span class="toc-text">1-10、进程退出清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E2%80%94vfork"><span class="toc-number">2.10.</span> <span class="toc-text">1-11、进程的创建—vfork</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-1%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%9C%A8%E7%88%B6%E8%BF%9B%E7%A8%8B%E4%B9%8B%E5%89%8D%E8%BF%90%E8%A1%8C"><span class="toc-number">2.10.1.</span> <span class="toc-text">1-11-1、子进程在父进程之前运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-2%E3%80%81%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4"><span class="toc-number">2.10.2.</span> <span class="toc-text">1-11-2、子进程和父进程共享同一块空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12%E3%80%81-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.10.3.</span> <span class="toc-text">1-12、 进程的替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13%E3%80%81system%E5%87%BD%E6%95%B0"><span class="toc-number">2.10.4.</span> <span class="toc-text">1-13、system函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">3.</span> <span class="toc-text">2、进程之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.1.</span> <span class="toc-text">2-1、信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1%E3%80%81%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">3.1.1.</span> <span class="toc-text">2-1-1、信号的概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1.2 产生信号的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E4%BF%A1%E5%8F%B7%E7%9A%84%E9%BB%98%E8%AE%A4%EF%BC%88%E7%BC%BA%E7%9C%81%EF%BC%89%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">2-1-3 信号的默认（缺省）处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%BF%9B%E7%A8%8B%E6%8E%A5%E6%94%B6%E5%88%B0%E4%BF%A1%E5%8F%B7%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">2-1-4 进程接收到信号后的处理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-number">3.1.5.</span> <span class="toc-text">2-1-5 常见的信号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81-kill%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">2-2、 kill函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81alarm%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">2-3、alarm函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81-raise%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">2-4、 raise函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81-abort%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">2-5、 abort函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E3%80%81-pause%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">2-6、 pause函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7%E3%80%81-signal%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">2-7、 signal函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8%E3%80%81-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">2-8、 可重入函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9%E3%80%81-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">3.9.</span> <span class="toc-text">2-9、 信号集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10%E3%80%81-%E4%BF%A1%E5%8F%B7%E9%98%BB%E5%A1%9E%E9%9B%86"><span class="toc-number">3.10.</span> <span class="toc-text">2-10、 信号阻塞集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E7%AE%A1%E9%81%93"><span class="toc-number">4.</span> <span class="toc-text">3、管道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">3-1、无名管道概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81-%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">4.2.</span> <span class="toc-text">3-2、 无名管道实现进程间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A7%84%E5%BE%8B"><span class="toc-number">4.3.</span> <span class="toc-text">3-3、无名管道的读写规律</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1%E3%80%81%E8%AF%BB%E5%86%99%E7%AB%AF%E9%83%BD%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8F%AA%E8%AF%BB%E4%B8%8D%E5%86%99"><span class="toc-number">4.3.1.</span> <span class="toc-text">3-3-1、读写端都存在，只读不写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E3%80%81%E8%AF%BB%E5%86%99%E7%AB%AF%E9%83%BD%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8F%AA%E5%86%99%E4%B8%8D%E8%AF%BB"><span class="toc-number">4.3.2.</span> <span class="toc-text">3-3-2、读写端都存在，只写不读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3%E3%80%81%E5%8F%AA%E6%9C%89%E8%AF%BB%E7%AB%AF%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%86%99%E7%AB%AF"><span class="toc-number">4.3.3.</span> <span class="toc-text">3-3-3、只有读端，没有写端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4%E3%80%81%E5%8F%AA%E6%9C%89%E5%86%99%E7%AB%AF%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%AF%BB%E7%AB%AF"><span class="toc-number">4.3.4.</span> <span class="toc-text">3-3-4、只有写端，没有读端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81%E9%80%9A%E8%BF%87fcntl%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%98%BB%E5%A1%9E%E7%89%B9%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">3-4、通过fcntl函数设置文件的阻塞特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">5.</span> <span class="toc-text">4、文件描述符概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81dup%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">4-1、dup函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9A"><span class="toc-number">5.1.1.</span> <span class="toc-text">案例1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">5.1.2.</span> <span class="toc-text">案例2：实现输出重定向的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%EF%BC%8C%E8%BF%98%E6%83%B3%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">案例3：实现输出重定向后，还想标准输出，如何实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81dup2%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">4-2、dup2函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.2.1.</span> <span class="toc-text">实现输出重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91%E5%90%8E%EF%BC%8C%E5%86%8D%E6%81%A2%E5%A4%8D%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA"><span class="toc-number">5.2.2.</span> <span class="toc-text">实现输出重定向后，再恢复标准输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-number">6.</span> <span class="toc-text">5、有名管道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">5-1、有名管道概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.2.</span> <span class="toc-text">5-2、有名管道的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.</span> <span class="toc-text">5-3、有名管道的基本读写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">6.4.</span> <span class="toc-text">5-4、有名管道实现进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#send"><span class="toc-number">6.4.1.</span> <span class="toc-text">send</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recv"><span class="toc-number">6.4.2.</span> <span class="toc-text">recv</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A7%84%E5%BE%8B%EF%BC%88%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">5-5、有名管道的读写规律（阻塞）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-1%E3%80%81%E8%AF%BB%E5%86%99%E7%AB%AF%E9%83%BD%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8F%AA%E8%AF%BB%E4%B8%8D%E5%86%99"><span class="toc-number">6.5.1.</span> <span class="toc-text">5-5-1、读写端都存在，只读不写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-2%E3%80%81%E8%AF%BB%E5%86%99%E7%AB%AF%E9%83%BD%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%8F%AA%E5%86%99%E4%B8%8D%E8%AF%BB"><span class="toc-number">6.5.2.</span> <span class="toc-text">5-5-2、读写端都存在，只写不读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-3%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%8F%AA%E6%9C%89%E8%AF%BB%E7%AB%AF%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%86%99%E7%AB%AF"><span class="toc-number">6.5.3.</span> <span class="toc-text">5-5-3、在一个进程中，只有读端，没有写端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-4%E3%80%81%E5%9C%A8%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%86%99%E7%AB%AF%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%AF%BB%E7%AB%AF"><span class="toc-number">6.5.4.</span> <span class="toc-text">5-5-4、在一个进程中，只有写端，没有读端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-5%E3%80%81-%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AA%E8%AF%BB%EF%BC%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AA%E5%86%99"><span class="toc-number">6.5.5.</span> <span class="toc-text">5-5-5、 一个进程只读，一个进程只写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-6%E3%80%81%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%E7%9A%84%E8%AF%BB%E5%86%99%E8%A7%84%E5%BE%8B%EF%BC%88%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-number">6.5.6.</span> <span class="toc-text">5-5-6、有名管道的读写规律（非阻塞）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">6、消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0"><span class="toc-number">7.0.1.</span> <span class="toc-text">6-1、消息队列概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81ftok%E5%87%BD%E6%95%B0"><span class="toc-number">7.0.2.</span> <span class="toc-text">6-2、ftok函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.0.3.</span> <span class="toc-text">6-3、消息队列的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1%E3%80%81%E5%88%9B%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E2%80%93-msgget"><span class="toc-number">7.0.3.1.</span> <span class="toc-text">6-3-1、创建消息队列 – msgget( )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2%E3%80%81%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-%E2%80%93-msgsnd"><span class="toc-number">7.0.3.2.</span> <span class="toc-text">6-3-2、发送消息 – msgsnd( )</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3%E3%80%81%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-%E2%80%93-msgrcv"><span class="toc-number">7.0.3.3.</span> <span class="toc-text">6-3-3、接收消息 – msgrcv( )</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">8.</span> <span class="toc-text">7、共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81-%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">8.1.</span> <span class="toc-text">7-1、 获得一个共享存储标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-attach"><span class="toc-number">8.2.</span> <span class="toc-text">7-2、 共享内存映射(attach)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E8%A7%A3%E9%99%A4%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84-detach"><span class="toc-number">8.3.</span> <span class="toc-text">7-3、解除共享内存映射(detach)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81%E6%A1%88%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.</span> <span class="toc-text">7-4、案例：使用共享内存实现读写操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E3%80%81%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6"><span class="toc-number">8.5.</span> <span class="toc-text">7-5、共享内存控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">8、线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">9.1.</span> <span class="toc-text">8-1、线程和进程的比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-number">9.2.</span> <span class="toc-text">8-2、多线程的用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.</span> <span class="toc-text">8-3、线程的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">9.3.1.</span> <span class="toc-text">8-3-1、线程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2%E3%80%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="toc-number">9.3.2.</span> <span class="toc-text">8-3-2、线程调度机制的验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3%E3%80%81%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82"><span class="toc-number">9.3.3.</span> <span class="toc-text">8-3-3、线程处理函数传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85"><span class="toc-number">9.3.4.</span> <span class="toc-text">8-3-4、线程等待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">9.3.5.</span> <span class="toc-text">8-3-5、线程的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-6%E3%80%81%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="toc-number">9.3.6.</span> <span class="toc-text">8-3-6、线程分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-7%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BA"><span class="toc-number">9.3.7.</span> <span class="toc-text">8-3-7、线程的退出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-8%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">9.3.8.</span> <span class="toc-text">8-3-8、线程的取消</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-8-1%E3%80%81%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%8F%96%E6%B6%88pthread-setcancelstate"><span class="toc-number">9.3.8.1.</span> <span class="toc-text">8-3-8-1、设置线程是否可以被取消pthread_setcancelstate()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-8-2%E3%80%81%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88%E7%82%B9pthread-testcancel"><span class="toc-number">9.3.8.2.</span> <span class="toc-text">8-3-8-2、设置线程的取消点pthread_testcancel()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-8-3%E3%80%81%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%AB%8B%E5%8D%B3%E5%8F%96%E6%B6%88-pthread-setcanceltype"><span class="toc-number">9.3.8.3.</span> <span class="toc-text">8-3-8-3、设置线程是否可以被立即取消 pthread_setcanceltype()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-9%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%80%E5%87%BApthread-cleanup-push"><span class="toc-number">9.3.9.</span> <span class="toc-text">8-3-9、线程的退出pthread_cleanup_push()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-9-1%E3%80%81pthread-cleanup-push"><span class="toc-number">9.3.9.1.</span> <span class="toc-text">8-3-9-1、pthread_cleanup_push()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-9-2%E3%80%81pthread-cleanup-pop"><span class="toc-number">9.3.9.2.</span> <span class="toc-text">8-3-9-2、pthread_cleanup_pop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-9-3%E3%80%81%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8pthread-exit%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.9.3.</span> <span class="toc-text">8-3-9-3、案例：验证线程调用pthread_exit函数时，系统自动调用线程清理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-9-4%E3%80%81%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%AA%8C%E8%AF%81%E7%BA%BF%E7%A8%8B%E8%A2%AB%E5%8F%96%E6%B6%88%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.9.4.</span> <span class="toc-text">8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-9-5%E3%80%81%E6%A1%88%E4%BE%8B%EF%BC%9A%E9%AA%8C%E8%AF%81%E8%B0%83%E7%94%A8pthread-cleanup-pop%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B8%85%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.9.5.</span> <span class="toc-text">8-3-9-5、案例：验证调用pthread_cleanup_pop函数时，系统自动调用线程清理函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="toc-number">10.</span> <span class="toc-text">9、多任务同步与互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">10.1.</span> <span class="toc-text">9-1、互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.1.</span> <span class="toc-text">9-1-1 互斥锁的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2%E3%80%81-%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.2.</span> <span class="toc-text">9-1-2、 互斥锁的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-1%E3%80%81-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">9-1-2-1、 初始化互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-2%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8A%E9%94%81"><span class="toc-number">10.1.2.2.</span> <span class="toc-text">9-1-2-2、互斥锁上锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-3%E3%80%81%E4%BA%92%E6%96%A5%E9%94%81%E8%A7%A3%E9%94%81"><span class="toc-number">10.1.2.3.</span> <span class="toc-text">9-1-2-3、互斥锁解锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-4%E3%80%81%E9%94%80%E6%AF%81%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">10.1.2.4.</span> <span class="toc-text">9-1-2-4、销毁互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">10.1.2.5.</span> <span class="toc-text">测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">10.2.</span> <span class="toc-text">9-2、信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.2.1.</span> <span class="toc-text">9-2-1、信号量的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.2.</span> <span class="toc-text">9-2-2、信号量的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-1%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">9-2-2-1、信号量的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-2%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84p%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">9-2-2-2、信号量的p操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-3%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84v%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">9-2-2-3、信号量的v操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-3%E3%80%81%E8%8E%B7%E5%8F%96%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%AE%A1%E6%95%B0"><span class="toc-number">10.2.2.4.</span> <span class="toc-text">9-2-2-3、获取信号量的计数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-4%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">10.2.2.5.</span> <span class="toc-text">9-2-2-4、信号量的销毁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.3.</span> <span class="toc-text">9-2-3、信号量的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E5%8A%9F%E8%83%BD"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">信号量实现互斥功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">10.2.3.2.</span> <span class="toc-text">信号量实现同步</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c1179e11.html" title="rootfs移植"><img src="/img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/mx6ull/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="rootfs移植"/></a><div class="content"><a class="title" href="/posts/c1179e11.html" title="rootfs移植">rootfs移植</a><time datetime="2025-07-06T15:30:24.665Z" title="发表于 2025-07-06 23:30:24">2025-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f85e2006.html" title="程序是怎么跑起来的"><img src="/img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="程序是怎么跑起来的"/></a><div class="content"><a class="title" href="/posts/f85e2006.html" title="程序是怎么跑起来的">程序是怎么跑起来的</a><time datetime="2025-07-03T16:47:58.050Z" title="发表于 2025-07-04 00:47:58">2025-07-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/0.html" title="无题">无题</a><time datetime="2025-07-02T21:47:56.079Z" title="发表于 2025-07-03 05:47:56">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f2e2a688.html" title="音视频原理入门"><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/ffmpeg/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="音视频原理入门"/></a><div class="content"><a class="title" href="/posts/f2e2a688.html" title="音视频原理入门">音视频原理入门</a><time datetime="2025-07-02T21:44:22.579Z" title="发表于 2025-07-03 05:44:22">2025-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/96a84f26.html" title="计算机是怎么跑起来的"><img src="/img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E5%B0%81%E9%9D%A2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机是怎么跑起来的"/></a><div class="content"><a class="title" href="/posts/96a84f26.html" title="计算机是怎么跑起来的">计算机是怎么跑起来的</a><time datetime="2025-07-02T17:42:15.661Z" title="发表于 2025-07-03 01:42:15">2025-07-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By naro-ygc</div><div class="footer_custom_text">未经本人同意不得作于其他用途</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 网络 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/驱动、bootleader、文件系统/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 驱动、bootleader、文件系统 (22)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/Linux开发/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Linux开发 (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/问题总结/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 问题总结 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/开发方法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 开发方法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/AI-深度学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 AI-深度学习 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://naro-ygc.cn/categories/音视频协议/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 音视频协议 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://naro-ygc.cn/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>