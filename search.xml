<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="掌握驱动移植开发知识"><a href="#掌握驱动移植开发知识" class="headerlink" title="掌握驱动移植开发知识"></a>掌握驱动移植开发知识</h1><h1 id="掌握qt-音视频开发"><a href="#掌握qt-音视频开发" class="headerlink" title="掌握qt,音视频开发"></a>掌握qt,音视频开发</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>音视频原理入门</title>
      <link href="/posts/f2e2a688.html"/>
      <url>/posts/f2e2a688.html</url>
      
        <content type="html"><![CDATA[<h1 id="入门基础"><a href="#入门基础" class="headerlink" title="入门基础"></a>入门基础</h1><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><h3 id="视频帧率"><a href="#视频帧率" class="headerlink" title="视频帧率"></a>视频帧率</h3><p>视频帧,帧率，帧率一般电视在25帧&#x2F;秒，电影在24帧&#x2F;秒，1080P 60帧&#x2F;秒，720P 30帧&#x2F;秒。过高无意义。</p><h3 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h3><p>常见的两种色彩空间：RGB 和 YUV。<br>RGB是彩色空间，RGB三通道，R为红色，G为绿色，B为蓝色。<br>早期的电视都是黑白的，YUV只有Y亮度值，后来加入两种色度UV，也叫YCbCr。<br>色度定义了颜色的两个方面：色度，饱和度。<br>Cr:反应的是输入信号红色部分与RGB信号之间的差异。<br>Cb:反应的是输入信号蓝色部分与RGB信号之间的差异。</p><p>总结：<br>Y:亮度,也代表一定程度的绿色通道量。<br>U:与蓝色部分之间的差异。<br>V:与红色部分之间的差异。</p><p>人眼对亮度的敏感度更高，对色度敏感度较低。</p><p>RGB和YUV进行线性量化转换。</p><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>音频数据的承载方式最常见的就是脉冲编码调制，也就是pcm。<br>pcm的采集可以分为以下<br>模拟信号-&gt;采样-&gt;量化-&gt;编码-&gt;数字信号</p><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>根据采样的奈奎斯特定理，采样率必须大于等于2倍的信号频率。人耳20Hz到20KHz之间可以听清。</p><p>采样率，就是采样的频率。</p><h3 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h3><p>这个直接涉及到振幅的大小。8位，16位，32位。采样位数越高，表示的幅度就越大。还原性越好。但是占用的空间会越大。</p><h3 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h3><p>这里就是坑，音频数字化的标准是每个样本16位，96dB信噪比。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机是怎么跑起来的</title>
      <link href="/posts/96a84f26.html"/>
      <url>/posts/96a84f26.html</url>
      
        <content type="html"><![CDATA[<p>这个是计算机怎么跑起来的读书笔记。<br>本书由日本作者失泽久雄所写<br><img src="/img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E5%B0%81%E9%9D%A2.png"></p><h1 id="计算机三大原则"><a href="#计算机三大原则" class="headerlink" title="计算机三大原则"></a>计算机三大原则</h1><h2 id="计算机三大原则：输入、处理-运算-、输出"><a href="#计算机三大原则：输入、处理-运算-、输出" class="headerlink" title="计算机三大原则：输入、处理(运算)、输出"></a>计算机三大原则：输入、处理(运算)、输出</h2><p>任何一个计算机都是这样运行的，同理程序也是如此。</p><p>输入：输入数据<br>处理：运算<br>输出：输出数据</p><h2 id="程序：本质是指令-数据"><a href="#程序：本质是指令-数据" class="headerlink" title="程序：本质是指令+数据"></a>程序：本质是指令+数据</h2><p><img src="/img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/%E4%BA%8C%E8%BF%9B%E5%88%B6.png"><br>这里的十六进制，全是数据。如果是可执行文件，开头前几个字节，基本就是指令。<br>所有的十六进制。要么是指令，要么是数据，不会有其他的。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码：将数据转换成计算机可识别的二进制数据。<br>常见的中文编码，颜色编码。本质是让计算机去识别。</p><h2 id="计算机只认识数字（废话）"><a href="#计算机只认识数字（废话）" class="headerlink" title="计算机只认识数字（废话）"></a>计算机只认识数字（废话）</h2><p>所有的程序都是一堆数字,连接这一切的就是编码</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>书上的例子。<br>微软为新一代互联网提出了.NET技术，作为.NET核心的XMLweb服务使用通用的soap、XML,使得互联网计算机之间协同工作。</p><p>这段话初读确实如书中所说的一样，不知道说的是什么。<br>但是按照计算机的三大原则，就可以说，使用soap规范了指令或者数据，XML规范了数据或者指令。至于为什么soap复杂什么的，那就归为是要计算机去处理的方式。<br>毕竟计算机只能认识到简答的数字。</p><h1 id="试着制造一台计算机吧"><a href="#试着制造一台计算机吧" class="headerlink" title="试着制造一台计算机吧"></a>试着制造一台计算机吧</h1><p>本次作者留了三个问题</p><p>初级问题<br>1 、 CPU 是什么的缩写？</p><p>中级问题<br>2、 Hz是表示什么的单位？</p><p>高级问题<br>3、 Z80 CPU是多少比特的CPU？</p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>openssl和unzip和zip移植</title>
      <link href="/posts/a003dbfe.html"/>
      <url>/posts/a003dbfe.html</url>
      
        <content type="html"><![CDATA[<h1 id="openssl-移植"><a href="#openssl-移植" class="headerlink" title="openssl 移植"></a>openssl 移植</h1><p>编译脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make clean</span><br><span class="line">mkdir output</span><br><span class="line">export CC=/home/wangyp/project/dtcwyp/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi-gcc</span><br><span class="line">./Configure \</span><br><span class="line">            no-zlib \</span><br><span class="line">            --shared \</span><br><span class="line">            --prefix=$(pwd)/output openssl-1.0.2h \</span><br><span class="line">            os/compiler:arm-fullhanv3-linux-uclibcgnueabi-b6 \</span><br><span class="line">            -DOPENSSL_THREADS \</span><br><span class="line">            -Wno-psabi -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4 -fno-aggressive-loop-optimizations</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h1 id="其他zip和unzip比较简单"><a href="#其他zip和unzip比较简单" class="headerlink" title="其他zip和unzip比较简单"></a>其他zip和unzip比较简单</h1><p>略</p><h1 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a>valgrind</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make clean</span><br><span class="line">export PATH=$PATH:/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/</span><br><span class="line">export CFLAGS=&quot;-Wno-psabi -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4 -fno-aggressive-loop-optimizations&quot;</span><br><span class="line">export CXXFLAGS=&quot;-Wno-psabi -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4 -fno-aggressive-loop-optimizations&quot;</span><br><span class="line">echo $PATH</span><br><span class="line">./configure --host=arm-fullhanv3-linux-uclibcgnueabi  --prefix=$(pwd)/./output</span><br><span class="line"></span><br><span class="line">make V=1</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>x264和x265 移植</title>
      <link href="/posts/fc7f7e68.html"/>
      <url>/posts/fc7f7e68.html</url>
      
        <content type="html"><![CDATA[<h1 id="x264-移植"><a href="#x264-移植" class="headerlink" title="x264 移植"></a>x264 移植</h1><p>编译脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo chmod 777 ./* -Rf</span><br><span class="line">path_cur=$(pwd)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> -rf x264</span></span><br><span class="line">build_x264() &#123;</span><br><span class="line">    cd x264</span><br><span class="line">    sudo make clean</span><br><span class="line">    local path=&quot;/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin&quot;</span><br><span class="line">    build_x264=$&#123;path_cur&#125;/buildx264</span><br><span class="line">    sudo rm -rf $build_x264</span><br><span class="line">    sudo mkdir -p $build_x264</span><br><span class="line">    ./configure \</span><br><span class="line">         --prefix=$build_x264 \</span><br><span class="line">        --host=arm-fullhanv3-linux-uclibcgnueabi \</span><br><span class="line">        --cross-prefix=$&#123;path&#125;/arm-fullhanv3-linux-uclibcgnueabi- \</span><br><span class="line">        CC=$&#123;path&#125;/arm-fullhanv3-linux-uclibcgnueabi-gcc \</span><br><span class="line">        --enable-shared \</span><br><span class="line">        --disable-static \</span><br><span class="line">        --disable-cli</span><br><span class="line">    make -j$(nproc)</span><br><span class="line">    sudo make install</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">download()&#123;</span><br><span class="line">    # git clone https://git.videolan.org/git/x264.git x264</span><br><span class="line">    # cd x264</span><br><span class="line">    # git checkout stable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # git clone https://code.videolan.org/videolan/x264.git x264</span><br><span class="line">    # cd x264</span><br><span class="line"></span><br><span class="line">    wget https://download.videolan.org/pub/videolan/x264/snapshots/x264-snapshot-20171210-2245-stable.tar.bz2</span><br><span class="line">    tar -jxvf x264-snapshot-20171210-2245-stable.tar.bz2</span><br><span class="line">    sudo chmod 777 ./* -Rf</span><br><span class="line">    mv x264-snapshot-20171210-2245-stable x264</span><br><span class="line">    rm -rf x264-snapshot-20171210-2245-stable.tar.bz2</span><br><span class="line">    cd x264</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ -d &quot;x264&quot; ]; then</span><br><span class="line">echo &quot;x264 exists&quot;</span><br><span class="line">else</span><br><span class="line">download</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">build_x264</span><br></pre></td></tr></table></figure><h1 id="x265-移植"><a href="#x265-移植" class="headerlink" title="x265 移植"></a>x265 移植</h1><p>x265的编译脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">sudo chmod 777 ./* -Rf</span><br><span class="line">sudo rm -rf x265</span><br><span class="line">curpath=$(pwd)</span><br><span class="line">buildx265() &#123;</span><br><span class="line">        cd x265</span><br><span class="line">        git checkout 2.6</span><br><span class="line">        sudo apt update</span><br><span class="line">        sudo apt install cmake build-essential yasm nasm</span><br><span class="line"></span><br><span class="line">        sudo apt install cmake-curses-gui</span><br><span class="line">        sudo make clean</span><br><span class="line"></span><br><span class="line">        local path=&quot;/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin&quot;</span><br><span class="line">        build_x265=$&#123;curpath&#125;/buildx265</span><br><span class="line">        rm -rf $build_x265</span><br><span class="line">        sudo mkdir -p $build_x265</span><br><span class="line"></span><br><span class="line">       set -x</span><br><span class="line">        cd ./build/arm-linux</span><br><span class="line">        rm crosscompile.cmake</span><br><span class="line">        # rm -rf ./*</span><br><span class="line">       sudo  cp $curpath/crosscompile.cmake ./</span><br><span class="line">       pwd</span><br><span class="line">       ls -l</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">       ./make-Makefiles.bash</span></span><br><span class="line">       cmake -G &quot;Unix Makefiles&quot; -DCMAKE_TOOLCHAIN_FILE=./crosscompile.cmake ../../source &amp;&amp; ccmake ../../source</span><br><span class="line">        set +x</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#   -DCMAKE_INSTALL_PREFIX=$build_x265 \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   -DENABLE_SHARED=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   -DENABLE_STATIC=ON \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   -DENABLE_CLI=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   -DENABLE_ASSEMBLY=ON \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   ../../source &amp;&amp; ccmake../../source</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">        CC=<span class="string">&quot;<span class="variable">$&#123;path&#125;</span>/arm-fullhanv3-linux-uclibcgnueabi-gcc&quot;</span> \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#         CXX=&quot;$&#123;path&#125;/arm-fullhanv3-linux-uclibcgnueabi-g++&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         cmake -G &quot;Unix Makefiles&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DCMAKE_INSTALL_PREFIX=&quot;$build_x265&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DCMAKE_C_COMPILER=$path/arm-fullhanv3-linux-uclibcgnueabi-gcc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DCMAKE_CXX_COMPILER=$path/arm-fullhanv3-linux-uclibcgnueabi-g++ \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#          -DCMAKE_C_FLAGS=&quot;-march=armv7-a -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#     -DCMAKE_CXX_FLAGS=&quot;-march=armv7-a -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#     -DENABLE_X86_64=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#     -DENABLE_X86_64=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DENABLE_SSE3=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DENABLE_SSSE3=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DENABLE_SSE4=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         -DENABLE_ASSEMBLY=OFF \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#         ../../source &amp;&amp; ccmake ../../source</span></span></span><br><span class="line"></span><br><span class="line">    make -j$(nproc)</span><br><span class="line">    sudo make install</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">download()&#123;</span><br><span class="line">        git clone  https://bitbucket.org/multicoreware/x265_git.git x265</span><br><span class="line">        sudo chmod 777 ./* -Rf</span><br><span class="line">        cd x265</span><br><span class="line">        git checkout 2.6</span><br><span class="line"></span><br><span class="line">        # wget https://bitbucket.org/multicoreware/x265/downloads/x265_2.6.tar.gz</span><br><span class="line">        # tar -xzf x265_2.6.tar.gz</span><br><span class="line">        # rm -rf x265_2.6.tar.gz</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -d &quot;x265&quot; ]; then</span><br><span class="line">        echo &quot;x265 exists&quot;</span><br><span class="line">else </span><br><span class="line">        download</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">buildx265</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>富瀚mmc移植</title>
      <link href="/posts/fc7f7e68.html"/>
      <url>/posts/fc7f7e68.html</url>
      
        <content type="html"><![CDATA[<h1 id="mmc-移植"><a href="#mmc-移植" class="headerlink" title="mmc 移植"></a>mmc 移植</h1><p>linux自带的无法对出错的mmc进行处理，需要自己移植mmc工具，参考mmc-utils</p><h1 id="编译脚本："><a href="#编译脚本：" class="headerlink" title="编译脚本："></a>编译脚本：</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">CC=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi-gcc</span><br><span class="line">CROSS_COMPILE=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi</span><br><span class="line">ARCH=arm</span><br><span class="line">export CC=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi-gcc</span><br><span class="line">export CROSS_COMPILE=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi</span><br><span class="line">export ARCH=arm</span><br><span class="line">build()</span><br><span class="line">&#123;</span><br><span class="line">        cd mmc-utils</span><br><span class="line">        make clean</span><br><span class="line">        make CROSS_COMPILE=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi</span><br><span class="line">        cd ..</span><br><span class="line">&#125;</span><br><span class="line">if [ -d &quot;mmc-utils&quot; ];then</span><br><span class="line">        build</span><br><span class="line">else</span><br><span class="line">        git clone https://git.kernel.org/pub/scm/utils/mmc/mmc-utils.git</span><br><span class="line">        cd setup-tools/mmc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>富瀚ffmpeg移植</title>
      <link href="/posts/d35c4abc.html"/>
      <url>/posts/d35c4abc.html</url>
      
        <content type="html"><![CDATA[<p>编译脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ffmpeg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo <span class="built_in">chown</span> <span class="variable">$USER</span>:<span class="variable">$USER</span> /output</span></span><br><span class="line">output=$&#123;PWD&#125;/output</span><br><span class="line">rm -rf output</span><br><span class="line">mkdir -p ./output</span><br><span class="line">build_ffmpeg() &#123;</span><br><span class="line">cd ffmpeg</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">make distclean</span></span><br><span class="line">export PATH=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin:$PATH</span><br><span class="line">CROSS_COMPILE=/home/tuling/.FuHan-arm-linux/opt/arm-fullhanv3-linux-uclibcgnueabi-b6/bin/arm-fullhanv3-linux-uclibcgnueabi-</span><br><span class="line">export CC=$&#123;CROSS_COMPILE&#125;gcc</span><br><span class="line">export CXX=$&#123;CROSS_COMPILE&#125;g++</span><br><span class="line">export AR=$&#123;CROSS_COMPILE&#125;ar</span><br><span class="line">export AS=$&#123;CROSS_COMPILE&#125;as</span><br><span class="line">export LD=$&#123;CROSS_COMPILE&#125;ld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">export</span> STRIP=<span class="variable">$&#123;CROSS_COMPILE&#125;</span>strip</span></span><br><span class="line">echo $CC</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --prefix=$output \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --target-os=linux \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --arch=arm \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --cross-prefix=$&#123;CROSS_COMPILE&#125; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-cross-compile \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-x86asm \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-shared \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-static \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-programs \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-doc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-ffmpeg \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-ffplay \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-ffprobe \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-pic \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-symver \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-everything \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=mp4 \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=hevc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=aac \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-neon \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-debug \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-bsf=h264_mp4toannexb,aac_adtstoasc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-protocol=file \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-asm  \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --extra-ldflags=&quot;-mfloat-abi=hard -Wl,--no-warn-mismatch&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --extra-cflags=&quot;-march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard&quot; \</span></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --prefix=$output \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --target-os=linux \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --arch=arm \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --cross-prefix=$&#123;CROSS_COMPILE&#125; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-cross-compile \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-x86asm \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-shared \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-static \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-programs \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-doc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-ffmpeg \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-ffplay \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-ffprobe \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-pic \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-symver \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-everything \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=avi \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-encoder=msmpeg4v2 \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-encoder=msmpeg4 \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-encoder=pcm_s16le \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=mp4 \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=matroska \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=webm \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=hevc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-muxer=aac \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-neon \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-debug \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-bsf=h264_mp4toannexb,aac_adtstoasc \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-protocol=file \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --disable-asm \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --extra-ldflags=&quot;-mfloat-abi=hard -Wl,--no-warn-mismatch&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --extra-cflags=&quot;-march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard&quot;</span></span></span><br><span class="line">./configure \</span><br><span class="line">  --prefix=$output \</span><br><span class="line">  --target-os=linux \</span><br><span class="line">  --arch=arm \</span><br><span class="line">  --cross-prefix=$&#123;CROSS_COMPILE&#125; \</span><br><span class="line">  --enable-cross-compile \</span><br><span class="line">  --disable-x86asm \</span><br><span class="line">  --disable-shared \</span><br><span class="line">  --enable-static \</span><br><span class="line">  --disable-programs \</span><br><span class="line">  --disable-doc \</span><br><span class="line">  --disable-ffmpeg \</span><br><span class="line">  --disable-ffplay \</span><br><span class="line">  --disable-ffprobe \</span><br><span class="line">  --disable-symver \</span><br><span class="line">  --disable-everything \</span><br><span class="line">  --enable-muxer=mp4 \</span><br><span class="line">  --enable-demuxer=mp4 \</span><br><span class="line">  --enable-demuxer=mov \</span><br><span class="line">  --enable-muxer=hevc \</span><br><span class="line">  --enable-demuxer=hevc \</span><br><span class="line">  --enable-parser=hevc \</span><br><span class="line">    --enable-decoder=aac \</span><br><span class="line">  --enable-encoder=pcm_s16le \</span><br><span class="line">  --enable-debug \</span><br><span class="line">  --enable-bsf=h264_mp4toannexb \</span><br><span class="line">    --enable-bsf=h264_mp4toannexb,aac_adtstoasc,hevc_mp4toannexb \</span><br><span class="line">  --enable-protocol=file \</span><br><span class="line">  --extra-ldflags=&quot;-mfloat-abi=hard -Wl,--no-warn-mismatch&quot; \</span><br><span class="line">  --extra-cflags=&quot;-march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">避免汇编代码绕过浮点ABI检查</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --enable-cross-compile \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --arch=armv7-a \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --target-os=linux \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --cross-prefix=arm-fullhanv3-linux-uclibcgnueabi- \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --extra-cflags=&quot;-mfloat-abi=hard -mfpu=neon-vfpv4 -fPIC&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment">#   --extra-ldflags=&quot;-mfloat-abi=hard -Wl,--no-warn-mismatch&quot; \</span></span></span><br><span class="line"><span class="language-bash"><span class="comment"># make -j$(nproc)</span></span></span><br><span class="line"></span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ -d &quot;ffmpeg&quot; ]; then</span><br><span class="line">  echo &quot;FFmpeg exists&quot;</span><br><span class="line">else</span><br><span class="line">   git clone https://gitee.com/mirrors/ffmpeg.git ffmpeg</span><br><span class="line">   cd ffmpeg</span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"> git checkout n3.4</span></span><br><span class="line">  git checkout n4.4</span><br><span class="line">    # git checkout   n6.0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">build_ffmpeg</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>map</title>
      <link href="/posts/93adaabb.html"/>
      <url>/posts/93adaabb.html</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>std::map&lt;key_type, value_type&gt; myMap;</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>map的key是唯一的，不能重复。<br>2、注意访问如果不存在会自动创建一个元素。所以尽量是用迭代器访问。(避免map[key]方式)</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/posts/1b6e485b.html"/>
      <url>/posts/1b6e485b.html</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>操作方法：sort、remove_if、find、erase等。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AAC音频格式详解</title>
      <link href="/posts/f2d77ef1.html"/>
      <url>/posts/f2d77ef1.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、格式头"><a href="#1、格式头" class="headerlink" title="1、格式头"></a>1、格式头</h1><p>头名字叫ADTS,如下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aac_data:ff f9 6c 40 16 ff fc 1 8 9e d8 12 76 2c 12 41 e8 ff 0 43 5d 43 49 48 5 92 b1 b2 85 ae ce 47 65 93 15 c6 cb a0 a8 82 b7 a 4e e0 cf 15 99 b0 66 fc c6 79 5e 6a 7e 74 93 1e 4d 9b 5c 4e f2 ca 7d d1 3a 77 b3 6b 29 54 51 bc fe 9e 72 77 91 19 ab 18 85 ad 10 9c 56 b6 87 6b d4 40 14 e5 d5 99 a 4b 1f 5d</span><br></pre></td></tr></table></figure><p>以ff f9开头。储存了音频的采样率、声道数、采样位数等信息。长度为7个字节。</p><p>如果要将 AAC 数据通过 RTP 发送，一般都需要 ADTS。<br>如果要写入 .aac 文件供播放器识别，也需要 ADTS。<br>如果要写入 MP4，则应去掉 ADTS，改用 AAC LATM 或容器本身的描述方式。</p><p>第一个字节固定ff。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mx6ull的uboot--2023版本移植</title>
      <link href="/posts/a8487789.html"/>
      <url>/posts/a8487789.html</url>
      
        <content type="html"><![CDATA[<h1 id="获取uboot源码"><a href="#获取uboot源码" class="headerlink" title="获取uboot源码"></a>获取uboot源码</h1><p><a href="https://github.com/nxp-imx">https://github.com/nxp-imx</a><br>nxp官方维护的仓库<br>拿到源码，编译。略</p><h1 id="采用和我芯片一样的模板编译"><a href="#采用和我芯片一样的模板编译" class="headerlink" title="采用和我芯片一样的模板编译"></a>采用和我芯片一样的模板编译</h1><p>编译mx6ull_14x14x_evk_defconfig<br>编译后直接搜索mx6ull_14x14x_evk_defconfig</p><h1 id="和之前移植有一些心得"><a href="#和之前移植有一些心得" class="headerlink" title="和之前移植有一些心得"></a>和之前移植有一些心得</h1><p>arch&#x2F;arm&#x2F;dts中，添加自己的设备树文件后，要在这个文件夹下有个makefile中添加上自己的设备树<br>这里改好还要去arch&#x2F;arm&#x2F;mach-imx&#x2F;Kconfig中添加自己的设备树配置项,不然设备树还是编译不到。里面还要<br>配置自己板子的Kconfig</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mx6ull的linux移植</title>
      <link href="/posts/9bc69965.html"/>
      <url>/posts/9bc69965.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p><a href="https://github.com/nxp-imx">https://github.com/nxp-imx</a><br>nxp官方维护的仓库</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译要选择的模板目录载arch&#x2F;arm&#x2F;configs&#x2F;下,<br>模板选择imx_v6_v7_defconfig</p><h1 id="tftp"><a href="#tftp" class="headerlink" title="tftp"></a>tftp</h1><p>采用网络下载的方法，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tftpd-hpa  # Debian/Ubuntu</span><br></pre></td></tr></table></figure><p>创建目录<br>然后修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/tftpd-hpa</span><br></pre></td></tr></table></figure><p>下面为配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> cat /etc/default/tftpd-hpa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/default/tftpd-hpa</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两个配置</span></span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/ygc/Desktop/project/tftp&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;-1 -c -s&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/tuling/nfs/tftp&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;-1 -c -s&quot;</span><br></pre></td></tr></table></figure><p>上面不生效，被覆盖了，采用链接的方式链接过去<br>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart tftpd-hpa</span><br></pre></td></tr></table></figure><h1 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h1><p>linux的移植相比于uboot。直接拷贝arch&#x2F;arm&#x2F;configs&#x2F;里面的配置，自已名字改一份，<br>比较容易。<br>而对于驱动，驱动的编译会在makefile里有一个config的选项,如果在.config里开起，就会去编译。</p><p>设备树的makefile中，</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">imx6sx-udoo-neo-full.dtb</span><br><span class="line">dtb-<span class="variable">$(CONFIG_SOC_IMX6UL)</span> += \</span><br><span class="line">imx6ul-14x14-evk.dtb \</span><br><span class="line">imx6ul-ccimx6ulsbcexpress.dtb \</span><br><span class="line">imx6ul-ccimx6ulsbcpro.dtb \</span><br><span class="line">imx6ul-geam.dtb \</span><br><span class="line">imx6ul-isiot-emmc.dtb \</span><br><span class="line">imx6ul-isiot-nand.dtb \</span><br><span class="line">imx6ul-kontron-n6310-s.dtb \</span><br><span class="line">imx6ul-kontron-n6310-s-43.dtb \</span><br><span class="line">imx6ul-liteboard.dtb \</span><br><span class="line">imx6ul-opos6uldev.dtb \</span><br><span class="line">imx6ul-pico-dwarf.dtb \</span><br><span class="line">imx6ul-pico-hobbit.dtb \</span><br><span class="line">imx6ul-pico-pi.dtb \</span><br><span class="line">imx6ul-phytec-segin-ff-rdk-emmc.dtb \</span><br><span class="line">imx6ul-phytec-segin-ff-rdk-nand.dtb \</span><br><span class="line">imx6ul-prti6g.dtb \</span><br><span class="line">imx6ul-tx6ul-0010.dtb \</span><br><span class="line">imx6ul-tx6ul-0011.dtb \</span><br><span class="line">imx6ul-tx6ul-mainboard.dtb \</span><br><span class="line">imx6ull-14x14-evk.dtb \</span><br><span class="line">imx6ull-colibri-emmc-eval-v3.dtb \</span><br><span class="line">imx6ull-colibri-eval-v3.dtb \</span><br><span class="line">imx6ull-colibri-wifi-eval-v3.dtb \</span><br><span class="line">imx6ull-jozacp.dtb \</span><br><span class="line">imx6ull-myir-mys-6ulx-eval.dtb \</span><br><span class="line">imx6ull-opos6uldev.dtb \</span><br><span class="line">imx6ull-phytec-segin-ff-rdk-nand.dtb \</span><br><span class="line">imx6ull-phytec-segin-ff-rdk-emmc.dtb \</span><br><span class="line">imx6ull-phytec-segin-lc-rdk-nand.dtb \</span><br><span class="line">imx6ulz-14x14-evk.dtb \</span><br><span class="line">imx6ulz-bsh-smm-m2.dtb</span><br><span class="line">dtb-<span class="variable">$(CONFIG_SOC_IMX6ULL)</span> += \</span><br><span class="line">imx6ull-naro.dtb </span><br></pre></td></tr></table></figure><p>注意最后一项不需要 \。</p><p>CONFIG_SOC_IMX6ULL 去deconfig文件中开启，对于图形化配置界面，则使用kconfg界面去开启。</p><p>对于deconfig文件和.config文件，两者的差异是：</p><p>在 Linux 内核源码中，<code>arch/arm/configs/</code> 下的配置文件和源码根目录下的 <code>.config</code> 文件虽然都用于配置内核编译选项，但它们的作用和使用场景有所不同。以下是两者的主要区别：</p><hr><h3 id="1-arch-arm-configs-下的配置文件"><a href="#1-arch-arm-configs-下的配置文件" class="headerlink" title="1. arch/arm/configs/ 下的配置文件"></a>1. <code>arch/arm/configs/</code> 下的配置文件</h3><ul><li><strong>作用</strong>：提供预定义的默认配置模板。</li><li><strong>类型</strong>：通常是架构相关的配置文件（如 <code>imx_v6_v7_defconfig</code>）。</li><li><strong>用途</strong>：<ul><li>作为构建 <code>.config</code> 的起点。</li><li>提供一个特定平台或功能集的标准配置。</li></ul></li><li><strong>生成方式</strong>：<ul><li>用户可以通过 <code>make ARCH=arm imx_v6_v7_defconfig</code> 命令将该配置文件复制到源码根目录下，生成 <code>.config</code> 文件。</li></ul></li><li><strong>特点</strong>：<ul><li>静态文件，不随编译过程变化。</li><li>可以有多个不同的 defconfig 文件，对应不同平台或需求。</li></ul></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm imx_v6_v7_defconfig</span><br></pre></td></tr></table></figure><hr><h3 id="2-config-文件（位于源码根目录）"><a href="#2-config-文件（位于源码根目录）" class="headerlink" title="2. .config 文件（位于源码根目录）"></a>2. <code>.config</code> 文件（位于源码根目录）</h3><ul><li><strong>作用</strong>：当前内核编译的实际配置文件。</li><li><strong>内容</strong>：包含了所有选中的内核选项（例如 <code>CONFIG_SOC_IMX6ULL=y</code>）。</li><li><strong>生成方式</strong>：<ul><li>通常由 <code>defconfig</code> 文件生成，也可以通过 <code>make menuconfig</code>、<code>make kconfig</code> 等图形化工具修改后保存。</li></ul></li><li><strong>用途</strong>：<ul><li>编译时直接被 Kbuild 使用来决定哪些代码需要编译。</li><li>所有模块、驱动、功能的启用&#x2F;禁用都由此文件控制。</li></ul></li><li><strong>特点</strong>：<ul><li>动态文件，会随着用户配置而改变。</li><li>是最终生效的配置文件。</li></ul></li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig   <span class="comment"># 修改配置后保存，会更新 .config</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th>特性</th><th><code>arch/arm/configs/xxx_defconfig</code></th><th><code>.config</code></th></tr></thead><tbody><tr><td><strong>位置</strong></td><td>在 configs 目录下</td><td>在源码根目录</td></tr><tr><td><strong>用途</strong></td><td>提供默认配置模板</td><td>实际使用的配置文件</td></tr><tr><td><strong>是否可编辑</strong></td><td>可以编辑，但一般只读</td><td>可随时修改</td></tr><tr><td><strong>生成方式</strong></td><td>用户手动选择或创建</td><td>由 defconfig 或 menuconfig 生成</td></tr><tr><td><strong>是否生效</strong></td><td>否，仅作为模板</td><td>是，直接影响编译结果</td></tr></tbody></table><hr><h3 id="应用场景建议"><a href="#应用场景建议" class="headerlink" title="应用场景建议"></a>应用场景建议</h3><ul><li>如果你是初次移植内核，可以从 <code>arch/arm/configs/</code> 中选择一个最接近目标平台的 <code>defconfig</code> 文件作为起点。</li><li>如果你已经有一个 <code>.config</code> 文件，并需要微调配置，可以使用 <code>make menuconfig</code> 来修改 <code>.config</code>。</li><li>在调试或开发过程中，<code>.config</code> 是主要操作对象；而 <code>defconfig</code> 更多用于标准化和复用配置。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>neovim</title>
      <link href="/posts/69453faf.html"/>
      <url>/posts/69453faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载neovim"><a href="#下载neovim" class="headerlink" title="下载neovim"></a>下载neovim</h1><p>github上点击wiki，选用最新的release版本下载</p><h1 id="nvim配置文件"><a href="#nvim配置文件" class="headerlink" title="nvim配置文件"></a>nvim配置文件</h1><p>使用命令</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: = vim.fn.stdpath(&#x27;config&#x27;)</span><br></pre></td></tr></table></figure><p>放弃了</p>]]></content>
      
      
      <categories>
          
          <category> neovim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mx6ull编译器选择</title>
      <link href="/posts/f8227b6f.html"/>
      <url>/posts/f8227b6f.html</url>
      
        <content type="html"><![CDATA[<h1 id="mx6ull编译器选择"><a href="#mx6ull编译器选择" class="headerlink" title="mx6ull编译器选择"></a>mx6ull编译器选择</h1><p><a href="https://github.com/nxp-imx">https://github.com/nxp-imx</a><br>nxp官方维护的仓库</p><p>属于arm架构，armv7a系类。支持硬件浮点运算。需要系统。<br>可选的编译器：<br>在Linaro官网下载交叉编译工具链：<a href="https://www.linaro.org/downloads/">https://www.linaro.org/downloads/</a><br>arm官方的：<a href="https://developer.arm.com/downloads/-/gnu-a">https://developer.arm.com/downloads/-/gnu-a</a></p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mx6ull的uboot--2024版本移植</title>
      <link href="/posts/8b3dcb08.html"/>
      <url>/posts/8b3dcb08.html</url>
      
        <content type="html"><![CDATA[<p>存在的问题，uboot的tftp下载速度太慢</p><h1 id="移植uboot"><a href="#移植uboot" class="headerlink" title="移植uboot"></a>移植uboot</h1><p><a href="https://github.com/nxp-imx">https://github.com/nxp-imx</a><br>nxp官方维护的仓库<br>拿到源码，编译。略</p><p>编译。<br>拿到板子， 选一个厂家的板子的配置，编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make mx6ull_14x14_evk_defconfig</span><br></pre></td></tr></table></figure><p>编译完成后直接搜索mx6ull_14x14_evk_defconfig<br><img src="../../../../../img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/mx6ull/uboot%E7%A7%BB%E6%A4%8D/1%E3%80%81%E6%90%9C%E7%B4%A2.png"></p><p>找到配置文件，复制一份。<br>在配置文件中修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">板子名字</span></span><br><span class="line">CONFIG_TARGET_MX6ULL_NARO=y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_LDO_BYPASS_CHECK is not <span class="built_in">set</span></span></span><br><span class="line">CONFIG_SYS_I2C_MXC_I2C1=y</span><br><span class="line">CONFIG_SYS_I2C_MXC_I2C2=y</span><br><span class="line">CONFIG_DM_GPIO=y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改设备树</span></span><br><span class="line">CONFIG_DEFAULT_DEVICE_TREE=&quot;imx6ull-naro&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个文件中最终要的就是指定设备树和boot的dtb文件，以及修改设备树名字。<br>剩下的就是根据编译过的文件创建一份，准备自己的修改</p><p>下面为编译的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> -rf uboot/</span></span><br><span class="line"></span><br><span class="line">test() &#123;</span><br><span class="line">        echo $&#123;1&#125;</span><br><span class="line">        cd uboot</span><br><span class="line">        echo  &quot;Building test...&quot;</span><br><span class="line">        make distclean</span><br><span class="line">        make mx6ull_14x14_evk_defconfig</span><br><span class="line">        # make mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">        make -j$(nproc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">        export CROSS_COMPILE=/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-</span><br><span class="line">        export ARCH=arm</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        if [ &quot;$&#123;1&#125;&quot; == &quot;test&quot; ]; then</span><br><span class="line">                test</span><br><span class="line">        elif [ &quot;$&#123;1&#125;&quot; == &quot;build&quot; ] ; then</span><br><span class="line">                echo   &quot;Building uboot...&quot;</span><br><span class="line">                cp -rf ./uboot-revise/* ./uboot</span><br><span class="line">                cd uboot</span><br><span class="line">                make distclean</span><br><span class="line">                make mx6ull_naro_defconfig</span><br><span class="line">                # make mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">                make -j$(nproc)</span><br><span class="line">        </span><br><span class="line">        elif [ &quot;$&#123;1&#125;&quot; == &quot;clean&quot; ]; then</span><br><span class="line">                echo $&#123;1&#125;</span><br><span class="line">                cd uboot</span><br><span class="line">                make distclean</span><br><span class="line">        else </span><br><span class="line">                echo &quot;Usage: build.sh [test][build|clean]&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if [ -f  &quot;u-boot.bin&quot; ]; then</span><br><span class="line"></span><br><span class="line">                echo &quot;u-boot.bin exist&quot;</span><br><span class="line">                sudo mkfs.fat -F 32 /dev/sdb1</span><br><span class="line">                ../imxdownload ./u-boot.bin /dev/sdb</span><br><span class="line">        else</span><br><span class="line">                echo &quot;u-boot.bin not exist&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -e &quot;uboot&quot; ]; then</span><br><span class="line">        build $&#123;1&#125;</span><br><span class="line">else </span><br><span class="line">        echo git clone ......</span><br><span class="line">        git clone https://github.com/nxp-imx/uboot-imx.git uboot</span><br><span class="line">        cd uboot</span><br><span class="line">        git checkout lf_v2024.04</span><br><span class="line">        cd  ../</span><br><span class="line">        build $&#123;1&#125;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="首先改网络"><a href="#首先改网络" class="headerlink" title="首先改网络"></a>首先改网络</h2><p>phy芯片用的LAN8720A 以太网 PHY 芯片<br>首先要在配置里支持上CONFIG_PHY_SMSC&#x3D;y<br>注释# CONFIG_PHY_MICREL&#x3D;y  # CONFIG_PHY_MICREL_KSZ8XXX&#x3D;y<br>不然白扯。</p><p>然后改设备树，将fec1相关的全部拷到自己的设备树里。dtsi里的要注释掉，不然编译出错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;fec1 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_enet1&gt;;</span><br><span class="line">phy-mode = &quot;rmii&quot;;</span><br><span class="line">phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">phy-supply = &lt;&amp;reg_peri_3v3&gt;;</span><br><span class="line">status = &quot;disable&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_enet2&gt;;</span><br><span class="line">phy-mode = &quot;rmii&quot;;</span><br><span class="line">phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">phy-supply = &lt;&amp;reg_peri_3v3&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">mdio &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">ethphy0: ethernet-phy@0 &#123;</span><br><span class="line">compatible = &quot;ethernet-phy-id0022.1560&quot;;</span><br><span class="line">reg = &lt;0&gt;;</span><br><span class="line">micrel,led-mode = &lt;1&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ENET_REF&gt;;</span><br><span class="line">clock-names = &quot;rmii-ref&quot;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ethphy1: ethernet-phy@1 &#123;</span><br><span class="line">compatible = &quot;ethernet-phy-id0022.1560&quot;;</span><br><span class="line">reg = &lt;1&gt;;</span><br><span class="line">micrel,led-mode = &lt;1&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ENET2_REF&gt;;</span><br><span class="line">clock-names = &quot;rmii-ref&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;iomuxc &#123;</span><br><span class="line">pinctrl_enet1: enet1grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK10x10b0</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pinctrl_enet2: enet2grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO07__ENET2_MDC0x1b0b0</span><br><span class="line">MX6UL_PAD_GPIO1_IO06__ENET2_MDIO0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK20x4001b031</span><br><span class="line">MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO080x10b0</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在改一个驱动的文件，在uboot&#x2F;drivers&#x2F;net&#x2F;phy&#x2F;phy.c中，设置一个复位genphy_config_aneg ，进入函数就phy_reset(phydev)</p><p>烧写代码，设置mac,注意要设置的是控制器2的mac,</p><h2 id="修改屏幕参数"><a href="#修改屏幕参数" class="headerlink" title="修改屏幕参数"></a>修改屏幕参数</h2><p>也还是设备树中，搜索lcd或者display，找到对应的节点，修改参数，比如分辨率，颜色位数，刷新率等等。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&amp;lcdif</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">pinctrl-names</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span><span class="punctuation">;</span></span><br><span class="line">pinctrl<span class="number">-0</span> = <span class="params">&lt;<span class="variable">&amp;pinctrl_lcdif_dat</span></span></span><br><span class="line"><span class="params">     <span class="variable">&amp;pinctrl_lcdif_ctrl</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">display</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;display0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">status</span> <span class="operator">=</span> <span class="string">&quot;okay&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">display0:</span> <span class="title class_">display@0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">bits-per-pixel</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">24</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">bus-width</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">24</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">display-timings</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">native-mode</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;timing0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">timing0:</span> <span class="title class_">timing0</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">clock-frequency</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">33000000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">hactive</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">800</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">vactive</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">480</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">hfront-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">40</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">hback-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">88</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">hsync-len</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">48</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">vback-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">32</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">vfront-porch</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">13</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">vsync-len</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">hsync-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">vsync-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">de-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">1</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">pixelclk-active</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="修改mmc"><a href="#修改mmc" class="headerlink" title="修改mmc"></a>修改mmc</h2><p>使用命令看mmc发现不正常<br>核对原理图，核对设备树mmc ,mmc1是sdcard,mmc2是emmc,发现emmc好像没用设置重置引脚，所以需要修改,并且emmc的控制</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">reg_sd1_vmmc:</span> <span class="title class_">regulator-sd1-vmmc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;VSD_3V3&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">gpio</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio1</span> <span class="number">9</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">off-on-delay-us</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">20000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">enable-active-high</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"><span class="comment">//复制一份sd卡的配置</span></span><br><span class="line"><span class="comment">//改为emmc的配置</span></span><br><span class="line"><span class="comment">//sd卡实际也是emmc的一种</span></span><br><span class="line"><span class="symbol">reg_sd2_vmmc:</span> <span class="title class_">regulator-sd2-vmmc</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;regulator-fixed&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">regulator-name</span> <span class="operator">=</span> <span class="string">&quot;+V3.3&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">regulator-min-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">regulator-max-microvolt</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">3300000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">gpio</span> <span class="operator">=</span> <span class="params">&lt;<span class="variable">&amp;gpio4</span> <span class="number">10</span> GPIO_ACTIVE_HIGH&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">off-on-delay-us</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">20000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">enable-active-high</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面修改注意regulator-name &#x3D; “+V3.3”;</p><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">aliases</span> <span class="punctuation">&#123;</span></span><br><span class="line">ethernet0 = <span class="variable">&amp;fec1</span><span class="punctuation">;</span></span><br><span class="line">ethernet1 = <span class="variable">&amp;fec2</span><span class="punctuation">;</span></span><br><span class="line">gpio0 = <span class="variable">&amp;gpio1</span><span class="punctuation">;</span></span><br><span class="line">gpio1 = <span class="variable">&amp;gpio2</span><span class="punctuation">;</span></span><br><span class="line">gpio2 = <span class="variable">&amp;gpio3</span><span class="punctuation">;</span></span><br><span class="line">gpio3 = <span class="variable">&amp;gpio4</span><span class="punctuation">;</span></span><br><span class="line">gpio4 = <span class="variable">&amp;gpio5</span><span class="punctuation">;</span></span><br><span class="line">i2c0 = <span class="variable">&amp;i2c1</span><span class="punctuation">;</span></span><br><span class="line">i2c1 = <span class="variable">&amp;i2c2</span><span class="punctuation">;</span></span><br><span class="line">i2c2 = <span class="variable">&amp;i2c3</span><span class="punctuation">;</span></span><br><span class="line">i2c3 = <span class="variable">&amp;i2c4</span><span class="punctuation">;</span></span><br><span class="line">mmc0 = <span class="variable">&amp;usdhc1</span><span class="punctuation">;</span></span><br><span class="line">mmc1 = <span class="variable">&amp;usdhc2</span><span class="punctuation">;</span></span><br><span class="line">serial0 = <span class="variable">&amp;uart1</span><span class="punctuation">;</span></span><br><span class="line">serial1 = <span class="variable">&amp;uart2</span><span class="punctuation">;</span></span><br><span class="line">serial2 = <span class="variable">&amp;uart3</span><span class="punctuation">;</span></span><br><span class="line">serial3 = <span class="variable">&amp;uart4</span><span class="punctuation">;</span></span><br><span class="line">serial4 = <span class="variable">&amp;uart5</span><span class="punctuation">;</span></span><br><span class="line">serial5 = <span class="variable">&amp;uart6</span><span class="punctuation">;</span></span><br><span class="line">serial6 = <span class="variable">&amp;uart7</span><span class="punctuation">;</span></span><br><span class="line">serial7 = <span class="variable">&amp;uart8</span><span class="punctuation">;</span></span><br><span class="line">sai1 = <span class="variable">&amp;sai1</span><span class="punctuation">;</span></span><br><span class="line">sai2 = <span class="variable">&amp;sai2</span><span class="punctuation">;</span></span><br><span class="line">sai3 = <span class="variable">&amp;sai3</span><span class="punctuation">;</span></span><br><span class="line">spi0 = <span class="variable">&amp;ecspi1</span><span class="punctuation">;</span></span><br><span class="line">spi1 = <span class="variable">&amp;ecspi2</span><span class="punctuation">;</span></span><br><span class="line">spi2 = <span class="variable">&amp;ecspi3</span><span class="punctuation">;</span></span><br><span class="line">spi3 = <span class="variable">&amp;ecspi4</span><span class="punctuation">;</span></span><br><span class="line">usb0 = <span class="variable">&amp;usbotg1</span><span class="punctuation">;</span></span><br><span class="line">usb1 = <span class="variable">&amp;usbotg2</span><span class="punctuation">;</span></span><br><span class="line">usbphy0 = <span class="variable">&amp;usbphy1</span><span class="punctuation">;</span></span><br><span class="line">usbphy1 = <span class="variable">&amp;usbphy2</span><span class="punctuation">;</span></span><br><span class="line">usbgadget0 = <span class="variable">&amp;usbg1</span><span class="punctuation">;</span></span><br><span class="line">usbgadget1 = <span class="variable">&amp;usbg2</span><span class="punctuation">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在设备树中有一个alias 节点，用于定义设备名称,可以根据这个找要修改的设备</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>编译脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> -rf uboot/</span></span><br><span class="line"></span><br><span class="line">test() &#123;</span><br><span class="line">        echo $&#123;1&#125;</span><br><span class="line">        cd uboot</span><br><span class="line">        echo  &quot;Building test...&quot;</span><br><span class="line">        make distclean</span><br><span class="line">        make mx6ull_14x14_evk_defconfig</span><br><span class="line">        # make mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">        make -j$(nproc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">build() &#123;</span><br><span class="line">        export CROSS_COMPILE=/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-</span><br><span class="line">        export ARCH=arm</span><br><span class="line"></span><br><span class="line">        if [ &quot;$&#123;1&#125;&quot; == &quot;test&quot; ]; then</span><br><span class="line">                test</span><br><span class="line">        elif [ &quot;$&#123;1&#125;&quot; == &quot;build&quot; ] ; then</span><br><span class="line">                echo   &quot;Building uboot...&quot;</span><br><span class="line">                cp -rf ./uboot-revise/* ./uboot</span><br><span class="line">                cd uboot</span><br><span class="line">                make clean</span><br><span class="line">                make distclean</span><br><span class="line">                make mx6ull_naro_defconfig</span><br><span class="line">                # make mx6ull_14x14_evk_emmc_defconfig</span><br><span class="line">                make -j$(nproc)</span><br><span class="line">        </span><br><span class="line">        elif [ &quot;$&#123;1&#125;&quot; == &quot;clean&quot; ]; then</span><br><span class="line">                echo $&#123;1&#125;</span><br><span class="line">                cd uboot</span><br><span class="line">                make distclean</span><br><span class="line">        else </span><br><span class="line">                echo &quot;Usage: build.sh [test][build|clean]&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ -f  &quot;u-boot.bin&quot; ]; then</span><br><span class="line">                if [ -b &quot;/dev/sdb&quot; ] ; then</span><br><span class="line">                        echo &quot;u-boot.bin exist&quot;</span><br><span class="line">                        sudo mkfs.fat -F 32 /dev/sdb1</span><br><span class="line">                        ../imxdownload ./u-boot.bin /dev/sdb</span><br><span class="line">                else    </span><br><span class="line">                        echo &quot;no /dev/sdb&quot;</span><br><span class="line">                fi</span><br><span class="line">        else</span><br><span class="line">                echo &quot;u-boot.bin not exist&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -e &quot;uboot&quot; ]; then</span><br><span class="line">        build $&#123;1&#125;</span><br><span class="line">else </span><br><span class="line">        echo git clone ......</span><br><span class="line">        git clone https://github.com/nxp-imx/uboot-imx.git uboot</span><br><span class="line">        cd uboot</span><br><span class="line">        git checkout lf_v2024.04</span><br><span class="line">        cd  ../</span><br><span class="line">        build $&#123;1&#125;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>最后就是如果要改环境变量，是在板子头文件中</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉编译器</title>
      <link href="/posts/df3b4268.html"/>
      <url>/posts/df3b4268.html</url>
      
        <content type="html"><![CDATA[<h1 id="交叉编译器"><a href="#交叉编译器" class="headerlink" title="交叉编译器"></a>交叉编译器</h1><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>交叉编译工具链的命名规则反映了目标架构、操作系统、ABI特性及工具链提供商等关键信息。理解命名规则有助于快速识别工具链的适用场景和特性。以下是常见规则及示例：</p><h3 id="一、标准GNU工具链命名格式"><a href="#一、标准GNU工具链命名格式" class="headerlink" title="一、标准GNU工具链命名格式"></a><strong>一、标准GNU工具链命名格式</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;架构&gt;-&lt;厂商&gt;-&lt;系统&gt;-&lt;ABI&gt;-&lt;工具&gt;</span><br></pre></td></tr></table></figure><h4 id="核心字段含义："><a href="#核心字段含义：" class="headerlink" title="核心字段含义："></a><strong>核心字段含义</strong>：</h4><ol><li><p><strong>架构（Architecture）</strong><br>目标芯片的架构类型，常见值：</p><ul><li><code>arm</code>&#x2F;<code>aarch64</code>：ARM 32&#x2F;64位架构</li><li><code>x86_64</code>&#x2F;<code>i686</code>：x86 64&#x2F;32位架构</li><li><code>riscv64</code>&#x2F;<code>riscv32</code>：RISC-V 64&#x2F;32位架构</li><li><code>mips</code>&#x2F;<code>powerpc</code>：MIPS&#x2F;PowerPC架构</li></ul></li><li><p><strong>厂商（Vendor）</strong><br>工具链提供商或定制者，常见值：</p><ul><li><code>none</code>：通用裸机（无操作系统）工具链</li><li><code>linux</code>：针对Linux系统的工具链</li><li><code>unknown</code>：未知&#x2F;通用厂商</li><li>特定厂商名（如 <code>uclibc</code>、<code>musl</code>）</li></ul></li><li><p><strong>系统（System）</strong><br>目标操作系统或环境：</p><ul><li><code>linux</code>：适用于Linux系统</li><li><code>elf</code>：适用于裸机或嵌入式系统（生成ELF格式二进制文件）</li><li><code>windows</code>：适用于Windows系统</li></ul></li><li><p><strong>ABI（Application Binary Interface）</strong><br>定义二进制兼容性的特性，常见值：</p><ul><li><code>gnu</code>：使用GNU C库（glibc）</li><li><code>gnueabi</code>：适用于ARM EABI（Embedded ABI）</li><li><code>gnueabihf</code>：适用于ARM EABI + 硬浮点（Hard Float）</li><li><code>musl</code>&#x2F;<code>uclibc</code>：使用轻量级C库（替代glibc）</li></ul></li><li><p><strong>工具（Tool）</strong><br>具体工具类型：</p><ul><li><code>gcc</code>&#x2F;<code>g++</code>：编译器</li><li><code>ld</code>：链接器</li><li><code>objdump</code>：目标文件分析工具</li><li><code>as</code>：汇编器</li></ul></li></ol><h3 id="二、常见命名示例"><a href="#二、常见命名示例" class="headerlink" title="二、常见命名示例"></a><strong>二、常见命名示例</strong></h3><h4 id="1-ARM架构工具链"><a href="#1-ARM架构工具链" class="headerlink" title="1. ARM架构工具链"></a><strong>1. ARM架构工具链</strong></h4><ul><li><strong>裸机开发（无OS）</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-none-eabi-gcc       # ARM 32位，适用于裸机（如STM32）</span><br><span class="line">aarch64-none-elf-gcc    # ARM 64位，适用于裸机</span><br></pre></td></tr></table></figure></li><li><strong>Linux系统开发</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc   # ARM 32位，软浮点，glibc库</span><br><span class="line">arm-linux-gnueabihf-gcc # ARM 32位，硬浮点，glibc库</span><br><span class="line">aarch64-linux-gnu-gcc   # ARM 64位，glibc库</span><br></pre></td></tr></table></figure></li><li><strong>特定厂商工具链</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabihf-gcc  # Buildroot定制的ARM工具链</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-RISC-V架构工具链"><a href="#2-RISC-V架构工具链" class="headerlink" title="2. RISC-V架构工具链"></a><strong>2. RISC-V架构工具链</strong></h4><ul><li><strong>裸机开发</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc    # RISC-V 64位，裸机</span><br></pre></td></tr></table></figure></li><li><strong>Linux系统开发</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc      # RISC-V 64位，Linux + glibc</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-x86架构工具链"><a href="#3-x86架构工具链" class="headerlink" title="3. x86架构工具链"></a><strong>3. x86架构工具链</strong></h4><ul><li><strong>Windows交叉编译</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_64-w64-mingw32-gcc     # x86_64架构，Windows系统，MinGW工具链</span><br></pre></td></tr></table></figure></li><li><strong>嵌入式Linux开发</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i686-poky-linux-gcc        # x86 32位，Yocto Project定制的Linux工具链</span><br></pre></td></tr></table></figure></li></ul><h3 id="三、命名规则中的关键缩写"><a href="#三、命名规则中的关键缩写" class="headerlink" title="三、命名规则中的关键缩写"></a><strong>三、命名规则中的关键缩写</strong></h3><table><thead><tr><th>缩写</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>eabi</code></td><td>Embedded Application Binary Interface</td><td><code>arm-none-eabi-gcc</code></td></tr><tr><td><code>hf</code></td><td>Hard Float（硬浮点支持）</td><td><code>arm-linux-gnueabihf-gcc</code></td></tr><tr><td><code>softfp</code></td><td>软浮点ABI（但允许硬件加速）</td><td><code>arm-none-eabi-gcc -mfloat-abi=softfp</code></td></tr><tr><td><code>gnu</code></td><td>使用GNU C库（glibc）</td><td><code>aarch64-linux-gnu-gcc</code></td></tr><tr><td><code>uclibc</code>&#x2F;<code>musl</code></td><td>使用轻量级C库</td><td><code>arm-linux-musleabihf-gcc</code></td></tr></tbody></table><h3 id="四、如何根据命名选择工具链"><a href="#四、如何根据命名选择工具链" class="headerlink" title="四、如何根据命名选择工具链"></a><strong>四、如何根据命名选择工具链</strong></h3><ol><li><p><strong>确定目标架构</strong>  </p><ul><li>如芯片为ARM Cortex-A53（64位），选 <code>aarch64-*</code> 工具链。</li><li>如为ARM Cortex-M4（32位），选 <code>arm-*</code> 工具链。</li></ul></li><li><p><strong>判断是否需要操作系统支持</strong>  </p><ul><li>裸机开发：选 <code>none-eabi</code> 或 <code>none-elf</code>。</li><li>Linux系统：选 <code>linux-gnu</code> 或 <code>linux-musl</code>。</li></ul></li><li><p><strong>确认浮点支持</strong>  </p><ul><li>芯片有FPU且需硬浮点：选带 <code>hf</code> 的工具链（如 <code>gnueabihf</code>）。</li><li>无FPU或仅软浮点：选不带 <code>hf</code> 的工具链（如 <code>gnueabi</code>）。</li></ul></li><li><p><strong>检查C库兼容性</strong>  </p><ul><li>标准Linux系统：用 <code>gnu</code>（glibc）。</li><li>资源受限设备：用 <code>uclibc</code> 或 <code>musl</code> 减小二进制体积。</li></ul></li></ol><h3 id="五、命名与编译选项的关系"><a href="#五、命名与编译选项的关系" class="headerlink" title="五、命名与编译选项的关系"></a><strong>五、命名与编译选项的关系</strong></h3><p>工具链名称中的特性（如硬浮点）通常需配合编译选项使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工具链名称含 &quot;hf&quot;，编译时需指定硬浮点选项</span></span><br><span class="line">arm-linux-gnueabihf-gcc -mfloat-abi=hard -mfpu=vfpv4 test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="六、常见命名误区"><a href="#六、常见命名误区" class="headerlink" title="六、常见命名误区"></a><strong>六、常见命名误区</strong></h3><ol><li><p><strong>混淆 <code>eabi</code> 和 <code>hf</code></strong>  </p><ul><li><code>eabi</code> 是ARM的二进制接口规范，与浮点无关。</li><li><code>hf</code> 专门表示硬浮点支持。</li></ul></li><li><p><strong>误判架构位数</strong>  </p><ul><li><code>arm-*</code> 通常指32位ARM，<code>aarch64-*</code> 才是64位ARM。</li></ul></li><li><p><strong>忽略C库差异</strong>  </p><ul><li><code>gnu</code>（glibc）体积大但功能全，<code>musl</code> 体积小但可能缺少部分特性。</li></ul></li></ol><p>通过分析工具链名称的各部分，可以快速定位其适用场景，避免因工具链选择错误导致编译失败或运行时问题。</p><h2 id="编译步骤"><a href="#编译步骤" class="headerlink" title="编译步骤"></a>编译步骤</h2><p>编译器将高级语言代码转换为机器代码的过程通常分为四个核心阶段，每个阶段完成特定的任务。以下是四个阶段的详细说明及示例：</p><h3 id="一、预处理阶段（Preprocessing）"><a href="#一、预处理阶段（Preprocessing）" class="headerlink" title="一、预处理阶段（Preprocessing）"></a><strong>一、预处理阶段（Preprocessing）</strong></h3><ul><li><strong>任务</strong>：处理源代码中的预处理指令（如 <code>#include</code>、<code>#define</code>、<code>#if</code> 等），生成纯净的源代码。</li><li><strong>关键操作</strong>：<ol><li><strong>文件包含</strong>：展开 <code>#include</code> 指令，将头文件内容插入到源文件中。</li><li><strong>宏替换</strong>：替换 <code>#define</code> 定义的宏（如 <code>#define PI 3.14</code> → <code>3.14</code>）。</li><li><strong>条件编译</strong>：根据 <code>#if</code>、<code>#ifdef</code> 等指令选择性保留代码。</li><li><strong>删除注释</strong>：移除代码中的注释（如 <code>// 这是注释</code>）。</li></ol></li><li><strong>示例</strong>：<br><strong>输入（test.c）</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = MAX(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 宏替换</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max: %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>预处理后</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;stdio.h&gt; 的内容被插入此处</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = ((<span class="number">3</span>) &gt; (<span class="number">5</span>) ? (<span class="number">3</span>) : (<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max: %d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i  <span class="comment"># 生成预处理后的文件（.i）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="二、编译阶段（Compilation）"><a href="#二、编译阶段（Compilation）" class="headerlink" title="二、编译阶段（Compilation）"></a><strong>二、编译阶段（Compilation）</strong></h3><ul><li><strong>任务</strong>：将预处理后的代码转换为汇编代码（assembly code）。</li><li><strong>关键操作</strong>：<ol><li><strong>词法分析</strong>：将源代码分割为标记（tokens），如 <code>int x = 1;</code> → <code>int</code>, <code>x</code>, <code>=</code>, <code>1</code>, <code>;</code>。</li><li><strong>语法分析</strong>：构建抽象语法树（AST），验证代码语法正确性。</li><li><strong>语义分析</strong>：检查类型匹配、变量声明等语义规则。</li><li><strong>代码优化</strong>：进行常量折叠（如 <code>2+3</code> → <code>5</code>）、循环展开等优化。</li><li><strong>生成汇编</strong>：将AST转换为目标机器的汇编指令。</li></ol></li><li><strong>示例</strong>：<br><strong>输入（预处理后的C代码）</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>输出（汇编代码，x86_64）</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    pushq   %rbp</span><br><span class="line">    movq    %rsp, %rbp</span><br><span class="line">    movl    $7, %eax  # 3+4 被优化为 7</span><br><span class="line">    popq    %rbp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></li><li><strong>命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s  <span class="comment"># 生成汇编文件（.s）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三、汇编阶段（Assembly）"><a href="#三、汇编阶段（Assembly）" class="headerlink" title="三、汇编阶段（Assembly）"></a><strong>三、汇编阶段（Assembly）</strong></h3><ul><li><strong>任务</strong>：将汇编代码转换为机器码（二进制目标文件）。</li><li><strong>关键操作</strong>：<ol><li><strong>翻译指令</strong>：将汇编指令（如 <code>mov</code>, <code>add</code>）转换为对应的机器码。</li><li><strong>地址分配</strong>：为变量和函数分配内存地址。</li><li><strong>生成目标文件</strong>：生成包含机器码、符号表的目标文件（.o 或 .obj）。</li></ol></li><li><strong>示例</strong>：<br><strong>输入（汇编代码）</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">    movl    $7, %eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><strong>输出（目标文件，二进制格式）</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 89 e5 b8 07 00 00 00 c9 c3  # 对应的机器码（十六进制）</span><br></pre></td></tr></table></figure></li><li><strong>命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as test.s -o test.o  <span class="comment"># 生成目标文件（.o）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="四、链接阶段（Linking）"><a href="#四、链接阶段（Linking）" class="headerlink" title="四、链接阶段（Linking）"></a><strong>四、链接阶段（Linking）</strong></h3><ul><li><strong>任务</strong>：将多个目标文件和库文件合并，生成可执行文件。</li><li><strong>关键操作</strong>：<ol><li><strong>符号解析</strong>：解析不同文件间的符号引用（如函数调用、全局变量）。</li><li><strong>地址重定位</strong>：调整代码和数据的内存地址，确保正确引用。</li><li><strong>合并文件</strong>：将目标文件、库文件合并为单一可执行文件。</li></ol></li><li><strong>示例</strong>：<br><strong>场景</strong>：  <ul><li><code>main.o</code>（调用 <code>printf</code>）  </li><li><code>libc.a</code>（C标准库，包含 <code>printf</code> 的实现）<br><strong>链接后</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o + libc.a → a.out  # 生成可执行文件</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o <span class="built_in">test</span>  <span class="comment"># 链接目标文件，生成可执行文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a><strong>总结对比表</strong></h3><table><thead><tr><th>阶段</th><th>输入</th><th>输出</th><th>核心工具</th><th>关键作用</th></tr></thead><tbody><tr><td>预处理</td><td>源代码（.c, .cpp）</td><td>预处理后的代码（.i）</td><td><code>cpp</code>（预处理器）</td><td>处理宏、头文件，生成纯净代码</td></tr><tr><td>编译</td><td>预处理后的代码</td><td>汇编代码（.s）</td><td><code>cc1</code>（编译器前端）</td><td>将高级语言转换为汇编</td></tr><tr><td>汇编</td><td>汇编代码</td><td>目标文件（.o）</td><td><code>as</code>（汇编器）</td><td>将汇编转换为机器码</td></tr><tr><td>链接</td><td>目标文件、库文件</td><td>可执行文件</td><td><code>ld</code>（链接器）</td><td>合并文件，解析符号引用</td></tr></tbody></table><h3 id="常见问题与调试技巧"><a href="#常见问题与调试技巧" class="headerlink" title="常见问题与调试技巧"></a><strong>常见问题与调试技巧</strong></h3><ol><li><p><strong>预处理错误</strong>：  </p><ul><li>错误信息：<code>stdio.h: No such file or directory</code>  </li><li>原因：头文件路径错误或缺失，检查 <code>#include</code> 路径。</li></ul></li><li><p><strong>编译错误</strong>：  </p><ul><li>错误信息：<code>expected &#39;;&#39; before &#39;&#125;&#39; token</code>  </li><li>原因：语法错误（如缺失分号），检查AST构建是否正确。</li></ul></li><li><p><strong>汇编错误</strong>：  </p><ul><li>错误信息：<code>undefined symbol &#39;_printf&#39;</code>  </li><li>原因：符号未定义，可能缺少库文件或函数声明。</li></ul></li><li><p><strong>链接错误</strong>：  </p><ul><li>错误信息：<code>cannot find -lm</code>  </li><li>原因：缺少数学库，添加 <code>-lm</code> 选项链接 <code>libm.a</code>。</li></ul></li></ol><p>通过理解这四个阶段，你可以更精准地定位编译问题，例如使用 <code>-E</code>、<code>-S</code>、<code>-c</code> 选项分步编译，或通过 <code>objdump</code> 分析目标文件的符号表和机器码。</p><p>一般情况下，运行在系统之上的程序不用指定ld的地址，只有底层软件，要链接程序的地址，如uboot，kernel,需要链接脚本来指定。</p><h2 id="交叉编译器的选择"><a href="#交叉编译器的选择" class="headerlink" title="交叉编译器的选择"></a>交叉编译器的选择</h2><p>选择芯片的交叉编译器时，需要综合考虑芯片架构、开发需求、工具链成熟度等多方面因素。以下是详细的选择指南：</p><h3 id="一、明确芯片架构与目标平台"><a href="#一、明确芯片架构与目标平台" class="headerlink" title="一、明确芯片架构与目标平台"></a><strong>一、明确芯片架构与目标平台</strong></h3><p>交叉编译器的核心功能是为<strong>不同架构的目标平台</strong>生成可执行代码，因此首先需确定芯片的架构类型：</p><ul><li><strong>常见芯片架构</strong>：<ul><li><strong>ARM</strong>：广泛用于嵌入式系统、移动设备（如树莓派、手机SoC）。</li><li><strong>x86&#x2F;x86-64</strong>：PC和服务器主流架构（如Intel&#x2F;AMD处理器）。</li><li><strong>RISC-V</strong>：开源架构，适用于定制化嵌入式场景（如平头哥玄铁处理器）。</li><li><strong>MIPS</strong>：传统嵌入式架构（如部分路由器、工业设备）。</li><li><strong>PowerPC</strong>：曾用于游戏主机、高端嵌入式系统（如IBM Power系列）。</li></ul></li><li><strong>操作平台</strong>：目标芯片运行的是裸机（无操作系统）、RTOS（如FreeRTOS）还是Linux&#x2F;Android等系统？不同系统对编译器的库支持和链接脚本要求不同。</li></ul><h3 id="二、选择编译器类型"><a href="#二、选择编译器类型" class="headerlink" title="二、选择编译器类型"></a><strong>二、选择编译器类型</strong></h3><p>根据开发场景和生态支持，交叉编译器主要分为以下几类：</p><h4 id="1-开源编译器（如GCC）"><a href="#1-开源编译器（如GCC）" class="headerlink" title="1. 开源编译器（如GCC）"></a>1. <strong>开源编译器（如GCC）</strong></h4><ul><li><strong>特点</strong>：免费、跨平台、支持多架构，但需要手动配置工具链，对新手不太友好。</li><li><strong>适用场景</strong>：嵌入式开发、Linux系统移植、开源项目适配。</li><li><strong>主流分支</strong>：<ul><li><strong>GCC官方版</strong>：支持标准架构（如ARM、x86），需配合交叉工具链（如<code>arm-linux-gnueabihf-gcc</code>）。</li><li><strong>Linaro工具链</strong>：专为ARM架构优化，适用于Linux系统开发（如树莓派官方推荐）。</li><li><strong>RISC-V GNU工具链</strong>：由开源社区维护，支持RISC-V架构的裸机和Linux开发。</li></ul></li></ul><h4 id="2-商业编译器（如IAR、Keil、SEGGER）"><a href="#2-商业编译器（如IAR、Keil、SEGGER）" class="headerlink" title="2. 商业编译器（如IAR、Keil、SEGGER）"></a>2. <strong>商业编译器（如IAR、Keil、SEGGER）</strong></h4><ul><li><strong>特点</strong>：图形化界面友好、集成调试工具，但需付费，部分仅支持特定架构。</li><li><strong>适用场景</strong>：商业嵌入式项目（如STM32、NXP芯片开发）、实时操作系统（RTOS）开发。</li><li><strong>主流工具</strong>：<ul><li><strong>Keil MDK</strong>：针对ARM Cortex-M系列芯片，支持裸机和RTX RTOS，界面直观。</li><li><strong>IAR Embedded Workbench</strong>：支持ARM、RISC-V、MSP430等架构，优化能力强。</li><li><strong>SEGGER Embedded Studio</strong>：轻量级商业工具，支持多种架构，集成J-Link调试。</li></ul></li></ul><h4 id="3-厂商定制工具链"><a href="#3-厂商定制工具链" class="headerlink" title="3. 厂商定制工具链"></a>3. <strong>厂商定制工具链</strong></h4><ul><li><strong>特点</strong>：芯片厂商官方提供，深度适配自家硬件（如寄存器定义、启动代码）。</li><li><strong>适用场景</strong>：新手入门、特定厂商芯片（如TI、Microchip）的快速开发。</li><li><strong>案例</strong>：<ul><li><strong>Arduino IDE</strong>：基于GCC定制，简化了AVR&#x2F;ESP32等芯片的编译流程。</li><li><strong>NXP MCUXpresso</strong>：集成GCC工具链，支持NXP的ARM芯片，提供图形化配置工具。</li></ul></li></ul><h3 id="三、关键功能与性能考量"><a href="#三、关键功能与性能考量" class="headerlink" title="三、关键功能与性能考量"></a><strong>三、关键功能与性能考量</strong></h3><h4 id="1-编译优化能力"><a href="#1-编译优化能力" class="headerlink" title="1. 编译优化能力"></a>1. <strong>编译优化能力</strong></h4><ul><li>选择支持<strong>代码大小优化（-Os）</strong>和<strong>运行速度优化（-O3）</strong>的编译器，例如GCC通过<code>-march</code>和<code>-mtune</code>参数针对特定芯片架构优化指令集。</li><li>商业编译器（如IAR）通常内置针对厂商芯片的优化选项（如“ARM Cortex-M专用优化”）。</li></ul><h4 id="2-调试与仿真支持"><a href="#2-调试与仿真支持" class="headerlink" title="2. 调试与仿真支持"></a>2. <strong>调试与仿真支持</strong></h4><ul><li>确保编译器与调试工具（如J-Link、ST-Link）兼容，支持断点调试、变量监控等功能。</li><li>商业工具链（如Keil）通常集成调试器，而开源工具需手动配置GDB Server。</li></ul><h4 id="3-库与生态支持"><a href="#3-库与生态支持" class="headerlink" title="3. 库与生态支持"></a>3. <strong>库与生态支持</strong></h4><ul><li><strong>标准库支持</strong>：若开发Linux应用，需选择支持glibc或uClibc的编译器（如<code>arm-linux-gnueabihf-gcc</code>）。</li><li><strong>RTOS集成</strong>：部分编译器（如Keil）内置RTX库，可直接调用RTOS接口。</li><li><strong>第三方组件</strong>：是否支持TensorFlow Lite、Zephyr等框架的交叉编译？</li></ul><h4 id="4-多架构与多系统兼容性"><a href="#4-多架构与多系统兼容性" class="headerlink" title="4. 多架构与多系统兼容性"></a>4. <strong>多架构与多系统兼容性</strong></h4><ul><li>若需跨平台开发（如同时支持ARM和RISC-V），开源工具链（如GCC）更灵活；商业工具可能需购买多架构授权。</li></ul><h3 id="四、开发流程与工具链集成"><a href="#四、开发流程与工具链集成" class="headerlink" title="四、开发流程与工具链集成"></a><strong>四、开发流程与工具链集成</strong></h3><h4 id="1-构建工具与IDE选择"><a href="#1-构建工具与IDE选择" class="headerlink" title="1. 构建工具与IDE选择"></a>1. <strong>构建工具与IDE选择</strong></h4><ul><li><strong>Makefile&#x2F;CMake</strong>：适合开源项目，需手动编写编译规则，搭配GCC工具链。</li><li><strong>图形化IDE</strong>：<ul><li><strong>开源</strong>：Eclipse + CDT插件，支持GCC交叉编译。</li><li><strong>商业</strong>：Keil、IAR直接集成编译器和调试器，一键编译下载。</li></ul></li></ul><h4 id="2-交叉编译步骤验证"><a href="#2-交叉编译步骤验证" class="headerlink" title="2. 交叉编译步骤验证"></a>2. <strong>交叉编译步骤验证</strong></h4><ul><li>测试流程：编写简单的“Hello World”程序，验证编译、链接、烧录是否成功。</li><li>常见问题：<ul><li>头文件路径错误：需指定目标平台的SDK路径（如<code>-I/path/to/arm-linux/include</code>）。</li><li>链接错误：检查链接脚本（.ld文件）是否匹配芯片内存布局。</li></ul></li></ul><h3 id="五、成本与学习曲线权衡"><a href="#五、成本与学习曲线权衡" class="headerlink" title="五、成本与学习曲线权衡"></a><strong>五、成本与学习曲线权衡</strong></h3><table><thead><tr><th><strong>类型</strong></th><th><strong>成本</strong></th><th><strong>学习难度</strong></th><th><strong>适合场景</strong></th></tr></thead><tbody><tr><td>开源工具链（GCC）</td><td>免费</td><td>高（需配置工具链）</td><td>复杂系统开发、定制化需求</td></tr><tr><td>商业工具（Keil&#x2F;IAR）</td><td>高（授权费）</td><td>低（图形化界面）</td><td>快速商业项目、新手入门</td></tr><tr><td>厂商定制工具</td><td>部分免费（如Arduino）</td><td>极低</td><td>特定厂商芯片的快速原型开发</td></tr></tbody></table><h3 id="六、实战选型案例"><a href="#六、实战选型案例" class="headerlink" title="六、实战选型案例"></a><strong>六、实战选型案例</strong></h3><h4 id="案例1：树莓派（ARM-Linux）"><a href="#案例1：树莓派（ARM-Linux）" class="headerlink" title="案例1：树莓派（ARM + Linux）"></a>案例1：树莓派（ARM + Linux）</h4><ul><li><strong>选择</strong>：Linaro GCC工具链（<code>arm-linux-gnueabihf-gcc</code>）。</li><li><strong>理由</strong>：官方推荐，支持ARMv7&#x2F;ARMv8架构，兼容Raspbian系统的glibc库。</li></ul><h4 id="案例2：STM32F4（ARM-Cortex-M4-裸机）"><a href="#案例2：STM32F4（ARM-Cortex-M4-裸机）" class="headerlink" title="案例2：STM32F4（ARM Cortex-M4 + 裸机）"></a>案例2：STM32F4（ARM Cortex-M4 + 裸机）</h4><ul><li><strong>选择</strong>：Keil MDK或STM32CubeIDE（基于GCC）。</li><li><strong>理由</strong>：Keil界面友好，集成STM32 HAL库；CubeIDE支持图形化配置，适合快速开发。</li></ul><h4 id="案例3：RISC-V开发板（如SiFive-Unmatched）"><a href="#案例3：RISC-V开发板（如SiFive-Unmatched）" class="headerlink" title="案例3：RISC-V开发板（如SiFive Unmatched）"></a>案例3：RISC-V开发板（如SiFive Unmatched）</h4><ul><li><strong>选择</strong>：RISC-V GNU工具链（如<code>riscv64-unknown-linux-gnu-gcc</code>）。</li><li><strong>理由</strong>：开源生态完善，支持Linux系统和自定义指令扩展。</li></ul><h3 id="七、总结：分步选择法"><a href="#七、总结：分步选择法" class="headerlink" title="七、总结：分步选择法"></a><strong>七、总结：分步选择法</strong></h3><ol><li><strong>确定芯片架构</strong>（如ARM Cortex-M）和目标系统（裸机&#x2F;RTOS&#x2F;Linux）。</li><li><strong>评估开发预算与团队能力</strong>：商业项目选商业工具，开源或定制化选GCC。</li><li><strong>验证工具链兼容性</strong>：下载官方例程测试编译和调试流程。</li><li><strong>参考社区与厂商文档</strong>：如STM32论坛、Raspberry Pi官网的工具推荐。</li></ol><p>通过以上步骤，可高效选择适合项目需求的交叉编译器，避免因工具链问题导致的开发延迟。</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设备与模块</title>
      <link href="/posts/9301ed49.html"/>
      <url>/posts/9301ed49.html</url>
      
        <content type="html"><![CDATA[<h1 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h1><h2 id="主要设备类型"><a href="#主要设备类型" class="headerlink" title="主要设备类型"></a>主要设备类型</h2><p>在Linux系统中，设备被抽象为文件，通过文件系统进行管理。根据设备的功能和特性，主要分为以下<strong>三种类型</strong>：</p><h3 id="1-字符设备（Character-Device）"><a href="#1-字符设备（Character-Device）" class="headerlink" title="1. 字符设备（Character Device）"></a><strong>1. 字符设备（Character Device）</strong></h3><ul><li><strong>定义</strong>：以<strong>字符流</strong>（字节流）的形式传输数据，数据的读取和写入是<strong>顺序的、无缓冲的</strong>，不支持随机访问。</li><li><strong>特点</strong>：<ul><li>数据传输实时性强，常用于<strong>单次少量数据交互</strong>的场景。</li><li>不支持通过文件系统的<code>lseek</code>命令随机定位读写位置。</li></ul></li><li><strong>常见设备</strong>：<ul><li>键盘、鼠标、串口（如<code>/dev/ttyS0</code>）、终端（如<code>/dev/tty1</code>）、打印机等。</li><li>部分传感器设备（如温度传感器、串口通信设备）。</li></ul></li><li><strong>设备文件标识</strong>：<ul><li>在<code>/dev</code>目录下，设备文件的类型标识为<code>c</code>（通过<code>ls -l</code>命令查看）。</li><li>示例：<code>crw-rw-r-- 1 root root 1, 3 May 23 08:00 /dev/null</code>（<code>c</code>表示字符设备）。</li></ul></li></ul><h3 id="2-块设备（Block-Device）"><a href="#2-块设备（Block-Device）" class="headerlink" title="2. 块设备（Block Device）"></a><strong>2. 块设备（Block Device）</strong></h3><ul><li><strong>定义</strong>：以<strong>数据块</strong>（Block，如4KB为一个块）为单位传输数据，支持<strong>随机访问</strong>（可通过块地址直接定位数据），通常有数据缓冲机制。</li><li><strong>特点</strong>：<ul><li>适合<strong>大批量数据的快速读写</strong>，如磁盘存储。</li><li>支持文件系统的创建（如EXT4、XFS等），数据可以按文件形式组织。</li></ul></li><li><strong>常见设备</strong>：<ul><li>硬盘（如<code>/dev/sda</code>、<code>/dev/nvme0n1</code>）、固态硬盘（SSD）、U盘、光驱、SD卡等。</li><li>分区设备（如<code>/dev/sda1</code>、<code>/dev/sdb2</code>）。</li></ul></li><li><strong>设备文件标识</strong>：<ul><li>在<code>/dev</code>目录下，设备文件的类型标识为<code>b</code>。</li><li>示例：<code>brw-rw---- 1 root disk 8, 0 May 23 08:00 /dev/sda</code>（<code>b</code>表示块设备）。</li></ul></li></ul><h3 id="3-网络设备（Network-Device）"><a href="#3-网络设备（Network-Device）" class="headerlink" title="3. 网络设备（Network Device）"></a><strong>3. 网络设备（Network Device）</strong></h3><ul><li><strong>定义</strong>：用于<strong>网络通信</strong>的设备，通过网络协议（如TCP&#x2F;IP）传输数据，不直接对应文件系统中的文件，而是通过网络接口进行管理。</li><li><strong>特点</strong>：<ul><li>数据传输基于网络协议，支持双向通信和数据包的收发。</li><li>通常不通过<code>/dev</code>目录下的文件访问，而是通过系统命令（如<code>ifconfig</code>、<code>ip</code>）或网络编程接口（如Socket）操作。</li></ul></li><li><strong>常见设备</strong>：<ul><li>以太网网卡（如<code>eth0</code>、<code>enp0s3</code>）、无线网卡（如<code>wlan0</code>）、虚拟网络设备（如<code>docker0</code>、<code>lo</code>回环接口）。</li></ul></li><li><strong>设备文件标识</strong>：<ul><li>没有对应的常规设备文件，可通过<code>/sys/class/net/</code>目录查看网络接口信息。</li><li>示例：通过<code>ls /sys/class/net/</code>命令查看当前系统的网络设备名称。</li></ul></li></ul><h3 id="补充说明：伪设备（虚拟设备）"><a href="#补充说明：伪设备（虚拟设备）" class="headerlink" title="补充说明：伪设备（虚拟设备）"></a><strong>补充说明：伪设备（虚拟设备）</strong></h3><p>除上述三类真实硬件设备外，Linux中还有一类<strong>伪设备（虚拟设备）</strong>，用于实现系统功能或模拟硬件行为：</p><ul><li><strong>示例</strong>：<ul><li>**<code>/dev/null</code>**：空设备，丢弃所有写入的数据，常用于日志重定向（如<code>command &gt; /dev/null</code>）。</li><li>**<code>/dev/zero</code>**：零设备，读取时返回无限的空字节（<code>\0</code>），用于填充数据或测试。</li><li>**<code>/dev/loop</code>**：回环设备，用于将文件模拟为块设备（如挂载ISO镜像）。</li><li><strong>管道（Pipe）和套接字（Socket）</strong>：用于进程间通信（IPC），在<code>/dev</code>目录下无实体文件，通过内存或特殊文件系统（如<code>tmpfs</code>）实现。</li></ul></li></ul><h3 id="设备管理的核心概念"><a href="#设备管理的核心概念" class="headerlink" title="设备管理的核心概念"></a><strong>设备管理的核心概念</strong></h3><ul><li><strong>设备文件与驱动程序</strong>：Linux通过<strong>设备驱动程序</strong>连接硬件设备和操作系统，每个设备文件对应一个驱动程序，用户通过操作设备文件（如读写）触发驱动程序完成硬件交互。</li><li><strong>主设备号与次设备号</strong>：<ul><li>每个设备文件通过<strong>主设备号（Major Number）</strong>和<strong>次设备号（Minor Number）</strong>唯一标识。</li><li>主设备号标识设备类型或驱动程序，次设备号标识同一类型中的具体设备实例（如同一硬盘的不同分区）。</li></ul></li></ul><p>通过将设备抽象为文件，Linux实现了“<strong>一切皆文件</strong>”的设计哲学，简化了用户对硬件的操作和管理。</p><h1 id="模块概念"><a href="#模块概念" class="headerlink" title="模块概念"></a>模块概念</h1><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在 Linux 系统中，<strong>模块（Module）</strong> 是一种可以动态加载和卸载的代码片段，用于扩展内核功能而无需重新编译整个内核。这种机制使得 Linux 内核具有高度的灵活性和可扩展性，尤其适用于硬件驱动、文件系统、网络协议等需要动态支持的场景。</p><h3 id="一、模块的基本概念"><a href="#一、模块的基本概念" class="headerlink" title="一、模块的基本概念"></a><strong>一、模块的基本概念</strong></h3><h4 id="1-模块的作用"><a href="#1-模块的作用" class="headerlink" title="1. 模块的作用"></a>1. <strong>模块的作用</strong></h4><ul><li><strong>动态扩展内核功能</strong>：例如为新硬件添加驱动程序，或支持新的文件系统（如 NTFS）、网络协议等。</li><li><strong>减少内核体积</strong>：常用功能编译进内核，不常用功能以模块形式存在，按需加载，节省内存和资源。</li><li><strong>热插拔支持</strong>：配合硬件热插拔（如 USB 设备），动态加载&#x2F;卸载模块，提升系统灵活性。</li></ul><h4 id="2-模块与内核的关系"><a href="#2-模块与内核的关系" class="headerlink" title="2. 模块与内核的关系"></a>2. <strong>模块与内核的关系</strong></h4><ul><li>模块运行在内核空间，拥有和内核相同的权限，可以直接访问硬件和内核数据结构。</li><li>模块依赖于内核提供的符号表（Symbol Table），加载时需与当前内核版本兼容（内核版本、架构必须一致）。</li></ul><h3 id="二、模块的分类"><a href="#二、模块的分类" class="headerlink" title="二、模块的分类"></a><strong>二、模块的分类</strong></h3><p>根据功能不同，模块主要分为以下几类：</p><h4 id="1-设备驱动模块"><a href="#1-设备驱动模块" class="headerlink" title="1. 设备驱动模块"></a>1. <strong>设备驱动模块</strong></h4><ul><li><strong>作用</strong>：为硬件设备提供驱动支持，如显卡驱动（NVIDIA&#x2F;AMD 闭源驱动）、网卡驱动、存储设备驱动等。</li><li><strong>示例</strong>：<ul><li><code>nvidia.ko</code>：NVIDIA 显卡驱动模块。</li><li><code>r8168.ko</code>：Realtek 8168 网卡驱动模块。</li></ul></li></ul><h4 id="2-文件系统模块"><a href="#2-文件系统模块" class="headerlink" title="2. 文件系统模块"></a>2. <strong>文件系统模块</strong></h4><ul><li><strong>作用</strong>：支持不同的文件系统格式，使内核能够读写对应格式的存储设备。</li><li><strong>示例</strong>：<ul><li><code>ntfs.ko</code>：NTFS 文件系统支持模块（用于访问 Windows 分区）。</li><li><code>exfat.ko</code>：EXFAT 文件系统支持模块（常用于U盘、SD卡）。</li></ul></li></ul><h4 id="3-网络协议模块"><a href="#3-网络协议模块" class="headerlink" title="3. 网络协议模块"></a>3. <strong>网络协议模块</strong></h4><ul><li><strong>作用</strong>：扩展网络功能，如虚拟专用网络（VPN）、网络过滤等。</li><li><strong>示例</strong>：<ul><li><code>ip_tables.ko</code>：iptables 防火墙核心模块。</li><li><code>openvpn.ko</code>：OpenVPN 虚拟网络模块（需配合用户空间程序使用）。</li></ul></li></ul><h4 id="4-系统功能模块"><a href="#4-系统功能模块" class="headerlink" title="4. 系统功能模块"></a>4. <strong>系统功能模块</strong></h4><ul><li><strong>作用</strong>：增强内核本身的功能，如内存管理、进程调度等。</li><li><strong>示例</strong>：<ul><li><code>overlay.ko</code>：OverlayFS 分层文件系统模块（常用于 Docker 容器）。</li><li><code>dm-mod.ko</code>：Device Mapper 模块（用于逻辑卷管理 LVM、磁盘加密等）。</li></ul></li></ul><h3 id="三、模块的相关文件与目录"><a href="#三、模块的相关文件与目录" class="headerlink" title="三、模块的相关文件与目录"></a><strong>三、模块的相关文件与目录</strong></h3><h4 id="1-模块文件的位置"><a href="#1-模块文件的位置" class="headerlink" title="1. 模块文件的位置"></a>1. <strong>模块文件的位置</strong></h4><ul><li><strong>默认存放路径</strong>：<ul><li>已安装的模块存放在 <code>/lib/modules/$(uname -r)/</code> 目录下，按内核版本分类。</li><li>临时模块可存放在 <code>/tmp</code> 或自定义目录（需确保权限）。</li></ul></li><li><strong>文件扩展名</strong>：模块文件通常为 <code>.ko</code>（Kernel Object）格式，本质是 ELF 可执行文件。</li></ul><h4 id="2-关键系统文件"><a href="#2-关键系统文件" class="headerlink" title="2. 关键系统文件"></a>2. <strong>关键系统文件</strong></h4><ul><li>**<code>/proc/modules</code>**：记录当前已加载的模块列表，包含模块名、大小、引用计数等信息。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例输出</span></span><br><span class="line">nvidia_drm 65536 2 - Live 0xffffffffc0340000</span><br><span class="line">nvidia_modeset 1392640 2 nvidia_drm, Live 0xffffffffc0040000</span><br></pre></td></tr></table></figure></li><li>**<code>/sys/module/</code>**：以目录形式展示已加载模块的详细信息（如参数、依赖关系），可通过文件读取或写入模块参数。</li><li>**<code>/etc/modules</code>**：系统启动时自动加载的模块列表（传统配置文件，部分系统使用 <code>/etc/modules-load.d/</code> 目录下的 <code>.conf</code> 文件）。</li></ul><h3 id="四、模块的管理命令"><a href="#四、模块的管理命令" class="headerlink" title="四、模块的管理命令"></a><strong>四、模块的管理命令</strong></h3><h4 id="1-加载模块（modprobe-insmod）"><a href="#1-加载模块（modprobe-insmod）" class="headerlink" title="1. 加载模块（modprobe&#x2F;insmod）"></a>1. <strong>加载模块（<code>modprobe</code>&#x2F;<code>insmod</code>）</strong></h4><ul><li>**<code>modprobe</code>**（推荐）：<ul><li>自动解决模块依赖关系（如先加载依赖模块）。</li><li>语法：<code>modprobe [模块名] [参数=值...]</code></li><li>示例：加载 NTFS 文件系统模块：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe ntfs</span><br></pre></td></tr></table></figure></li></ul></li><li>**<code>insmod</code>**：<ul><li>直接加载模块文件，不处理依赖，需手动指定完整路径。</li><li>语法：<code>insmod /path/to/module.ko [参数=值...]</code></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod /lib/modules/5.15.0-72-generic/kernel/fs/ntfs/ntfs.ko</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-卸载模块（rmmod-modprobe-r）"><a href="#2-卸载模块（rmmod-modprobe-r）" class="headerlink" title="2. 卸载模块（rmmod&#x2F;modprobe -r）"></a>2. <strong>卸载模块（<code>rmmod</code>&#x2F;<code>modprobe -r</code>）</strong></h4><ul><li>**<code>rmmod</code>**：<ul><li>直接卸载模块，若模块被其他进程或模块依赖，则卸载失败。</li><li>语法：<code>rmmod [模块名]</code></li></ul></li><li>**<code>modprobe -r</code>**（推荐）：<ul><li>自动递归卸载无依赖的模块（先卸载依赖它的模块）。</li><li>语法：<code>modprobe -r [模块名]</code></li><li>示例：卸载 NTFS 模块：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -r ntfs</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-查看模块信息"><a href="#3-查看模块信息" class="headerlink" title="3. 查看模块信息"></a>3. <strong>查看模块信息</strong></h4><ul><li>**<code>lsmod</code>**：列出当前已加载的模块及其依赖关系。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例输出</span></span><br><span class="line">Module                  Size  Used by</span><br><span class="line">nvidia_drm             65536  2 </span><br><span class="line">nvidia_modeset       1392640  1 nvidia_drm</span><br></pre></td></tr></table></figure></li><li>**<code>modinfo</code>**：查看模块文件的详细信息（作者、描述、依赖、参数等）。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modinfo ntfs</span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">filename:       /lib/modules/5.15.0-72-generic/kernel/fs/ntfs/ntfs.ko</span><br><span class="line">description:    NTFS filesystem driver</span><br><span class="line">author:         Anton Altaparmakov, Richard Russel, Etienne Carriere,</span><br><span class="line">                Christoph Hellwig, Paul Mackerras</span><br><span class="line">license:        GPL</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-配置模块自动加载"><a href="#4-配置模块自动加载" class="headerlink" title="4. 配置模块自动加载"></a>4. <strong>配置模块自动加载</strong></h4><ul><li><strong>传统方法（<code>/etc/modules</code>）</strong>：<br>在文件中每行添加一个模块名，系统启动时自动加载。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/modules</span><br><span class="line"><span class="comment"># 添加内容（示例）：</span></span><br><span class="line">ntfs</span><br><span class="line">overlay</span><br></pre></td></tr></table></figure></li><li><strong>现代方法（<code>/etc/modules-load.d/*.conf</code>）</strong>：<br>在 <code>/etc/modules-load.d/</code> 目录下创建 <code>.conf</code> 文件，每行写入模块名。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/modules-load.d/custom-modules.conf</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line">ntfs</span><br><span class="line">overlay</span><br></pre></td></tr></table></figure></li></ul><h3 id="五、模块的依赖与符号表"><a href="#五、模块的依赖与符号表" class="headerlink" title="五、模块的依赖与符号表"></a><strong>五、模块的依赖与符号表</strong></h3><h4 id="1-依赖关系"><a href="#1-依赖关系" class="headerlink" title="1. 依赖关系"></a>1. <strong>依赖关系</strong></h4><ul><li>模块可能依赖其他模块（如 <code>nvidia_modeset</code> 依赖 <code>nvidia_drm</code>），加载时需按顺序加载。</li><li><code>modprobe</code> 会自动读取 <code>/lib/modules/$(uname -r)/modules.dep</code> 文件，处理依赖关系。</li></ul><h4 id="2-符号表（Symbol-Table）"><a href="#2-符号表（Symbol-Table）" class="headerlink" title="2. 符号表（Symbol Table）"></a>2. <strong>符号表（Symbol Table）</strong></h4><ul><li>内核和模块通过符号表共享函数和变量（如内核导出的 <code>printk</code> 函数）。</li><li>模块加载时，需检查内核符号表是否包含所需符号（版本不兼容会导致加载失败）。</li><li>可通过 <code>nm</code> 命令查看模块或内核中的符号：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -D /lib/modules/$(<span class="built_in">uname</span> -r)/kernel/kernel/module.ko | grep printk</span><br></pre></td></tr></table></figure></li></ul><h3 id="六、编译与安装自定义模块"><a href="#六、编译与安装自定义模块" class="headerlink" title="六、编译与安装自定义模块"></a><strong>六、编译与安装自定义模块</strong></h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. <strong>准备工作</strong></h4><ul><li>安装内核开发工具：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line">sudo apt install linux-headers-$(<span class="built_in">uname</span> -r) build-essential</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo yum install kernel-devel kernel-headers</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-编写模块代码（示例：简单-Hello-World-模块）"><a href="#2-编写模块代码（示例：简单-Hello-World-模块）" class="headerlink" title="2. 编写模块代码（示例：简单 Hello World 模块）"></a>2. <strong>编写模块代码（示例：简单 Hello World 模块）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Hello World Module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, Linux kernel!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, Linux kernel!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br></pre></td></tr></table></figure><h4 id="3-编写-Makefile"><a href="#3-编写-Makefile" class="headerlink" title="3. 编写 Makefile"></a>3. <strong>编写 Makefile</strong></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure><h4 id="4-编译与安装"><a href="#4-编译与安装" class="headerlink" title="4. 编译与安装"></a>4. <strong>编译与安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo insmod hello.ko  <span class="comment"># 加载模块</span></span><br><span class="line">dmesg | <span class="built_in">tail</span>  <span class="comment"># 查看模块输出的日志（printk 输出到内核日志）</span></span><br><span class="line">sudo rmmod hello  <span class="comment"># 卸载模块</span></span><br></pre></td></tr></table></figure><h3 id="七、常见问题与注意事项"><a href="#七、常见问题与注意事项" class="headerlink" title="七、常见问题与注意事项"></a><strong>七、常见问题与注意事项</strong></h3><ol><li><p><strong>模块版本兼容性</strong>：</p><ul><li>模块必须与当前内核的版本、架构完全一致（可通过 <code>uname -r</code> 查看内核版本）。</li><li>升级内核后，旧模块可能无法使用，需重新编译或安装对应版本的模块。</li></ul></li><li><p><strong>权限问题</strong>：</p><ul><li>加载&#x2F;卸载模块需 <code>root</code> 权限（使用 <code>sudo</code>）。</li></ul></li><li><p><strong>依赖冲突</strong>：</p><ul><li>若模块依赖已加载的其他模块，需先卸载依赖模块（或使用 <code>modprobe -r</code> 自动处理）。</li></ul></li><li><p><strong>闭源模块的风险</strong>：</p><ul><li>部分硬件厂商提供的闭源模块（如 NVIDIA 驱动）可能与内核更新不兼容，需谨慎处理。</li></ul></li></ol><p>通过模块机制，Linux 内核实现了“核心精简、功能可扩展”的设计目标，用户可根据需求动态调整系统功能，这也是 Linux 生态灵活性和强大适配能力的重要体现。</p><h2 id="模块退出和调用"><a href="#模块退出和调用" class="headerlink" title="模块退出和调用"></a>模块退出和调用</h2><p>退出和调用必须符合my_init和my_exit。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>块IO层</title>
      <link href="/posts/e7bbd886.html"/>
      <url>/posts/e7bbd886.html</url>
      
        <content type="html"><![CDATA[<h1 id="块"><a href="#块" class="headerlink" title="块"></a>块</h1><h2 id="块设备和字符设备"><a href="#块设备和字符设备" class="headerlink" title="块设备和字符设备"></a>块设备和字符设备</h2><p>在 Linux 系统中，<strong>块设备（Block Device）</strong>和<strong>字符设备（Character Device）</strong>是两种基本的设备分类，用于区分不同类型的硬件设备及其数据交互方式。它们的核心区别在于数据读写的方式、缓冲机制和应用场景。</p><h3 id="一、块设备（Block-Device）"><a href="#一、块设备（Block-Device）" class="headerlink" title="一、块设备（Block Device）"></a><strong>一、块设备（Block Device）</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>块设备是一种以“数据块（Block）”为单位进行随机读写的设备</strong>。数据块的大小通常为固定值（如 512字节、4KB 等），设备驱动程序会对数据进行缓冲和缓存，支持按块随机访问（即可以直接读取任意块的数据，无需按顺序）。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><p><strong>数据交互方式</strong>  </p><ul><li>以<strong>块（Block）</strong>为最小单位读写，块大小由设备硬件决定（如硬盘的扇区通常是 512B 或 4KB）。  </li><li>支持<strong>随机访问</strong>：可以直接定位到任意块进行读写，无需按顺序操作（类似数组索引）。</li></ul></li><li><p><strong>缓冲机制</strong>  </p><ul><li>内核会为块设备提供<strong>缓冲区（Buffer）</strong>或<strong>缓存（Cache）</strong>，用于暂存数据以提高读写效率。例如，硬盘的读写操作会先经过文件系统的块缓冲区。</li></ul></li><li><p><strong>典型设备</strong>  </p><ul><li>存储设备：硬盘（HDD&#x2F;SSD）、U盘、光盘（CD&#x2F;DVD）、SD卡等。  </li><li>虚拟存储设备：磁盘分区（如 <code>/dev/sda1</code>）、RAID 设备、LVM 逻辑卷等。</li></ul></li><li><p><strong>设备文件路径</strong>  </p><ul><li>通常位于 <code>/dev</code> 目录下，文件名以 <code>sd</code>（SCSI 设备）、<code>hd</code>（IDE 设备）、<code>nvme</code>（NVMe 硬盘）等开头，如 <code>/dev/sda</code>（整块硬盘）、<code>/dev/sda3</code>（硬盘分区）。</li></ul></li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li>需要频繁进行随机读写和数据存储，如文件系统的创建、数据块的批量操作。  </li><li>支持文件系统的挂载（如 ext4、NTFS 等），用于持久化存储数据。</li></ul><h3 id="二、字符设备（Character-Device）"><a href="#二、字符设备（Character-Device）" class="headerlink" title="二、字符设备（Character Device）"></a><strong>二、字符设备（Character Device）</strong></h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a><strong>定义</strong></h4><p><strong>字符设备是一种以“字符（字节）”为单位进行顺序读写的设备</strong>，数据交互不经过缓冲区，直接按字节流顺序处理（类似流式传输），通常不支持随机访问。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><p><strong>数据交互方式</strong>  </p><ul><li>以<strong>字节（Byte）</strong>为最小单位读写，数据按顺序传输（如串口通信中的字符逐个发送）。  </li><li><strong>不支持随机访问</strong>：无法直接跳转到指定位置读写，必须按顺序处理数据（如键盘输入必须按按键顺序接收）。</li></ul></li><li><p><strong>缓冲机制</strong>  </p><ul><li>通常<strong>不使用缓冲区</strong>（或仅有简单缓冲），数据直接由设备驱动程序处理并传递给用户空间。</li></ul></li><li><p><strong>典型设备</strong>  </p><ul><li>输入输出设备：键盘、鼠标、串口（RS-232）、并口、终端（Terminal）、打印机等。  </li><li>传感器设备：温度传感器、湿度传感器等。  </li><li>特殊设备： <code>/dev/null</code>（空设备）、<code>/dev/zero</code>（零设备）、<code>/dev/random</code>（随机数生成器）等。</li></ul></li><li><p><strong>设备文件路径</strong>  </p><ul><li>位于 <code>/dev</code> 目录下，文件名通常反映设备类型，如 <code>/dev/keyboard</code>（键盘）、<code>/dev/ttyS0</code>（串口）、<code>/dev/console</code>（控制台）。</li></ul></li></ol><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ul><li>需要实时、顺序的数据交互，如用户输入、设备状态监控、流式数据传输（如串口通信）。  </li><li>不适合存储大规模结构化数据，常用于实时交互或简单的输入输出操作。</li></ul><h3 id="三、核心区别对比"><a href="#三、核心区别对比" class="headerlink" title="三、核心区别对比"></a><strong>三、核心区别对比</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>块设备</strong></th><th><strong>字符设备</strong></th></tr></thead><tbody><tr><td><strong>基本单位</strong></td><td>块（Block，如 4KB）</td><td>字符（Byte，1字节）</td></tr><tr><td><strong>访问方式</strong></td><td>随机访问（支持定位到块）</td><td>顺序访问（按字节流处理）</td></tr><tr><td><strong>缓冲机制</strong></td><td>有缓冲区&#x2F;缓存（提升效率）</td><td>无或仅有简单缓冲</td></tr><tr><td><strong>典型设备</strong></td><td>硬盘、U盘、磁盘分区</td><td>键盘、串口、传感器</td></tr><tr><td><strong>文件系统支持</strong></td><td>支持（可挂载文件系统）</td><td>不支持（无法存储文件系统）</td></tr><tr><td><strong>设备文件类型</strong></td><td>类型标识为 <code>b</code>（通过 <code>ls -l</code> 查看）</td><td>类型标识为 <code>c</code>（通过 <code>ls -l</code> 查看）</td></tr></tbody></table><h3 id="四、如何查看设备类型？"><a href="#四、如何查看设备类型？" class="headerlink" title="四、如何查看设备类型？"></a><strong>四、如何查看设备类型？</strong></h3><p>在 Linux 中，使用 <code>ls -l</code> 命令查看 <code>/dev</code> 目录下的设备文件，通过开头的字符判断类型：  </p><ul><li><strong>块设备</strong>：文件类型标识为 <code>b</code>（block），如：  <pre><code class="bash">brw-rw---- 1 root disk 8, 0 May 21 10:00 /dev/sda  </code></pre></li><li><strong>字符设备</strong>：文件类型标识为 <code>c</code>（character），如：  <pre><code class="bash">crw-rw-rw- 1 root tty 5, 0 May 21 10:00 /dev/tty0  </code></pre></li></ul><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><ul><li><strong>块设备</strong>适合存储结构化数据，支持随机读写和文件系统，是操作系统管理存储的核心；  </li><li><strong>字符设备</strong>适合实时、顺序的输入输出场景，是设备与用户交互的桥梁。<br>理解这两类设备的区别，有助于在 Linux 中正确管理硬件设备、编写驱动程序或处理底层输入输出操作。</li></ul><h2 id="扇区"><a href="#扇区" class="headerlink" title="扇区"></a>扇区</h2><p><strong>扇区（Sector）</strong>是计算机存储设备（如硬盘、固态硬盘、U盘等）上<strong>最小的物理存储单元</strong>，也是操作系统与存储设备进行数据交互的底层基本单位。它的概念最早源于传统机械硬盘（HDD），但在现代存储设备（如SSD、NVMe硬盘）中依然沿用类似的逻辑结构。</p><h3 id="一、扇区的基本定义"><a href="#一、扇区的基本定义" class="headerlink" title="一、扇区的基本定义"></a><strong>一、扇区的基本定义</strong></h3><ol><li><p><strong>物理意义</strong>  </p><ul><li>在<strong>机械硬盘（HDD）</strong>中，扇区是磁盘盘片上划分出的环形区域，是磁头读写数据的最小物理单元。每个盘片被划分为多个同心圆（磁道），每个磁道又被等分为若干个扇区。  </li><li>在<strong>固态硬盘（SSD）</strong>中，扇区是基于NAND闪存的逻辑存储单元，对应底层的“页”（Page）或“块”（Block）结构，但操作系统仍以扇区为单位进行抽象管理。</li></ul></li><li><p><strong>容量大小</strong>  </p><ul><li>传统扇区大小为 <strong>512字节（Byte）</strong>，这是早期硬盘的标准（如IDE硬盘）。  </li><li>现代存储设备普遍采用 <strong>4096字节（4KB）</strong> 的扇区，称为<strong>高级格式扇区（Advanced Format, AF）</strong>，以提高存储效率和可靠性。  </li><li>部分设备支持可变大小的扇区（如512e、4Kn等，需操作系统和硬件共同支持）。</li></ul></li></ol><h3 id="二、扇区的作用"><a href="#二、扇区的作用" class="headerlink" title="二、扇区的作用"></a><strong>二、扇区的作用</strong></h3><ol><li><p><strong>数据存储的最小单位</strong>  </p><ul><li>操作系统无法读写小于一个扇区的数据。例如，若要存储1000字节的数据，至少需要占用2个512字节的扇区（前一个扇区存512字节，后一个存488字节，剩余空间浪费）。</li></ul></li><li><p><strong>硬件与软件的接口</strong>  </p><ul><li>存储设备的驱动程序和文件系统（如ext4、NTFS）通过扇区地址（LBA，逻辑块地址）与硬件交互。文件系统会将多个扇区组合为<strong>块（Block）</strong>（如Linux的块通常为4KB，即1个4KB扇区或8个512字节扇区），用于上层文件管理。</li></ul></li><li><p><strong>错误校验与管理</strong>  </p><ul><li>每个扇区通常包含<strong>校验码（如CRC校验）</strong>，用于检测数据读写时的错误。  </li><li>在机械硬盘中，扇区还包含磁道编号、扇区编号等物理地址信息，用于磁头定位。</li></ul></li></ol><h3 id="三、扇区与块（Block）的区别"><a href="#三、扇区与块（Block）的区别" class="headerlink" title="三、扇区与块（Block）的区别"></a><strong>三、扇区与块（Block）的区别</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>扇区（Sector）</strong></th><th><strong>块（Block）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>存储设备的<strong>物理最小单元</strong></td><td>操作系统&#x2F;文件系统的<strong>逻辑最小单元</strong></td></tr><tr><td><strong>管理层面</strong></td><td>由硬件或固件定义（底层物理结构）</td><td>由文件系统或操作系统抽象定义</td></tr><tr><td><strong>容量</strong></td><td>通常为512B或4KB（固定值）</td><td>通常为扇区的整数倍（如4KB、8KB等）</td></tr><tr><td><strong>应用场景</strong></td><td>硬件底层读写（如磁盘控制器操作）</td><td>文件系统读写（如分配文件存储空间）</td></tr></tbody></table><p><strong>举例</strong>：  </p><ul><li>一个采用4KB扇区的SSD，其底层以4KB为单位读写；  </li><li>Linux的ext4文件系统默认将块大小设为4KB，与扇区大小一致，因此1个块对应1个扇区。  </li><li>若硬盘扇区为512B，文件系统块为4KB，则1个块包含8个扇区。</li></ul><h3 id="四、扇区对齐（Sector-Alignment）"><a href="#四、扇区对齐（Sector-Alignment）" class="headerlink" title="四、扇区对齐（Sector Alignment）"></a><strong>四、扇区对齐（Sector Alignment）</strong></h3><h4 id="什么是扇区对齐？"><a href="#什么是扇区对齐？" class="headerlink" title="什么是扇区对齐？"></a><strong>什么是扇区对齐？</strong></h4><ul><li>当操作系统访问存储设备时，数据的起始地址需与扇区边界对齐（即从扇区的起始位置开始读写），称为<strong>扇区对齐</strong>。  </li><li>若未对齐（如数据从扇区中间位置开始），会导致<strong>跨扇区读写</strong>，降低性能甚至引发错误（尤其在SSD中）。</li></ul><h4 id="为什么需要对齐？"><a href="#为什么需要对齐？" class="headerlink" title="为什么需要对齐？"></a><strong>为什么需要对齐？</strong></h4><ol><li><strong>机械硬盘</strong>：跨扇区读写需磁头移动两次（访问两个扇区），增加寻道时间和延迟。  </li><li><strong>固态硬盘</strong>：NAND闪存的写入以“页”为单位，跨扇区操作可能触发额外的擦除&#x2F;写入操作（如磨损均衡），影响寿命和性能。</li></ol><h4 id="如何确保对齐？"><a href="#如何确保对齐？" class="headerlink" title="如何确保对齐？"></a><strong>如何确保对齐？</strong></h4><ul><li>现代操作系统（如Windows、Linux）在分区时会自动对齐扇区（通常以4KB为边界）。  </li><li>可通过工具查看分区对齐情况，例如：  <ul><li>Linux：<code>fdisk -l</code> 查看分区起始扇区是否为8的倍数（对4KB扇区而言，8个512B扇区&#x3D;4KB）。  </li><li>Windows：使用DiskPart工具检查分区偏移量。</li></ul></li></ul><h3 id="五、扇区的发展趋势"><a href="#五、扇区的发展趋势" class="headerlink" title="五、扇区的发展趋势"></a><strong>五、扇区的发展趋势</strong></h3><ol><li><p><strong>从512B到4KB扇区</strong>  </p><ul><li>随着存储密度增加，4KB扇区成为主流（减少元数据开销，提升纠错效率），但需操作系统和软件兼容（如Windows 7以上、Linux内核2.6.31+支持4KB扇区）。</li></ul></li><li><p><strong>逻辑扇区与物理扇区的抽象</strong>  </p><ul><li>现代存储设备通过<strong>设备固件（Firmware）</strong>实现逻辑扇区（LBA）与物理扇区的映射，支持磨损均衡、坏块管理等功能（如SSD的FTL闪存转换层）。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>扇区是存储设备的物理基石，决定了数据读写的最小粒度。理解扇区的概念有助于优化存储性能（如扇区对齐）、排查磁盘故障（如坏扇区修复），以及理解文件系统与硬件的交互逻辑。无论是机械硬盘还是固态硬盘，扇区始终是连接物理存储与上层软件的关键纽带。</p><h2 id="簇"><a href="#簇" class="headerlink" title="簇"></a>簇</h2><p><strong>簇（Cluster）</strong>是操作系统中用于管理存储设备（如硬盘、U盘）的<strong>逻辑存储单元</strong>，是文件系统（如NTFS、FAT32、ext4等）分配存储空间的最小单位。它建立在扇区（物理存储单元）之上，通过将多个扇区组合成一个更大的单元，简化文件系统对磁盘空间的管理。</p><h3 id="一、簇的基本定义"><a href="#一、簇的基本定义" class="headerlink" title="一、簇的基本定义"></a><strong>一、簇的基本定义</strong></h3><ol><li><p><strong>逻辑单元的本质</strong>  </p><ul><li>簇是文件系统层面的概念，不直接对应物理硬件的结构，而是由操作系统在格式化存储设备时定义。  </li><li>每个簇由连续的<strong>扇区（Sector）</strong>组成，扇区是存储设备的物理最小单元（通常为512字节或4KB）。例如：  <ul><li>一个簇可能包含4个512字节的扇区（总大小2KB），或1个4KB的扇区（与扇区大小一致）。</li></ul></li></ul></li><li><p><strong>簇大小的特点</strong>  </p><ul><li>簇的大小必须是扇区大小的整数倍，且在格式化时由用户或系统默认设置（如FAT32默认簇大小随分区容量增大而增大）。  </li><li>常见簇大小：512字节、1KB、2KB、4KB、8KB、16KB等。</li></ul></li></ol><h3 id="二、簇的核心作用"><a href="#二、簇的核心作用" class="headerlink" title="二、簇的核心作用"></a><strong>二、簇的核心作用</strong></h3><ol><li><p><strong>简化存储空间分配</strong>  </p><ul><li>文件系统以簇为单位为文件分配空间。例如，一个10KB的文件在簇大小为4KB的系统中，会占用3个簇（前两个簇存8KB，第三个簇存2KB，剩余2KB浪费）。  </li><li>这种机制避免了直接操作大量扇区的复杂性，提升文件系统的管理效率。</li></ul></li><li><p><strong>影响存储效率与性能</strong>  </p><ul><li><strong>簇大小与文件大小的关系</strong>：  <ul><li>簇越小，存储小文件时空间利用率越高（浪费少），但文件系统需要记录更多簇的位置，增加元数据开销。  </li><li>簇越大，存储大文件时效率更高（减少簇数量），但小文件会浪费更多空间（如1KB文件占用4KB簇，浪费3KB）。</li></ul></li><li><strong>性能影响</strong>：大簇可减少文件碎片（尤其是大文件），但可能导致更多空间浪费；小簇适合存储大量小文件，但可能增加碎片风险。</li></ul></li><li><p><strong>文件系统兼容性</strong>  </p><ul><li>不同文件系统支持的簇大小范围不同：  <ul><li><strong>FAT32</strong>：最大簇大小为32KB（分区容量≤32GB时）。  </li><li><strong>NTFS</strong>：支持更大的簇大小（最大可达64KB），适合大容量硬盘。  </li><li><strong>ext4（Linux）</strong>：默认簇大小通常为4KB，可根据分区大小自动调整。</li></ul></li></ul></li></ol><h3 id="三、簇与扇区、块的区别"><a href="#三、簇与扇区、块的区别" class="headerlink" title="三、簇与扇区、块的区别"></a><strong>三、簇与扇区、块的区别</strong></h3><table><thead><tr><th><strong>概念</strong></th><th><strong>定义</strong></th><th><strong>所属层面</strong></th><th><strong>大小关系</strong></th><th><strong>典型应用</strong></th></tr></thead><tbody><tr><td><strong>扇区</strong></td><td>存储设备的物理最小单元</td><td>硬件&#x2F;固件层</td><td>512B或4KB（固定）</td><td>硬盘、SSD底层读写</td></tr><tr><td><strong>簇</strong></td><td>文件系统分配空间的逻辑最小单元</td><td>文件系统层</td><td>扇区的整数倍（如4KB、8KB）</td><td>FAT32、NTFS等文件系统管理</td></tr><tr><td><strong>块</strong></td><td>操作系统与文件系统交互的逻辑单元</td><td>操作系统内核层</td><td>通常等于簇大小（如ext4块&#x3D;簇）</td><td>Linux内核缓存、I&#x2F;O操作</td></tr></tbody></table><p><strong>关键区别</strong>：  </p><ul><li>扇区是硬件定义的物理单位，簇是文件系统定义的逻辑单位，块是操作系统抽象的逻辑单位（可能与簇重合）。  </li><li>例如：Windows的NTFS文件系统中，簇直接对应“分配单元”；Linux的ext4文件系统中，块通常等于簇大小（如默认4KB）。</li></ul><h3 id="四、簇大小的选择与优化"><a href="#四、簇大小的选择与优化" class="headerlink" title="四、簇大小的选择与优化"></a><strong>四、簇大小的选择与优化</strong></h3><h4 id="如何选择簇大小？"><a href="#如何选择簇大小？" class="headerlink" title="如何选择簇大小？"></a><strong>如何选择簇大小？</strong></h4><ol><li><p><strong>根据文件类型</strong>：  </p><ul><li><strong>小文件为主</strong>（如文档、图片）：选择较小的簇（如4KB），减少空间浪费。  </li><li><strong>大文件为主</strong>（如视频、虚拟机文件）：选择较大的簇（如16KB或32KB），提升读写效率。</li></ul></li><li><p><strong>根据存储设备类型</strong>：  </p><ul><li><strong>机械硬盘（HDD）</strong>：大簇可减少寻道次数，适合大文件。  </li><li><strong>固态硬盘（SSD）</strong>：小簇（如4KB）更兼容现代文件系统（如NTFS默认4KB），且避免过度写入（大簇可能导致不必要的擦写）。</li></ul></li><li><p><strong>格式化时的设置</strong>：  </p><ul><li>Windows：格式化分区时可手动选择簇大小（“分配单元大小”）。  </li><li>Linux：使用<code>mkfs</code>命令指定块大小（如<code>mkfs.ext4 -b 4096 /dev/sda1</code>）。</li></ul></li></ol><h4 id="簇大小对性能的影响案例"><a href="#簇大小对性能的影响案例" class="headerlink" title="簇大小对性能的影响案例"></a><strong>簇大小对性能的影响案例</strong></h4><ul><li><p><strong>场景1</strong>：存储1000个1KB的小文件  </p><ul><li>簇大小4KB：每个文件占用1个簇，总占用4000KB（浪费3000KB）。  </li><li>簇大小1KB：每个文件占用1个簇，总占用1000KB（无浪费）。  </li><li><strong>结论</strong>：小簇更适合小文件密集型存储。</li></ul></li><li><p><strong>场景2</strong>：存储1个1GB的大文件  </p><ul><li>簇大小4KB：占用262144个簇（1GB&#x2F;4KB）。  </li><li>簇大小32KB：占用32768个簇（1GB&#x2F;32KB）。  </li><li><strong>结论</strong>：大簇减少簇数量，降低文件系统元数据开销，提升访问速度。</li></ul></li></ul><h3 id="五、簇的常见问题"><a href="#五、簇的常见问题" class="headerlink" title="五、簇的常见问题"></a><strong>五、簇的常见问题</strong></h3><ol><li><p><strong>簇与文件碎片</strong>  </p><ul><li>文件碎片是指文件数据分散在非连续的簇中。大簇可能减少碎片（因每个簇存储更多数据），但小文件更容易碎片化。  </li><li>定期整理碎片（如Windows磁盘整理工具）可优化文件连续性，提升性能（仅限机械硬盘，SSD无需碎片整理）。</li></ul></li><li><p><strong>簇大小与分区容量限制</strong>  </p><ul><li>某些文件系统（如FAT32）的簇大小随分区容量增大而增大，导致小文件空间浪费显著。例如：  <ul><li>32GB的FAT32分区默认簇大小为32KB，存储1KB文件会浪费31KB&#x2F;文件。</li></ul></li><li>因此，FAT32更适合小容量设备（如U盘），NTFS或exFAT更适合大容量硬盘。</li></ul></li><li><p><strong>跨平台兼容性</strong>  </p><ul><li>不同操作系统对簇大小的支持不同。例如：  <ul><li>macOS对exFAT的簇大小有限制，而Windows支持更灵活。  </li><li>跨平台使用存储设备时，建议选择兼容性强的簇大小（如默认4KB）。</li></ul></li></ul></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>簇是文件系统管理存储的核心逻辑单元，其大小直接影响存储效率、性能和空间利用率。理解簇的概念有助于根据实际需求（如文件类型、设备容量）选择合适的文件系统和簇配置，避免空间浪费或性能瓶颈。无论是日常使用U盘存储文件，还是管理服务器硬盘，簇都是优化存储体验的关键因素之一。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟文件系统</title>
      <link href="/posts/ab453ce.html"/>
      <url>/posts/ab453ce.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="/posts/41e39f2b.html"/>
      <url>/posts/41e39f2b.html</url>
      
        <content type="html"><![CDATA[<h1 id="页"><a href="#页" class="headerlink" title="页"></a>页</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在现代计算机系统中，处理器的寻址通常通过 <strong>虚拟地址（Virtual Address）</strong> 进行，而虚拟地址到物理地址的转换过程涉及“页”（Page）的概念。对于支持内存管理单元（MMU）的处理器（如ARMv7），<strong>寻址过程会按照页来划分和管理内存</strong>，但具体机制需要结合硬件架构和操作系统来理解。以下是详细说明：</p><h3 id="一、处理器寻址的基本概念"><a href="#一、处理器寻址的基本概念" class="headerlink" title="一、处理器寻址的基本概念"></a><strong>一、处理器寻址的基本概念</strong></h3><ol><li><p><strong>虚拟地址与物理地址</strong>  </p><ul><li><strong>虚拟地址</strong>：应用程序看到的内存地址（由操作系统分配），范围由处理器位数决定（如32位处理器虚拟地址空间为0~4GB）。  </li><li><strong>物理地址</strong>：实际内存（RAM）的硬件地址，由处理器地址总线宽度决定（如32位处理器物理地址空间通常也是4GB）。  </li><li><strong>MMU的作用</strong>：负责将虚拟地址转换为物理地址，这个过程称为 <strong>地址转换（Address Translation）</strong>。</li></ul></li><li><p><strong>分页（Paging）机制</strong>  </p><ul><li>操作系统将虚拟地址空间和物理地址空间划分为固定大小的块，称为 <strong>页（Page）</strong>。  </li><li>虚拟地址对应的页称为 <strong>虚拟页（Virtual Page）</strong>，物理地址对应的页称为 <strong>物理页（Physical Page）</strong>。  </li><li>页的大小由处理器架构决定（如ARMv7支持4KB、64KB等页大小，见前文）。</li></ul></li></ol><h3 id="二、ARMv7的寻址与分页流程"><a href="#二、ARMv7的寻址与分页流程" class="headerlink" title="二、ARMv7的寻址与分页流程"></a><strong>二、ARMv7的寻址与分页流程</strong></h3><h4 id="1-虚拟地址的结构（以32位ARMv7为例）"><a href="#1-虚拟地址的结构（以32位ARMv7为例）" class="headerlink" title="1. 虚拟地址的结构（以32位ARMv7为例）"></a><strong>1. 虚拟地址的结构（以32位ARMv7为例）</strong></h4><p>虚拟地址被划分为多个字段，用于索引页表和定位页内偏移：  </p><ul><li><strong>大页（64KB）</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  31       20 19      12 11       0</span><br><span class="line">  +----------+---------+-----------+</span><br><span class="line">  | 段索引   | 页索引  | 页内偏移  |</span><br><span class="line">  +----------+---------+-----------+</span><br><span class="line">  （12位）   （8位）   （12位）</span><br><span class="line">  ```  </span><br><span class="line">- **小页（4KB）**：  </span><br></pre></td></tr></table></figure>31       20 19      16 15       0<br>+———-+———+———–+<br>| 段索引   | 页表索引| 页内偏移  |<br>+———-+———+———–+<br>（12位）   （4位）   （12位）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  - **段索引**：用于定位一级页表（Section Table）。  </span><br><span class="line">  - **页索引/页表索引**：用于定位二级页表（Page Table）或直接映射大页/小页。  </span><br><span class="line">  - **页内偏移**：确定页内的具体地址（与页大小对应，如4KB页的偏移为12位）。</span><br><span class="line"></span><br><span class="line">#### **2. 地址转换过程（以小页为例）**</span><br><span class="line">1. **一级页表查询**：  </span><br><span class="line">   - 虚拟地址的 **段索引（12位）** 作为一级页表的索引，找到对应的一级页表项（PTE）。  </span><br><span class="line">   - 若页表项标记为“小页”（通过标志位`S=1`判断），则进入二级页表查询。  </span><br><span class="line"></span><br><span class="line">2. **二级页表查询**：  </span><br><span class="line">   - 虚拟地址的 **页表索引（4位）** 作为二级页表的索引，找到对应的二级页表项。  </span><br><span class="line">   - 二级页表项包含物理页的基地址（高位部分），与虚拟地址的 **页内偏移（12位）** 拼接，得到最终的物理地址。  </span><br><span class="line"></span><br><span class="line">#### **3. 关键寄存器与缓存**  </span><br><span class="line">- **页表基址寄存器（TTBR0/TTBR1）**：存储页表的基地址，用于定位一级页表。  </span><br><span class="line">- **转换后备缓冲器（TLB）**：缓存最近使用的虚拟地址到物理地址的映射，加速地址转换（避免每次寻址都查询页表）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **三、处理器是否“按页寻址”？**</span><br><span class="line">- **直接回答**：  </span><br><span class="line">  处理器的寻址**基于虚拟地址**，而虚拟地址到物理地址的转换**按页进行**。应用程序和处理器本身不直接操作“页”，但操作系统和硬件通过分页机制管理内存。  </span><br><span class="line"></span><br><span class="line">- **核心逻辑**：  </span><br><span class="line">  1. 处理器生成虚拟地址后，MMU自动将其拆分为“页索引”和“页内偏移”，通过页表找到对应的物理页基址，再加上偏移得到物理地址。  </span><br><span class="line">  2. 对处理器而言，寻址是连续的虚拟地址空间；对硬件和操作系统而言，内存管理以“页”为单位（如分配、换入/换出、权限控制等）。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **四、分页的作用与优势**</span><br><span class="line">1. **内存保护**：通过页表项的权限标志（如可读、可写、可执行），防止进程越权访问内存。  </span><br><span class="line">2. **内存共享**：多个虚拟地址可映射到同一物理页（如共享库、进程间通信）。  </span><br><span class="line">3. **虚拟内存**：支持将不活跃的页交换到磁盘，扩展可用内存（需操作系统支持）。  </span><br><span class="line">4. **地址空间隔离**：每个进程拥有独立的虚拟地址空间，避免相互干扰。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **五、非分页模式（段映射）**</span><br><span class="line">在ARMv7中，若不启用MMU或配置为非分页模式，处理器会使用 **段映射（Segment Mapping）**：  </span><br><span class="line">- 虚拟地址直接划分为1MB的段（无页表参与），段索引对应物理地址的高位，段内偏移直接映射。  </span><br><span class="line">- 此时寻址不涉及“页”，但内存管理粒度较粗（仅1MB），适用于简单系统（如实时操作系统）。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **总结**</span><br><span class="line">- **处理器寻址的本质**：基于虚拟地址，通过MMU按页划分和转换地址。  </span><br><span class="line">- **程序员视角**：无需显式操作“页”，仅需处理虚拟地址（由操作系统和编译器抽象）。  </span><br><span class="line">- **硬件与系统视角**：内存以页为单位管理，页大小由处理器架构决定（如ARMv7的4KB/64KB）。  </span><br><span class="line"></span><br><span class="line">如需进一步理解，可结合具体处理器的MMU章节（如《ARM Architecture Reference Manual》）和操作系统内存管理原理进行学习。</span><br><span class="line"></span><br><span class="line">## 获取页</span><br><span class="line">在Linux内存管理中获取页的方法 </span><br><span class="line"> </span><br><span class="line">在Linux内核内存管理中，获取页（page）是内存分配的基本操作之一。以下是几种主要的获取页的方法：</span><br><span class="line"> </span><br><span class="line">1. 低级页分配器接口 </span><br><span class="line"> </span><br><span class="line">alloc_pages()</span><br><span class="line">```c </span><br><span class="line">struct page *alloc_pages(gfp_t gfp_mask, unsigned int order);</span><br></pre></td></tr></table></figure></li><li>最基础的页分配函数 </li><li><code>gfp_mask</code>：分配标志（如<code>GFP_KERNEL</code>, <code>GFP_ATOMIC</code>等）</li><li><code>order</code>：请求的页数（2^order页）</li><li>返回指向第一个页的<code>page</code>结构体指针</li></ul><p>alloc_page()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span>;</span><br></pre></td></tr></table></figure><ul><li>分配单个页的简化版本（相当于<code>alloc_pages(gfp_mask, 0)</code>）</li></ul><ol start="2"><li>常用变体</li></ol><p>__get_free_pages()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br></pre></td></tr></table></figure><ul><li>类似于<code>alloc_pages()</code>，但返回的是页的虚拟地址而非<code>page</code>结构体</li></ul><p>get_zeroed_page()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span>;</span><br></pre></td></tr></table></figure><ul><li>分配单个页并将其内容清零</li></ul><ol start="3"><li>特定用途的分配器</li></ol><p>vmalloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li>分配虚拟地址连续但物理地址可能不连续的内存区域</li></ul><p>kmalloc()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>用于分配小块内存（小于页大小）</li></ul><ol start="4"><li>释放页的函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span>;</span><br></pre></td></tr></table></figure><p>示例代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 分配2个页（8KB）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> alloc_pages(GFP_KERNEL, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">    <span class="comment">// 处理分配失败 </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用页...</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放页 </span></span><br><span class="line">__free_pages(page, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>注意事项 </p><ol><li><p>分配标志(<code>gfp_mask</code>)非常重要，它决定了：</p><ul><li>分配行为（能否睡眠、能否访问高端内存等）</li><li>内存区域（DMA、常规、高端内存等）</li></ul></li><li><p>在原子上下文中（如中断处理程序）必须使用<code>GFP_ATOMIC</code>标志 </p></li><li><p>分配失败是可能的，必须检查返回值 </p></li><li><p>分配后应尽快释放，避免内存泄漏</p></li></ol><p>Linux内核提供了丰富的页分配API，选择哪种方法取决于具体的需求和上下文环境。</p><h3 id="gfp-mask"><a href="#gfp-mask" class="headerlink" title="gfp_mask"></a>gfp_mask</h3><p>Linux内存分配中的<code>gfp_mask</code>详解</p><p><code>gfp_mask</code>（Get Free Page mask）是Linux内核内存分配函数中最重要的参数之一，它控制着内存分配的行为和特性。这个标志位掩码决定了内存分配器如何寻找和分配内存页。</p><ol><li><code>gfp_mask</code>的基本组成</li></ol><p><code>gfp_mask</code>由三部分组成：</p><ul><li>行为修饰符：控制分配行为（如能否睡眠）</li><li>区域修饰符：指定从哪个内存区域分配</li><li>类型标志：预定义的常用组合</li></ul><ol start="2"><li>主要标志分类</li></ol><p>2.1 行为修饰符 (Allocation Behavior)</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>__GFP_WAIT</code></td><td>允许分配器睡眠（已弃用，用<code>GFP_KERNEL</code>代替）</td></tr><tr><td><code>__GFP_HIGH</code></td><td>高优先级分配，可以使用紧急内存池</td></tr><tr><td><code>__GFP_IO</code></td><td>允许启动I&#x2F;O操作（如换出页面）</td></tr><tr><td><code>__GFP_FS</code></td><td>允许调用文件系统相关操作</td></tr><tr><td><code>__GFP_COLD</code></td><td>请求缓存冷页（不常访问的页）</td></tr><tr><td><code>__GFP_NOWARN</code></td><td>分配失败时不产生警告</td></tr><tr><td><code>__GFP_REPEAT</code></td><td>失败后重试几次</td></tr><tr><td><code>__GFP_NOFAIL</code></td><td>无限重试直到成功（慎用）</td></tr><tr><td><code>__GFP_NORETRY</code></td><td>失败后不再重试</td></tr><tr><td><code>__GFP_ZERO</code></td><td>分配后将内存清零</td></tr></tbody></table><p>2.2 区域修饰符 (Zone Modifiers)</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>__GFP_DMA</code></td><td>从DMA区域分配（&lt;16MB）</td></tr><tr><td><code>__GFP_DMA32</code></td><td>从DMA32区域分配（&lt;4GB）</td></tr><tr><td><code>__GFP_HIGHMEM</code></td><td>从高端内存区域分配</td></tr></tbody></table><p>2.3 类型标志 (Type Flags)</p><p>这些是预定义的常用组合：</p><table><thead><tr><th>标志</th><th>组成</th><th>使用场景</th></tr></thead><tbody><tr><td><code>GFP_ATOMIC</code></td><td><code>__GFP_HIGH</code></td><td>原子上下文，不能睡眠</td></tr><tr><td><code>GFP_KERNEL</code></td><td><code>__GFP_WAIT | __GFP_IO | __GFP_FS</code></td><td>常规内核分配，可睡眠</td></tr><tr><td><code>GFP_USER</code></td><td><code>__GFP_WAIT | __GFP_IO | __GFP_FS</code></td><td>用户空间分配</td></tr><tr><td><code>GFP_HIGHUSER</code></td><td><code>GFP_USER | __GFP_HIGHMEM</code></td><td>用户空间高端内存分配</td></tr><tr><td><code>GFP_NOIO</code></td><td><code>__GFP_WAIT</code></td><td>禁止I&#x2F;O操作</td></tr><tr><td><code>GFP_NOFS</code></td><td><code>__GFP_WAIT | __GFP_IO</code></td><td>禁止文件系统操作</td></tr><tr><td><code>GFP_NOWAIT</code></td><td><code>0</code></td><td>不等待，快速失败</td></tr></tbody></table><ol start="3"><li>使用场景示例</li></ol><p>3.1 常规内核分配（可睡眠）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = kmalloc(size, GFP_KERNEL);</span><br></pre></td></tr></table></figure><ul><li>可以睡眠等待内存释放</li><li>可以启动I&#x2F;O操作（如换出页面）</li><li>可以调用文件系统操作</li></ul><p>3.2 原子上下文分配（不可睡眠）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = kmalloc(size, GFP_ATOMIC);</span><br></pre></td></tr></table></figure><ul><li>用于中断上下文、自旋锁保护区域等不能睡眠的地方 </li><li>分配失败概率较高</li></ul><p>3.3 DMA内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page = alloc_pages(GFP_DMA, order);</span><br></pre></td></tr></table></figure><ul><li>用于需要DMA访问的设备</li><li>从物理内存的前16MB分配</li></ul><p>3.4 高端内存分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page = alloc_pages(GFP_HIGHUSER, order);</span><br></pre></td></tr></table></figure><ul><li>用于用户空间映射 </li><li>可能来自高端内存区域(&gt;896MB)</li></ul><ol start="4"><li><p>标志组合规则 </p></li><li><p>不能混合类型标志：不能同时使用<code>GFP_KERNEL</code>和<code>GFP_ATOMIC</code></p></li><li><p>可以添加修饰符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc_pages(GFP_KERNEL | __GFP_ZERO, order); <span class="comment">// 分配并清零 </span></span><br></pre></td></tr></table></figure></li><li><p>区域修饰符优先级：</p><ul><li><code>__GFP_DMA</code> &gt; <code>__GFP_DMA32</code> &gt; 普通区域 &gt; <code>__GFP_HIGHMEM</code></li></ul></li><li><p>实际开发建议 </p></li><li><p>优先使用预定义类型标志：除非有特殊需求，否则使用<code>GFP_KERNEL</code>或<code>GFP_ATOMIC</code></p></li><li><p>原子上下文必须使用<code>GFP_ATOMIC</code>：在中断处理、自旋锁保护区域等 </p></li><li><p>谨慎使用<code>__GFP_NOFAIL</code>：可能导致死锁</p></li><li><p>清零分配考虑性能：<code>__GFP_ZERO</code>会增加开销</p></li><li><p>DMA内存要明确指定：设备驱动需要DMA内存时必须使用<code>__GFP_DMA</code></p></li><li><p>内核版本变化</p></li></ol><p>不同内核版本的<code>gfp_mask</code>标志可能有变化：</p><ul><li>新版内核中<code>__GFP_WAIT</code>被移除 </li><li>新增了一些特殊用途的标志 </li><li>具体定义见<code>&lt;linux/gfp.h&gt;</code></li></ul><p>理解<code>gfp_mask</code>对于Linux内核开发至关重要，它直接影响内存分配的成功率和系统性能。正确使用这些标志可以避免内存分配失败和系统不稳定问题。</p><h2 id="kmalloc和vmalloc区别"><a href="#kmalloc和vmalloc区别" class="headerlink" title="kmalloc和vmalloc区别"></a>kmalloc和vmalloc区别</h2><p>在 Linux 内核里，kmalloc 和 vmalloc 都是用于分配内存的函数，但它们的实现方式和适用场景存在明显差异，下面为你详细介绍：</p><h3 id="分配区域与连续性"><a href="#分配区域与连续性" class="headerlink" title="分配区域与连续性"></a>分配区域与连续性</h3><ul><li><strong>kmalloc</strong>：主要用于分配物理地址连续的内存块。这些内存位于物理内存的低端区域，也就是所谓的 ZONE_DMA 和 ZONE_NORMAL 区域。由于物理地址是连续的，所以对应的虚拟地址自然也是连续的。</li><li><strong>vmalloc</strong>：分配的是虚拟地址连续但物理地址不一定连续的内存块。这些内存一般来自于高端内存区域（ZONE_HIGHMEM）。为了让虚拟地址连续，内核会建立专门的页表来映射这些不连续的物理页。</li></ul><h3 id="分配大小与效率"><a href="#分配大小与效率" class="headerlink" title="分配大小与效率"></a>分配大小与效率</h3><ul><li><strong>kmalloc</strong>：比较适合分配小内存块，通常分配的内存大小不超过一页（在 32 位系统中一般是 4KB）。它的分配效率很高，这得益于采用了 slab 分配器，能够快速地分配和释放内存。</li><li><strong>vmalloc</strong>：适用于分配大内存块，例如几 MB 的连续虚拟地址空间。不过，它的分配效率相对较低，因为在分配过程中需要建立新的页表，会带来一定的开销。</li></ul><h3 id="分配成功率"><a href="#分配成功率" class="headerlink" title="分配成功率"></a>分配成功率</h3><ul><li><strong>kmalloc</strong>：由于是从物理内存的低端区域分配，当系统内存碎片化严重时，分配大内存块可能会失败。</li><li><strong>vmalloc</strong>：因为可以使用不连续的物理页，所以在系统内存碎片化的情况下，分配大内存块的成功率要比 kmalloc 高。</li></ul><h3 id="缓存属性"><a href="#缓存属性" class="headerlink" title="缓存属性"></a>缓存属性</h3><ul><li><strong>kmalloc</strong>：默认分配的是可缓存的内存，这对于需要高速访问的场景非常有利，比如作为硬件缓冲区。</li><li><strong>vmalloc</strong>：分配的内存同样默认是可缓存的，但也可以通过特定的标志（如 GFP_DMA）分配不可缓存的内存。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>kmalloc</strong>：在需要物理地址连续的场景中经常会用到，像为硬件设备分配 DMA 缓冲区，或者在中断处理程序中分配内存，因为中断处理程序要求快速执行，而 kmalloc 的高效率正好满足这一需求。</li><li><strong>vmalloc</strong>：主要用于分配大内存块的情况，比如模块加载时分配内存，或者在不需要物理地址连续的情况下分配内存，像内核线程的堆栈分配。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>kmalloc</strong></th><th><strong>vmalloc</strong></th></tr></thead><tbody><tr><td><strong>物理连续性</strong></td><td>连续</td><td>不连续</td></tr><tr><td><strong>虚拟连续性</strong></td><td>连续</td><td>连续</td></tr><tr><td><strong>分配大小</strong></td><td>小内存块（通常 ≤ 1 页）</td><td>大内存块（可达几 MB）</td></tr><tr><td><strong>效率</strong></td><td>高（slab 分配器）</td><td>低（需要建立页表）</td></tr><tr><td><strong>成功率</strong></td><td>低（碎片化时）</td><td>高（可使用不连续物理页）</td></tr><tr><td><strong>典型场景</strong></td><td>DMA 缓冲区、中断处理程序</td><td>模块加载、大内存分配</td></tr></tbody></table><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个简单的代码示例，展示了 kmalloc 和 vmalloc 的基本用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">mem_alloc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *kmalloc_ptr, *vmalloc_ptr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 kmalloc 分配 1024 字节内存，标志为 GFP_KERNEL</span></span><br><span class="line">    kmalloc_ptr = kmalloc(<span class="number">1024</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!kmalloc_ptr) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;kmalloc failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;kmalloc address: %p\n&quot;</span>, kmalloc_ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 vmalloc 分配 1MB 内存</span></span><br><span class="line">    vmalloc_ptr = vmalloc(<span class="number">1024</span> * <span class="number">1024</span>);  <span class="comment">// 1MB</span></span><br><span class="line">    <span class="keyword">if</span> (!vmalloc_ptr) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;vmalloc failed\n&quot;</span>);</span><br><span class="line">        kfree(kmalloc_ptr);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;vmalloc address: %p\n&quot;</span>, vmalloc_ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用内存...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    vfree(vmalloc_ptr);</span><br><span class="line">    kfree(kmalloc_ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">mem_alloc_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Memory allocation module exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mem_alloc_init);</span><br><span class="line">module_exit(mem_alloc_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，我们可以看到：</p><ul><li>kmalloc 用于分配 1024 字节的小内存块。</li><li>vmalloc 用于分配 1MB 的大内存块。</li><li>使用完内存后，分别用 kfree 和 vfree 释放对应的内存。</li></ul><h1 id="区"><a href="#区" class="headerlink" title="区"></a>区</h1><p>在ARM Linux系统中，内存管理的“区”（Zone）是对物理内存进行分类管理的逻辑概念，用于区分不同特性的内存区域，以便内核更高效地分配和管理内存。以下是关于ARM Linux内存管理中区的详细介绍：</p><h3 id="一、内存区的分类及作用"><a href="#一、内存区的分类及作用" class="headerlink" title="一、内存区的分类及作用"></a><strong>一、内存区的分类及作用</strong></h3><p>Linux内核根据物理内存的属性（如是否可直接映射到内核地址空间、是否支持DMA等），将内存划分为多个区。在ARM架构中，常见的内存区包括：</p><h4 id="1-ZONE-DMA（DMA区）"><a href="#1-ZONE-DMA（DMA区）" class="headerlink" title="1. ZONE_DMA（DMA区）"></a>1. <strong>ZONE_DMA（DMA区）</strong></h4><ul><li><strong>特点</strong>：<br>该区域的内存用于支持直接内存访问（DMA）操作，主要供外设（如网卡、硬盘控制器等）使用。这些外设通常只能访问低端内存地址，因此DMA区通常位于物理内存的低端（如ARM 32位系统中通常为前16MB）。</li><li><strong>作用</strong>：<br>确保外设通过DMA传输数据时能正确访问内存，避免因地址空间限制导致的兼容性问题。</li></ul><h4 id="2-ZONE-NORMAL（常规区）"><a href="#2-ZONE-NORMAL（常规区）" class="headerlink" title="2. ZONE_NORMAL（常规区）"></a>2. <strong>ZONE_NORMAL（常规区）</strong></h4><ul><li><strong>特点</strong>：<br>该区域是内核直接管理的常规内存，可直接映射到内核虚拟地址空间（即“线性映射”），内核可以高效地访问该区域的内存。  <ul><li>在32位ARM系统中，ZONE_NORMAL通常对应物理内存中高于DMA区且小于896MB的部分（受内核虚拟地址空间限制）。  </li><li>在64位ARM系统（如ARM64）中，由于虚拟地址空间足够大，ZONE_NORMAL可覆盖更大范围的内存。</li></ul></li><li><strong>作用</strong>：<br>是内核分配内存的主要区域，用于普通进程的内存分配、内核数据结构等。</li></ul><h4 id="3-ZONE-HIGHMEM（高端内存区，可选）"><a href="#3-ZONE-HIGHMEM（高端内存区，可选）" class="headerlink" title="3. ZONE_HIGHMEM（高端内存区，可选）"></a>3. <strong>ZONE_HIGHMEM（高端内存区，可选）</strong></h4><ul><li><strong>特点</strong>：<br>该区域的内存无法被内核直接线性映射到虚拟地址空间，需要通过动态映射（如临时映射或页表切换）才能访问。  <ul><li>在32位ARM系统中，当物理内存超过896MB时，超出部分会被划入ZONE_HIGHMEM（因32位内核虚拟地址空间有限，仅能线性映射前896MB）。  </li><li>在64位ARM系统中，由于虚拟地址空间足够大（如48位或更多），通常不需要ZONE_HIGHMEM（或该区域可能不存在）。</li></ul></li><li><strong>作用</strong>：<br>允许系统使用超过内核线性映射范围的内存，提高大内存系统的利用率（常见于32位系统）。</li></ul><h3 id="二、ARM架构下的内存管理特点"><a href="#二、ARM架构下的内存管理特点" class="headerlink" title="二、ARM架构下的内存管理特点"></a><strong>二、ARM架构下的内存管理特点</strong></h3><h4 id="1-32位ARM系统（如ARMv7）"><a href="#1-32位ARM系统（如ARMv7）" class="headerlink" title="1. 32位ARM系统（如ARMv7）"></a>1. <strong>32位ARM系统（如ARMv7）</strong></h4><ul><li><strong>地址空间限制</strong>：<br>内核虚拟地址空间通常为3GB（用户空间1GB，内核空间3GB），其中线性映射的物理内存上限约为896MB（剩余空间用于内核代码、页表等）。  </li><li><strong>分区逻辑</strong>：  <ul><li><strong>ZONE_DMA</strong>：前16MB（典型值，可通过内核配置调整）。  </li><li><strong>ZONE_NORMAL</strong>：16MB ~ 896MB。  </li><li><strong>ZONE_HIGHMEM</strong>：896MB以上（若物理内存超过该值）。</li></ul></li></ul><h4 id="2-64位ARM系统（如ARM64-ARMv8）"><a href="#2-64位ARM系统（如ARM64-ARMv8）" class="headerlink" title="2. 64位ARM系统（如ARM64&#x2F;ARMv8）"></a>2. <strong>64位ARM系统（如ARM64&#x2F;ARMv8）</strong></h4><ul><li><strong>地址空间优势</strong>：<br>内核虚拟地址空间可达48位（如Linux内核在ARM64上使用48位虚拟地址），可直接映射更大范围的物理内存（如1TB），因此ZONE_HIGHMEM通常不再需要，内存主要分为：  <ul><li><strong>ZONE_DMA</strong>：若外设支持64位DMA地址，可能需要更大的DMA区（如全部内存均可用于DMA，具体取决于硬件支持）。  </li><li><strong>ZONE_NORMAL</strong>：覆盖几乎所有物理内存，内核可直接线性映射。</li></ul></li></ul><h3 id="三、内存区的管理机制"><a href="#三、内存区的管理机制" class="headerlink" title="三、内存区的管理机制"></a><strong>三、内存区的管理机制</strong></h3><h4 id="1-伙伴系统（Buddy-System）"><a href="#1-伙伴系统（Buddy-System）" class="headerlink" title="1. 伙伴系统（Buddy System）"></a>1. <strong>伙伴系统（Buddy System）</strong></h4><ul><li>每个区独立使用伙伴系统管理空闲内存块，以页（通常为4KB）为单位进行分配和回收，避免内存碎片。  </li><li>内核根据分配请求的大小（如申请多个页），在对应的区中查找合适的空闲块。</li></ul><h4 id="2-页分配器（Page-Allocator）"><a href="#2-页分配器（Page-Allocator）" class="headerlink" title="2. 页分配器（Page Allocator）"></a>2. <strong>页分配器（Page Allocator）</strong></h4><ul><li>内核通过<code>alloc_pages()</code>等接口从指定区分配内存，可指定分配策略（如是否允许从高端内存分配、是否使用DMA等）。  </li><li>例如，外设驱动申请DMA内存时，会明确要求从ZONE_DMA分配。</li></ul><h4 id="3-高端内存的映射机制（仅32位系统）"><a href="#3-高端内存的映射机制（仅32位系统）" class="headerlink" title="3. 高端内存的映射机制（仅32位系统）"></a>3. <strong>高端内存的映射机制（仅32位系统）</strong></h4><ul><li>对于ZONE_HIGHMEM中的页，内核通过以下方式访问：  <ul><li><strong>永久映射</strong>：使用固定的虚拟地址范围动态映射高端内存页。  </li><li><strong>临时映射</strong>：使用临时虚拟地址（如<code>kmap_atomic()</code>）短期映射页，适用于中断处理等场景。</li></ul></li></ul><h3 id="四、查看内存区信息"><a href="#四、查看内存区信息" class="headerlink" title="四、查看内存区信息"></a><strong>四、查看内存区信息</strong></h3><p>在ARM Linux系统中，可通过以下命令查看内存区划分和使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统内存区的总体信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/zoneinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例输出（部分字段）：</span></span><br><span class="line">Node 0, zone      DMA</span><br><span class="line">  pages free     1234</span><br><span class="line">  pages total    16384  <span class="comment"># DMA区总页数（如16MB = 16*1024KB / 4KB = 4096页，示例中可能为不同配置）</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">Node 0, zone    Normal</span><br><span class="line">  pages free     56789</span><br><span class="line">  pages total    2097152  <span class="comment"># 常规区总页数（如896MB = 896*1024KB /4KB = 229376页，示例中可能为更大内存）</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a><strong>五、总结</strong></h3><ul><li><strong>分区目的</strong>：通过将内存按特性分区，Linux内核可针对不同场景（如DMA、常规访问、大内存支持）优化内存分配，提高系统稳定性和效率。  </li><li><strong>ARM架构差异</strong>：32位系统受地址空间限制，需通过ZONE_HIGHMEM利用大内存；64位系统因虚拟地址空间充足，分区逻辑更简单。  </li><li><strong>核心概念</strong>：伙伴系统、页分配策略、DMA兼容性是理解内存区管理的关键。</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="slab层"><a href="#slab层" class="headerlink" title="slab层"></a>slab层</h2><p>在Linux内核里，slab层（也被叫做slab分配器）是内存管理系统的重要组成部分。它的主要作用是高效地分配和释放内核对象，像task_struct、file_struct这类经常使用的结构体实例都能通过它来管理。下面详细介绍slab层的相关内容：</p><h3 id="基本概念与设计目标"><a href="#基本概念与设计目标" class="headerlink" title="基本概念与设计目标"></a>基本概念与设计目标</h3><ul><li><strong>解决内存碎片问题</strong>：当系统频繁地分配和释放小块内存时，容易产生内存碎片。slab分配器通过缓存机制，将这些小块内存进行复用，从而避免了碎片的产生。</li><li><strong>提升分配效率</strong>：传统的内存分配方式，比如直接使用页分配器，会带来较大的开销。而slab分配器会预先分配一组对象，并将它们缓存起来。这样在需要的时候，就能快速地分配和释放内存，大大提高了效率。</li><li><strong>减少初始化开销</strong>：对于一些需要复杂初始化的对象，slab分配器会提前完成初始化，然后进行缓存。当用户请求分配内存时，直接使用这些已经初始化好的对象，减少了重复初始化的开销。</li></ul><h3 id="核心组件与工作原理"><a href="#核心组件与工作原理" class="headerlink" title="核心组件与工作原理"></a>核心组件与工作原理</h3><p>slab层的架构主要包含以下几个核心组件：</p><ul><li><strong>Cache（缓存）</strong>：每一种内核对象类型，比如inode、file等，都有对应的cache。每个cache负责管理特定类型对象的分配和释放。</li><li><strong>Slab（ slabs ）</strong>：Cache由一个或多个slab组成，slab实际上就是一组物理页面。它存在三种状态：满（所有对象都已被分配）、部分满（还有部分对象未被分配）和空（所有对象都未被分配）。</li><li><strong>对象（Objects）</strong>：内核所使用的实际数据结构，它们被分配在slab中。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><strong>缓存初始化</strong>：在内核启动或者模块加载的时候，会为特定类型的对象创建缓存。</li><li><strong>对象分配</strong>：当需要分配一个对象时，slab分配器会先查看部分满的slab中是否有空闲对象。如果有，就直接分配；如果没有，再去空的slab中查找；若还是没有，就会从页分配器中获取新的内存页，创建一个新的slab。</li><li><strong>对象释放</strong>：当释放一个对象时，该对象会被标记为空闲，但不会立即返回给系统，而是留在缓存中，等待下次分配使用。</li><li><strong>缓存收缩</strong>：在内存紧张的情况下，slab分配器会回收一些空的slab，将内存归还给系统。</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><strong>避免内部碎片</strong>：slab分配器会根据对象的实际大小来调整分配策略，从而减少了内部碎片的产生。</li><li><strong>快速分配与释放</strong>：由于使用了缓存机制，避免了频繁调用页分配器，使得内存的分配和释放速度大幅提升。</li><li><strong>减少初始化开销</strong>：对于一些需要复杂初始化的对象，slab分配器通过预先初始化并缓存这些对象，减少了重复初始化的开销。</li></ul><h3 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h3><p>在Linux内核的发展过程中，基于slab分配器又衍生出了一些相关技术：</p><ul><li><strong>Slob分配器</strong>：这是一种简化版的slab分配器，主要用于资源受限的系统，比如嵌入式系统。</li><li><strong>Slub分配器</strong>：对slab分配器进行了优化，提高了性能，并且降低了内存的使用量，现在已经成为主流的分配器。</li><li><strong>Slub分配器</strong>：进一步优化了内存使用效率，特别是在64位系统上表现更为出色。</li></ul><h3 id="与其他内存分配器的关系"><a href="#与其他内存分配器的关系" class="headerlink" title="与其他内存分配器的关系"></a>与其他内存分配器的关系</h3><p>slab层位于Linux内存管理架构的中间层，它的上层是各种内核组件，下层是页分配器（如伙伴系统）和vmalloc机制。具体关系如下：</p><ul><li><strong>页分配器</strong>：负责管理物理内存页，为slab分配器提供内存页。</li><li><strong>Slab分配器</strong>：基于页分配器提供的内存页，管理小块内存的分配和释放。</li><li><strong>Vmalloc</strong>：用于分配大块的虚拟地址空间，这些空间对应的物理页可能是不连续的。</li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面通过一个简单的代码示例，展示如何在内核模块中使用slab分配器：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个简单的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_object</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个kmem_cache对象</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">my_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的缓存</span></span><br><span class="line">    my_cache = kmem_cache_create(<span class="string">&quot;my_cache&quot;</span>, </span><br><span class="line">                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> my_object),</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                SLAB_HWCACHE_ALIGN,</span><br><span class="line">                                <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!my_cache) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to create cache\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从缓存中分配一个对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_object</span> *<span class="title">obj</span> =</span> kmem_cache_alloc(my_cache, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 初始化对象</span></span><br><span class="line">        obj-&gt;data = <span class="number">42</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(obj-&gt;name, <span class="string">&quot;example&quot;</span>);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;Allocated object: data=%d, name=%s\n&quot;</span>, obj-&gt;data, obj-&gt;name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放对象</span></span><br><span class="line">        kmem_cache_free(my_cache, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 销毁缓存</span></span><br><span class="line">    kmem_cache_destroy(my_cache);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>slab层是Linux内核内存管理的关键技术，它通过缓存机制高效地管理小块内存，避免了内存碎片，提高了系统性能。在现代Linux系统中，虽然slab分配器已经演变成了slub分配器，但基本的设计理念仍然保持不变。</p><h2 id="用户在函数栈上进行static"><a href="#用户在函数栈上进行static" class="headerlink" title="用户在函数栈上进行static"></a>用户在函数栈上进行static</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>栈内存分配</strong>：由操作系统自动管理，函数的局部变量、参数以及返回地址等都存放在这里。它的分配和释放遵循后进先出（LIFO）的原则，效率很高。栈内存的空间是有限的，通常只有几MB到几GB。</li><li><strong>静态内存分配</strong>：程序在编译时就确定了所需的内存空间，这些内存会被分配到数据段（已初始化的静态变量和全局变量）或BSS段（未初始化的静态变量和全局变量）。静态分配的内存，其生命周期贯穿整个程序运行期间。</li><li><strong>堆内存分配</strong>：这是一种动态内存分配方式，程序在运行时通过系统调用（如malloc、new）来申请内存。堆内存的空间较大，但管理起来比较复杂，容易出现内存泄漏和碎片问题。</li></ul><h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>栈分配</strong></th><th><strong>静态分配</strong></th><th><strong>堆分配</strong></th></tr></thead><tbody><tr><td><strong>分配时间</strong></td><td>程序运行时</td><td>编译时</td><td>程序运行时</td></tr><tr><td><strong>释放时间</strong></td><td>函数返回时</td><td>程序结束时</td><td>手动释放（如free、delete）</td></tr><tr><td><strong>内存区域</strong></td><td>栈</td><td>数据段&#x2F;BSS段</td><td>堆</td></tr><tr><td><strong>生命周期</strong></td><td>函数调用期间</td><td>整个程序运行期间</td><td>从分配到释放</td></tr><tr><td><strong>效率</strong></td><td>高（硬件支持）</td><td>高（编译时确定）</td><td>低（需要系统调用）</td></tr><tr><td><strong>灵活性</strong></td><td>低（大小固定）</td><td>低（大小固定）</td><td>高（动态调整）</td></tr></tbody></table><h3 id="常见混淆点"><a href="#常见混淆点" class="headerlink" title="常见混淆点"></a>常见混淆点</h3><p>用户提到的“在栈上进行静态分配”可能是以下几种情况：</p><ol><li><strong>栈上的自动变量</strong>：这是最常见的栈内存使用方式，函数内的局部变量（非static）都属于此类。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 在栈上分配</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];  <span class="comment">// 在栈上分配</span></span><br><span class="line">&#125;  <span class="comment">// 函数返回时，这些变量自动释放</span></span><br></pre></td></tr></table></figure></li><li><strong>静态局部变量</strong>：虽然使用了<code>static</code>关键字，但实际上是在静态存储区分配内存，而不是在栈上。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 在数据段分配，只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;  <span class="comment">// 函数返回后，count的值仍然保留</span></span><br></pre></td></tr></table></figure></li><li><strong>静态数组</strong>：同样是在静态存储区分配内存，而不是在栈上。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">1024</span>];  <span class="comment">// 静态存储区，全局可见（如果是文件作用域）</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="栈分配的特点"><a href="#栈分配的特点" class="headerlink" title="栈分配的特点"></a>栈分配的特点</h3><ul><li><strong>优点</strong>：分配和释放速度快，由硬件（栈指针）直接管理；不会产生内存碎片。</li><li><strong>缺点</strong>：栈空间有限，分配过大的数组或递归过深可能会导致栈溢出（Stack Overflow）。</li><li><strong>适用场景</strong>：局部变量、函数调用上下文、小型临时数据存储。</li></ul><h3 id="静态分配的特点"><a href="#静态分配的特点" class="headerlink" title="静态分配的特点"></a>静态分配的特点</h3><ul><li><strong>优点</strong>：无需运行时开销，访问速度快；数据持久性强（整个程序运行期间都存在）。</li><li><strong>缺点</strong>：内存使用不灵活，一旦分配就无法调整大小；可能导致全局变量滥用，影响代码的可维护性。</li><li><strong>适用场景</strong>：配置参数、全局状态、需要持久保存的数据。</li></ul><h3 id="动态分配（堆）的特点"><a href="#动态分配（堆）的特点" class="headerlink" title="动态分配（堆）的特点"></a>动态分配（堆）的特点</h3><ul><li><strong>优点</strong>：灵活，可以在运行时根据需要分配和释放内存；适用于存储大小不确定或生命周期复杂的数据。</li><li><strong>缺点</strong>：分配和释放开销大；容易出现内存泄漏和碎片问题；需要手动管理内存。</li><li><strong>适用场景</strong>：动态数据结构（如链表、树）、大型对象、需要跨函数共享的数据。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在实际编程中，应该根据数据的生命周期、大小和使用方式来选择合适的内存分配方式：</p><ul><li>如果数据是局部的、短期使用的，并且大小固定，那么选择栈分配。</li><li>如果数据需要在整个程序运行期间存在，或者需要跨函数共享，那么选择静态分配。</li><li>如果数据的大小不确定，或者需要动态调整，那么选择堆分配。</li></ul><p>要避免“在栈上进行静态分配”这种错误的概念，正确理解栈、静态存储区和堆的工作原理，是写出高效、安全代码的关键。</p><h2 id="单页内核栈"><a href="#单页内核栈" class="headerlink" title="单页内核栈"></a>单页内核栈</h2><p>在 Linux 内核中，<strong>单页内核栈（Single Page Kernel Stack）</strong> 是一种内核栈内存分配优化技术，主要用于减少每个进程&#x2F;线程的内核栈内存占用。传统内核栈通常使用两个物理页面（例如在 x86_64 架构上为 8KB），而单页内核栈将其压缩到一个页面（通常为 4KB），从而显著节省内存资源。</p><h3 id="背景与动机"><a href="#背景与动机" class="headerlink" title="背景与动机"></a><strong>背景与动机</strong></h3><ol><li><strong>内存效率问题</strong>：传统的双页内核栈（如 8KB）在现代服务器环境中会造成大量内存浪费。例如，一个拥有 10 万个进程的系统会额外占用约 781MB 内存。</li><li><strong>内核栈溢出风险</strong>：虽然栈空间减小，但现代内核通过更严格的栈检查和优化（如<code>WARN_ON()</code>机制）降低了溢出风险。</li><li><strong>嵌入式系统需求</strong>：在资源受限的设备（如 IoT、嵌入式系统）中，单页内核栈能有效减少内存使用。</li></ol><h3 id="单页内核栈的实现"><a href="#单页内核栈的实现" class="headerlink" title="单页内核栈的实现"></a><strong>单页内核栈的实现</strong></h3><ol><li><p><strong>配置选项</strong>：<br>内核需启用 <code>CONFIG_THREAD_INFO_IN_TASK</code> 和 <code>CONFIG_SINGLE_THREAD_INFO</code> 选项，将线程信息嵌入进程描述符（<code>task_struct</code>），而非单独分配空间。</p></li><li><p><strong>内存布局</strong>：<br>单页内核栈通常与 <code>thread_info</code> 结构共享一个页面，布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+  &lt;- 栈顶（高地址）</span><br><span class="line">|      内核栈       |</span><br><span class="line">+-------------------+</span><br><span class="line">|                   |</span><br><span class="line">|                   |</span><br><span class="line">+-------------------+</span><br><span class="line">|    thread_info    |</span><br><span class="line">+-------------------+  &lt;- 栈底（低地址）</span><br></pre></td></tr></table></figure></li><li><p><strong>栈溢出检测</strong>：<br>内核通过以下机制避免溢出：</p><ul><li><strong>金丝雀值（Stack Canary）</strong>：在栈底放置特殊值，函数返回时检查其完整性。</li><li><strong>动态栈扩展</strong>：当栈接近耗尽时，通过 <code>expand_stack()</code> 动态分配额外空间（需内核支持）。</li></ul></li></ol><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a><strong>优缺点分析</strong></h3><table><thead><tr><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>减少内存占用（每个进程节省 4KB）</td><td>栈空间更小，可能触发溢出</td></tr><tr><td>提高缓存利用率</td><td>需更严格的栈使用规范</td></tr><tr><td>适合嵌入式系统和内存紧张的环境</td><td>部分内核特性可能受限（如深度递归）</td></tr></tbody></table><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h3><ol><li><strong>内存受限系统</strong>：如嵌入式设备、容器环境（cgroups）。</li><li><strong>高并发服务器</strong>：减少每个线程的内存开销，提升系统吞吐量。</li><li><strong>内核开发</strong>：通过 <code>CONFIG_DEBUG_STACK_USAGE</code> 选项监控栈使用情况。</li></ol><h3 id="如何启用单页内核栈"><a href="#如何启用单页内核栈" class="headerlink" title="如何启用单页内核栈"></a><strong>如何启用单页内核栈</strong></h3><ol><li><p>在编译内核时，配置以下选项：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_THREAD_INFO_IN_TASK=y</span><br><span class="line">CONFIG_SINGLE_THREAD_INFO=y</span><br><span class="line">CONFIG_PAGE_OFFSET_IS_BASE=y</span><br></pre></td></tr></table></figure></li><li><p>验证内核是否启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zgrep CONFIG_THREAD_INFO_IN_TASK /proc/config.gz</span><br></pre></td></tr></table></figure></li></ol><h3 id="相关内核代码"><a href="#相关内核代码" class="headerlink" title="相关内核代码"></a><strong>相关内核代码</strong></h3><p>内核中与单页内核栈相关的关键文件包括：</p><ul><li><code>arch/x86/include/asm/stack.h</code>：定义栈布局和大小。</li><li><code>include/linux/thread_info.h</code>：管理 <code>thread_info</code> 与栈的关系。</li><li><code>mm/stacktrace.c</code>：实现栈跟踪和溢出检测。</li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>单页内核栈是一种通过压缩内核栈空间来优化内存使用的技术，适用于对内存敏感的场景。虽然它减少了每个进程的内存占用，但需要内核更严格地控制栈使用，并依赖溢出检测机制确保安全。在实际应用中，需根据系统需求权衡内存节省与潜在风险。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统调用</title>
      <link href="/posts/4f5d4e8d.html"/>
      <url>/posts/4f5d4e8d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、系统调用号"><a href="#1、系统调用号" class="headerlink" title="1、系统调用号"></a>1、系统调用号</h1><h2 id="asmlinkage"><a href="#asmlinkage" class="headerlink" title="asmlinkage"></a>asmlinkage</h2><p>asmlinkage：asmlinkage 是 Linux 内核中用于定义系统调用的函数的修饰符。asmlinkage 表示该函数是内核函数，不能被用户空间程序调用。只从栈中获取参数，返回结果也只通过栈返回。<br>在 Linux 系统中，每个系统调用都有一个唯一的系统调用号，用户空间程序通过这些系统调用号来请求内核执行特定的系统调用。不同的 Linux 内核版本和架构（如 x86、ARM 等）的系统调用号可能会有所不同。以下为你分别介绍常见架构下的部分系统调用及其系统调用号：</p><h3 id="x86-64-架构"><a href="#x86-64-架构" class="headerlink" title="x86_64 架构"></a>x86_64 架构</h3><p>在 x86_64 架构下，系统调用通过 <code>syscall</code> 指令发起，下面是一些常见系统调用及其系统调用号：</p><table><thead><tr><th>系统调用名</th><th>系统调用号</th><th>功能描述</th></tr></thead><tbody><tr><td><code>read</code></td><td>0</td><td>从文件描述符读取数据</td></tr><tr><td><code>write</code></td><td>1</td><td>向文件描述符写入数据</td></tr><tr><td><code>open</code></td><td>2</td><td>打开文件或设备</td></tr><tr><td><code>close</code></td><td>3</td><td>关闭文件描述符</td></tr><tr><td><code>stat</code></td><td>4</td><td>获取文件状态信息</td></tr><tr><td><code>fstat</code></td><td>5</td><td>通过文件描述符获取文件状态信息</td></tr><tr><td><code>lstat</code></td><td>6</td><td>获取符号链接的状态信息</td></tr><tr><td><code>poll</code></td><td>7</td><td>等待文件描述符上的 I&#x2F;O 事件</td></tr><tr><td><code>lseek</code></td><td>8</td><td>移动文件读写指针</td></tr><tr><td><code>mmap</code></td><td>9</td><td>内存映射文件或设备</td></tr><tr><td><code>munmap</code></td><td>11</td><td>解除内存映射</td></tr><tr><td><code>brk</code></td><td>12</td><td>调整数据段的大小</td></tr><tr><td><code>rt_sigaction</code></td><td>13</td><td>设置信号处理函数</td></tr><tr><td><code>rt_sigprocmask</code></td><td>14</td><td>阻塞或解除阻塞信号</td></tr><tr><td><code>rt_sigreturn</code></td><td>15</td><td>从信号处理程序返回</td></tr><tr><td><code>ioctl</code></td><td>16</td><td>对设备文件执行特定操作</td></tr><tr><td><code>pread64</code></td><td>17</td><td>从指定偏移量处读取数据</td></tr><tr><td><code>pwrite64</code></td><td>18</td><td>向指定偏移量处写入数据</td></tr><tr><td><code>readv</code></td><td>19</td><td>分散读</td></tr><tr><td><code>writev</code></td><td>20</td><td>集中写</td></tr><tr><td><code>access</code></td><td>21</td><td>检查文件的访问权限</td></tr><tr><td><code>pipe</code></td><td>22</td><td>创建管道</td></tr><tr><td><code>select</code></td><td>23</td><td>等待文件描述符上的 I&#x2F;O 事件</td></tr><tr><td><code>sched_yield</code></td><td>24</td><td>主动让出 CPU</td></tr></tbody></table><h3 id="ARM-架构"><a href="#ARM-架构" class="headerlink" title="ARM 架构"></a>ARM 架构</h3><p>ARM 架构下系统调用的实现和系统调用号也有其特点，以下是部分常见系统调用号：</p><table><thead><tr><th>系统调用名</th><th>系统调用号</th><th>功能描述</th></tr></thead><tbody><tr><td><code>read</code></td><td>3</td><td>从文件描述符读取数据</td></tr><tr><td><code>write</code></td><td>4</td><td>向文件描述符写入数据</td></tr><tr><td><code>open</code></td><td>5</td><td>打开文件或设备</td></tr><tr><td><code>close</code></td><td>6</td><td>关闭文件描述符</td></tr><tr><td><code>stat</code></td><td>106</td><td>获取文件状态信息</td></tr><tr><td><code>fstat</code></td><td>107</td><td>通过文件描述符获取文件状态信息</td></tr><tr><td><code>lstat</code></td><td>108</td><td>获取符号链接的状态信息</td></tr></tbody></table><p>你可以通过以下几种方式查看系统调用号：</p><ul><li><strong>查阅内核源码</strong>：Linux 内核源码中的 <code>include/uapi/asm-generic/unistd.h</code>（对于通用部分）以及 <code>arch/&lt;架构&gt;/include/uapi/asm/unistd.h</code>（对于特定架构）文件中定义了系统调用号。</li><li><strong>使用 <code>man</code> 手册</strong>：部分 <code>man</code> 手册页会提及系统调用号，例如 <code>man 2 syscalls</code>。</li><li><strong>使用 <code>syscall(2)</code> 手册</strong>：<code>man 2 syscall</code> 可以提供有关系统调用号的一些信息。</li></ul><h2 id="系统调用号传递给内核"><a href="#系统调用号传递给内核" class="headerlink" title="系统调用号传递给内核"></a>系统调用号传递给内核</h2><p>在 ARM Linux 系统中，当用户空间程序发起系统调用并陷入内核之前，需要将系统调用号以及相关参数传递给内核，主要通过以下方式实现：</p><h3 id="1-寄存器传递"><a href="#1-寄存器传递" class="headerlink" title="1. 寄存器传递"></a>1. 寄存器传递</h3><p>在 ARM 架构里，通常使用寄存器来传递系统调用号和参数。具体的寄存器分配规则由 ABI（Application Binary Interface）规定，常见的做法如下：</p><ul><li><strong>系统调用号传递</strong>：一般会把系统调用号存于特定的寄存器中，像 ARM EABI（Embedded Application Binary Interface）规定使用 <code>R7</code> 寄存器来存放系统调用号。例如，当用户程序要发起 <code>read</code> 系统调用时，会先把 <code>read</code> 对应的系统调用号加载到 <code>R7</code> 寄存器。</li><li><strong>参数传递</strong>：系统调用所需的参数会按顺序存于其他寄存器，常见的是 <code>R0 - R6</code> 寄存器。例如，<code>read</code> 系统调用需要文件描述符、缓冲区地址和读取字节数这三个参数，那么这些参数会依次存于 <code>R0</code>、<code>R1</code> 和 <code>R2</code> 寄存器。</li></ul><h3 id="2-代码示例（以汇编代码模拟系统调用）"><a href="#2-代码示例（以汇编代码模拟系统调用）" class="headerlink" title="2. 代码示例（以汇编代码模拟系统调用）"></a>2. 代码示例（以汇编代码模拟系统调用）</h3><p>以下是一个简单的 ARM 汇编代码示例，展示了如何通过 <code>svc</code> 指令发起 <code>write</code> 系统调用，同时传递系统调用号和参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    @ 数据段</span><br><span class="line">    .data</span><br><span class="line">message:</span><br><span class="line">    .ascii &quot;Hello, World!\n&quot;</span><br><span class="line">    .equ len, . - message</span><br><span class="line"></span><br><span class="line">    @ 代码段</span><br><span class="line">    .text</span><br><span class="line">    .global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    @ 设置系统调用号，write 系统调用号为 4</span><br><span class="line">    mov r7, #4      </span><br><span class="line">    @ 设置文件描述符，标准输出为 1</span><br><span class="line">    mov r0, #1      </span><br><span class="line">    @ 设置缓冲区地址</span><br><span class="line">    ldr r1, =message </span><br><span class="line">    @ 设置写入的字节数</span><br><span class="line">    mov r2, #len     </span><br><span class="line">    @ 触发系统调用</span><br><span class="line">    svc 0           </span><br><span class="line"></span><br><span class="line">    @ 设置退出系统调用号，exit 系统调用号为 1</span><br><span class="line">    mov r7, #1      </span><br><span class="line">    @ 设置退出状态码</span><br><span class="line">    mov r0, #0      </span><br><span class="line">    @ 触发系统调用</span><br><span class="line">    svc 0           </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li><strong>系统调用号设置</strong>：<code>mov r7, #4</code> 将 <code>write</code> 系统调用号 4 存于 <code>R7</code> 寄存器；<code>mov r7, #1</code> 把 <code>exit</code> 系统调用号 1 存于 <code>R7</code> 寄存器。</li><li><strong>参数设置</strong>：<code>mov r0, #1</code> 将标准输出的文件描述符 1 存于 <code>R0</code> 寄存器；<code>ldr r1, =message</code> 把要输出的字符串地址加载到 <code>R1</code> 寄存器；<code>mov r2, #len</code> 把字符串长度存于 <code>R2</code> 寄存器；<code>mov r0, #0</code> 将退出状态码 0 存于 <code>R0</code> 寄存器。</li><li><strong>触发系统调用</strong>：<code>svc 0</code> 指令触发异常，使处理器从用户模式切换到内核模式，内核依据 <code>R7</code> 寄存器中的系统调用号调用相应的系统调用处理函数，并使用 <code>R0 - R6</code> 寄存器中的参数执行具体操作。</li></ul><h3 id="3-高级语言中的封装"><a href="#3-高级语言中的封装" class="headerlink" title="3. 高级语言中的封装"></a>3. 高级语言中的封装</h3><p>在高级语言（如 C 语言）里，系统调用一般通过库函数进行封装。这些库函数会在内部完成系统调用号和参数的设置，然后触发 <code>svc</code> 指令。例如，在 C 语言中使用 <code>write</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    write(<span class="number">1</span>, message, <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译和执行这段代码时，<code>write</code> 库函数会把 <code>write</code> 系统调用号和参数按 ABI 规定存于相应寄存器，再触发 <code>svc</code> 指令来发起系统调用。 </p><h2 id="swi-指令"><a href="#swi-指令" class="headerlink" title="swi 指令"></a>swi 指令</h2><p>在早期的 ARM 架构中，确实使用 <code>SWI</code>（Software Interrupt，软件中断）指令来触发系统调用，不过后来逐渐被 <code>SVC</code>（Supervisor Call）指令所取代。下面为你详细介绍它们在传递系统调用号进入内核时的相关情况：</p><h3 id="使用-SWI-指令触发系统调用"><a href="#使用-SWI-指令触发系统调用" class="headerlink" title="使用 SWI 指令触发系统调用"></a>使用 <code>SWI</code> 指令触发系统调用</h3><h4 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h4><p><code>SWI</code> 指令是一种软中断指令，当执行该指令时，处理器会从用户模式切换到管理模式（Supervisor Mode），并跳转到异常向量表中 <code>SWI</code> 异常对应的入口地址，从而进入内核执行相应的异常处理程序。</p><h4 id="2-系统调用号传递"><a href="#2-系统调用号传递" class="headerlink" title="2. 系统调用号传递"></a>2. 系统调用号传递</h4><p>在使用 <code>SWI</code> 指令时，系统调用号通常被编码在 <code>SWI</code> 指令的立即数中。例如，<code>SWI</code> 指令的格式可能如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SWI &lt;imm24&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>&lt;imm24&gt;</code> 是一个 24 位的立即数，系统调用号就包含在这个立即数中。当执行 <code>SWI</code> 指令时，内核可以从这个立即数中提取出系统调用号，进而确定要执行的具体系统调用。</p><h4 id="3-代码示例（汇编）"><a href="#3-代码示例（汇编）" class="headerlink" title="3. 代码示例（汇编）"></a>3. 代码示例（汇编）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    @ 数据段</span><br><span class="line">    .data</span><br><span class="line">message:</span><br><span class="line">    .ascii &quot;Hello, World!\n&quot;</span><br><span class="line">    .equ len, . - message</span><br><span class="line"></span><br><span class="line">    @ 代码段</span><br><span class="line">    .text</span><br><span class="line">    .global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    @ 设置文件描述符，标准输出为 1</span><br><span class="line">    mov r0, #1      </span><br><span class="line">    @ 设置缓冲区地址</span><br><span class="line">    ldr r1, =message </span><br><span class="line">    @ 设置写入的字节数</span><br><span class="line">    mov r2, #len     </span><br><span class="line">    @ 触发 SWI 指令，假设 write 系统调用号编码在立即数中</span><br><span class="line">    swi #4          </span><br><span class="line"></span><br><span class="line">    @ 设置退出系统调用</span><br><span class="line">    mov r0, #0      @ 设置退出状态码</span><br><span class="line">    swi #1          @ 触发 SWI 指令，exit 系统调用号</span><br><span class="line"></span><br><span class="line">    @ 程序结束</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>swi #4</code> 触发了 <code>write</code> 系统调用，<code>swi #1</code> 触发了 <code>exit</code> 系统调用，系统调用号被直接编码在 <code>SWI</code> 指令的立即数中。</p><h3 id="从-SWI-到-SVC-的转变"><a href="#从-SWI-到-SVC-的转变" class="headerlink" title="从 SWI 到 SVC 的转变"></a>从 <code>SWI</code> 到 <code>SVC</code> 的转变</h3><p>随着 ARM 架构的发展，为了提高指令集的安全性和兼容性，引入了 <code>SVC</code> 指令来替代 <code>SWI</code> 指令。<code>SVC</code> 指令在功能上与 <code>SWI</code> 指令类似，也是用于触发系统调用，但它的设计更加清晰和安全。在使用 <code>SVC</code> 指令时，系统调用号通常通过寄存器（如 <code>R7</code>）传递，而不是编码在指令的立即数中。</p><h4 id="代码示例（使用-SVC-指令）"><a href="#代码示例（使用-SVC-指令）" class="headerlink" title="代码示例（使用 SVC 指令）"></a>代码示例（使用 <code>SVC</code> 指令）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    @ 数据段</span><br><span class="line">    .data</span><br><span class="line">message:</span><br><span class="line">    .ascii &quot;Hello, World!\n&quot;</span><br><span class="line">    .equ len, . - message</span><br><span class="line"></span><br><span class="line">    @ 代码段</span><br><span class="line">    .text</span><br><span class="line">    .global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    @ 设置系统调用号，write 系统调用号为 4</span><br><span class="line">    mov r7, #4      </span><br><span class="line">    @ 设置文件描述符，标准输出为 1</span><br><span class="line">    mov r0, #1      </span><br><span class="line">    @ 设置缓冲区地址</span><br><span class="line">    ldr r1, =message </span><br><span class="line">    @ 设置写入的字节数</span><br><span class="line">    mov r2, #len     </span><br><span class="line">    @ 触发 SVC 指令</span><br><span class="line">    svc 0           </span><br><span class="line"></span><br><span class="line">    @ 设置退出系统调用号，exit 系统调用号为 1</span><br><span class="line">    mov r7, #1      </span><br><span class="line">    @ 设置退出状态码</span><br><span class="line">    mov r0, #0      </span><br><span class="line">    @ 触发 SVC 指令</span><br><span class="line">    svc 0           </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，系统调用号通过 <code>R7</code> 寄存器传递，<code>svc 0</code> 指令触发系统调用进入内核。</p><p>综上所述，早期 ARM 架构使用 <code>SWI</code> 指令触发系统调用，系统调用号编码在指令立即数中；后来的架构采用 <code>SVC</code> 指令，系统调用号通过寄存器传递。 </p><h1 id="2、内核将数据接收，内核向用户空间返回数据"><a href="#2、内核将数据接收，内核向用户空间返回数据" class="headerlink" title="2、内核将数据接收，内核向用户空间返回数据"></a>2、内核将数据接收，内核向用户空间返回数据</h1><p>在 Linux 系统中，内核与用户空间的数据交互是一个关键操作，下面将详细介绍内核接收来自用户空间的数据以及将内核空间的数据传递给用户空间的相关内容。</p><h2 id="内核接收来自用户空间的数据"><a href="#内核接收来自用户空间的数据" class="headerlink" title="内核接收来自用户空间的数据"></a>内核接收来自用户空间的数据</h2><h3 id="1-系统调用中的参数传递"><a href="#1-系统调用中的参数传递" class="headerlink" title="1. 系统调用中的参数传递"></a>1. 系统调用中的参数传递</h3><p>当用户空间程序发起系统调用时，会将数据通过寄存器或栈传递给内核。在 ARM 架构中，常见的是使用寄存器传递参数，例如使用 <code>R0 - R6</code> 传递系统调用的参数。内核在处理系统调用时，会从这些寄存器中获取用户传递的数据。</p><h3 id="2-使用-copy-from-user-函数"><a href="#2-使用-copy-from-user-函数" class="headerlink" title="2. 使用 copy_from_user 函数"></a>2. 使用 <code>copy_from_user</code> 函数</h3><p>在系统调用处理函数中，如果需要将用户空间的大块数据复制到内核空间，通常会使用 <code>copy_from_user</code> 函数。该函数会检查用户空间地址的有效性，并将数据从用户空间复制到内核空间。</p><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_from_user</span><span class="params">(<span class="type">void</span> *to, <span class="type">const</span> <span class="type">void</span> __user *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>to</code>：指向内核空间的目标缓冲区。</li><li><code>from</code>：指向用户空间的源缓冲区。</li><li><code>n</code>：要复制的字节数。</li></ul><p><strong>返回值</strong>：如果复制成功，返回 0；如果出现错误，返回未复制的字节数。</p><p><strong>示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是一个系统调用处理函数</span></span><br><span class="line">SYSCALL_DEFINE1(my_syscall, <span class="type">char</span> __user *, user_buffer) &#123;</span><br><span class="line">    <span class="type">char</span> kernel_buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户空间的数据复制到内核空间</span></span><br><span class="line">    result = copy_from_user(kernel_buffer, user_buffer, <span class="keyword">sizeof</span>(kernel_buffer));</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to copy data from user space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理内核空间的数据</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Received data from user space: %s\n&quot;</span>, kernel_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核将数据传递给用户空间"><a href="#内核将数据传递给用户空间" class="headerlink" title="内核将数据传递给用户空间"></a>内核将数据传递给用户空间</h2><h3 id="1-使用-copy-to-user-函数"><a href="#1-使用-copy-to-user-函数" class="headerlink" title="1. 使用 copy_to_user 函数"></a>1. 使用 <code>copy_to_user</code> 函数</h3><p>与 <code>copy_from_user</code> 函数相对应，<code>copy_to_user</code> 函数用于将内核空间的数据复制到用户空间。该函数同样会检查用户空间地址的有效性，并将数据从内核空间复制到用户空间。</p><p><strong>函数原型</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">copy_to_user</span><span class="params">(<span class="type">void</span> __user *to, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">long</span> n)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>to</code>：指向用户空间的目标缓冲区。</li><li><code>from</code>：指向内核空间的源缓冲区。</li><li><code>n</code>：要复制的字节数。</li></ul><p><strong>返回值</strong>：如果复制成功，返回 0；如果出现错误，返回未复制的字节数。</p><p><strong>示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这是一个系统调用处理函数</span></span><br><span class="line">SYSCALL_DEFINE1(my_syscall, <span class="type">char</span> __user *, user_buffer) &#123;</span><br><span class="line">    <span class="type">char</span> kernel_buffer[] = <span class="string">&quot;Hello from kernel!&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将内核空间的数据复制到用户空间</span></span><br><span class="line">    result = copy_to_user(user_buffer, kernel_buffer, <span class="keyword">sizeof</span>(kernel_buffer));</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to copy data to user space\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h3><ul><li><strong>地址有效性检查</strong>：在使用 <code>copy_from_user</code> 和 <code>copy_to_user</code> 函数时，内核会自动检查用户空间地址的有效性，以防止用户程序传递无效的地址。</li><li><strong>权限问题</strong>：内核需要确保用户程序具有访问目标缓冲区的权限，避免数据泄露或越界访问。</li><li><strong>错误处理</strong>：在复制数据时，可能会出现各种错误，如内存不足、地址无效等，因此需要进行适当的错误处理。</li></ul><p>通过上述方法，内核可以安全、有效地与用户空间进行数据交互。</p><p>当系统调用返回的时候，控制权在system_call()函数中，返回给用户空间。</p><h1 id="3、我们的实现一个系统调用"><a href="#3、我们的实现一个系统调用" class="headerlink" title="3、我们的实现一个系统调用"></a>3、我们的实现一个系统调用</h1><p>系统调用号实现自己的比较简单，这里不做说明。可以百度到</p><p>对于想在内核中获取信息传递到应用层。可以使用一个设备节点，对节点进行读写操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程</title>
      <link href="/posts/31a6b40.html"/>
      <url>/posts/31a6b40.html</url>
      
        <content type="html"><![CDATA[<h1 id="2、进程调度"><a href="#2、进程调度" class="headerlink" title="2、进程调度"></a>2、进程调度</h1><p>多任务系统有两种类型：抢占式多任务和非抢占式多任务系统。<br>linux是抢占式内核。早期有非抢占式版本。<br>进程调度有两种算法：O(1)和反转楼梯最后期限调度算法。<br>O(1)算法：这个算法在交互式桌面上表现不佳，后来转为linux的交互式桌面提出了反转楼梯最后期限调度算法。<br>进程可分为I&#x2F;O消耗型和CPU消耗型进程。</p><h2 id="2-1、程序调度优先级"><a href="#2-1、程序调度优先级" class="headerlink" title="2-1、程序调度优先级"></a>2-1、程序调度优先级</h2><p>linux系统偏向于调度I&#x2F;O消耗型进程，I&#x2F;O消耗型进程的优先级比CPU消<br>耗型进程高。但并不是忽略cpu消耗型进程。<br>linux有设定两种优先级配置。一种时用nice值来设置优先级，<br>优先级越大，nice值越小。范围是-20到19，-20是最高优先级，<br>19是最低优先级。使用<code>ps -el</code>查看进程表，其中标记NI就是nice值。<br>第二种是实时优先级，<code>ps -eo pid,rtprio,comm</code>命令可以查看实时优先级。<br>这两个优先级相互不统筹。</p><h2 id="2-2、时间片"><a href="#2-2、时间片" class="headerlink" title="2-2、时间片"></a>2-2、时间片</h2><p>时间片会影响I&#x2F;O消耗型和cpu消耗型。<br>I&#x2F;O消耗性不需要长时间片，cpu消耗型则越长越好，以增加高速缓冲的命中率。<br>linux并不是直接分配时间片到进程，而是直接分配处理器使用比例。<br>这样，每个进程所使用的的时间就和系统的负载密切相关。<br>如一个进程消耗的使用占比消耗的占比比当前的小，那么这个进程会被立刻执行。否则推迟运行。</p><p>一个简要例子：一个按键输入文字，一个视频处理程序。按键处理时间很短，程序运行的也很短，视频处理很长，当两者优先级一样时，各占百分之50处理器处理比重，当按键操作时，因为按键处理的时间短，所以会被立刻执行。按键处理肯定要优先处理，不然会让用户体验上不是很好。</p><h2 id="2-3、调度器类"><a href="#2-3、调度器类" class="headerlink" title="2-3、调度器类"></a>2-3、调度器类</h2><p>linux的调度器类是按模块提供的，允许不同的进程使用不同的调度器类，比如：CFS–完全公平调度器，针对普通进程，基础的调度器定义在<code>kernel/sched.c</code>中。linux的两种调度依靠CFS分配。</p><h2 id="2-4、进程调度主要依靠四部分"><a href="#2-4、进程调度主要依靠四部分" class="headerlink" title="2-4、进程调度主要依靠四部分"></a>2-4、进程调度主要依靠四部分</h2><h3 id="2-4-1、时间记账"><a href="#2-4-1、时间记账" class="headerlink" title="2-4-1、时间记账"></a>2-4-1、时间记账</h3><p>所有调度器都需要对进程进行时间记账。当每次系统时钟节拍发送变化时，都需要减少一个节拍时间，当减少为0时，进程就会被可运行的进程抢占。</p><h3 id="2-4-2、进程选择"><a href="#2-4-2、进程选择" class="headerlink" title="2-4-2、进程选择"></a>2-4-2、进程选择</h3><p>CFS调度器使用红黑树来组织可运行进程队列。宏黑树也称为自平衡二叉搜索树。</p><h3 id="2-4-3、调度器入口"><a href="#2-4-3、调度器入口" class="headerlink" title="2-4-3、调度器入口"></a>2-4-3、调度器入口</h3><p>进程的调度器入口函数时schedule()。</p><h3 id="2-4-4、休眠和唤醒"><a href="#2-4-4、休眠和唤醒" class="headerlink" title="2-4-4、休眠和唤醒"></a>2-4-4、休眠和唤醒</h3><p>休眠是一个特殊的状态，如果没有这个状态，调度程序可能会选出一个没有意义的进程来执行。</p><p>过程：进程把自己标记成休眠状态，然后把自己从可执行红黑树中移除。放入到等待队列中，等待被唤醒。被唤醒后，进程被设置为可执行状态<br>，被放入到可执行红黑树中。被schedule()调用。</p><h2 id="2-5、抢占和上下文切换"><a href="#2-5、抢占和上下文切换" class="headerlink" title="2-5、抢占和上下文切换"></a>2-5、抢占和上下文切换</h2><p>用户抢占发生情况：<br>含义：当一个用户空间进程在运行时，系统可通过调度器中断该进程，让更高优先级的进程优先执行。</p><ul><li>触发场景：<br>  进程主动放弃 CPU（如调用sleep等函数）。<br>  进程时间片耗尽。<br>  有更高优先级进程进入就绪状态（如实时进程唤醒）。</li><li>实现基础：<br>  依赖 CPU 的中断机制和进程调度器（如 CFS 调度器）。</li></ul><p>内核抢占<br>含义：内核代码在执行时，允许被更高优先级的任务中断，转而执行其他内核任务或用户进程。</p><ul><li><p>触发场景：</p><p>  内核中存在显式的抢占点（如调度器函数schedule()）。<br>  内核代码执行时，若开启抢占（通过preempt_enable），<br>  且满足抢占条件（如更高优先级任务就绪）。</p></li><li><p>关键点：</p><p>  需处理内核临界资源的互斥（如自旋锁），避免竞态条件。</p></li></ul><p>总结：</p><pre><code>用户抢占确保用户进程间的公平调度，提升响应速度。内核抢占让内核能及时响应高优先级任务（如硬件中断处理），避免内核代码长期占用 CPU，提升系统整体实时性和吞吐量。</code></pre><h2 id="2-6、实时调度策略"><a href="#2-6、实时调度策略" class="headerlink" title="2-6、实时调度策略"></a>2-6、实时调度策略</h2><p>Linux的实时调度策略旨在为对时间敏感度较高的任务提供更可靠的响应和执行保证，主要有以下两种：</p><ul><li><strong>SCHED_FIFO</strong><ul><li><strong>特点</strong>：先进先出调度策略。一旦任务进入就绪状态，它将一直运行，直到完成或者被更高优先级的实时任务抢占。这种策略下，相同优先级的任务按照进入就绪队列的顺序依次执行，不会发生时间片轮转。</li><li><strong>适用场景</strong>：适用于那些对时间确定性要求极高、不希望被其他低优先级任务干扰的实时任务，如工业控制中的实时数据采集和处理任务。</li></ul></li><li><strong>SCHED_RR</strong><ul><li><strong>特点</strong>：时间片轮转调度策略。与SCHED_FIFO类似，具有较高优先级的任务会优先执行，但不同的是，相同优先级的任务会分配一个时间片，当时间片用完后，如果该任务还未执行完，它将被放回就绪队列尾部，等待下一次调度，以此实现相同优先级任务之间的公平轮转执行。</li><li><strong>适用场景</strong>：适用于那些需要在多个实时任务之间实现公平共享CPU资源，同时又有一定时间限制的场景，例如实时多媒体应用中的音频和视频流处理。</li></ul></li></ul><p>在Linux中，还可以通过<code>chrt</code>命令或者编程方式使用<code>setpriority</code>等函数来设置进程的调度策略和优先级，以满足不同实时应用的需求。</p><h2 id="2-7、调度相关的系统调用"><a href="#2-7、调度相关的系统调用" class="headerlink" title="2-7、调度相关的系统调用"></a>2-7、调度相关的系统调用</h2><p>以下是Linux中与调度相关的常见系统调用及其功能：</p><ol><li>**<code>sched_setscheduler</code>**：为指定进程或线程设置调度策略和优先级。</li><li>**<code>sched_getscheduler</code>**：获取指定进程或线程的当前调度策略。</li><li>**<code>sched_setparam</code>**：设置指定进程或线程的调度参数（主要是优先级）。</li><li>**<code>sched_getparam</code>**：获取指定进程或线程的调度参数。</li><li>**<code>sched_yield</code>**：当前进程主动放弃CPU，让调度器选择其他进程运行。</li><li>**<code>sched_get_priority_max</code>**：返回指定调度策略可使用的最大优先级。</li><li>**<code>sched_get_priority_min</code>**：返回指定调度策略可使用的最小优先级。</li><li>**<code>sched_rr_get_interval</code>**：获取采用<code>SCHED_RR</code>（轮转调度）策略的进程的时间片长度。</li><li>**<code>sched_setaffinity</code>**：设置指定进程或线程的CPU亲和性，即限制其只能在某些CPU上运行。</li><li>**<code>sched_getaffinity</code>**：获取指定进程或线程的CPU亲和性掩码。</li></ol><p>之前的设置<br>nice值也可以设置，如**<code>nice()</code>**<br>这里很多，不举例。</p><p>总的来说，有调度相关的，优先级相关的，处理器绑定的，放弃处理器的调度的相关系统调用。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>input子系统</title>
      <link href="/posts/a0e06ac4.html"/>
      <url>/posts/a0e06ac4.html</url>
      
        <content type="html"><![CDATA[<h1 id="input子系统"><a href="#input子系统" class="headerlink" title="input子系统"></a>input子系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>input子系统是linux内核针对某一类型的设备而创建的，比如键盘、鼠标、触摸屏、手柄等。input子系统分为以下几部分：input驱动层，input核心层，input事件层。</p><p><img src="./../../../../img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/input%E5%AD%90%E7%B3%BB%E7%BB%9F/1%E3%80%81%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="子设备"></p><p>上图中，最左边的就是具体的设备,这个不用管。<br>中间部分就是我们要关注的input驱动层，input核心层，input事件层。<br>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。<br>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。<br>事件层：主要和用户空间进行交互。</p><p>drivers&#x2F;input&#x2F;input.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">     INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个文件中注册了一个类，设备号是13</p><h2 id="输入设备注册"><a href="#输入设备注册" class="headerlink" title="输入设备注册"></a>输入设备注册</h2><p>在使用 input 子系统的时候我们只需要注册一个 input 设备即可，input_dev 结构体表示 input设备，此结构体定义在 include&#x2F;linux&#x2F;input.h 文件中，定义如下(部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];</span><br></pre></td></tr></table></figure><p>evbit 表示输入事件类型，可选的事件类型定义在 include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件<br>中，事件类型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MAX0x1f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_CNT(EV_MAX+1)</span></span><br></pre></td></tr></table></figure><p>evbit、keybit、relbit 等等都是存放不同<br>事件对应的值。比如要使用按键事件，<br>因此要用到 keybit，keybit 就是按键事件使用的位图，<br>Linux 内核定义了很多按键值，<br>这些按键值定义在include&#x2F;uapi&#x2F;linux&#x2F;input.h 文件中，按键值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_78</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发与竞争</title>
      <link href="/posts/bcc2870b.html"/>
      <url>/posts/bcc2870b.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、应用层的锁和内核中的锁区别"><a href="#1、应用层的锁和内核中的锁区别" class="headerlink" title="1、应用层的锁和内核中的锁区别"></a>1、应用层的锁和内核中的锁区别</h1><h2 id="1-1、特性"><a href="#1-1、特性" class="headerlink" title="1-1、特性"></a>1-1、特性</h2><h3 id="1-1-1、-内核锁（Kernel-Locks）"><a href="#1-1-1、-内核锁（Kernel-Locks）" class="headerlink" title="1-1-1、 内核锁（Kernel Locks）"></a>1-1-1、 内核锁（Kernel Locks）</h3><ul><li><strong>作用</strong>：内核锁用于保护内核数据结构，防止多个内核线程或进程同时访问和修改这些数据结构，从而避免数据不一致或竞争条件。</li><li><strong>类型</strong>：<ul><li><strong>自旋锁（Spinlock）</strong>：当一个线程试图获取已经被占用的自旋锁时，它会不断循环（自旋）直到锁可用。适用于持有时间短的场景。</li><li><strong>互斥锁（Mutex）</strong>：当一个线程试图获取已经被占用的互斥锁时，它会被阻塞，直到锁可用。适用于持有时间较长的场景。</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个读操作同时进行，但写操作是独占的。适用于读多写少的场景。</li></ul></li><li><strong>使用场景</strong>：内核锁主要用于内核空间，保护内核数据结构，确保内核的稳定性和一致性。</li></ul><h3 id="1-1-2、-应用层锁（Application-Level-Locks）"><a href="#1-1-2、-应用层锁（Application-Level-Locks）" class="headerlink" title="1-1-2、 应用层锁（Application-Level Locks）"></a>1-1-2、 应用层锁（Application-Level Locks）</h3><ul><li><strong>作用</strong>：应用层锁用于保护应用程序中的共享数据，防止多个线程或进程同时访问和修改这些数据，从而避免数据不一致或竞争条件。</li><li><strong>类型</strong>：<ul><li><strong>互斥锁（Mutex）</strong>：类似于内核中的互斥锁，用于保护共享资源，确保同一时间只有一个线程可以访问。</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个读操作同时进行，但写操作是独占的。</li><li><strong>条件变量（Condition Variable）</strong>：用于线程间的通信，允许一个线程等待某个条件成立后再继续执行。</li><li><strong>信号量（Semaphore）</strong>：用于控制对共享资源的访问，可以是二进制信号量（类似于互斥锁）或多级信号量。</li></ul></li><li><strong>使用场景</strong>：应用层锁主要用于用户空间，保护应用程序中的共享数据，确保应用程序的稳定性和一致性。</li></ul><h3 id="1-1-3、-关系"><a href="#1-1-3、-关系" class="headerlink" title="1-1-3、 关系"></a>1-1-3、 关系</h3><ul><li><strong>隔离性</strong>：内核锁和应用层锁在功能上是隔离的。内核锁用于保护内核数据结构，而应用层锁用于保护用户空间的数据。</li><li><strong>互操作</strong>：虽然内核锁和应用层锁在功能上是隔离的，但在某些情况下，它们可能会相互影响。例如，当一个线程在内核空间中持有锁时，如果该线程被调度到用户空间执行应用层代码，应用层代码可能会尝试获取锁，这需要确保锁的粒度和使用方式不会导致死锁或其他并发问题。</li><li><strong>性能考虑</strong>：内核锁和应用层锁的性能特性不同。内核锁通常更高效，但只能在内核空间中使用；应用层锁则可以在用户空间中使用，但可能需要更多的系统调用来实现。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内核锁和应用层锁虽然在功能和使用场景上有明显的区别，但它们都是为了保护共享数据，避免并发问题。在设计并发程序时，需要根据具体的需求选择合适的锁类型，并确保锁的使用不会导致死锁或其他并发问题。</p><h1 id="2、自旋锁"><a href="#2、自旋锁" class="headerlink" title="2、自旋锁"></a>2、自旋锁</h1><p>自旋锁（Spinlock）是一种同步机制，用于保护共享资源，确保同一时间只有一个线程可以访问该资源。自旋锁的基本思想是当一个线程试图获取已经被占用的锁时，它会不断循环（自旋）直到锁可用。自旋锁适用于持有时间短的场景，因为它不会使线程进入睡眠状态，从而避免了线程切换的开销。</p><p>在不同的操作系统和编程环境中，自旋锁的API可能会有所不同。以下是一些常见的操作系统和编程环境中的自旋锁API示例：</p><h2 id="2-1、api"><a href="#2-1、api" class="headerlink" title="2-1、api"></a>2-1、api</h2><h3 id="2-1-1、-Linux-内核中的自旋锁"><a href="#2-1-1、-Linux-内核中的自旋锁" class="headerlink" title="2-1-1、 Linux 内核中的自旋锁"></a>2-1-1、 Linux 内核中的自旋锁</h3><p>在Linux内核中，自旋锁的API定义在<code>&lt;linux/spinlock.h&gt;</code>头文件中。以下是一些常用的自旋锁API：</p><ul><li><p><strong>定义自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> my_lock;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_init(&amp;my_lock);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_lock(&amp;my_lock);</span><br></pre></td></tr></table></figure></li><li><p><strong>释放自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spin_unlock(&amp;my_lock);</span><br></pre></td></tr></table></figure></li><li><p><strong>带中断保护的自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">spin_lock_irqsave(&amp;my_lock, flags);</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">spin_unlock_irqrestore(&amp;my_lock, flags);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-2、-POSIX-线程（Pthreads）中的自旋锁"><a href="#2-1-2、-POSIX-线程（Pthreads）中的自旋锁" class="headerlink" title="2-1-2、 POSIX 线程（Pthreads）中的自旋锁"></a>2-1-2、 POSIX 线程（Pthreads）中的自旋锁</h3><p>在POSIX线程中，自旋锁的API定义在<code>&lt;pthread.h&gt;</code>头文件中。以下是一些常用的自旋锁API：</p><ul><li><p><strong>定义自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_spinlock_t</span> my_lock;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_init(&amp;my_lock, PTHREAD_PROCESS_PRIVATE);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_lock(&amp;my_lock);</span><br></pre></td></tr></table></figure></li><li><p><strong>释放自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_unlock(&amp;my_lock);</span><br></pre></td></tr></table></figure></li><li><p><strong>销毁自旋锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_spin_destroy(&amp;my_lock);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-3、-C-11-标准库中的自旋锁"><a href="#2-1-3、-C-11-标准库中的自旋锁" class="headerlink" title="2-1-3、 C++11 标准库中的自旋锁"></a>2-1-3、 C++11 标准库中的自旋锁</h3><p>在C++11标准库中，并没有直接提供自旋锁的实现，但可以使用<code>std::atomic</code>来实现自旋锁。以下是一个简单的自旋锁实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpinLock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire)) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic_flag flag = ATOMIC_FLAG_INIT;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用Linux内核自旋锁的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spinlock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">spinlock_t</span> my_lock;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    spin_lock_init(&amp;my_lock);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">critical_section</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    spin_lock(&amp;my_lock);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Shared resource: %d\n&quot;</span>, shared_resource);</span><br><span class="line">    spin_unlock(&amp;my_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple module with spinlock&quot;</span>);</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>spin_lock</code>和<code>spin_unlock</code>用于保护对<code>shared_resource</code>的访问，确保同一时间只有一个线程可以修改该资源。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>自旋锁的API在不同的操作系统和编程环境中有所不同。在Linux内核中，自旋锁的API定义在<code>&lt;linux/spinlock.h&gt;</code>中；在POSIX线程中，自旋锁的API定义在<code>&lt;pthread.h&gt;</code>中；在C++11标准库中，可以使用<code>std::atomic</code>来实现自旋锁。选择合适的自旋锁API取决于具体的编程环境和需求。</p><h1 id="3、原子操作"><a href="#3、原子操作" class="headerlink" title="3、原子操作"></a>3、原子操作</h1><p>某个值的原子操作<br>原子操作（Atomic Operations）是一种在多线程环境中对共享数据进行无锁操作的技术，确保操作的原子性，即操作是不可分割的，不会被其他线程中断。原子操作通常用于实现锁-free 数据结构或提高并发性能。以下是一些常见操作系统和编程环境中的原子操作API示例。</p><h2 id="3-1、api"><a href="#3-1、api" class="headerlink" title="3-1、api"></a>3-1、api</h2><h3 id="3-1-1、-Linux-内核中的原子操作"><a href="#3-1-1、-Linux-内核中的原子操作" class="headerlink" title="3-1-1、 Linux 内核中的原子操作"></a>3-1-1、 Linux 内核中的原子操作</h3><p>在Linux内核中，原子操作的API定义在<code>&lt;linux/atomic.h&gt;</code>头文件中。以下是一些常用的原子操作API：</p><ul><li><p><strong>定义原子变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> my_atomic_var;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化原子变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_set</span>(&amp;my_atomic_var, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>读取原子变量的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="type">atomic_read</span>(&amp;my_atomic_var);</span><br></pre></td></tr></table></figure></li><li><p><strong>增加原子变量的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_inc</span>(&amp;my_atomic_var);</span><br></pre></td></tr></table></figure></li><li><p><strong>减少原子变量的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_dec</span>(&amp;my_atomic_var);</span><br></pre></td></tr></table></figure></li><li><p><strong>增加并返回新值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> new_value = atomic_add_return(<span class="number">5</span>, &amp;my_atomic_var);</span><br></pre></td></tr></table></figure></li><li><p><strong>减少并返回新值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> new_value = atomic_sub_return(<span class="number">5</span>, &amp;my_atomic_var);</span><br></pre></td></tr></table></figure></li><li><p><strong>比较并交换（Compare and Swap, CAS）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> old_value = atomic_cmpxchg(&amp;my_atomic_var, old, new);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-1-2、-POSIX-线程（Pthreads）中的原子操作"><a href="#3-1-2、-POSIX-线程（Pthreads）中的原子操作" class="headerlink" title="3-1-2、 POSIX 线程（Pthreads）中的原子操作"></a>3-1-2、 POSIX 线程（Pthreads）中的原子操作</h3><p>在POSIX线程中，原子操作的API定义在<code>&lt;stdatomic.h&gt;</code>头文件中。以下是一些常用的原子操作API：</p><ul><li><p><strong>定义原子变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_int</span> my_atomic_var;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化原子变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_init</span>(&amp;my_atomic_var, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>读取原子变量的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="type">atomic_load</span>(&amp;my_atomic_var);</span><br></pre></td></tr></table></figure></li><li><p><strong>存储值到原子变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_store</span>(&amp;my_atomic_var, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>增加原子变量的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_fetch_add(&amp;my_atomic_var, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>减少原子变量的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic_fetch_sub(&amp;my_atomic_var, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>比较并交换（Compare and Swap, CAS）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = atomic_compare_exchange_strong(&amp;my_atomic_var, &amp;expected, desired);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-1-3、-C-11-标准库中的原子操作"><a href="#3-1-3、-C-11-标准库中的原子操作" class="headerlink" title="3-1-3、 C++11 标准库中的原子操作"></a>3-1-3、 C++11 标准库中的原子操作</h3><p>在C++11标准库中，原子操作的API定义在<code>&lt;atomic&gt;</code>头文件中。以下是一些常用的原子操作API：</p><ul><li><p><strong>定义原子变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; my_atomic_var;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化原子变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_atomic_var = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>读取原子变量的值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = my_atomic_var.<span class="built_in">load</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>存储值到原子变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_atomic_var.<span class="built_in">store</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>增加原子变量的值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_atomic_var.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>减少原子变量的值</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_atomic_var.<span class="built_in">fetch_sub</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>比较并交换（Compare and Swap, CAS）</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> expected = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> desired = <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> success = my_atomic_var.<span class="built_in">compare_exchange_strong</span>(expected, desired);</span><br></pre></td></tr></table></figure></li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一些使用不同环境中的原子操作的示例代码。</p><h4 id="Linux-内核中的原子操作示例"><a href="#Linux-内核中的原子操作示例" class="headerlink" title="Linux 内核中的原子操作示例"></a>Linux 内核中的原子操作示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/atomic.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> my_atomic_var;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">atomic_set</span>(&amp;my_atomic_var, <span class="number">0</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atomic_operations</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;my_atomic_var);</span><br><span class="line">    <span class="type">int</span> value = <span class="type">atomic_read</span>(&amp;my_atomic_var);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Atomic variable value: %d\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple module with atomic operations&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="POSIX-线程中的原子操作示例"><a href="#POSIX-线程中的原子操作示例" class="headerlink" title="POSIX 线程中的原子操作示例"></a>POSIX 线程中的原子操作示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdatomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_int</span> my_atomic_var;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    atomic_fetch_add(&amp;my_atomic_var, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> value = <span class="type">atomic_load</span>(&amp;my_atomic_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Atomic variable value: %d\n&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">atomic_init</span>(&amp;my_atomic_var, <span class="number">0</span>);</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-11-标准库中的原子操作示例"><a href="#C-11-标准库中的原子操作示例" class="headerlink" title="C++11 标准库中的原子操作示例"></a>C++11 标准库中的原子操作示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="type">int</span>&gt; my_atomic_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    my_atomic_var.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> value = my_atomic_var.<span class="built_in">load</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Atomic variable value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    my_atomic_var = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(thread_func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>原子操作的API在不同的操作系统和编程环境中有所不同。在Linux内核中，原子操作的API定义在<code>&lt;linux/atomic.h&gt;</code>中；在POSIX线程中，原子操作的API定义在<code>&lt;stdatomic.h&gt;</code>中；在C++11标准库中，原子操作的API定义在<code>&lt;atomic&gt;</code>中。选择合适的原子操作API取决于具体的编程环境和需求。原子操作可以显著提高并发程序的性能，特别是在多线程环境中。</p><h1 id="4、互斥锁"><a href="#4、互斥锁" class="headerlink" title="4、互斥锁"></a>4、互斥锁</h1><p>互斥锁（Mutex）是一种同步机制，用于保护共享资源，确保同一时间只有一个线程可以访问该资源。互斥锁的基本思想是当一个线程试图获取已经被占用的互斥锁时，它会被阻塞，直到锁可用。互斥锁适用于持有时间较长的场景，因为它允许线程在等待锁时进入睡眠状态，从而避免了线程切换的开销。</p><h2 id="4-1、api"><a href="#4-1、api" class="headerlink" title="4-1、api"></a>4-1、api</h2><p>以下是不同操作系统和编程环境中的互斥锁API示例：</p><h3 id="4-1-1、-Linux-内核中的互斥锁"><a href="#4-1-1、-Linux-内核中的互斥锁" class="headerlink" title="4-1-1、 Linux 内核中的互斥锁"></a>4-1-1、 Linux 内核中的互斥锁</h3><p>在Linux内核中，互斥锁的API定义在<code>&lt;linux/mutex.h&gt;</code>头文件中。以下是一些常用的互斥锁API：</p><ul><li><p><strong>定义互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">my_mutex</span>;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>初始化互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex_init(&amp;my_mutex);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock(&amp;my_mutex);</span><br></pre></td></tr></table></figure></li><li><p><strong>释放互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex_unlock(&amp;my_mutex);</span><br></pre></td></tr></table></figure></li><li><p><strong>尝试获取互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mutex_trylock(&amp;my_mutex)) &#123;</span><br><span class="line">    <span class="comment">// 成功获取锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-1-2、-POSIX-线程（Pthreads）中的互斥锁"><a href="#4-1-2、-POSIX-线程（Pthreads）中的互斥锁" class="headerlink" title="4-1-2、 POSIX 线程（Pthreads）中的互斥锁"></a>4-1-2、 POSIX 线程（Pthreads）中的互斥锁</h3><p>在POSIX线程中，互斥锁的API定义在<code>&lt;pthread.h&gt;</code>头文件中。以下是一些常用的互斥锁API：</p><ul><li><p><strong>定义互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> my_mutex;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(&amp;my_mutex, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;my_mutex);</span><br></pre></td></tr></table></figure></li><li><p><strong>释放互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(&amp;my_mutex);</span><br></pre></td></tr></table></figure></li><li><p><strong>销毁互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_destroy(&amp;my_mutex);</span><br></pre></td></tr></table></figure></li><li><p><strong>尝试获取互斥锁</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pthread_mutex_trylock(&amp;my_mutex) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功获取锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-1-3、C-11-标准库中的互斥锁"><a href="#4-1-3、C-11-标准库中的互斥锁" class="headerlink" title="4-1-3、C++11 标准库中的互斥锁"></a>4-1-3、C++11 标准库中的互斥锁</h3><p>在C++11标准库中，互斥锁的API定义在<code>&lt;mutex&gt;</code>头文件中。以下是一些常用的互斥锁API：</p><ul><li><p><strong>定义互斥锁</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::mutex my_mutex;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取互斥锁</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_mutex.<span class="built_in">lock</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>释放互斥锁</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_mutex.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>尝试获取互斥锁</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my_mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    <span class="comment">// 成功获取锁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用锁保护代码块</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一些使用不同环境中的互斥锁的示例代码。</p><h4 id="Linux-内核中的互斥锁示例"><a href="#Linux-内核中的互斥锁示例" class="headerlink" title="Linux 内核中的互斥锁示例"></a>Linux 内核中的互斥锁示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">my_mutex</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_init(&amp;my_mutex);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">critical_section</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    mutex_lock(&amp;my_mutex);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Shared resource: %d\n&quot;</span>, shared_resource);</span><br><span class="line">    mutex_unlock(&amp;my_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple module with mutex&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="POSIX-线程中的互斥锁示例"><a href="#POSIX-线程中的互斥锁示例" class="headerlink" title="POSIX 线程中的互斥锁示例"></a>POSIX 线程中的互斥锁示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> my_mutex;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;my_mutex);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared resource: %d\n&quot;</span>, shared_resource);</span><br><span class="line">    pthread_mutex_unlock(&amp;my_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_mutex_init(&amp;my_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;my_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-11-标准库中的互斥锁示例"><a href="#C-11-标准库中的互斥锁示例" class="headerlink" title="C++11 标准库中的互斥锁示例"></a>C++11 标准库中的互斥锁示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex my_mutex;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared resource: &quot;</span> &lt;&lt; shared_resource &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(thread_func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>互斥锁的API在不同的操作系统和编程环境中有所不同。在Linux内核中，互斥锁的API定义在<code>&lt;linux/mutex.h&gt;</code>中；在POSIX线程中，互斥锁的API定义在<code>&lt;pthread.h&gt;</code>中；在C++11标准库中，互斥锁的API定义在<code>&lt;mutex&gt;</code>中。选择合适的互斥锁API取决于具体的编程环境和需求。互斥锁可以有效地保护共享资源，避免并发问题，但在使用时需要注意避免死锁和其他并发问题。</p><h1 id="5、信号量"><a href="#5、信号量" class="headerlink" title="5、信号量"></a>5、信号量</h1><p>信号量（Semaphore）是一种同步机制，用于控制对共享资源的访问，可以是二进制信号量（类似于互斥锁）或多级信号量。信号量通过维护一个计数器来管理资源的访问权限，允许多个线程或进程同时访问共享资源，但数量受限于信号量的初始值。</p><h2 id="5-1、api"><a href="#5-1、api" class="headerlink" title="5-1、api"></a>5-1、api</h2><p>以下是不同操作系统和编程环境中的信号量API示例：</p><h3 id="5-1-1-Linux-内核中的信号量"><a href="#5-1-1-Linux-内核中的信号量" class="headerlink" title="5-1-1. Linux 内核中的信号量"></a>5-1-1. Linux 内核中的信号量</h3><p>在Linux内核中，信号量的API定义在<code>&lt;linux/semaphore.h&gt;</code>头文件中。以下是一些常用的信号量API：</p><ul><li><p><strong>定义信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">my_semaphore</span>;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>初始化信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sema_init(&amp;my_semaphore, count);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">down(&amp;my_semaphore);</span><br></pre></td></tr></table></figure></li><li><p><strong>释放信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">up(&amp;my_semaphore);</span><br></pre></td></tr></table></figure></li><li><p><strong>尝试获取信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (down_trylock(&amp;my_semaphore) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功获取信号量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取信号量失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-1-2、-POSIX-线程（Pthreads）中的信号量"><a href="#5-1-2、-POSIX-线程（Pthreads）中的信号量" class="headerlink" title="5-1-2、 POSIX 线程（Pthreads）中的信号量"></a>5-1-2、 POSIX 线程（Pthreads）中的信号量</h3><p>在POSIX线程中，信号量的API定义在<code>&lt;semaphore.h&gt;</code>头文件中。以下是一些常用的信号量API：</p><ul><li><p><strong>定义信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> my_semaphore;</span><br></pre></td></tr></table></figure></li><li><p><strong>初始化信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_init(&amp;my_semaphore, <span class="number">0</span>, count);</span><br></pre></td></tr></table></figure></li><li><p><strong>获取信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;my_semaphore);</span><br></pre></td></tr></table></figure></li><li><p><strong>释放信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_post(&amp;my_semaphore);</span><br></pre></td></tr></table></figure></li><li><p><strong>销毁信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sem_destroy(&amp;my_semaphore);</span><br></pre></td></tr></table></figure></li><li><p><strong>尝试获取信号量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sem_trywait(&amp;my_semaphore) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功获取信号量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取信号量失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-1-3、-C-11-标准库中的信号量"><a href="#5-1-3、-C-11-标准库中的信号量" class="headerlink" title="5-1-3、 C++11 标准库中的信号量"></a>5-1-3、 C++11 标准库中的信号量</h3><p>C++11标准库中并没有直接提供信号量的实现，但可以使用<code>std::counting_semaphore</code>（C++20引入）或通过<code>std::mutex</code>和<code>std::condition_variable</code>来实现信号量。以下是使用<code>std::counting_semaphore</code>的示例：</p><ul><li><p><strong>定义信号量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::counting_semaphore&lt;5&gt; <span class="title">my_semaphore</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 初始值为5</span></span><br></pre></td></tr></table></figure></li><li><p><strong>获取信号量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_semaphore.<span class="built_in">acquire</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>释放信号量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_semaphore.<span class="built_in">release</span>();</span><br></pre></td></tr></table></figure></li><li><p><strong>尝试获取信号量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my_semaphore.<span class="built_in">try_acquire</span>()) &#123;</span><br><span class="line">    <span class="comment">// 成功获取信号量</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取信号量失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一些使用不同环境中的信号量的示例代码。</p><h4 id="Linux-内核中的信号量示例"><a href="#Linux-内核中的信号量示例" class="headerlink" title="Linux 内核中的信号量示例"></a>Linux 内核中的信号量示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">my_semaphore</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    sema_init(&amp;my_semaphore, <span class="number">1</span>); <span class="comment">// 初始化信号量为1，相当于互斥锁</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module loaded\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module unloaded\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">critical_section</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    down(&amp;my_semaphore);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Shared resource: %d\n&quot;</span>, shared_resource);</span><br><span class="line">    up(&amp;my_semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple module with semaphore&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="POSIX-线程中的信号量示例"><a href="#POSIX-线程中的信号量示例" class="headerlink" title="POSIX 线程中的信号量示例"></a>POSIX 线程中的信号量示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> my_semaphore;</span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">thread_func</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;my_semaphore);</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Shared resource: %d\n&quot;</span>, shared_resource);</span><br><span class="line">    sem_post(&amp;my_semaphore);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sem_init(&amp;my_semaphore, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化信号量为1，相当于互斥锁</span></span><br><span class="line">    <span class="type">pthread_t</span> threads[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;my_semaphore);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-20-中的信号量示例"><a href="#C-20-中的信号量示例" class="headerlink" title="C++20 中的信号量示例"></a>C++20 中的信号量示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::counting_semaphore&lt;5&gt; <span class="title">my_semaphore</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 初始值为5</span></span><br><span class="line"><span class="type">int</span> shared_resource = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    my_semaphore.<span class="built_in">acquire</span>();</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    shared_resource++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared resource: &quot;</span> &lt;&lt; shared_resource &lt;&lt; std::endl;</span><br><span class="line">    my_semaphore.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(thread_func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>信号量的API在不同的操作系统和编程环境中有所不同。在Linux内核中，信号量的API定义在<code>&lt;linux/semaphore.h&gt;</code>中；在POSIX线程中，信号量的API定义在<code>&lt;semaphore.h&gt;</code>中；在C++20标准库中，信号量的API定义在<code>&lt;semaphore&gt;</code>中。选择合适的信号量API取决于具体的编程环境和需求。信号量可以有效地控制对共享资源的访问，允许多个线程或进程同时访问，但数量受限于信号量的初始值。</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux中断</title>
      <link href="/posts/835d4465.html"/>
      <url>/posts/835d4465.html</url>
      
        <content type="html"><![CDATA[<h1 id="linux中断"><a href="#linux中断" class="headerlink" title="linux中断"></a>linux中断</h1><h2 id="1、硬件中断"><a href="#1、硬件中断" class="headerlink" title="1、硬件中断"></a>1、硬件中断</h2><h3 id="1-1、Linux内核中断API"><a href="#1-1、Linux内核中断API" class="headerlink" title="1-1、Linux内核中断API"></a>1-1、Linux内核中断API</h3><p>以下是Linux内核中断处理相关的API</p><h4 id="1-1-1、中断处理函数注册和注销"><a href="#1-1-1、中断处理函数注册和注销" class="headerlink" title="1-1-1、中断处理函数注册和注销"></a>1-1-1、中断处理函数注册和注销</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>request_irq</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>unsigned int irq</code>: 中断号。</li><li><code>irq_handler_t handler</code>: 中断处理函数指针。</li><li><code>unsigned long flags</code>: 中断标志（如<code>IRQF_SHARED</code>表示共享中断线）。</li><li><code>const char *name</code>: 中断处理程序的名称，用于调试。</li><li><code>void *dev</code>: 设备标识符，通常为设备结构体。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>0</code>: 成功注册。</li><li>非零值: 注册失败。</li></ul></li></ul></li><li><p><strong><code>free_irq</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>unsigned int irq</code>: 中断号。</li><li><code>void *dev</code>: 设备标识符，必须与注册时一致。</li></ul></li></ul></li></ul><h4 id="1-1-2、中断处理函数原型"><a href="#1-1-2、中断处理函数原型" class="headerlink" title="1-1-2、中断处理函数原型"></a>1-1-2、中断处理函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span> irq, <span class="type">void</span> *dev_id);</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>int irq</code>: 中断号。</li><li><code>void *dev_id</code>: 设备标识符，与<code>request_irq</code>中的<code>dev</code>参数一致。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>IRQ_HANDLED</code>: 成功处理了中断。</li><li><code>IRQ_NONE</code>: 未处理中断。</li></ul></li></ul><h4 id="1-1-3、禁用和启用中断"><a href="#1-1-3、禁用和启用中断" class="headerlink" title="1-1-3、禁用和启用中断"></a>1-1-3、禁用和启用中断</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">local_irq_disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_save</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_irq_restore</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>local_irq_disable</code></strong></p><ul><li><strong>参数</strong>：无。</li><li><strong>功能</strong>：禁用当前CPU上的本地中断。</li></ul></li><li><p><strong><code>local_irq_enable</code></strong></p><ul><li><strong>参数</strong>：无。</li><li><strong>功能</strong>：启用当前CPU上的本地中断。</li></ul></li><li><p><strong><code>local_irq_save</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>unsigned long flags</code>: 用于保存当前中断状态。</li></ul></li><li><strong>功能</strong>：保存当前中断状态并禁用中断。</li></ul></li><li><p><strong><code>local_irq_restore</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>unsigned long flags</code>: 通过<code>local_irq_save</code>保存的状态。</li></ul></li><li><strong>功能</strong>：恢复之前保存的中断状态。</li></ul></li></ul><h4 id="1-1-3、延迟工作队列（Bottom-Halves）"><a href="#1-1-3、延迟工作队列（Bottom-Halves）" class="headerlink" title="1-1-3、延迟工作队列（Bottom Halves）"></a>1-1-3、延迟工作队列（Bottom Halves）</h4><h5 id="任务队列（Tasklet）"><a href="#任务队列（Tasklet）" class="headerlink" title="任务队列（Tasklet）"></a>任务队列（Tasklet）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>DECLARE_TASKLET</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>name</code>: 任务队列的名称。</li><li><code>void (*func)(unsigned long)</code>: 任务队列的处理函数。</li><li><code>unsigned long data</code>: 私有数据，传递给处理函数。</li></ul></li><li><strong>功能</strong>：定义一个任务队列结构体。</li></ul></li><li><p><strong><code>tasklet_schedule</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct tasklet_struct *t</code>: 任务队列结构体指针。</li></ul></li><li><strong>功能</strong>：调度任务队列执行。</li></ul></li><li><p><strong><code>tasklet_init</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct tasklet_struct *t</code>: 任务队列结构体指针。</li><li><code>void (*func)(unsigned long)</code>: 任务队列的处理函数。</li><li><code>unsigned long data</code>: 私有数据，传递给处理函数。</li></ul></li><li><strong>功能</strong>：初始化任务队列。</li></ul></li><li><p><strong><code>tasklet_kill</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct tasklet_struct *t</code>: 任务队列结构体指针。</li></ul></li><li><strong>功能</strong>：等待任务队列完成并销毁它。</li></ul></li></ul><h5 id="工作队列（Workqueue）"><a href="#工作队列（Workqueue）" class="headerlink" title="工作队列（Workqueue）"></a>工作队列（Workqueue）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">create_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq, <span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">INIT_WORK</span><span class="params">(<span class="keyword">struct</span> work_struct *work, <span class="type">work_func_t</span> func)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">flush_workqueue</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>create_workqueue</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>const char *name</code>: 工作队列的名称。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>struct workqueue_struct *</code>: 工作队列结构体指针。</li></ul></li><li><strong>功能</strong>：创建一个新的工作队列。</li></ul></li><li><p><strong><code>destroy_workqueue</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct workqueue_struct *wq</code>: 工作队列结构体指针。</li></ul></li><li><strong>功能</strong>：销毁工作队列。</li></ul></li><li><p><strong><code>queue_work</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct workqueue_struct *wq</code>: 工作队列结构体指针。</li><li><code>struct work_struct *work</code>: 工作项结构体指针。</li></ul></li><li><strong>功能</strong>：将工作项加入工作队列。</li></ul></li><li><p><strong><code>INIT_WORK</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct work_struct *work</code>: 工作项结构体指针。</li><li><code>work_func_t func</code>: 工作项的处理函数。</li></ul></li><li><strong>功能</strong>：初始化工作项结构体。</li></ul></li><li><p><strong><code>flush_workqueue</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct workqueue_struct *wq</code>: 工作队列结构体指针。</li></ul></li><li><strong>功能</strong>：等待工作队列中的所有工作项完成。</li></ul></li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="使用任务队列（Tasklet）"><a href="#使用任务队列（Tasklet）" class="headerlink" title="使用任务队列（Tasklet）"></a>使用任务队列（Tasklet）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Tasklet handler executed, data=%lu\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    tasklet_schedule(&amp;my_tasklet);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    tasklet_init(&amp;my_tasklet, my_tasklet_handler, (<span class="type">unsigned</span> <span class="type">long</span>)<span class="number">12345</span>);</span><br><span class="line">    ret = request_irq(irq, my_interrupt_handler, IRQF_SHARED, <span class="string">&quot;my_interrupt&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register interrupt handler\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler registered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">    tasklet_kill(&amp;my_tasklet);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler unregistered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="使用工作队列（Workqueue）"><a href="#使用工作队列（Workqueue）" class="headerlink" title="使用工作队列（Workqueue）"></a>使用工作队列（Workqueue）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">my_wq</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Work handler executed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    queue_work(my_wq, &amp;my_work);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    my_wq = create_workqueue(<span class="string">&quot;my_wq&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!my_wq) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to create workqueue\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    INIT_WORK(&amp;my_work, my_work_handler);</span><br><span class="line">    ret = request_irq(irq, my_interrupt_handler, IRQF_SHARED, <span class="string">&quot;my_interrupt&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register interrupt handler\n&quot;</span>);</span><br><span class="line">        destroy_workqueue(my_wq);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler registered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">    flush_workqueue(my_wq);</span><br><span class="line">    destroy_workqueue(my_wq);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler unregistered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这些API提供了在Linux内核中管理和处理中断的必要工具。通过使用任务队列和工作队列，可以有效地将中断处理中的复杂任务推迟到下半部执行，从而提高系统的响应速度和稳定性。</p><h2 id="2、Linux内核软中断（Softirq）API"><a href="#2、Linux内核软中断（Softirq）API" class="headerlink" title="2、Linux内核软中断（Softirq）API"></a>2、Linux内核软中断（Softirq）API</h2><h3 id="2-1、Linux内核软中断（Softirq）API"><a href="#2-1、Linux内核软中断（Softirq）API" class="headerlink" title="2-1、Linux内核软中断（Softirq）API"></a>2-1、Linux内核软中断（Softirq）API</h3><p>软中断（Softirq）是Linux内核中用于处理下半部任务的一种机制。软中断在中断上下文之外执行，但仍然具有较高的优先级。以下是与软中断相关的API及其参数解释：</p><h4 id="2-1-1、软中断API"><a href="#2-1-1、软中断API" class="headerlink" title="2-1-1、软中断API"></a>2-1-1、软中断API</h4><h5 id="软中断类型"><a href="#软中断类型" class="headerlink" title="软中断类型"></a>软中断类型</h5><p>Linux内核定义了多个软中断类型，常见的包括：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">    TIMER_SOFTIRQ,</span><br><span class="line">    NET_TX_SOFTIRQ,</span><br><span class="line">    NET_RX_SOFTIRQ,</span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,</span><br><span class="line">    SCHED_SOFTIRQ,</span><br><span class="line">    HRTIMER_SOFTIRQ,</span><br><span class="line">    RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="软中断处理函数注册和注销"><a href="#软中断处理函数注册和注销" class="headerlink" title="软中断处理函数注册和注销"></a>软中断处理函数注册和注销</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">int</span> nr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq_irqoff</span><span class="params">(<span class="type">int</span> nr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_softirq</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_bh_disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">local_bh_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>open_softirq</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>int nr</code>: 软中断类型（如<code>NET_RX_SOFTIRQ</code>）。</li><li><code>void (*action)(struct softirq_action *)</code>: 软中断处理函数。</li></ul></li><li><strong>功能</strong>：注册一个软中断处理函数。</li></ul></li><li><p><strong><code>raise_softirq</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>int nr</code>: 软中断类型。</li></ul></li><li><strong>功能</strong>：触发一个软中断。</li></ul></li><li><p><strong><code>raise_softirq_irqoff</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>int nr</code>: 软中断类型。</li></ul></li><li><strong>功能</strong>：触发一个软中断，假设中断已经禁用。</li></ul></li><li><p><strong><code>do_softirq</code></strong></p><ul><li><strong>参数</strong>：无。</li><li><strong>功能</strong>：执行所有待处理的软中断。</li></ul></li><li><p><strong><code>local_bh_disable</code></strong></p><ul><li><strong>参数</strong>：无。</li><li><strong>功能</strong>：禁用软中断。</li></ul></li><li><p><strong><code>local_bh_enable</code></strong></p><ul><li><strong>参数</strong>：无。</li><li><strong>功能</strong>：启用软中断。</li></ul></li></ul><h4 id="2-1-2、软中断处理函数原型"><a href="#2-1-2、软中断处理函数原型" class="headerlink" title="2-1-2、软中断处理函数原型"></a>2-1-2、软中断处理函数原型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *);</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>struct softirq_action *action</code>: 软中断动作结构体，包含私有数据。</li></ul></li></ul><h3 id="2-2-2、示例代码"><a href="#2-2-2、示例代码" class="headerlink" title="2-2-2、示例代码"></a>2-2-2、示例代码</h3><p>下面是一个简单的示例，展示如何注册和触发一个软中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/smp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义软中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Softirq handler executed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册软中断</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册软中断处理函数</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, my_softirq_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发软中断</span></span><br><span class="line">    raise_softirq(TASKLET_SOFTIRQ);</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Softirq registered and raised\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载模块时注销软中断</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module exiting\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple module to demonstrate softirqs&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>定义软中断处理函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Softirq handler executed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>注册软中断</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, my_softirq_handler);</span><br><span class="line">    raise_softirq(TASKLET_SOFTIRQ);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Softirq registered and raised\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>open_softirq</code>注册软中断处理函数。</li><li>使用<code>raise_softirq</code>触发软中断。</li></ul></li><li><p><strong>卸载模块时注销软中断</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module exiting\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h2 id="3、软中断和中断的区别"><a href="#3、软中断和中断的区别" class="headerlink" title="3、软中断和中断的区别"></a>3、软中断和中断的区别</h2><p>软中断是Linux内核中用于处理下半部任务的一种高效机制。通过注册和触发软中断，可以将中断处理中的复杂任务推迟到软中断上下文中执行，从而提高系统的响应速度和稳定性。上述示例展示了如何注册和触发一个软中断。</p><p>软中断（Softirq）和硬件中断是Linux内核中两种不同的中断处理机制，它们在触发和执行时机上有明显的区别。</p><h3 id="3-1、硬件中断"><a href="#3-1、硬件中断" class="headerlink" title="3-1、硬件中断"></a>3-1、硬件中断</h3><ul><li><strong>触发时机</strong>：当硬件设备发生特定事件（如数据到达、状态变化等）时，硬件会向CPU发送中断信号。</li><li><strong>执行时机</strong>：CPU立即响应中断，进入中断处理程序（Interrupt Handler），执行中断处理逻辑。</li><li><strong>上下文</strong>：中断处理程序在中断上下文中执行，中断上下文是原子的，不允许睡眠或阻塞。</li></ul><h3 id="3-2、软中断"><a href="#3-2、软中断" class="headerlink" title="3-2、软中断"></a>3-2、软中断</h3><ul><li><strong>触发时机</strong>：软中断不是由硬件直接触发的，而是由内核代码显式调用<code>raise_softirq</code>或<code>raise_softirq_irqoff</code>函数来触发。</li><li><strong>执行时机</strong>：软中断在中断上下文之外执行，通常在中断返回之前或在内核调度器调度下一个任务时执行。</li><li><strong>上下文</strong>：软中断在软中断上下文中执行，允许一定程度的延迟处理，但仍然具有较高的优先级。</li></ul><h3 id="3-3、软中断的执行流程"><a href="#3-3、软中断的执行流程" class="headerlink" title="3-3、软中断的执行流程"></a>3-3、软中断的执行流程</h3><ol><li><p><strong>硬件中断发生</strong>：</p><ul><li>CPU响应硬件中断，进入中断处理程序。</li><li>中断处理程序执行必要的快速操作，然后触发软中断（通过调用<code>raise_softirq</code>）。</li></ul></li><li><p><strong>软中断触发</strong>：</p><ul><li>中断处理程序调用<code>raise_softirq</code>来设置软中断标志。</li><li>内核在中断返回之前或在内核调度器调度下一个任务时检查软中断标志。</li></ul></li><li><p><strong>软中断执行</strong>：</p><ul><li>内核调用<code>do_softirq</code>函数来执行所有待处理的软中断。</li><li>软中断处理函数在软中断上下文中执行，处理延迟的任务。</li></ul></li></ol><h3 id="3-4、示例代码解释"><a href="#3-4、示例代码解释" class="headerlink" title="3-4、示例代码解释"></a>3-4、示例代码解释</h3><p>以下是一个简单的示例，展示如何在硬件中断处理程序中触发软中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/smp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义软中断处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Softirq handler executed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hardware interrupt handler executed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发软中断</span></span><br><span class="line">    raise_softirq(TASKLET_SOFTIRQ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册软中断</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册软中断处理函数</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, my_softirq_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册硬件中断处理程序</span></span><br><span class="line">    ret = request_irq(irq, my_interrupt_handler, IRQF_SHARED, <span class="string">&quot;my_interrupt&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register interrupt handler\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler registered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载模块时注销软中断和硬件中断处理程序</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler unregistered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple module to demonstrate softirqs&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><p><strong>定义软中断处理函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Softirq handler executed\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>中断处理函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hardware interrupt handler executed\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发软中断</span></span><br><span class="line">    raise_softirq(TASKLET_SOFTIRQ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当硬件中断发生时，<code>my_interrupt_handler</code>被调用。</li><li>在中断处理程序中，调用<code>raise_softirq(TASKLET_SOFTIRQ)</code>来触发软中断。</li></ul></li><li><p><strong>注册软中断和硬件中断处理程序</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册软中断处理函数</span></span><br><span class="line">    open_softirq(TASKLET_SOFTIRQ, my_softirq_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册硬件中断处理程序</span></span><br><span class="line">    ret = request_irq(irq, my_interrupt_handler, IRQF_SHARED, <span class="string">&quot;my_interrupt&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register interrupt handler\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler registered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>open_softirq</code>注册软中断处理函数。</li><li>使用<code>request_irq</code>注册硬件中断处理程序。</li></ul></li><li><p><strong>卸载模块时注销软中断和硬件中断处理程序</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = <span class="number">42</span>; <span class="comment">// 示例中断号</span></span><br><span class="line"></span><br><span class="line">    free_irq(irq, <span class="literal">NULL</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler unregistered for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>硬件中断</strong>：由硬件直接触发，立即执行中断处理程序。</li><li><strong>软中断</strong>：由内核代码显式触发，通常在中断返回之前或在内核调度器调度下一个任务时执行。</li></ul><p>通过这种方式，软中断可以将复杂的中断处理任务推迟到软中断上下文中执行，从而提高系统的响应速度和稳定性。</p><h2 id="4、设备树调整"><a href="#4、设备树调整" class="headerlink" title="4、设备树调整"></a>4、设备树调整</h2><p>以按键的中断为例，在设备树中添加中断信息，并修改中断处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">key&#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">compatible = <span class="string">&quot;naro-key&quot;</span>;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">interrupts = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">naro-key = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复用为gpio</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_key: keygrp &#123;</span><br><span class="line"> fsl,pins = &lt;</span><br><span class="line"> MX6UL_PAD_UART1_CTS_B__GPIO1_IO18   <span class="number">0xF080</span> <span class="comment">/* KEY1 */</span></span><br><span class="line"> &gt;;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts </span><br></pre></td></tr></table></figure><p>可以查添加到设备树的中断开启了没有。</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<p>设备树中，半导体厂商一般已经将芯片的型号、频率、IO、中断、时钟、DMA、内存等参数进行了封装，用户只需要在设备树中引用即可。<br>举例：配置gpio，gpio一般在设备树中以节点方式描述，节点名以gpio开头，节点名后面接gpio的编号，如gpio0、gpio1、gpio2等。<br>如imx6ull的gpio1节点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gpio1: gpio@<span class="number">0209</span>c000 &#123;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x0209c000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI <span class="number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">     &lt;GIC_SPI <span class="number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">gpio-controller;</span><br><span class="line"><span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">interrupt-controller;</span><br><span class="line"><span class="meta">#interrupt-cells cc <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>起了别名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">can0 = &amp;flexcan1;</span><br><span class="line">can1 = &amp;flexcan2;</span><br><span class="line">ethernet0 = &amp;fec1;</span><br><span class="line">ethernet1 = &amp;fec2;</span><br><span class="line">gpio0 = &amp;gpio1;</span><br><span class="line">gpio1 = &amp;gpio2;</span><br><span class="line">gpio2 = &amp;gpio3;</span><br><span class="line">gpio3 = &amp;gpio4;</span><br><span class="line">gpio4 = &amp;gpio5;</span><br><span class="line">i2c0 = &amp;i2c1;</span><br><span class="line">i2c1 = &amp;i2c2;</span><br><span class="line">i2c2 = &amp;i2c3;</span><br><span class="line">i2c3 = &amp;i2c4;</span><br><span class="line">mmc0 = &amp;usdhc1;</span><br><span class="line">mmc1 = &amp;usdhc2;</span><br><span class="line">serial0 = &amp;uart1;</span><br><span class="line">serial1 = &amp;uart2;</span><br><span class="line">serial2 = &amp;uart3;</span><br><span class="line">serial3 = &amp;uart4;</span><br><span class="line">serial4 = &amp;uart5;</span><br><span class="line">serial5 = &amp;uart6;</span><br><span class="line">serial6 = &amp;uart7;</span><br><span class="line">serial7 = &amp;uart8;</span><br><span class="line">spi0 = &amp;ecspi1;</span><br><span class="line">spi1 = &amp;ecspi2;</span><br><span class="line">spi2 = &amp;ecspi3;</span><br><span class="line">spi3 = &amp;ecspi4;</span><br><span class="line">usbphy0 = &amp;usbphy1;</span><br><span class="line">usbphy1 = &amp;usbphy2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以创建一个节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">        beep&#123;</span><br><span class="line"> <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"> <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"> compatible = <span class="string">&quot;naro-led&quot;</span>;</span><br><span class="line"> pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"> pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_beep&gt;;</span><br><span class="line"> beep-gpio = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line"> status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在驱动中获取节点即可。</p><h1 id="查找引脚的电气属性"><a href="#查找引脚的电气属性" class="headerlink" title="查找引脚的电气属性"></a>查找引脚的电气属性</h1><p>在nxp中，命名一般是gpio,<br>举个例子，我通过电气原理图看到控制灯的引脚引脚是gpio1_3，那么就直接在设备树中搜索gpio1_3，通过关键字得到。而引脚地址通常要到根节点去找。</p><p>找设备树中节点技巧就是搜索关键字</p><h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><p>编译的选项一般就再当前的文件中makefile中定义。添加上自己的代码即可。而选项则在config中定义。这个的配置有两个文件，一个是.config，一个是deconfig</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux内核定时器</title>
      <link href="/posts/7ec46997.html"/>
      <url>/posts/7ec46997.html</url>
      
        <content type="html"><![CDATA[<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="1、内核config配置"><a href="#1、内核config配置" class="headerlink" title="1、内核config配置"></a>1、内核config配置</h2><p>配置内核定时器步骤</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt;kernel Features</span><br><span class="line">        -&gt;timer <span class="title function_">frequency</span> <span class="params">(&lt;choice&gt; [=y])</span></span><br></pre></td></tr></table></figure><p>在里面可以选择系统的节拍数，默认是1000Hz，也就是1ms节拍，如果选择2000Hz，就是0.5ms节拍，如果选择10000Hz，就是0.1ms节拍。配置完成后，在源码中的.config文件中，会自动生成如下配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_HZ=<span class="number">1000</span></span><br></pre></td></tr></table></figure><p>这个就是节拍率。</p><p>这个配置生效在：include&#x2F;asm-generic&#x2F;param.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASM_GENERIC_PARAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM_GENERIC_PARAM_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/asm-generic/param.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">undef</span> HZ</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HZCONFIG_HZ<span class="comment">/* Internal kernel timer frequency */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> USER_HZ100<span class="comment">/* some user interfaces are */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCKS_PER_SEC(USER_HZ)       <span class="comment">/* in &quot;ticks&quot; like times() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASM_GENERIC_PARAM_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是内核定时器的频率了</p><h2 id="2、api"><a href="#2、api" class="headerlink" title="2、api"></a>2、api</h2><h3 id="2-1、Linux内核定时器API"><a href="#2-1、Linux内核定时器API" class="headerlink" title="2-1、Linux内核定时器API"></a>2-1、Linux内核定时器API</h3><h4 id="定时器数据结构"><a href="#定时器数据结构" class="headerlink" title="定时器数据结构"></a>定时器数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span>;</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>struct timer_list *timer</code></strong>: 所有定时器操作都基于此结构。</li></ul><h4 id="初始化和设置定时器"><a href="#初始化和设置定时器" class="headerlink" title="初始化和设置定时器"></a>初始化和设置定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>init_timer</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li></ul></li><li><strong>功能</strong>：初始化定时器。</li><li><strong>推荐使用</strong>：在较新的内核版本中，推荐使用<code>setup_timer</code>函数。</li></ul></li><li><p><strong><code>setup_timer</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li><li><code>void (*function)(unsigned long)</code>: 定时器回调函数指针。</li><li><code>unsigned long data</code>: 传递给回调函数的私有数据。</li></ul></li><li><strong>功能</strong>：初始化定时器并同时设置回调函数和定时器私有数据。</li></ul></li></ul><h4 id="修改和启动定时器"><a href="#修改和启动定时器" class="headerlink" title="修改和启动定时器"></a>修改和启动定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>mod_timer</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li><li><code>unsigned long expires</code>: 定时器到期时间（以jiffies为单位）。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>0</code>: 成功修改或启动定时器。</li><li>非零值: 修改或启动失败。</li></ul></li><li><strong>功能</strong>：修改定时器的超时时间。如果定时器已经在等待队列中，它将被移除并重新安排新的超时时间。如果定时器未启动，则启动定时器。</li></ul></li><li><p><strong><code>add_timer</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li></ul></li><li><strong>功能</strong>：向系统添加定时器，指定定时器到期时间。等同于初始化定时器后调用<code>mod_timer</code>。</li></ul></li></ul><h4 id="删除定时器"><a href="#删除定时器" class="headerlink" title="删除定时器"></a>删除定时器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">del_timer_sync</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>del_timer</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>1</code>: 定时器被成功删除。</li><li><code>0</code>: 定时器未被删除（可能未找到或正在运行）。</li></ul></li><li><strong>功能</strong>：删除定时器。如果定时器当前正在运行，则不会等待其完成，直接删除。</li></ul></li><li><p><strong><code>del_timer_sync</code></strong></p><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>1</code>: 定时器被成功删除。</li><li><code>0</code>: 定时器未被删除（可能未找到或正在运行）。</li></ul></li><li><strong>功能</strong>：同步删除定时器。确保定时器在多处理器系统中的所有CPU上都不再运行后再删除。</li></ul></li></ul><h4 id="检查定时器状态"><a href="#检查定时器状态" class="headerlink" title="检查定时器状态"></a>检查定时器状态</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">timer_pending</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>timer_pending</code></strong><ul><li><strong>参数</strong>：<ul><li><code>struct timer_list *timer</code>: 定时器结构体指针。</li></ul></li><li><strong>返回值</strong>：<ul><li><code>1</code>: 定时器已启动但尚未到期。</li><li><code>0</code>: 定时器未启动或已到期。</li></ul></li><li><strong>功能</strong>：检查定时器是否挂起（即已启动但尚未到期）。</li></ul></li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>下面是一个简单的使用定时器的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_timer_callback</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Timer expired, data=%lu\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化定时器，并设置回调函数和私有数据</span></span><br><span class="line">    setup_timer(&amp;my_timer, my_timer_callback, <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器在5秒后触发</span></span><br><span class="line">    mod_timer(&amp;my_timer, jiffies + msecs_to_jiffies(<span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 同步删除定时器</span></span><br><span class="line">    del_timer_sync(&amp;my_timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上是Linux内核定时器的主要API及其使用方法。通过这些API，开发者可以在内核模块中实现精确的时间管理功能。</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内核4.8后与4.8之前的gpio差异</title>
      <link href="/posts/59a0a1ec.html"/>
      <url>/posts/59a0a1ec.html</url>
      
        <content type="html"><![CDATA[<p>在 Linux 内核中，有专门用于控制 GPIO（General - Purpose Input&#x2F;Output，通用输入输出）输出的函数。</p><h1 id="4-8-之前的内核"><a href="#4-8-之前的内核" class="headerlink" title="4.8 之前的内核"></a>4.8 之前的内核</h1><p>在较旧的 Linux 内核版本中，使用的是传统的 GPIO 接口。相关函数主要定义在 &lt;linux&#x2F;gpio.h&gt; 头文件中。</p><h2 id="1、请求GPIO"><a href="#1、请求GPIO" class="headerlink" title="1、请求GPIO"></a>1、请求GPIO</h2><p>在使用 GPIO 之前，需要先请求该 GPIO 资源，以确保不会与其他驱动冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span>;</span><br></pre></td></tr></table></figure><h2 id="2、设置GPIO方向输出"><a href="#2、设置GPIO方向输出" class="headerlink" title="2、设置GPIO方向输出"></a>2、设置GPIO方向输出</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li>gpio：要设置的 GPIO 编号。</li><li>value：初始输出电平，0 表示低电平，1 表示高电平。<br>返回值：成功时返回 0，失败时返回负数错误码。</li></ul><h2 id="3、设置-GPIO-输出电平"><a href="#3、设置-GPIO-输出电平" class="headerlink" title="3、设置 GPIO 输出电平"></a>3、设置 GPIO 输出电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li>gpio：要设置的 GPIO 编号。</li><li>value：要设置的输出电平，0 表示低电平，1 表示高电平。</li></ul><h2 id="4、读取-GPIO-输入电平"><a href="#4、读取-GPIO-输入电平" class="headerlink" title="4、读取 GPIO 输入电平"></a>4、读取 GPIO 输入电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br></pre></td></tr></table></figure><ul><li>gpio：要读取的 GPIO 编号。</li><li>返回值：成功时返回 0 或 1，表示输入电平的高或低电平。失败时返回负数错误码。</li></ul><h2 id="5、释放-GPIO"><a href="#5、释放-GPIO" class="headerlink" title="5、释放 GPIO"></a>5、释放 GPIO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br></pre></td></tr></table></figure><ul><li>gpio：要释放的 GPIO 编号。</li></ul><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_GPIO_PIN 17</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_gpio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = gpio_request(MY_GPIO_PIN, <span class="string">&quot;my_gpio&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request GPIO %d\n&quot;</span>, MY_GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = gpio_direction_output(MY_GPIO_PIN, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to set GPIO %d as output\n&quot;</span>, MY_GPIO_PIN);</span><br><span class="line">        gpio_free(MY_GPIO_PIN);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpio_set_value(MY_GPIO_PIN, <span class="number">0</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d set to low level\n&quot;</span>, MY_GPIO_PIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_gpio_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    gpio_free(MY_GPIO_PIN);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO %d freed\n&quot;</span>, MY_GPIO_PIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_gpio_init);</span><br><span class="line">module_exit(my_gpio_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="4-8之后的内核改动"><a href="#4-8之后的内核改动" class="headerlink" title="4.8之后的内核改动"></a>4.8之后的内核改动</h1><p>从 Linux 内核 4.8 版本开始，引入了更现代的 GPIO 子系统，使用 gpiod_* 系列函数，相关函数定义在 &lt;linux&#x2F;gpio&#x2F;consumer.h&gt; 头文件中</p><h2 id="1、获取-GPIO-描述符"><a href="#1、获取-GPIO-描述符" class="headerlink" title="1、获取 GPIO 描述符"></a>1、获取 GPIO 描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">gpiod_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *con_id, <span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>dev：关联的设备结构体指针。</li><li>con_id：GPIO 控制器的连接标识符。</li><li>flags：标志位，例如 GPIOD_OUT_LOW 或 GPIOD_OUT_HIGH 用于设置初始输出电平。<br>返回值：成功时返回 GPIO 描述符指针，失败时返回 ERR_PTR。</li></ul><h2 id="2、设置-GPIO-输出电平"><a href="#2、设置-GPIO-输出电平" class="headerlink" title="2、设置 GPIO 输出电平"></a>2、设置 GPIO 输出电平</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li>desc：GPIO 描述符指针。</li><li>value：要设置的输出电平，0 表示低电平，1 表示高电平。</li></ul><h2 id="3、释放-GPIO-描述符"><a href="#3、释放-GPIO-描述符" class="headerlink" title="3、释放 GPIO 描述符"></a>3、释放 GPIO 描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">gpiod_put</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure><p>释放 GPIO 描述符，释放 GPIO 描述符后，GPIO 描述符将不再可用。</p><h2 id="例程-1"><a href="#例程-1" class="headerlink" title="例程"></a>例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">my_gpio_desc</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_gpio_init_new</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    my_gpio_desc = gpiod_get(<span class="literal">NULL</span>, <span class="string">&quot;my_gpio&quot;</span>, GPIOD_OUT_LOW);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(my_gpio_desc)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to get GPIO descriptor\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(my_gpio_desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gpiod_set_value(my_gpio_desc, <span class="number">1</span>);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO set to high level\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_gpio_exit_new</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    gpiod_put(my_gpio_desc);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;GPIO descriptor freed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_gpio_init_new);</span><br><span class="line">module_exit(my_gpio_exit_new);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;YGC&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符内核驱动框架</title>
      <link href="/posts/a299f17f.html"/>
      <url>/posts/a299f17f.html</url>
      
        <content type="html"><![CDATA[<p>需要重点掌握的的函数：<br>物理内存映射到虚拟空间后，在内核使用ioremap进行映射，在用户空间使用mmap进行映射。</p><p>ioremap函数与readl,readb,readw,readq,writel,writeb,writew,函数配合使用</p><h1 id="1、字符型设备框架–旧"><a href="#1、字符型设备框架–旧" class="headerlink" title="1、字符型设备框架–旧"></a>1、字符型设备框架–旧</h1><p>相关函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">retvalue = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);</span><br><span class="line">unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);</span><br><span class="line"></span><br><span class="line">copy_to_user(.....);</span><br><span class="line">copy_from_user(.....);</span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * LICENSE和作者信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="1-1、旧字符框架"><a href="#1-1、旧字符框架" class="headerlink" title="1-1、旧字符框架"></a>1-1、旧字符框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHRDEVBASE_MAJOR200<span class="comment">/* 主设备号 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHRDEVBASE_NAME<span class="string">&quot;chrdevbase&quot;</span> <span class="comment">/* 设备名     */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> readbuf[<span class="number">100</span>];<span class="comment">/* 读缓冲区 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> writebuf[<span class="number">100</span>];<span class="comment">/* 写缓冲区 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kerneldata[] = &#123;<span class="string">&quot;kernel data!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode : 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> *   一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdevbase_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printk(&quot;chrdevbase open!\r\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 从设备读取数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @param - buf : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdevbase_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向用户空间发送数据 */</span></span><br><span class="line"><span class="built_in">memcpy</span>(readbuf, kerneldata, <span class="keyword">sizeof</span>(kerneldata));</span><br><span class="line">retvalue = copy_to_user(buf, readbuf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue == <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;kernel senddata ok!\r\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">printk(<span class="string">&quot;kernel senddata failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printk(&quot;chrdevbase read!\r\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">chrdevbase_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 接收用户空间传递给内核的数据并且打印出来 */</span></span><br><span class="line">retvalue = copy_from_user(writebuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue == <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;kernel recevdata:%s\r\n&quot;</span>, writebuf);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">printk(<span class="string">&quot;kernel recevdata failed!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printk(&quot;chrdevbase write!\r\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 关闭/释放设备</span></span><br><span class="line"><span class="comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdevbase_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printk(&quot;chrdevbase release！\r\n&quot;);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设备操作函数结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrdevbase_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = chrdevbase_open,</span><br><span class="line">.read = chrdevbase_read,</span><br><span class="line">.write = chrdevbase_write,</span><br><span class="line">.release = chrdevbase_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动入口函数 </span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevbase_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">retvalue = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;chrdevbase driver register failed\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;chrdevbase init!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevbase_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);</span><br><span class="line">printk(<span class="string">&quot;chrdevbase exit!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 将上面两个函数指定为驱动的入口和出口函数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">module_init(chrdevbase_init);</span><br><span class="line">module_exit(chrdevbase_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * LICENSE和作者信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">KERNELDIR := /home/ygc/Desktop/project/myproject/imx6ull/imx6ull-kernel/linux-imx-rel_imx_4.1.15_2.1.0_ga</span><br><span class="line">CURRENT_PATH := $(shell pwd)</span><br><span class="line">obj-m := chrdevbase.o</span><br><span class="line"></span><br><span class="line"># 添加编译选项，确保不使用 PIC 模式</span><br><span class="line">KBUILD_CFLAGS += -fno-pic</span><br><span class="line"></span><br><span class="line">CROSS_COMPILE ?= /home/ygc/Desktop/linux-gcc/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">build: kernel_modules</span><br><span class="line"></span><br><span class="line">kernel_modules:</span><br><span class="line">$&#123;MAKE&#125; -C $(KERNELDIR) M=$(CURRENT_PATH) modules  ARCH=arm CROSS_COMPILE=$(CROSS_COMPILE)</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">$&#123;MAKE&#125; -C $(KERNELDIR) M=$(CURRENT_PATH) clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用：先在&#x2F;dev下创建&#x2F;modules&#x2F;4.1.15,<br>具体可以使用depmod命令,创建这个目录。<br>然后使用insmod命令加载驱动。lsmod 查看是否加载成功。cat &#x2F;proc&#x2F;devices查看是否注册成功。</p><p><code>lsmod命令不依赖depmod,而modprobe命令依赖depmod。</code><br>modprobe相对与lsmod命令，会去分析依赖。<br>运行：mknod &#x2F;dev&#x2F;chrdevbase c 200 0<br>c表示字符设备，200表示主设备号，0表示次设备号。添加节点</p><p>通过对节点下的dev进行操作可以使用该设备。</p><h2 id="app测试"><a href="#app测试" class="headerlink" title="app测试"></a>app测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> retvalue = <span class="number">-1</span>;</span><br><span class="line">        std::string filename;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        filename = argv[<span class="number">1</span>];</span><br><span class="line">fd = <span class="built_in">open</span>(filename.<span class="built_in">c_str</span>(), O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open file %s error!\n&quot;</span>, filename.<span class="built_in">c_str</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span>(filename == <span class="string">&quot;write&quot;</span>) &#123;</span><br><span class="line">retvalue = <span class="built_in">write</span>(fd, <span class="string">&quot;hello kernel&quot;</span>, <span class="number">12</span>);</span><br><span class="line">&#125; </span><br><span class="line">        <span class="keyword">if</span>(filename == <span class="string">&quot;read&quot;</span>) &#123;</span><br><span class="line">retvalue = <span class="built_in">read</span>(fd, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">        retvalue = <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;close file %s error!\n&quot;</span>, filename.<span class="built_in">c_str</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建编译打包脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path=&quot;/home/ygc/Desktop/linux-gcc/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin&quot;</span><br><span class="line">app_path=$&#123;PWD&#125;</span><br><span class="line">echo $app_path</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">path/arm-linux-gnueabihf-g++ <span class="variable">$app_path</span>/app.cpp -o app</span> </span><br><span class="line">make clean</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">cp app /home/ygc/Desktop/project/nfs/rootfs/usr</span><br><span class="line">cp chrdevbase.ko /home/ygc/Desktop/project/nfs/rootfs/usr/module</span><br></pre></td></tr></table></figure><p>使用app对对节点操作，从而操作硬件。</p><p>最后卸载lsmod。</p><h1 id="2、新字符设备驱动"><a href="#2、新字符设备驱动" class="headerlink" title="2、新字符设备驱动"></a>2、新字符设备驱动</h1><p>新字符设备驱动主要解决的是旧字符设备设备号要自己设定的问题。从linux内核直接申请设备号,insmod后不用mknod。</p><p>相关函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="comment">/* 用到的结构封装 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备  */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号  */</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">/* 次设备号   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span> <span class="title">newchrled</span>;</span><span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line">MKDEV(...)</span><br><span class="line">MAJOR(...)</span><br><span class="line">MINOR(...)</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">register_chrdev_region(...)</span><br><span class="line">alloc_chrdev_region(...)</span><br><span class="line">cdev_init(..)</span><br><span class="line">cdev_add(...)</span><br><span class="line">device_create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">cdev_del(...);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(...); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(...);</span><br><span class="line">class_destroy(...);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-1、驱动框架"><a href="#2-1、驱动框架" class="headerlink" title="2-1、驱动框架"></a>2-1、驱动框架</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWCHRLED_CNT1  <span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWCHRLED_NAME<span class="string">&quot;newchrled&quot;</span><span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0<span class="comment">/* 关灯 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1<span class="comment">/* 开灯 */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 寄存器物理地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 映射后的寄存器虚拟地址指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* newchrled设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备  */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号  */</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">/* 次设备号   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span> <span class="title">newchrled</span>;</span><span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: LED打开/关闭</span></span><br><span class="line"><span class="comment"> * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sta == LEDON) &#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta == LEDOFF) &#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val|= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode : 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> *   一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;newchrled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 从设备读取数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @param - buf : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ledstat = databuf[<span class="number">0</span>];<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line">led_switch(LEDON);<span class="comment">/* 打开LED灯 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">led_switch(LEDOFF);<span class="comment">/* 关闭LED灯 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 关闭/释放设备</span></span><br><span class="line"><span class="comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">newchrled_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.read = led_read,</span><br><span class="line">.write = led_write,</span><br><span class="line">.release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化LED */</span></span><br><span class="line"><span class="comment">/* 1、寄存器地址映射 */</span></span><br><span class="line">  IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">  SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、使能GPIO1时钟 */</span></span><br><span class="line">val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">/* 清楚以前的设置 */</span></span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">/* 设置新值 */</span></span><br><span class="line">writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span></span><br><span class="line"><span class="comment"> *    GPIO1_IO03，最后设置IO属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span></span><br><span class="line"><span class="comment"> *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment"> *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、设置GPIO1_IO03为输出功能 */</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);<span class="comment">/* 清除以前的设置 */</span></span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);<span class="comment">/* 设置为输出 */</span></span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、默认关闭LED */</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line"><span class="comment">/* 1、创建设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (newchrled.major) &#123;<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">newchrled.devid = MKDEV(newchrled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">alloc_chrdev_region(&amp;newchrled.devid, <span class="number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME);<span class="comment">/* 申请设备号 */</span></span><br><span class="line">newchrled.major = MAJOR(newchrled.devid);<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">newchrled.minor = MINOR(newchrled.devid);<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">newchrled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、添加一个cdev */</span></span><br><span class="line">cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建类 */</span></span><br><span class="line">newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、创建设备 */</span></span><br><span class="line">newchrled.device = device_create(newchrled.class, <span class="literal">NULL</span>, newchrled.devid, <span class="literal">NULL</span>, NEWCHRLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 取消映射 */</span></span><br><span class="line">iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">cdev_del(&amp;newchrled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(newchrled.devid, NEWCHRLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(newchrled.class, newchrled.devid);</span><br><span class="line">class_destroy(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><p>编译使用上一节的脚本和makefile</p><h1 id="3、采用设备树方式"><a href="#3、采用设备树方式" class="headerlink" title="3、采用设备树方式"></a>3、采用设备树方式</h1><p>需要用到的函数：<br>of系列函数</p><h2 id="3-1、框架"><a href="#3-1、框架" class="headerlink" title="3-1、框架"></a>3-1、框架</h2><p>在设备树文件中添加设备节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">naro&#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">compatible = <span class="string">&quot;naro-led&quot;</span>;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">reg = &lt; <span class="number">0X020C406C</span> <span class="number">0X04</span> <span class="comment">/* CCM_CCGR1_BASE */</span></span><br><span class="line"><span class="number">0X020E0068</span> <span class="number">0X04</span> <span class="comment">/* SW_MUX_GPIO1_IO03_BASE */</span></span><br><span class="line"> <span class="number">0X020E02F4</span> <span class="number">0X04</span> <span class="comment">/* SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line"> <span class="number">0X0209C000</span> <span class="number">0X04</span> <span class="comment">/* GPIO1_DR_BASE */</span></span><br><span class="line"> <span class="number">0X0209C004</span> <span class="number">0X04</span> &gt;; <span class="comment">/* GPIO1_GDIR_BASE */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_CNT1  <span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_NAME<span class="string">&quot;dtsled&quot;</span><span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0<span class="comment">/* 关灯 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1<span class="comment">/* 开灯 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 映射后的寄存器虚拟地址指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dtsled设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备  */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号  */</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">/* 次设备号   */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> <span class="title">dtsled</span>;</span><span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: LED打开/关闭</span></span><br><span class="line"><span class="comment"> * @param - sta : LEDON(0) 打开LED，LEDOFF(1) 关闭LED</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sta == LEDON) &#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta == LEDOFF) &#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val|= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode : 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> *   一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;dtsled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 从设备读取数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @param - buf : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ledstat = databuf[<span class="number">0</span>];<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line">led_switch(LEDON);<span class="comment">/* 打开LED灯 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">led_switch(LEDOFF);<span class="comment">/* 关闭LED灯 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 关闭/释放设备</span></span><br><span class="line"><span class="comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dtsled_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.read = led_read,</span><br><span class="line">.write = led_write,</span><br><span class="line">.release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">u32 regdata[<span class="number">14</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取设备树中的属性数据 */</span></span><br><span class="line"><span class="comment">/* 1、获取设备节点：alphaled */</span></span><br><span class="line">dtsled.nd = of_find_node_by_path(<span class="string">&quot;/alphaled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(dtsled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;alphaled node nost find!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">&quot;alphaled node find!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、获取compatible属性内容 */</span></span><br><span class="line">proper = of_find_property(dtsled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(proper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">&quot;compatible = %s\r\n&quot;</span>, (<span class="type">char</span>*)proper-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、获取status属性内容 */</span></span><br><span class="line">ret = of_property_read_string(dtsled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">printk(<span class="string">&quot;status read failed!\r\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、获取reg属性内容 */</span></span><br><span class="line">ret = of_property_read_u32_array(dtsled.nd, <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">u8 i = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;reg data:\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化LED */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/* 1、寄存器地址映射 */</span></span><br><span class="line">IMX6U_CCM_CCGR1 = ioremap(regdata[<span class="number">0</span>], regdata[<span class="number">1</span>]);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="number">2</span>], regdata[<span class="number">3</span>]);</span><br><span class="line">  SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="number">4</span>], regdata[<span class="number">5</span>]);</span><br><span class="line">GPIO1_DR = ioremap(regdata[<span class="number">6</span>], regdata[<span class="number">7</span>]);</span><br><span class="line">GPIO1_GDIR = ioremap(regdata[<span class="number">8</span>], regdata[<span class="number">9</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">IMX6U_CCM_CCGR1 = of_iomap(dtsled.nd, <span class="number">0</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">1</span>);</span><br><span class="line">  SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">2</span>);</span><br><span class="line">GPIO1_DR = of_iomap(dtsled.nd, <span class="number">3</span>);</span><br><span class="line">GPIO1_GDIR = of_iomap(dtsled.nd, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、使能GPIO1时钟 */</span></span><br><span class="line">val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">/* 清楚以前的设置 */</span></span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">/* 设置新值 */</span></span><br><span class="line">writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span></span><br><span class="line"><span class="comment"> *    GPIO1_IO03，最后设置IO属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span></span><br><span class="line"><span class="comment"> *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment"> *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、设置GPIO1_IO03为输出功能 */</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);<span class="comment">/* 清除以前的设置 */</span></span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);<span class="comment">/* 设置为输出 */</span></span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、默认关闭LED */</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line"><span class="comment">/* 1、创建设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (dtsled.major) &#123;<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">dtsled.devid = MKDEV(dtsled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">alloc_chrdev_region(&amp;dtsled.devid, <span class="number">0</span>, DTSLED_CNT, DTSLED_NAME);<span class="comment">/* 申请设备号 */</span></span><br><span class="line">dtsled.major = MAJOR(dtsled.devid);<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">dtsled.minor = MINOR(dtsled.devid);<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;dtsled major=%d,minor=%d\r\n&quot;</span>,dtsled.major, dtsled.minor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">dtsled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、添加一个cdev */</span></span><br><span class="line">cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建类 */</span></span><br><span class="line">dtsled.class = class_create(THIS_MODULE, DTSLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dtsled.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(dtsled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、创建设备 */</span></span><br><span class="line">dtsled.device = device_create(dtsled.class, <span class="literal">NULL</span>, dtsled.devid, <span class="literal">NULL</span>, DTSLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dtsled.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(dtsled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 取消映射 */</span></span><br><span class="line">iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">cdev_del(&amp;dtsled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(dtsled.devid, DTSLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line">class_destroy(dtsled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、gpio子系统"><a href="#4、gpio子系统" class="headerlink" title="4、gpio子系统"></a>4、gpio子系统</h1><p>在 Linux 驱动开发中，GPIO（General Purpose Input&#x2F;Output，通用输入输出）子系统是一个非常重要的部分，它为内核空间和用户空间提供了一种统一的、标准化的方式来访问和控制 GPIO 引脚<br>驱动编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_CNT1  <span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_NAME<span class="string">&quot;gpioled&quot;</span><span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 0<span class="comment">/* 关灯 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 1<span class="comment">/* 开灯 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* gpioled设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备  */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号  */</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">/* 次设备号   */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="type">int</span> led_gpio;<span class="comment">/* led所使用的GPIO编号*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span><span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 打开设备</span></span><br><span class="line"><span class="comment"> * @param - inode : 传递给驱动的inode</span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span></span><br><span class="line"><span class="comment"> *   一般在open的时候将private_data指向设备结构体。</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">filp-&gt;private_data = &amp;gpioled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 从设备读取数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 要打开的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @param - buf : 返回给用户空间的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 向设备写数据 </span></span><br><span class="line"><span class="comment"> * @param - filp : 设备文件，表示打开的文件描述符</span></span><br><span class="line"><span class="comment"> * @param - buf : 要写给设备写入的数据</span></span><br><span class="line"><span class="comment"> * @param - cnt : 要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @param - offt : 相对于文件首地址的偏移</span></span><br><span class="line"><span class="comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retvalue;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line"><span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ledstat = databuf[<span class="number">0</span>];<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ledstat == LEDON) &#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);<span class="comment">/* 打开LED灯 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);<span class="comment">/* 关闭LED灯 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 关闭/释放设备</span></span><br><span class="line"><span class="comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span></span><br><span class="line"><span class="comment"> * @return : 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备操作函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpioled_fops</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_open,</span><br><span class="line">.read = led_read,</span><br><span class="line">.write = led_write,</span><br><span class="line">.release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置LED所使用的GPIO */</span></span><br><span class="line"><span class="comment">/* 1、获取设备节点：gpioled */</span></span><br><span class="line">gpioled.nd = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(gpioled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node not find!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">printk(<span class="string">&quot;gpioled node find!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、 获取设备树中的gpio属性，得到LED所使用的LED编号 */</span></span><br><span class="line">gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(gpioled.led_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t get led-gpio&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、设置GPIO1_IO03为输出，并且输出高电平，默认关闭LED灯 */</span></span><br><span class="line">ret = gpio_direction_output(gpioled.led_gpio, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line"><span class="comment">/* 1、创建设备号 */</span></span><br><span class="line"><span class="keyword">if</span> (gpioled.major) &#123;<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>, GPIOLED_CNT, GPIOLED_NAME);<span class="comment">/* 申请设备号 */</span></span><br><span class="line">gpioled.major = MAJOR(gpioled.devid);<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">gpioled.minor = MINOR(gpioled.devid);<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">&quot;gpioled major=%d,minor=%d\r\n&quot;</span>,gpioled.major, gpioled.minor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、添加一个cdev */</span></span><br><span class="line">cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建类 */</span></span><br><span class="line">gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpioled.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、创建设备 */</span></span><br><span class="line">gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>, gpioled.devid, <span class="literal">NULL</span>, GPIOLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpioled.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 驱动出口函数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">cdev_del(&amp;gpioled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(gpioled.devid, GPIOLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">class_destroy(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="5、测试蜂鸣器"><a href="#5、测试蜂鸣器" class="headerlink" title="5、测试蜂鸣器"></a>5、测试蜂鸣器</h1><p>蜂鸣器是GPIO输出，所以和LED一样，也是通过GPIO驱动来控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWCHRDEV_CNT 1 <span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWCHRDEV_NAME <span class="string">&quot;newchrdev&quot;</span> <span class="comment">/* 设备名 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_ON <span class="string">&#x27;1&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_OFF <span class="string">&#x27;0&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWCHRLED_NAME <span class="string">&quot;led_newchrdev&quot;</span> <span class="comment">/* led设备名 */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span> <span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 设备 */</span></span><br><span class="line"><span class="type">dev_t</span> devid; <span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> cache_buf[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寄存器物理地址 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 映射后的寄存器虚拟地址指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* newchrled设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span>&#123;</span></span><br><span class="line"><span class="type">dev_t</span> devid;<span class="comment">/* 设备号  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* cdev */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备  */</span></span><br><span class="line"><span class="type">int</span> major;<span class="comment">/* 主设备号  */</span></span><br><span class="line"><span class="type">int</span> minor;<span class="comment">/* 次设备号   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newchrled_dev</span> <span class="title">newchrled</span>;</span><span class="comment">/* led设备 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sta == LED_ON) &#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta == LED_OFF) &#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val|= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;led_open\n&quot;</span>);</span><br><span class="line">        filp-&gt;private_data = &amp;newchrled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// int retvalue = 0;</span></span><br><span class="line">        <span class="comment">// retvalue = copy_to_user(buf, &amp;newchrled.led_status, sizeof(newchrled.led_status));</span></span><br><span class="line">        printk(<span class="string">&quot;led_read\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span>  retvalue = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> databuf[count];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line">        </span><br><span class="line">        printk(<span class="string">&quot;led_write\n&quot;</span>);</span><br><span class="line">        retvalue = copy_from_user(databuf, buf, count);</span><br><span class="line">        <span class="keyword">if</span> (retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;the value is %c \r\n&quot;</span>, databuf[<span class="number">0</span>]);</span><br><span class="line">        ledstat = databuf[<span class="number">0</span>];</span><br><span class="line">        printk(<span class="string">&quot;ledstat = %c\r\n&quot;</span>,ledstat);</span><br><span class="line">        <span class="keyword">if</span>(ledstat == LED_ON) &#123;</span><br><span class="line">                led_switch(LED_ON);</span><br><span class="line">                printk(<span class="string">&quot;open led\r\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LED_OFF) &#123;</span><br><span class="line">                led_switch(LED_OFF);</span><br><span class="line">                printk(<span class="string">&quot;close led\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;led_release\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">newchrled_fops</span> =</span> </span><br><span class="line">&#123;</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .open = led_open,</span><br><span class="line">        .read = led_read,</span><br><span class="line">        .write = led_write,</span><br><span class="line">        .release = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        u32 val = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;led init\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 1、初始化led */</span></span><br><span class="line">IMX6U_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">  SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2、使能GPIO1 */</span></span><br><span class="line">        val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">        val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>); </span><br><span class="line">        val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);<span class="comment">/* 设置新值 */</span></span><br><span class="line">writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span></span><br><span class="line"><span class="comment"> *    GPIO1_IO03，最后设置IO属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span></span><br><span class="line"><span class="comment"> *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment"> *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、设置GPIO1_IO03为输出功能 */</span></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);<span class="comment">/* 清除以前的设置 */</span></span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);<span class="comment">/* 设置为输出 */</span></span><br><span class="line">writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、默认关闭LED */</span></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建类 */</span></span><br><span class="line"><span class="keyword">if</span> (newchrled.major) &#123; <span class="comment">/* 定义了设备号 */</span></span><br><span class="line">                devid = MKDEV(newchrled.major, <span class="number">0</span>);</span><br><span class="line">                register_chrdev_region(devid,NEWCHRDEV_CNT,NEWCHRLED_NAME);        </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                alloc_chrdev_region(&amp;newchrled.devid,<span class="number">0</span>,NEWCHRDEV_CNT,NEWCHRLED_NAME); <span class="comment">/* 申请设备号 */</span></span><br><span class="line">                newchrled.major = MAJOR(newchrled.devid); <span class="comment">/* 获得主设备号 */</span></span><br><span class="line">                newchrled.minor = MINOR(newchrled.devid); <span class="comment">/* 获得次设备号 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;newchrled major = %d,minor = %d\r\n&quot;</span>,newchrled.major,newchrled.minor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">newchrled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops);</span><br><span class="line"></span><br><span class="line">        cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRDEV_CNT); <span class="comment">/* 注册设备 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 4、创建类 */</span></span><br><span class="line">newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.class)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 5、创建设备 */</span></span><br><span class="line">newchrled.device = device_create(newchrled.class, <span class="literal">NULL</span>, newchrled.devid, <span class="literal">NULL</span>, NEWCHRLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.device)) &#123;</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(newchrled.device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;led exit\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 取消映射 */</span></span><br><span class="line">iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">cdev_del(&amp;newchrled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">unregister_chrdev_region(newchrled.devid, NEWCHRDEV_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">device_destroy(newchrled.class, newchrled.devid);</span><br><span class="line">class_destroy(newchrled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ygc&quot;</span>);</span><br></pre></td></tr></table></figure><p>app:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        std::string cmd;</span><br><span class="line">        <span class="type">char</span> data[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">if</span>(argc != <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;error param &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; std::endl; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cmd = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(cmd.<span class="built_in">c_str</span>(), O_RDWR);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;open &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cmd = argv[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(cmd == <span class="string">&quot;read&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">read</span>(fd, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;read data:&quot;</span> &lt;&lt; cmd &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmd == <span class="string">&quot;write&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;write data:&quot;</span> &lt;&lt; argv[<span class="number">3</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="built_in">strcpy</span>(data, argv[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">write</span>(fd, data, <span class="built_in">sizeof</span>(data));</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;write data:&quot;</span> &lt;&lt; argv[<span class="number">3</span>] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;error cmd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kernel移植（linux4.115移植）</title>
      <link href="/posts/f9607d0d.html"/>
      <url>/posts/f9607d0d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、选择编译器"><a href="#1、选择编译器" class="headerlink" title="1、选择编译器"></a>1、选择编译器</h1><p>安装必备库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br></pre></td></tr></table></figure><p>内核版本，uboot版本，编译器版本，都会影响到程序能否正常运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/bin/bash</span></span><br><span class="line">path=&quot;/home/ygc/Desktop/linux-gcc/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin&quot;</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$path/arm-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$path/arm-linux-gnueabihf- imx_v7_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$path/arm-linux-gnueabihf- menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$path/arm-linux-gnueabihf- all -j16</span><br></pre></td></tr></table></figure><p>确认编译器没有问题。</p><h1 id="2、添加板子的配置文件"><a href="#2、添加板子的配置文件" class="headerlink" title="2、添加板子的配置文件"></a>2、添加板子的配置文件</h1><p>板子的配置文件在arch&#x2F;arm&#x2F;configs&#x2F;目录下，复制一份，修改文件名，并修改内核配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp imx_v7_mfg_defconfig imx_v7_naro_defconfig</span><br></pre></td></tr></table></figure><p>在这个文件中注释掉下面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_BLK_DEV_BSG is not <span class="built_in">set</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CONFIG_ARCH_MULTI_V6=y</span></span><br><span class="line">CONFIG_ARCH_MXC=y</span><br></pre></td></tr></table></figure><h1 id="3、添加板子的dtb文件"><a href="#3、添加板子的dtb文件" class="headerlink" title="3、添加板子的dtb文件"></a>3、添加板子的dtb文件</h1><p>CONFIG_ARCH_MULTI_V6 是armv6的配置。<br>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;目录下，复制一份，修改文件名，并修改内核配置。</p><p>imx6ull-14x14-evk-emmc.dtsi复制一份，改为imx6ull-14x14-evk-emmc-naro.dtsi</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp imx6ull-14x14-evk-emmc.dtsi imx6ull-14x14-evk-emmc-naro.dtsi</span><br></pre></td></tr></table></figure><p>在&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;目录下,修改makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imx6ull-14x14-evk-btwifi.dtb \</span><br><span class="line">imx6ull-14x14-evk-emmc.dtb \</span><br><span class="line">imx6ull-14x14-naro-emmc.dtb \</span><br><span class="line">imx6ull-14x14-evk-gpmi-weim.dtb \</span><br><span class="line">imx6ull-14x14-evk-usb-certi.dtb \</span><br></pre></td></tr></table></figure><h1 id="4、修改网络驱动"><a href="#4、修改网络驱动" class="headerlink" title="4、修改网络驱动"></a>4、修改网络驱动</h1><p>imx6ull-14x14-evk.dtsi<br>注释一下部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_spi4: spi4grp &#123;</span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">        MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10        0x70a1</span><br><span class="line">        MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11        0x70a1</span><br><span class="line">        # MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07      0x70a1</span><br><span class="line">        # MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08      0x80000000</span><br><span class="line">        &gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有以下部分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pinctrl-0 = &lt;&amp;pinctrl_spi4&gt;;</span><br><span class="line">// pinctrl-assert-gpios = &lt;&amp;gpio5 8 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">gpio-sck = &lt;&amp;gpio5 11 0&gt;;</span><br><span class="line">gpio-mosi = &lt;&amp;gpio5 10 0&gt;;</span><br><span class="line">// cs-gpios = &lt;&amp;gpio5 7 0&gt;;</span><br><span class="line">num-chipselects = &lt;1&gt;;</span><br></pre></td></tr></table></figure><ul><li>增加网口的复位引脚：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc_snvs &#123;</span><br><span class="line">pinctrl-names = &quot;default_snvs&quot;;</span><br><span class="line">        pinctrl-0 = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">        imx6ul-evk &#123;</span><br><span class="line"></span><br><span class="line">pinctrl_enet1_reset: enet1resetgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">/* used for enet1 reset */</span><br><span class="line">MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 0x10B0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">pinctrl_enet2_reset: enet2resetgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">/* used for enet2 reset */</span><br><span class="line">MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 0x10B0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>修改两个网口的时钟配置<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_enet1: enet1grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 0x4001b009</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pinctrl_enet2: enet2grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO07__ENET2_MDC0x1b0b0</span><br><span class="line">MX6UL_PAD_GPIO1_IO06__ENET2_MDIO0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN0x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA000x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA010x1b0b0</span><br><span class="line">MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 0x4001b009</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>修改节点属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;fec1 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_enet1</span><br><span class="line">&amp;pinctrl_enet1_reset&gt;;</span><br><span class="line">phy-mode = &quot;rmii&quot;;</span><br><span class="line">phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_enet2</span><br><span class="line">&amp;pinctrl_enet2_reset&gt;;</span><br><span class="line">phy-mode = &quot;rmii&quot;;</span><br><span class="line">phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">mdio &#123;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">address-cells = &lt;1&gt;;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">size-cells = &lt;0&gt;;</span></span><br><span class="line"></span><br><span class="line">ethphy0: ethernet-phy@0 &#123;</span><br><span class="line">compatible = &quot;ethernet-phy-ieee802.3-c22&quot;;</span><br><span class="line">reg = &lt;0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ethphy1: ethernet-phy@1 &#123;</span><br><span class="line">compatible = &quot;ethernet-phy-ieee802.3-c22&quot;;</span><br><span class="line">reg = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>修改内核源码：<br>修改fec.c文件，修改fec_probe函数，这个文件在drivers&#x2F;net&#x2F;ethernet&#x2F;freescale&#x2F;fec.c 代码修改如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">fec_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fec_enet_private</span> *<span class="title">fep</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fec_platform_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">ndev</span>;</span></span><br><span class="line"><span class="type">int</span> i, irq, ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">r</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dev_id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node, *phy_node;</span><br><span class="line"><span class="type">int</span> num_tx_qs;</span><br><span class="line"><span class="type">int</span> num_rx_qs;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __iomem *IMX6U_ENET1_TX_CLK;</span><br><span class="line"><span class="type">void</span> __iomem *IMX6U_ENET2_TX_CLK;</span><br><span class="line">IMX6U_ENET1_TX_CLK = ioremap(<span class="number">0X020E00DC</span>, <span class="number">4</span>);</span><br><span class="line">IMX6U_ENET2_TX_CLK = ioremap(<span class="number">0X020E00FC</span>, <span class="number">4</span>);</span><br><span class="line">writel(<span class="number">0X14</span>, IMX6U_ENET1_TX_CLK);</span><br><span class="line">writel(<span class="number">0X14</span>, IMX6U_ENET2_TX_CLK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ************</span></span><br></pre></td></tr></table></figure></li></ul><p>修改smsc.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***********</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">smsc_phy_reset</span><span class="params">(<span class="keyword">struct</span> phy_device *phydev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> err, phy_reset;</span><br><span class="line"><span class="type">int</span> msec = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line"><span class="type">int</span> timeout = <span class="number">50000</span>;</span><br><span class="line"><span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (phydev-&gt;mdio.addr == <span class="number">0</span>) &#123;</span><br><span class="line">np = of_find_node_by_path(<span class="string">&quot;/soc/aips-bus@02100000/ethernet@02188000&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (phydev-&gt;mdio.addr == <span class="number">1</span>) &#123;</span><br><span class="line">np = of_find_node_by_path(<span class="string">&quot;/soc/aips-bus@02000000/ethernet@020b4000&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!np) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A sane reset duration should not be longer than 1s */</span></span><br><span class="line">err = of_property_read_u32(np, <span class="string">&quot;phy-reset-duration&quot;</span>, &amp;msec);</span><br><span class="line"><span class="keyword">if</span> (!err &amp;&amp; msec &gt; <span class="number">1000</span>)</span><br><span class="line">msec = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">phy_reset = of_get_named_gpio(np, <span class="string">&quot;phy-reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!gpio_is_valid(phy_reset))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">gpio_direction_output(phy_reset, <span class="number">0</span>);</span><br><span class="line">gpio_set_value(phy_reset, <span class="number">0</span>);</span><br><span class="line">msleep(msec);</span><br><span class="line">gpio_set_value(phy_reset, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> rc;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uboot移植（uboot2016移植）</title>
      <link href="/posts/99b63079.html"/>
      <url>/posts/99b63079.html</url>
      
        <content type="html"><![CDATA[<h1 id="移植uboot2016-03版本"><a href="#移植uboot2016-03版本" class="headerlink" title="移植uboot2016.03版本"></a>移植uboot2016.03版本</h1><p>主要修改：配置文件，板子头文件。驱动文件</p><p><code>注意使用低版本的交叉编译工具，板子运行报错。</code></p><h2 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h2><p>找到符合自己板子的配置文件–mx6ull_14x14_evk_emmc_deconfig<br>复制一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mx6ull_14x14_evk_emmc_deconfig mx6ull_naro_emmc_deconfig</span><br></pre></td></tr></table></figure><p>文件内容修改如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS=&quot;IMX_CONFIG=board/freescale/mx6ull_naro/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span><br><span class="line">CONFIG_ARM=y</span><br><span class="line">CONFIG_ARCH_MX6=y</span><br><span class="line">CONFIG_TARGET_MX6ULL_NARO=y</span><br><span class="line">CONFIG_CMD_GPIO=y</span><br></pre></td></tr></table></figure><p>修改第一条板级配置文件路径，修改第四条编译的选项。</p><h2 id="2、修改板子的头文件"><a href="#2、修改板子的头文件" class="headerlink" title="2、修改板子的头文件"></a>2、修改板子的头文件</h2><p>找到include&#x2F;configs&#x2F;mx6ullevk.h，复制一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mx6ullevk.h mx6ull_naro.h</span><br></pre></td></tr></table></figure><p>将开头的编译宏改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MX6ULL_NARO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MX6ULL_NARO </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>移植uboot的是时候没有某个功能可以到下面这个文件中找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mx6_common.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="3、修改板子board文件夹下文件"><a href="#3、修改板子board文件夹下文件" class="headerlink" title="3、修改板子board文件夹下文件"></a>3、修改板子board文件夹下文件</h2><p>将board&#x2F;freescale&#x2F;mx6ullevk复制一份,命名为mx6ull_naro</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r board/freescale/mx6ullevk board/freescale/mx6ull_naro</span><br></pre></td></tr></table></figure><ul><li><p>修改board&#x2F;freescale&#x2F;mx6ull_naro&#x2F;Kconfig<br>原本的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_14X14_EVK || TARGET_MX6ULL_9X9_EVK</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default &quot;mx6ullevk&quot;</span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default &quot;freescale&quot;</span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default &quot;mx6ullevk&quot;</span><br><span class="line"></span><br><span class="line">endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_NARO</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default &quot;mx6ull_naro&quot;</span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default &quot;freescale&quot;</span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default &quot;mx6ull_naro&quot;</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure></li><li><p>修改makefile</p></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">obj-y  := mx6ull_naro.o</span><br><span class="line"></span><br><span class="line">extra-<span class="variable">$(CONFIG_USE_PLUGIN)</span> :=  plugin.bin</span><br><span class="line"><span class="variable">$(obj)</span>/plugin.bin: <span class="variable">$(obj)</span>/plugin.o</span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -O binary --gap-fill 0xff <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj-y  := mx6ull_naro.o</span><br><span class="line"></span><br><span class="line">extra-<span class="variable">$(CONFIG_USE_PLUGIN)</span> :=  plugin.bin</span><br><span class="line"><span class="variable">$(obj)</span>/plugin.bin: <span class="variable">$(obj)</span>/plugin.o</span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -O binary --gap-fill 0xff <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>修改imximage.cfg<br>原来的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_USE_PLUGIN</span></span><br><span class="line">/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/</span><br><span class="line">PLUGINboard/freescale/mx6ullevk/plugin.bin 0x00907000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_USE_PLUGIN</span></span><br><span class="line">/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/</span><br><span class="line">PLUGINboard/freescale/mx6ull_naro/plugin.bin 0x00907000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br></pre></td></tr></table></figure></li><li><p>修改MAINTAINERS文件<br>原来的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MX6ULLEVK BOARD</span><br><span class="line">M:Peng Fan &lt;peng.fan@nxp.com&gt;</span><br><span class="line">S:Maintained</span><br><span class="line">F:board/freescale/mx6ullevk/</span><br><span class="line">F:include/configs/mx6ullevk.h</span><br><span class="line">F:configs/mx6ull_14x14_evk_defconfig</span><br><span class="line">F:configs/mx6ull_9x9_evk_defconfig</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MX6ULLEVK BOARD</span><br><span class="line">M:Peng Fan &lt;peng.fan@nxp.com&gt;</span><br><span class="line">S:Maintained</span><br><span class="line">F:board/freescale/mx6ull_naro/</span><br><span class="line">F:include/configs/mx6ull_naro.h</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="4、修改图形配置文件"><a href="#4、修改图形配置文件" class="headerlink" title="4、修改图形配置文件"></a>4、修改图形配置文件</h1><p>修改arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;mx6&#x2F;Kconfig,找到mx6ull相关的配置，添加以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;board/freescale/mx6ull_naro/Kconfig&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_NARO</span><br><span class="line">bool &quot;Support mx6ull_naro&quot;</span><br><span class="line">select MX6ULL</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br></pre></td></tr></table></figure><h1 id="5、修改lcd"><a href="#5、修改lcd" class="headerlink" title="5、修改lcd"></a>5、修改lcd</h1><p>在board&#x2F;freescale&#x2F;mx6ull_naro&#x2F;mx6ull_naro.c，修改如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">display_info_t</span> <span class="title">const</span> <span class="title">displays</span>[] =</span> &#123;&#123;</span><br><span class="line">.bus = MX6UL_LCDIF1_BASE_ADDR,</span><br><span class="line">.addr = <span class="number">0</span>,</span><br><span class="line">.pixfmt = <span class="number">24</span>,</span><br><span class="line">.detect = <span class="literal">NULL</span>,</span><br><span class="line">.enable= do_enable_parallel_lcd,</span><br><span class="line">.mode= &#123;</span><br><span class="line">.name= <span class="string">&quot;TFT4384&quot;</span>,</span><br><span class="line">.xres           = <span class="number">800</span>,</span><br><span class="line">.yres           = <span class="number">480</span>,</span><br><span class="line">.pixclock       = <span class="number">32258</span>,</span><br><span class="line">.left_margin    = <span class="number">88</span>,</span><br><span class="line">.right_margin   = <span class="number">40</span>,</span><br><span class="line">.upper_margin   = <span class="number">32</span>,</span><br><span class="line">.lower_margin   = <span class="number">13</span>,</span><br><span class="line">.hsync_len      = <span class="number">48</span>,</span><br><span class="line">.vsync_len      = <span class="number">3</span>,</span><br><span class="line">.sync           = <span class="number">0</span>,</span><br><span class="line">.vmode          = FB_VMODE_NONINTERLACED</span><br><span class="line">&#125; &#125; &#125;;</span><br></pre></td></tr></table></figure><p>.pixclock 这个值要参考屏幕的的手册。</p><h1 id="6、修改网络驱动"><a href="#6、修改网络驱动" class="headerlink" title="6、修改网络驱动"></a>6、修改网络驱动</h1><ul><li>在mx6ull_naro.h中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHPRIME<span class="string">&quot;FEC&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>修改为：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHPRIME<span class="string">&quot;FEC&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PHYLIB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_PHY_SMSC</span></span><br></pre></td></tr></table></figure><ul><li>在mx6ull_naro.c中,修改复位口，如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #define IOX_SDI IMX_GPIO_NR(5, 10)</span></span><br><span class="line"><span class="comment">// #define IOX_STCP IMX_GPIO_NR(5, 7)</span></span><br><span class="line"><span class="comment">// #define IOX_SHCP IMX_GPIO_NR(5, 11)</span></span><br><span class="line"><span class="comment">// #define IOX_OE IMX_GPIO_NR(5, 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENET1_RESET IMX_GPIO_NR(5, 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENET2_RESET IMX_GPIO_NR(5, 8)</span></span><br></pre></td></tr></table></figure></li></ul><p>继续往下找：将这部分注释掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> iox_pads[] = &#123;</span><br><span class="line"><span class="comment">// /* IOX_SDI */</span></span><br><span class="line"><span class="comment">// MX6_PAD_BOOT_MODE0__GPIO5_IO10 | MUX_PAD_CTRL(NO_PAD_CTRL),</span></span><br><span class="line"><span class="comment">// /* IOX_SHCP */</span></span><br><span class="line"><span class="comment">// MX6_PAD_BOOT_MODE1__GPIO5_IO11 | MUX_PAD_CTRL(NO_PAD_CTRL),</span></span><br><span class="line"><span class="comment">// /* IOX_STCP */</span></span><br><span class="line"><span class="comment">// MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),</span></span><br><span class="line"><span class="comment">// /* IOX_nOE */</span></span><br><span class="line"><span class="comment">// MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释掉下面的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">iox74lv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// int i;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_OE, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (i = 7; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 0);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 1);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 0);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//  * shift register will be output to pins</span></span><br><span class="line"><span class="comment">//  */</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (i = 7; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 0);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 1);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 0);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//  * shift register will be output to pins</span></span><br><span class="line"><span class="comment">//  */</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 1);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">iox74lv_set</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// int i;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (i = 7; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if (i == index)</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SDI, seq[qn_output[i]][0]);</span></span><br><span class="line"><span class="comment">// else</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 1);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 0);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//   * shift register will be output to pins</span></span><br><span class="line"><span class="comment">//   */</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (i = 7; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 0);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SDI, seq[qn_output[i]][1]);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_SHCP, 1);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 0);</span></span><br><span class="line"><span class="comment">// udelay(500);</span></span><br><span class="line"><span class="comment">// /*</span></span><br><span class="line"><span class="comment">//   * shift register will be output to pins</span></span><br><span class="line"><span class="comment">//   */</span></span><br><span class="line"><span class="comment">// gpio_direction_output(IOX_STCP, 1);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有这个，板子的初始化中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nt <span class="title function_">board_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Address of boot parameters */</span></span><br><span class="line">gd-&gt;bd-&gt;bi_boot_params = PHYS_SDRAM + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// imx_iomux_v3_setup_multiple_pads(iox_pads, ARRAY_SIZE(iox_pads));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iox74lv_init();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYS_I2C_MXC</span></span><br></pre></td></tr></table></figure><ul><li><p>在网口的接口体中添加复位接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> fec1_pads[] = &#123;</span><br><span class="line">MX6_PAD_GPIO1_IO06__ENET1_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),</span><br><span class="line">MX6_PAD_GPIO1_IO07__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_TX_DATA0__ENET1_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_TX_DATA1__ENET1_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_TX_EN__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_TX_CLK__ENET1_REF_CLK1 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_RX_DATA0__ENET1_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_RX_DATA1__ENET1_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_RX_ER__ENET1_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET1_RX_EN__ENET1_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">iomux_v3_cfg_t</span> <span class="type">const</span> fec2_pads[] = &#123;</span><br><span class="line">MX6_PAD_GPIO1_IO06__ENET2_MDIO | MUX_PAD_CTRL(MDIO_PAD_CTRL),</span><br><span class="line">MX6_PAD_GPIO1_IO07__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line"></span><br><span class="line">MX6_PAD_ENET2_TX_DATA0__ENET2_TDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_TX_DATA1__ENET2_TDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_TX_EN__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line"></span><br><span class="line">MX6_PAD_ENET2_RX_DATA0__ENET2_RDATA00 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_RX_DATA1__ENET2_RDATA01 | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_RX_EN__ENET2_RX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_ENET2_RX_ER__ENET2_RX_ER | MUX_PAD_CTRL(ENET_PAD_CTRL),</span><br><span class="line">MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>修改复位函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setup_iomux_fec</span><span class="params">(<span class="type">int</span> fec_id)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fec_id == <span class="number">0</span>) &#123;</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec1_pads,</span><br><span class="line"> ARRAY_SIZE(fec1_pads));</span><br><span class="line">gpio_direction_output(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec2_pads,</span><br><span class="line"> ARRAY_SIZE(fec2_pads));</span><br><span class="line">gpio_direction_output(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在uboot&#x2F;drivers&#x2F;net&#x2F;phy&#x2F;phy.c中添加如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">genphy_update_link</span><span class="params">(<span class="keyword">struct</span> phy_device *phydev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mii_reg;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PHY_SMSC</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lan8720_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> bmcr_reg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (lan8720_flag == <span class="number">0</span>) &#123;</span><br><span class="line">bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);</span><br><span class="line"><span class="keyword">while</span> (phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; <span class="number">0X8000</span>) &#123;</span><br><span class="line">udelay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);</span><br><span class="line">lan8720_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><p>不然网络复位有问题</p><h1 id="7、修改板子名字"><a href="#7、修改板子名字" class="headerlink" title="7、修改板子名字"></a>7、修改板子名字</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkboard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_mx6ull_9x9_evk())</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL 9x9 EVK\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL NARO\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8、编译测试"><a href="#8、编译测试" class="headerlink" title="8、编译测试"></a>8、编译测试</h1><p>重置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env default -a</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>配置uboot网络环境,有两个网口，设置mac要注意顺序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.8.11</span><br><span class="line">setenv eth1addr b8:ae:1d:01:00:00</span><br><span class="line">setenv gatewayip 192.168.8.1</span><br><span class="line">setenv netmask 255.255.255.0</span><br><span class="line">setenv serverip 192.168.8.9</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>启动后。测试ping通，显示正常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=&gt; ping 192.168.8.9</span><br><span class="line">Using ethernet@20b4000 device</span><br><span class="line">host 192.168.8.9 is alive</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; imx6ull-14x14-emmc-4.3-800x480-c.dtb; bootz 80800000 - 83000000;&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>可以通过下面命令核对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc part</span><br><span class="line">fatls mmc 1:1</span><br></pre></td></tr></table></figure><p>网络挂载系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-naro-emmc.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nfs挂载文件出错</title>
      <link href="/posts/be6530dc.html"/>
      <url>/posts/be6530dc.html</url>
      
        <content type="html"><![CDATA[<p>在uboot中设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootargs,setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.8.213:/home/ygc/Desktop/driver/nfs/rootfs,proto=tcp rw ip=192.168.8.50:192.168.8.213:192.168.8.1:255.255.255.0::eth0:off&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是引导后出现nfs挂载网络根文件系统是出现错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0)</span><br><span class="line">---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0)</span><br><span class="line">random: nonblocking pool is initialized</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过各种试验发现是nfs服务的问题。</p><p>原因是：ubuntu18.04只支持nfs 3和nfs 4，而uboot默认使用nfs 2。</p><p>解决方法：</p><p>在ubuntu16.04以上的 “&#x2F;etc&#x2F;default&#x2F;nfs-kernel-server” 文件末尾加一行，如图所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Number of servers to start up</span><br><span class="line">RPCNFSDCOUNT=&quot;-V 2 8&quot;</span><br><span class="line"></span><br><span class="line"># Runtime priority of server (see nice(1))</span><br><span class="line">RPCNFSDPRIORITY=0</span><br><span class="line"></span><br><span class="line"># Options for rpc.mountd.</span><br><span class="line"># If you have a port-based firewall, you might want to set up</span><br><span class="line"># a fixed port here using the --port option. For more information, </span><br><span class="line"># see rpc.mountd(8) or http://wiki.debian.org/SecuringNFS</span><br><span class="line"># To disable NFSv4 on the server, specify &#x27;--no-nfs-version 4&#x27; here</span><br><span class="line">RPCMOUNTDOPTS=&quot;-V 2 --manage-gids&quot;</span><br><span class="line"></span><br><span class="line"># Do you want to start the svcgssd daemon? It is only required for Kerberos</span><br><span class="line"># exports. Valid alternatives are &quot;yes&quot; and &quot;no&quot;; the default is &quot;no&quot;.</span><br><span class="line">NEED_SVCGSSD=&quot;&quot;</span><br><span class="line"></span><br><span class="line"># Options for rpc.svcgssd.</span><br><span class="line">RPCSVCGSSDOPTS=&quot;&quot;</span><br><span class="line">RPCSNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的之对ubuntu20.04以前的版本生效</p><p>20.04以后的版本需要将sudo vim &#x2F;etc&#x2F;nfs.conf,没有就自己创建一份<br>中的将文件中的udp和ver2打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[nfsd]</span><br><span class="line"># debug=0</span><br><span class="line"># threads=8</span><br><span class="line"># host=</span><br><span class="line"># port=0</span><br><span class="line"># grace-time=90</span><br><span class="line"># lease-time=90</span><br><span class="line">udp=y</span><br><span class="line"># tcp=y</span><br><span class="line">vers2=y</span><br><span class="line"># vers3=y</span><br><span class="line"># vers4=y</span><br><span class="line"># vers4.0=y</span><br><span class="line"># vers4.1=y</span><br><span class="line"># vers4.2=y</span><br><span class="line"># rdma=n</span><br><span class="line"># rdma-port=20049</span><br></pre></td></tr></table></figure><p>ubuntu22.04无法开启v2，已经验证  </p><p>查看版本<br>cat &#x2F;proc&#x2F;fs&#x2F;nfsd&#x2F;versions</p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见问题汇总</title>
      <link href="/posts/83ff2157.html"/>
      <url>/posts/83ff2157.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、挂在busybox的时候出现内核崩溃"><a href="#1、挂在busybox的时候出现内核崩溃" class="headerlink" title="1、挂在busybox的时候出现内核崩溃"></a>1、挂在busybox的时候出现内核崩溃</h1><p><img src="./../../../img/2_%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/%E5%BD%93%E6%8C%82%E5%9C%A8busybox%E5%87%BA%E7%8E%B0%E5%86%85%E6%A0%B8%E5%B4%A9%E6%BA%83%E7%9A%84%E9%94%99%E8%AF%AF/%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.png"></p><p>解决办法， 原因为没有使用交叉编译器进行编译，在Makefile中定义一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE ?= arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">ARCH ？= arm</span><br></pre></td></tr></table></figure><p>如果不定义，需要在编译的时候加上CROSS那一串。<br>​</p><h1 id="2、popen函数引发僵尸进程"><a href="#2、popen函数引发僵尸进程" class="headerlink" title="2、popen函数引发僵尸进程"></a>2、popen函数引发僵尸进程</h1><p>目前没有好的办法，将调用频率降低，或者使用fork函数。</p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>问题总结</title>
      <link href="/posts/c0eb5989.html"/>
      <url>/posts/c0eb5989.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、隐式函数错误一般原因"><a href="#1、隐式函数错误一般原因" class="headerlink" title="1、隐式函数错误一般原因"></a>1、隐式函数错误一般原因</h1><p>写驱动的时候经常遇到报隐式函数的报错，很麻烦，查找了很多原因,一般是函数拼写错误。</p><h1 id="2、system命令导致系统问题"><a href="#2、system命令导致系统问题" class="headerlink" title="2、system命令导致系统问题"></a>2、system命令导致系统问题</h1><p>system会导致系统出现严重的性能消耗，如果在程序中调用，需要单独开启一个线程进行使用，否则会生不可知错误。</p><h1 id="3、结构体易错点"><a href="#3、结构体易错点" class="headerlink" title="3、结构体易错点"></a>3、结构体易错点</h1><h2 id="3-1、第一个易错点"><a href="#3-1、第一个易错点" class="headerlink" title="3-1、第一个易错点"></a>3-1、第一个易错点</h2><p>采用memset函数初始化结构体，全部成员变量的值清零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;queen,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项，如果把一个结构体的地址传给子函数，子函数用一个结构体指针（如struct st_girl *pst）来存放传入的结构体的地址，那么，在子函数中只能用以下方法来初始化结构体：          </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br></pre></td></tr></table></figure><p>不能用以下方法来初始化结构体：         </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(pst,<span class="number">0</span>,<span class="keyword">sizeof</span>(pst));</span><br></pre></td></tr></table></figure><p>因为子函数中用sizeof(pst)，得到的不是结构体占用内存的字节数，而是结构体指针变量占用内存的字节数（8字节）                  </p><h2 id="3-2、第二个易错点"><a href="#3-2、第二个易错点" class="headerlink" title="3-2、第二个易错点"></a>3-2、第二个易错点</h2><p>结构体是一种自定义的数据类型，结构体变量是内存变量，有内存地址，也就有结构体指针。</p><p>在指针章节中我们已经学习过，采用不同数据类型的指针指向不同数据类型的变量的地址，这一规则也适用于结构体。如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">queen</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> *<span class="title">pst</span>=</span>&amp; queen;</span><br></pre></td></tr></table></figure><p>通过结构体指针可以使用结构体成员，一般形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pointer).memberName</span><br></pre></td></tr></table></figure><p>或者：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;memberName</span><br></pre></td></tr></table></figure><p>第一种写法中，圆点.的优先级高于<em>，(<em>pointer)两边的括号不能少。如果去掉括号写作</em>pointer.memberName，那么就等效于</em>(pointer.memberName)，这样意义就完全不对了。</p><p>第二种写法中，-&gt;是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接使用结构体成员；这也是-&gt;在C语言中的唯一用途。</p><p>上面的两种写法是等效的，程序员通常采用后面的写法，这样更加直观。</p><h2 id="3-3、第三个易错点"><a href="#3-3、第三个易错点" class="headerlink" title="3-3、第三个易错点"></a>3-3、第三个易错点</h2><p>在C语言中，结构体的成员如果是基本数据类型（int、char、double）可以用&#x3D;号赋值，如果是字符串，字符串不是基本数据类型，可以用strcpy函数赋值，如果要把结构体变量的值赋给另一个结构体变量，有两种方法：1）一种是把结构体变量成员的值逐个赋值给另一个结构体变量的成员，这种方法太笨，没人使用；2）另一种方法是内存拷贝，C语言提供了memcpy（memory copy的简写）实现内存拷贝功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参数说明：</p><p>src 源内存变量的起始地址。</p><p>dest 目的内存变量的起始地址。</p><p>n 需要复制内容的字节数。</p><p>函数返回指向dest的地址，函数的返回值意义不大，程序员一般不关心这个返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 程序名：book94.c， 此程序演示采用memcpy函数复制结构体</span></span><br><span class="line"><span class="comment"> * 作者：C语言技术网(www.freecplus.net) 日期：20190525</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">50</span>];     <span class="comment">// 姓名</span></span><br><span class="line">  <span class="type">int</span>  age;          <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_girl</span> <span class="title">girl1</span>,<span class="title">girl2</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(girl1.name,<span class="string">&quot;西施&quot;</span>);  <span class="comment">// 对girl1的成员赋值</span></span><br><span class="line">  girl1.age=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把girl1的内容复制到girl2中</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;girl2,&amp;girl1,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> st_girl));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girl1.name=%s,girl1.age=%d\n&quot;</span>,girl1.name,girl1.age);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;girl2.name=%s,girl2.age=%d\n&quot;</span>,girl2.name,girl2.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能想起了strcpy函数，与memcpy有相似之处，实际上这两个函数从功能和实现原理上完本不同，甚至不应该放在一起比较。</p><p>1）复制的内容不同，strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</p><p>2）用途不同，通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</p><p>3）复制的方法不同，strcpy不需要指定长度，它遇到被复制字符的串结尾符0才结束，memcpy则是根据其第3个参数决定复制的长度.</p><h1 id="4、变量，函数等命名"><a href="#4、变量，函数等命名" class="headerlink" title="4、变量，函数等命名"></a>4、变量，函数等命名</h1><p>函数，变量命名长度有限制，超过限制通常报未定义错误。</p>]]></content>
      
      
      <categories>
          
          <category> 问题总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、设备树学习的关键问题"><a href="#1、设备树学习的关键问题" class="headerlink" title="1、设备树学习的关键问题"></a>1、设备树学习的关键问题</h1><h2 id="1-1、设备树是什么"><a href="#1-1、设备树是什么" class="headerlink" title="1-1、设备树是什么"></a>1-1、设备树是什么</h2><p>(1)device tree，设备树，是一种linux内核中采用的参数表示和传递的一种技术。<br>(2)dts，device tree source ,设备树源文件  一般的给改设备树就在这里进行。<br>(3)dtc，device tree compiler，设备树编译&#x2F;调试工具。<br>(4)dtb，device tree blob，二进制设备树镜像。</p><h2 id="1-2、为什么需要设备树"><a href="#1-2、为什么需要设备树" class="headerlink" title="1-2、为什么需要设备树"></a>1-2、为什么需要设备树</h2><p>(1)典型需求就是内核设备驱动，但不止可以用在驱动上，也可以用在uboot向内核的传参。<br>(2)驱动源码包括2大部分：策略（操作函数）和数据（硬件信息）。<br>(3)早期在策略和数据都在kernel中。   </p><h2 id="1-3、设备树如何工作的"><a href="#1-3、设备树如何工作的" class="headerlink" title="1-3、设备树如何工作的"></a>1-3、设备树如何工作的</h2><p>(1)驱动开发者编写或者改写dts ,适配硬件和自己的需求。<br>(2)make uImage时，kernel会先编译出dtc，然后用dtc加工成dtb。<br>(3)uboot启动kernel时，将uImage和dtb都准备好并告诉uImage在哪里找到dtb。<br>(4)kernel启动初期会调用内部的函数去解析dtb，得到硬件信息，并组装成数据结构，配合策略函数工作。   </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xml语法规则</title>
      <link href="/posts/e2fc93b1.html"/>
      <url>/posts/e2fc93b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="xml读写规则"><a href="#xml读写规则" class="headerlink" title="xml读写规则"></a>xml读写规则</h1><p><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/xml%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99/xml%E8%AF%BB%E5%86%99%E8%A7%84%E5%88%99.png"><br>        # 避免 “:” 字符。冒号会被转换为命名空间来使用<br>        表格定义：标签结构<br>        数据对应：指定元素</p><pre><code>所有的标题都用&lt;&gt;来表示。示例&lt;新闻&gt;            &lt;新闻&gt;                        &lt;id&gt;&lt;1001&gt;&lt;\id&gt;                        &lt;标题&gt;&lt;尚......&gt;&lt;\标题&gt;                        &lt;&gt;......                        ......            &lt;\新闻&gt;                    &lt;id&gt;&lt;1002&gt;&lt;\id&gt;                    &lt;标题&gt;&lt;JAVA......&gt;&lt;\标题&gt;                    &lt;&gt;......                    ......&lt;\新闻&gt;    </code></pre><p>XML 被设计用来传输和存储数据。<br>HTML 被设计用来显示数据。</p><h1 id="XML-简化数据传输"><a href="#XML-简化数据传输" class="headerlink" title="XML 简化数据传输"></a>XML 简化数据传输</h1><pre><code>    通过 XML，可以在不兼容的系统之间轻松地交换数据。对开发人员来说，其中一项最费时的挑战一直是在因特网上的不兼容系统之间交换数据。由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</code></pre><h1 id="XML-简化平台的变更"><a href="#XML-简化平台的变更" class="headerlink" title="XML 简化平台的变更"></a>XML 简化平台的变更</h1><pre><code>    升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。    XML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新应用程序或新的浏览器。</code></pre><h1 id="XML-标签对大小写敏感"><a href="#XML-标签对大小写敏感" class="headerlink" title="XML 标签对大小写敏感"></a>XML 标签对大小写敏感</h1><pre><code>XML 元素使用 XML 标签进行定义。XML 标签对大小写敏感。在 XML 中，标签 &lt;Letter&gt; 与标签 &lt;letter&gt; 是不同的。必须使用相同的大小写来编写打开标签和关闭标签：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Message&gt;这是错误的。&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;message&gt;这是正确的。&lt;/message&gt; </span><br></pre></td></tr></table></figure><h1 id="XML-必须正确地嵌套"><a href="#XML-必须正确地嵌套" class="headerlink" title="XML 必须正确地嵌套"></a>XML 必须正确地嵌套</h1><pre><code>在 HTML 中，常会看到没有正确嵌套的元素：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</span><br><span class="line">在 XML 中，所有元素都必须彼此正确地嵌套：</span><br><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure><pre><code>    在上例中，正确嵌套的意思是：由于 &lt;i&gt; 元素是在 &lt;b&gt; 元素内打开的，那么它必须在 &lt;b&gt; 元素内关闭。</code></pre><h1 id="XML-文档必须有根元素"><a href="#XML-文档必须有根元素" class="headerlink" title="XML 文档必须有根元素"></a>XML 文档必须有根元素</h1><pre><code>XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;child&gt;</span><br><span class="line">    &lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">  &lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h1 id="XML-的属性值须加引号"><a href="#XML-的属性值须加引号" class="headerlink" title="XML 的属性值须加引号"></a>XML 的属性值须加引号</h1><pre><code>与 HTML 类似，XML 也可拥有属性（名称/值的对）。XML 元素可以在开始标签中包含属性，类似 HTML。属性 (Attribute) 提供关于元素的额外（附加）信息。在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;note date=08/08/2008&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;/note&gt; </span><br><span class="line">&lt;note date=&quot;08/08/2008&quot;&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;/note&gt; </span><br></pre></td></tr></table></figure><pre><code>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</code></pre><h1 id="XML-属性必须加引号"><a href="#XML-属性必须加引号" class="headerlink" title="XML 属性必须加引号"></a>XML 属性必须加引号</h1><pre><code>    属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 标签可以这样写：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;person sex=&quot;female&quot;&gt;</span><br><span class="line">或者这样也可以：</span><br><span class="line"></span><br><span class="line">&lt;person sex=&#x27;female&#x27;&gt;</span><br><span class="line">注释：如果属性值本身包含双引号，那么有必要使用单引号包围它，就像这个例子：</span><br><span class="line"></span><br><span class="line">&lt;gangster name=&#x27;George &quot;Shotgun&quot; Ziegler&#x27;&gt;</span><br><span class="line">或者可以使用实体引用：</span><br><span class="line"></span><br><span class="line">&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="XML-中的注释"><a href="#XML-中的注释" class="headerlink" title="XML 中的注释"></a>XML 中的注释</h1><pre><code>在 XML 中编写注释的语法与 HTML 的语法很相似：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is a comment --&gt; </span><br></pre></td></tr></table></figure><h1 id="在-XML-中，空格会被保留"><a href="#在-XML-中，空格会被保留" class="headerlink" title="在 XML 中，空格会被保留"></a>在 XML 中，空格会被保留</h1><pre><code>HTML 会把多个连续的空格字符裁减（合并）为一个：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML:Hello           my name is David.</span><br><span class="line">输出:Hello my name is David.</span><br><span class="line">在 XML 中，文档中的空格不会被删节。</span><br></pre></td></tr></table></figure><h1 id="XML-文档包含-XML-元素。"><a href="#XML-文档包含-XML-元素。" class="headerlink" title="XML 文档包含 XML 元素。"></a>XML 文档包含 XML 元素。</h1><pre><code>    什么是 XML 元素？XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bookstore&gt;</span><br><span class="line">&lt;book category=&quot;CHILDREN&quot;&gt;</span><br><span class="line">  &lt;title&gt;Harry Potter&lt;/title&gt; </span><br><span class="line">  &lt;author&gt;J K. Rowling&lt;/author&gt; </span><br><span class="line">  &lt;year&gt;2005&lt;/year&gt; </span><br><span class="line">  &lt;price&gt;29.99&lt;/price&gt; </span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;book category=&quot;WEB&quot;&gt;</span><br><span class="line">  &lt;title&gt;Learning XML&lt;/title&gt; </span><br><span class="line">  &lt;author&gt;Erik T. Ray&lt;/author&gt; </span><br><span class="line">  &lt;year&gt;2003&lt;/year&gt; </span><br><span class="line">  &lt;price&gt;39.95&lt;/price&gt; </span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;/bookstore&gt; </span><br></pre></td></tr></table></figure><pre><code>        在上例中，&lt;bookstore&gt; 和 &lt;book&gt; 都拥有元素内容，因为它们包含了其他元素。    &lt;author&gt; 只有文本内容，因为它仅包含文本。    在上例中，只有 &lt;book&gt; 元素拥有属性 (category=&quot;CHILDREN&quot;)。</code></pre><h1 id="XML-元素是可扩展的"><a href="#XML-元素是可扩展的" class="headerlink" title="XML 元素是可扩展的"></a>XML 元素是可扩展的</h1><pre><code>XML 元素是可扩展，以携带更多的信息。</code></pre><p>请看下面这个 XML 例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt; </span><br></pre></td></tr></table></figure><p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及 <body> 元素提取出来，并产生以下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">To: George</span><br><span class="line">From: John</span><br><span class="line"></span><br><span class="line">Don&#x27;t forget the meeting!</span><br></pre></td></tr></table></figure><pre><code>想象一下，之后这个 XML 文档作者又向这个文档添加了一些额外的信息：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;note&gt;</span><br><span class="line">&lt;date&gt;2008-08-08&lt;/date&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><pre><code>那么这个应用程序会中断或崩溃吗？不会。这个应用程序仍然可以找到 XML 文档中的 &lt;to&gt;、&lt;from&gt; 以及 &lt;body&gt; 元素，并产生同样的输出。XML 的优势之一，就是可以经常在不中断应用程序的情况进行扩展。</code></pre><h1 id="XML-命名空间提供避免元素命名冲突的方法。"><a href="#XML-命名空间提供避免元素命名冲突的方法。" class="headerlink" title="XML 命名空间提供避免元素命名冲突的方法。"></a>XML 命名空间提供避免元素命名冲突的方法。</h1><pre><code>    命名冲突在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。这个 XML 文档携带着某个表格中的信息：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;Apples&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;Bananas&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><pre><code>这个 XML 文档携带有关桌子的信息（一件家具）：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">   &lt;name&gt;African Coffee Table&lt;/name&gt;</span><br><span class="line">   &lt;width&gt;80&lt;/width&gt;</span><br><span class="line">   &lt;length&gt;120&lt;/length&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><pre><code>假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 &lt;table&gt; 元素，就会发生命名冲突。XML 解析器无法确定如何处理这类冲突。</code></pre><p>本篇完结！</p>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器视觉、音视频开发</title>
      <link href="/posts/e33939ec.html"/>
      <url>/posts/e33939ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><pre><code>  ipc的英文是ipcamera，没入行之前认为这是嵌入式驱动相关的    工作，后来才知道不是。    基本的过程：采集图像，进行存储，进行传输。    IPC开发为目前嵌入式前沿技术最为密集的领域，    涉及AI，图像识别，人脸识别，动作识别，各种算法等。</code></pre><p><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/ipc%E5%BC%80%E5%8F%91/%E6%A6%82%E8%BF%B0.png"></p><h2 id="1-1、原理"><a href="#1-1、原理" class="headerlink" title="1-1、原理"></a>1-1、原理</h2><p><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/ipc%E5%BC%80%E5%8F%91/%E5%8E%9F%E7%90%86.png"></p><pre><code>    首先是外景的光线进入镜头，经过一定调焦，打到图像传感器上，也就是sensor，转换成模拟信号，然后通过A/D转换，转换成数字信号。然后经过DSP编码处理。（如果出现模糊等各种情况就可以进行追溯，比如是镜头问题等）    数据消费中的其他指的是传给其他的平台，进行协议的对接。</code></pre><h2 id="1-2、方案介绍"><a href="#1-2、方案介绍" class="headerlink" title="1-2、方案介绍"></a>1-2、方案介绍</h2><pre><code> 当有的人问你，你们公司的摄像机是基于什么方案，什么平台做的外围的配件、电机、摄像头、麦克风等一般都是从供应商拿的，而主控芯片，就是从方案代理公司拿的，所以就是，主控是什么类型的，方案就是基于什么来做的。一般的方案公司有：海思、富瀚、瑞芯微，全志、索尼。所以就形成了一个上下游：芯片制造、芯片代理、方案代理、安防公司。一般从方案公司拿到芯片和sdk。sdk包：具体有arm板文档、uboot、内核、文件系统、busybox、驱动、库、工具，硬件上则是有一个demo板。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>onvif协议</title>
      <link href="/posts/df20592e.html"/>
      <url>/posts/df20592e.html</url>
      
        <content type="html"><![CDATA[<pre><code>probe为onvif连接时，会产生一个广播，一般情况下不影响整个协议。WSDL的web服务公共接口。之间的关系，onvif协议以soap协议为基础，而soap又是用WSDL进行规范，所以onvif相当于规范了WSDL。理解上：onvif = 服务端 +客户端 =（web services + rtsp）+ 客户端 =（ （WSDL + soap）+rtsp）+ 客户端WSDL是服务端用来向客户描述自己实现那些请求，发送请求时需要带上那些参数xml格式soap是客户端向服务器端发送请求时xml的参数格式。web services是实现摄像头控制（比如一些参数配置、摄像头上下左右（PTZ）控制）；rtsp实现摄像头传输，web services指ipc控制到具体的技术实现，进行技术交互，其实和http差不多，客户端类似http post的格式向服务端发送请求，然后服务端响应客户端请求。onvif中的profiles是什么？onvif提供了很多的profiles概要文件，用来规范onvif设备端与onvif客户端的通信标准。目前已经发布的profile文件主要包括S，G，C，Q，A，不同的profile文件应用于不同的领域，不同的profile文件可以组合使用，profile文件的一致性是确保符合onvif产品兼容性的唯一方法，因此，只有符合profile文件的注册产品才被认为是兼容onvif的。profile S应用于网络视频系统，内容包括：1、视频和音频流2、PTZ控制和继电器输出3、视频配置和多播profile S应用于网络视频系统。profile S的设备（例如：网络摄像机或视频编码器）可以将视频数据通过IP网络发送到profile S的客户端。profile S的客户端（例如：视频管理软件）可以配置、请求和控制从profile S的设备上的IP网络视频流。profile G应用于边缘存储与检索，内容包括：1、配置、请求、控制录像2、接收视频/音频流profile G设备（例如：网络摄像机或视频编码器）可以通过网络存储或本地存储录像。profile G客户端（例如：视频管理软件）可以配置、请求和控制profile G设备上的录像profile C应用网络电子门禁系统，内容包括：1、站点信息和配置2、事件和警报管理3、门禁控制profile C应用于电子门禁系统。profile C设备和客户应支持站点信息、门禁控制、事件和报警管理。profile Q应用于快速安装，内容包括：1、简单的设置2、发现、配置和控制设备3、先进的安全功能profile Q应用于网络视频系统，其目的是提供profile Q产品的快速发现和配置（例如：网路摄像机、网络交换机、网络监视器）。profile Q的客户端能够发现、配置和控制profile Q设备。peofile Q也支持传输层安全协议（TLS），允许onvif设备与客户端以防止被篡改和窃听的安全方式进行通讯。profile A应用于更广泛的访问控制配置，内容包括：1、授予/撤销证书2、创建时间表3、指定访问规则profie A应用于电子门禁系统。profile A的设备可以检索信息，状态和事件，并配置访问规则、凭据和时间表等。profile A的客户端可以访问规则配置、凭据和时间表。profile A客户端还可以检索和接收标准化的访问控制相关的事件。profile T适用于高级视频流，内容包括：1、H.264/H.265视频压缩2、成像设置3、动作报警和篡改事件4、元数据流5、双向音频profile T专为基于IP的视频系统而设计。profile T支持视频流的功能，例如使用H.264和H.265编码格式，成像设置及诸运动和篡改检测之类的警报事件，设备的强制功能还包括屏幕显示和元数据流，而客户端的强制功能还包括PTZ控制。profile T还覆盖了用于HTTOS流，PTZ配置，运动区配置，数字输入和继电器输出的onvif规范，以及支持此类功能的符合设备和客户端的双向音频。</code></pre><h1 id="1、规范的内容"><a href="#1、规范的内容" class="headerlink" title="1、规范的内容"></a>1、规范的内容</h1><pre><code>1、DeviceMgmt（设备管理） 2、DeviceIO（设备io服务）3、Event（事件服务）4、Analytics（视频分析）5、AnalyticsDevice（分析设备）6、Display（显示服务）7、Imaging（图像配置）8、Media（媒体配置）9、PTZ（PTZ控制）10、Receiver（接收端配置）11、RemoteDiscovery（设备发现）12、Recording（录像控制）13、Replay（重新控制）14、Search（记录搜索）</code></pre><h2 id="1-1、怎么查找？"><a href="#1-1、怎么查找？" class="headerlink" title="1-1、怎么查找？"></a>1-1、怎么查找？</h2><pre><code>    需要了解那一部分的内容，只需要查找对应的接口文档，例如移动侦测就去找event的文档。文档已下载。</code></pre><h1 id="2、web-service-wsdl-soap"><a href="#2、web-service-wsdl-soap" class="headerlink" title="2、web service + wsdl +soap"></a>2、web service + wsdl +soap</h1><h2 id="2-1、web-service"><a href="#2-1、web-service" class="headerlink" title="2-1、web service"></a>2-1、web service</h2><pre><code>web service主要使用HTTP和soap协议使数据在web上传输。web service是基于xml和http的一种服务，其通讯协议主要基于soap。服务端、客户端传递符合xml的soap消息实现服务的请求与回应。客户端根据wsdl描述文档，会生成一个soap请求消息，该请求会被嵌入在一个HTTP post请求中，发送到web services所在的web服务器，web services请求处理器解析收到的soap请求，调用相应的web services。然后再生成相应的soap应答。web服务器得到soap应答后，会再通过http应答的方式把信息送回客户端。</code></pre><h2 id="2-2、wsdl"><a href="#2-2、wsdl" class="headerlink" title="2-2、wsdl"></a>2-2、wsdl</h2><pre><code>是一个用来描述Web服务和说明如何与Web服务通信的XML语言，为用户提供详细的接口说明书</code></pre><h1 id="3、ONVIF-能力集"><a href="#3、ONVIF-能力集" class="headerlink" title="3、ONVIF 能力集"></a>3、ONVIF 能力集</h1><pre><code>    ONVIF设备管理标准分为如下子标准，其中前5个是ONVIF设备必须实现的，后面2个是可选操作</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CapabilitiesONVIF设备能力集相关API</span><br><span class="line">Network网络相关API</span><br><span class="line">System系统配置相关API</span><br><span class="line">Security安全相关API</span><br><span class="line">Input/Output(I/O)</span><br><span class="line">Auxiliary operation</span><br><span class="line">Storage Configuration</span><br></pre></td></tr></table></figure><h2 id="3-1、交集过程（示例）"><a href="#3-1、交集过程（示例）" class="headerlink" title="3-1、交集过程（示例）"></a>3-1、交集过程（示例）</h2><h3 id="3-1-1、Getcapabilities"><a href="#3-1-1、Getcapabilities" class="headerlink" title="3-1-1、Getcapabilities"></a>3-1-1、Getcapabilities</h3><pre><code>tds:Getcapabilities客户端请求报文：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://www.w3.org/2003/05/soap-envelope&quot; </span><br><span class="line">xmlns:tds=&quot;http://www.onvif.org/ver10/device/wsdl&quot;&gt; </span><br><span class="line">&lt;SOAP-ENV:Body&gt; </span><br><span class="line">&lt;tds:GetCapabilities&gt; </span><br><span class="line">   &lt;tds:Category&gt;All&lt;/tds:Category&gt; </span><br><span class="line">&lt;/tds:GetCapabilities&gt; </span><br><span class="line">&lt;/SOAP-ENV:Body&gt; </span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>    服务器回复报文：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://www.w3.org/2003/05/soap-envelope&quot; </span><br><span class="line">xmlns:tt=&quot;http://www.onvif.org/ver10/schema&quot; </span><br><span class="line">xmlns:tds=&quot;http://www.onvif.org/ver10/device/wsdl&quot;&gt; </span><br><span class="line"> &lt;SOAP-ENV:Body&gt; </span><br><span class="line">  &lt;tds:GetCapabilitiesResponse&gt; </span><br><span class="line">&lt;tds:Capabilities&gt; </span><br><span class="line">&lt;tt:Device&gt; </span><br><span class="line">&lt;tt:XAddr&gt;http://169.254.76.145/onvif/services&lt;/tt:XAddr&gt; </span><br><span class="line">&lt;tt:Network&gt; </span><br><span class="line">&lt;tt:IPFilter&gt;true&lt;/tt:IPFilter&gt; </span><br><span class="line">&lt;tt:ZeroConfiguration&gt;true&lt;/tt:ZeroConfiguration&gt; </span><br><span class="line">&lt;tt:IPVersion6&gt;true&lt;/tt:IPVersion6&gt; </span><br><span class="line">&lt;tt:DynDNS&gt;true&lt;/tt:DynDNS&gt; </span><br><span class="line">&lt;/tt:Network&gt; </span><br><span class="line">&lt;tt:System&gt; </span><br><span class="line">&lt;tt:DiscoveryResolve&gt;true&lt;/tt:DiscoveryResolve&gt; </span><br><span class="line">   &lt;tt:DiscoveryBye&gt;true&lt;/tt:DiscoveryBye&gt; </span><br><span class="line">&lt;tt:RemoteDiscovery&gt;false&lt;/tt:RemoteDiscovery&gt; </span><br><span class="line">&lt;tt:SystemBackup&gt;false&lt;/tt:SystemBackup&gt; </span><br><span class="line">&lt;tt:SystemLogging&gt;true&lt;/tt:SystemLogging&gt; </span><br><span class="line">&lt;tt:FirmwareUpgrade&gt;false&lt;/tt:FirmwareUpgrade&gt; </span><br><span class="line">&lt;tt:SupportedVersions&gt; </span><br><span class="line">&lt;tt:Major&gt;1&lt;/tt:Major&gt; </span><br><span class="line">&lt;tt:Minor&gt;0&lt;/tt:Minor&gt; </span><br><span class="line">&lt;/tt:SupportedVersions&gt; </span><br><span class="line">&lt;/tt:System&gt; </span><br><span class="line">&lt;tt:IO&gt; </span><br><span class="line">&lt;tt:InputConnectors&gt;1&lt;/tt:InputConnectors&gt; </span><br><span class="line">&lt;tt:RelayOutputs&gt;0&lt;/tt:RelayOutputs&gt; </span><br><span class="line">&lt;/tt:IO&gt; </span><br><span class="line">&lt;tt:Security&gt; </span><br><span class="line">&lt;tt:TLS1.1&gt;false&lt;/tt:TLS1.1&gt; </span><br><span class="line">&lt;tt:TLS1.2&gt;false&lt;/tt:TLS1.2&gt; </span><br><span class="line">&lt;tt:OnboardKeyGeneration&gt;false&lt;/tt:OnboardKeyGeneration&gt; </span><br><span class="line">&lt;tt:AccessPolicyConfig&gt;false&lt;/tt:AccessPolicyConfig&gt; </span><br><span class="line">&lt;tt:X.509Token&gt;false&lt;/tt:X.509Token&gt; </span><br><span class="line">&lt;tt:SAMLToken&gt;false&lt;/tt:SAMLToken&gt; </span><br><span class="line">&lt;tt:KerberosToken&gt;false&lt;/tt:KerberosToken&gt; </span><br><span class="line">&lt;tt:RELToken&gt;false&lt;/tt:RELToken&gt; </span><br><span class="line">&lt;/tt:Security&gt; </span><br><span class="line">&lt;/tt:Device&gt; </span><br><span class="line">&lt;tt:Events&gt; </span><br><span class="line">&lt;tt:XAddr&gt;http://169.254.76.145/onvif/services&lt;/tt:XAddr&gt; </span><br><span class="line">&lt;tt:WSSubscriptionPolicySupport&gt;false&lt;/tt:WSSubscriptionPolicySupport&gt; </span><br><span class="line">&lt;tt:WSPullPointSupport&gt;false&lt;/tt:WSPullPointSupport&gt;</span><br><span class="line">&lt;tt:WSPausableSubscriptionManagerInterfaceSupport&gt;false&lt;/tt:WSPausableSubscriptionManagerInterfaceSupport&gt; </span><br><span class="line">   &lt;/tt:Events&gt;</span><br><span class="line">&lt;tt:Media&gt; </span><br><span class="line">   &lt;tt:XAddr&gt;http://169.254.76.145/onvif/services&lt;/tt:XAddr&gt; </span><br><span class="line">   &lt;tt:StreamingCapabilities&gt; </span><br><span class="line">   &lt;tt:RTPMulticast&gt;true&lt;/tt:RTPMulticast&gt; </span><br><span class="line">   &lt;tt:RTP_TCP&gt;true&lt;/tt:RTP_TCP&gt; </span><br><span class="line">   &lt;tt:RTP_RTSP_TCP&gt;true&lt;/tt:RTP_RTSP_TCP&gt; </span><br><span class="line">   &lt;/tt:StreamingCapabilities&gt; </span><br><span class="line">&lt;/tt:Media&gt; </span><br><span class="line">&lt;/tds:Capabilities&gt; </span><br><span class="line">  &lt;/tds:GetCapabilitiesResponse&gt; </span><br><span class="line"> &lt;/SOAP-ENV:Body&gt; </span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>宇视后端抓取得：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">POST /onvif/device_service HTTP/1.1</span><br><span class="line">Host: 192.168.1.100:9007</span><br><span class="line">User-Agent: SOAP Client</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: 963</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot; ?&gt;</span><br><span class="line">&lt;s:Envelope</span><br><span class="line">    xmlns:s=&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span><br><span class="line">    xmlns:sc=&quot;http://www.w3.org/2003/05/soap-encoding&quot;</span><br><span class="line">    xmlns:tt=&quot;http://www.onvif.org/ver10/schema&quot;</span><br><span class="line">    xmlns:wsnt=&quot;http://docs.oasis-open.org/wsn/b-2&quot;</span><br><span class="line">    xmlns:wsrf-bf=&quot;http://docs.oasis-open.org/wsrf/bf-2&quot;</span><br><span class="line">    xmlns:xop=&quot;http://www.w3.org/2004/08/xop/include&quot;</span><br><span class="line">    xmlns:tds=&quot;http://www.onvif.org/ver10/device/wsdl&quot;</span><br><span class="line">    xmlns:wsa5=&quot;http://www.w3.org/2005/08/addressing&quot;</span><br><span class="line">    xmlns:wstop=&quot;http://docs.oasis-open.org/wsn/t-1&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;</span><br><span class="line">    xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;</span><br><span class="line">    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">    xmlns:xmime=&quot;http://tempuri.org/xmime.xsd&quot;&gt;</span><br><span class="line">    &lt;s:Header/&gt;</span><br><span class="line">    &lt;s:Body&gt;</span><br><span class="line">        &lt;tds:GetCapabilities&gt;</span><br><span class="line">            &lt;tds:Category&gt;All&lt;/tds:Category&gt;</span><br><span class="line">        &lt;/tds:GetCapabilities&gt;</span><br><span class="line">    &lt;/s:Body&gt;</span><br><span class="line">&lt;/s:Envelope&gt;HTTP/1.1 200 OK</span><br><span class="line">Server: hsoap/2.8</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT, OPTIONS</span><br><span class="line">Access-Control-Allow-Headers: Content-Type, Authorization, X-Custom-Header</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: 5491</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;s:Envelope</span><br><span class="line">    xmlns:s=&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span><br><span class="line">    xmlns:e=&quot;http://www.w3.org/2003/05/soap-encoding&quot;</span><br><span class="line">    xmlns:wsa=&quot;http://schemas.xmlsoap.org/ws/2004/08/addressing&quot;</span><br><span class="line">    xmlns:wsa5=&quot;http://www.w3.org/2005/08/addressing&quot;</span><br><span class="line">    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:wsaw=&quot;http://www.w3.org/2006/05/addressing/wsdl&quot;</span><br><span class="line">    xmlns:wsnt=&quot;http://docs.oasis-open.org/wsn/b-2&quot;</span><br><span class="line">    xmlns:wstop=&quot;http://docs.oasis-open.org/wsn/t-1&quot;</span><br><span class="line">    xmlns:wsntw=&quot;http://docs.oasis-open.org/wsn/bw-2&quot;</span><br><span class="line">    xmlns:wsrf-rw=&quot;http://docs.oasis-open.org/wsrf/rw-2&quot;</span><br><span class="line">    xmlns:wsrf-r=&quot;http://docs.oasis-open.org/wsrf/r-2&quot;</span><br><span class="line">    xmlns:wsrf-bf=&quot;http://docs.oasis-open.org/wsrf/bf-2&quot;</span><br><span class="line">    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl&quot;</span><br><span class="line">    xmlns:wsoap12=&quot;http://schemas.xmlsoap.org/wsdl/soap12&quot;</span><br><span class="line">    xmlns:http=&quot;http://schemas.xmlsoap.org/wsdl/http&quot;</span><br><span class="line">    xmlns:d=&quot;http://schemas.xmlsoap.org/ws/2005/04/discovery&quot;</span><br><span class="line">    xmlns:wsadis=&quot;http://schemas.xmlsoap.org/ws/2004/08/addressing&quot;</span><br><span class="line">    xmlns:tt=&quot;http://www.onvif.org/ver10/schema&quot;</span><br><span class="line">    xmlns:tns1=&quot;http://www.onvif.org/ver10/topics&quot;</span><br><span class="line">    xmlns:tds=&quot;http://www.onvif.org/ver10/device/wsdl&quot;</span><br><span class="line">    xmlns:trt=&quot;http://www.onvif.org/ver10/media/wsdl&quot;</span><br><span class="line">    xmlns:tev=&quot;http://www.onvif.org/ver10/events/wsdl&quot;</span><br><span class="line">    xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot;</span><br><span class="line">    xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot;</span><br><span class="line">    xmlns:timg=&quot;http://www.onvif.org/ver20/imaging/wsdl&quot;</span><br><span class="line">    xmlns:tst=&quot;http://www.onvif.org/ver10/storage/wsdl&quot;</span><br><span class="line">    xmlns:dn=&quot;http://www.onvif.org/ver10/network/wsdl&quot;</span><br><span class="line">    xmlns:tr2=&quot;http://www.onvif.org/ver20/media/wsdl&quot;</span><br><span class="line">    xmlns:tptz=&quot;http://www.onvif.org/ver20/ptz/wsdl&quot;</span><br><span class="line">    xmlns:tan=&quot;http://www.onvif.org/ver20/analytics/wsdl&quot;</span><br><span class="line">    xmlns:axt=&quot;http://www.onvif.org/ver20/analytics&quot;</span><br><span class="line">    xmlns:tmd=&quot;http://www.onvif.org/ver10/deviceIO/wsdl&quot;</span><br><span class="line">    xmlns:tcr=&quot;http://www.onvif.org/ver10/credential/wsdl&quot;</span><br><span class="line">    xmlns:tar=&quot;http://www.onvif.org/ver10/accessrules/wsdl&quot;</span><br><span class="line">    xmlns:ewsd=&quot;http://www.onvifext.com/onvif/ext/ver10/wsdl&quot;</span><br><span class="line">    xmlns:exsd=&quot;http://www.onvifext.com/onvif/ext/ver10/schema&quot;</span><br><span class="line">    xmlns:tnshik=&quot;http://www.hikvision.com/2011/event/topics&quot;</span><br><span class="line">    xmlns:hikwsd=&quot;http://www.onvifext.com/onvif/ext/ver10/wsdl&quot;</span><br><span class="line">    xmlns:hikxsd=&quot;http://www.onvifext.com/onvif/ext/ver10/schema&quot;</span><br><span class="line">    xmlns:ter=&quot;http://www.onvif.org/ver10/error&quot;&gt;</span><br><span class="line">    &lt;s:Header&gt;&lt;/s:Header&gt;</span><br><span class="line">    &lt;s:Body&gt;</span><br><span class="line">        &lt;tds:GetCapabilitiesResponse&gt;</span><br><span class="line">            &lt;tds:Capabilities&gt;</span><br><span class="line">                &lt;tt:Analytics&gt;</span><br><span class="line">                    &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/Analytics&lt;/tt:XAddr&gt;</span><br><span class="line">                    &lt;tt:RuleSupport&gt;true&lt;/tt:RuleSupport&gt;</span><br><span class="line">                    &lt;tt:AnalyticsModuleSupport&gt;true&lt;/tt:AnalyticsModuleSupport&gt;</span><br><span class="line">                &lt;/tt:Analytics&gt;</span><br><span class="line">                &lt;tt:Device&gt;</span><br><span class="line">                    &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/device_service&lt;/tt:XAddr&gt;</span><br><span class="line">                    &lt;tt:Network&gt;</span><br><span class="line">                        &lt;tt:IPFilter&gt;false&lt;/tt:IPFilter&gt;</span><br><span class="line">                        &lt;tt:ZeroConfiguration&gt;false&lt;/tt:ZeroConfiguration&gt;</span><br><span class="line">                        &lt;tt:IPVersion6&gt;false&lt;/tt:IPVersion6&gt;</span><br><span class="line">                        &lt;tt:DynDNS&gt;false&lt;/tt:DynDNS&gt;</span><br><span class="line">                        &lt;tt:Extension&gt;</span><br><span class="line">                            &lt;tt:Dot11Configuration&gt;false&lt;/tt:Dot11Configuration&gt;</span><br><span class="line">                        &lt;/tt:Extension&gt;</span><br><span class="line">                    &lt;/tt:Network&gt;</span><br><span class="line">                    &lt;tt:System&gt;</span><br><span class="line">                        &lt;tt:DiscoveryResolve&gt;false&lt;/tt:DiscoveryResolve&gt;</span><br><span class="line">                        &lt;tt:DiscoveryBye&gt;false&lt;/tt:DiscoveryBye&gt;</span><br><span class="line">                        &lt;tt:RemoteDiscovery&gt;false&lt;/tt:RemoteDiscovery&gt;</span><br><span class="line">                        &lt;tt:SystemBackup&gt;false&lt;/tt:SystemBackup&gt;</span><br><span class="line">                        &lt;tt:SystemLogging&gt;false&lt;/tt:SystemLogging&gt;</span><br><span class="line">                        &lt;tt:FirmwareUpgrade&gt;false&lt;/tt:FirmwareUpgrade&gt;</span><br><span class="line">                        &lt;tt:SupportedVersions&gt;</span><br><span class="line">                            &lt;tt:Major&gt;17&lt;/tt:Major&gt;</span><br><span class="line">                            &lt;tt:Minor&gt;12&lt;/tt:Minor&gt;</span><br><span class="line">                        &lt;/tt:SupportedVersions&gt;</span><br><span class="line">                        &lt;tt:Extension&gt;</span><br><span class="line">                            &lt;tt:HttpFirmwareUpgrade&gt;false&lt;/tt:HttpFirmwareUpgrade&gt;</span><br><span class="line">                            &lt;tt:HttpSystemBackup&gt;false&lt;/tt:HttpSystemBackup&gt;</span><br><span class="line">                            &lt;tt:HttpSystemLogging&gt;false&lt;/tt:HttpSystemLogging&gt;</span><br><span class="line">                            &lt;tt:HttpSupportInformation&gt;false&lt;/tt:HttpSupportInformation&gt;</span><br><span class="line">                        &lt;/tt:Extension&gt;</span><br><span class="line">                    &lt;/tt:System&gt;</span><br><span class="line">                    &lt;tt:IO&gt;</span><br><span class="line">                        &lt;tt:InputConnectors&gt;0&lt;/tt:InputConnectors&gt;</span><br><span class="line">                        &lt;tt:RelayOutputs&gt;0&lt;/tt:RelayOutputs&gt;</span><br><span class="line">                    &lt;/tt:IO&gt;</span><br><span class="line">                    &lt;tt:Security&gt;</span><br><span class="line">                        &lt;tt:TLS1.1&gt;false&lt;/tt:TLS1.1&gt;</span><br><span class="line">                        &lt;tt:TLS1.2&gt;false&lt;/tt:TLS1.2&gt;</span><br><span class="line">                        &lt;tt:OnboardKeyGeneration&gt;false&lt;/tt:OnboardKeyGeneration&gt;</span><br><span class="line">                        &lt;tt:AccessPolicyConfig&gt;false&lt;/tt:AccessPolicyConfig&gt;</span><br><span class="line">                        &lt;tt:X.509Token&gt;false&lt;/tt:X.509Token&gt;</span><br><span class="line">                        &lt;tt:SAMLToken&gt;false&lt;/tt:SAMLToken&gt;</span><br><span class="line">                        &lt;tt:KerberosToken&gt;false&lt;/tt:KerberosToken&gt;</span><br><span class="line">                        &lt;tt:RELToken&gt;false&lt;/tt:RELToken&gt;</span><br><span class="line">                    &lt;/tt:Security&gt;</span><br><span class="line">                &lt;/tt:Device&gt;</span><br><span class="line">                &lt;tt:Events&gt;</span><br><span class="line">                    &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/events&lt;/tt:XAddr&gt;</span><br><span class="line">                    &lt;tt:WSSubscriptionPolicySupport&gt;true&lt;/tt:WSSubscriptionPolicySupport&gt;</span><br><span class="line">                    &lt;tt:WSPullPointSupport&gt;false&lt;/tt:WSPullPointSupport&gt;</span><br><span class="line">                    &lt;tt:WSPausableSubscriptionManagerInterfaceSupport&gt;false&lt;/tt:WSPausableSubscriptionManagerInterfaceSupport&gt;</span><br><span class="line">                &lt;/tt:Events&gt;</span><br><span class="line">                &lt;tt:Imaging&gt;</span><br><span class="line">                    &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/imaging&lt;/tt:XAddr&gt;</span><br><span class="line">                &lt;/tt:Imaging&gt;</span><br><span class="line">                &lt;tt:Media&gt;</span><br><span class="line">                    &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/media&lt;/tt:XAddr&gt;</span><br><span class="line">                    &lt;tt:StreamingCapabilities&gt;</span><br><span class="line">                        &lt;tt:RTPMulticast&gt;false&lt;/tt:RTPMulticast&gt;</span><br><span class="line">                        &lt;tt:RTP_TCP&gt;true&lt;/tt:RTP_TCP&gt;</span><br><span class="line">                        &lt;tt:RTP_RTSP_TCP&gt;true&lt;/tt:RTP_RTSP_TCP&gt;</span><br><span class="line">                    &lt;/tt:StreamingCapabilities&gt;</span><br><span class="line">                    &lt;tt:Extension&gt;</span><br><span class="line">                        &lt;tt:ProfileCapabilities&gt;</span><br><span class="line">                            &lt;tt:MaximumNumberOfProfiles&gt;2&lt;/tt:MaximumNumberOfProfiles&gt;</span><br><span class="line">                        &lt;/tt:ProfileCapabilities&gt;</span><br><span class="line">                    &lt;/tt:Extension&gt;</span><br><span class="line">                &lt;/tt:Media&gt;</span><br><span class="line">                &lt;tt:PTZ&gt;</span><br><span class="line">                    &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/ptz&lt;/tt:XAddr&gt;</span><br><span class="line">                &lt;/tt:PTZ&gt;</span><br><span class="line">                &lt;tt:Extension&gt;</span><br><span class="line">                    &lt;hikxsd:hikCapabilities&gt;</span><br><span class="line">                        &lt;hikxsd:XAddr&gt;http://192.168.1.100:9007/onvif/hik_ext&lt;/hikxsd:XAddr&gt;</span><br><span class="line">                        &lt;hikxsd:IOInputSupport&gt;false&lt;/hikxsd:IOInputSupport&gt;</span><br><span class="line">                        &lt;hikxsd:PrivacyMaskSupport&gt;true&lt;/hikxsd:PrivacyMaskSupport&gt;</span><br><span class="line">                        &lt;hikxsd:PTZ3DZoomSupport&gt;false&lt;/hikxsd:PTZ3DZoomSupport&gt;</span><br><span class="line">                        &lt;hikxsd:PTZPatternSupport&gt;true&lt;/hikxsd:PTZPatternSupport&gt;</span><br><span class="line">                    &lt;/hikxsd:hikCapabilities&gt;</span><br><span class="line">                    &lt;tt:DeviceIO&gt;</span><br><span class="line">                        &lt;tt:XAddr&gt;http://192.168.1.100:9007/onvif/deviceIO&lt;/tt:XAddr&gt;</span><br><span class="line">                        &lt;tt:VideoSources&gt;1&lt;/tt:VideoSources&gt;</span><br><span class="line">                        &lt;tt:VideoOutputs&gt;0&lt;/tt:VideoOutputs&gt;</span><br><span class="line">                        &lt;tt:AudioSources&gt;1&lt;/tt:AudioSources&gt;</span><br><span class="line">                        &lt;tt:AudioOutputs&gt;1&lt;/tt:AudioOutputs&gt;</span><br><span class="line">                        &lt;tt:RelayOutputs&gt;1&lt;/tt:RelayOutputs&gt;</span><br><span class="line">                    &lt;/tt:DeviceIO&gt;</span><br><span class="line">                &lt;/tt:Extension&gt;</span><br><span class="line">            &lt;/tds:Capabilities&gt;</span><br><span class="line">        &lt;/tds:GetCapabilitiesResponse&gt;</span><br><span class="line">    &lt;/s:Body&gt;</span><br><span class="line">&lt;/s:Envelope&gt;</span><br></pre></td></tr></table></figure><h3 id="3-1-2、tev-GetServiceCapabilities"><a href="#3-1-2、tev-GetServiceCapabilities" class="headerlink" title="3-1-2、tev:GetServiceCapabilities"></a>3-1-2、tev:GetServiceCapabilities</h3><p>客服端请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">客户端请求报文：</span><br><span class="line">POST /onvif/device_service HTTP/1.1</span><br><span class="line">Host: 192.16.11.180</span><br><span class="line">User-Agent: gSOAP/2.8</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8; action=&quot;http://www.onvif.org/ver10/events/wsdl/EventPortType/GetServiceCapabilitiesRequest&quot;</span><br><span class="line">Content-Length: 2589</span><br><span class="line">Connection: close</span><br><span class="line">SOAPAction: &quot;http://www.onvif.org/ver10/events/wsdl/EventPortType/GetServiceCapabilitiesRequest&quot;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:SOAP-ENC=&quot;http://www.w3.org/2003/05/soap-encoding&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:wsa5=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:wsa=&quot;http://www.w3.org/2005/08/addressing&quot; xmlns:wsdd=&quot;http://schemas.xmlsoap.org/ws/2005/04/discovery&quot; xmlns:chan=&quot;http://schemas.microsoft.com/ws/2005/02/duplex&quot; xmlns:c14n=&quot;http://www.w3.org/2001/10/xml-exc-c14n#&quot; xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot; xmlns:saml1=&quot;urn:oasis:names:tc:SAML:1.0:assertion&quot; xmlns:saml2=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot; xmlns:wsu=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd&quot; xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot; xmlns:wsc=&quot;http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512&quot; xmlns:wsse=&quot;http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd&quot; xmlns:xmime=&quot;http://tempuri.org/xmime.xsd&quot; xmlns:xop=&quot;http://www.w3.org/2004/08/xop/include&quot; xmlns:wsnt=&quot;http://docs.oasis-open.org/wsn/b-2&quot; xmlns:tt=&quot;http://www.onvif.org/ver10/schema&quot; xmlns:tns1=&quot;http://www.onvif.org/ver10/topics&quot; xmlns:wsrfbf=&quot;http://docs.oasis-open.org/wsrf/bf-2&quot; xmlns:wstop=&quot;http://docs.oasis-open.org/wsn/t-1&quot; xmlns:wsrfr=&quot;http://docs.oasis-open.org/wsrf/r-2&quot; xmlns:dn=&quot;http://www.onvif.org/ver10/network/wsdl&quot; xmlns:tan=&quot;http://www.onvif.org/ver20/analytics/wsdl&quot; xmlns:tds=&quot;http://www.onvif.org/ver10/device/wsdl&quot; xmlns:tev=&quot;http://www.onvif.org/ver10/events/wsdl&quot; xmlns:timg=&quot;http://www.onvif.org/ver20/imaging/wsdl&quot; xmlns:tmd=&quot;http://www.onvif.org/ver10/deviceIO/wsdl&quot; xmlns:tptz=&quot;http://www.onvif.org/ver20/ptz/wsdl&quot; xmlns:tr2=&quot;http://www.onvif.org/ver20/media/wsdl&quot; xmlns:trc=&quot;http://www.onvif.org/ver10/recording/wsdl&quot; xmlns:trp=&quot;http://www.onvif.org/ver10/replay/wsdl&quot; xmlns:trt=&quot;http://www.onvif.org/ver10/media/wsdl&quot; xmlns:tse=&quot;http://www.onvif.org/ver10/search/wsdl&quot;&gt;</span><br><span class="line">&lt;SOAP-ENV:Header&gt;</span><br><span class="line">   &lt;wsa:MessageID&gt;urn:uuid:432d9097-6c1d-4a60-81d9-0b27d815ba6a&lt;/wsa:MessageID&gt;</span><br><span class="line">   &lt;wsa:ReplyTo SOAP-ENV:mustUnderstand=&quot;true&quot;&gt;</span><br><span class="line">   &lt;wsa:Address&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/wsa:Address&gt;</span><br><span class="line">   &lt;/wsa:ReplyTo&gt;</span><br><span class="line">   &lt;wsa:To SOAP-ENV:mustUnderstand=&quot;true&quot;&gt;</span><br><span class="line">   http://172.16.11.180:80/onvif/device_service</span><br><span class="line">   &lt;/wsa:To&gt;</span><br><span class="line">   &lt;wsa:Action SOAP-ENV:mustUnderstand=&quot;true&quot;&gt;</span><br><span class="line">   http://www.onvif.org/ver10/events/wsdl/EventPortType/GetServiceCapabilitiesRequest</span><br><span class="line">   &lt;/wsa:Action&gt;</span><br><span class="line">&lt;/SOAP-ENV:Header&gt;</span><br><span class="line">&lt;SOAP-ENV:Body&gt;</span><br><span class="line">   &lt;tev:GetServiceCapabilities&gt;&lt;/tev:GetServiceCapabilities&gt;</span><br><span class="line">&lt;/SOAP-ENV:Body&gt;</span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>服务器回复报文：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: 827</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV=&quot;http://www.w3.org/2003/05/soap-envelope&quot; xmlns:SOAP-ENC=&quot;http://www.w3.org/2003/05/soap-encoding&quot; xmlns:tev=&quot;http://www.onvif.org/ver10/events/wsdl&quot; xmlns:wsa5=&quot;http://www.w3.org/2005/08/addressing&quot;&gt;</span><br><span class="line">    &lt;SOAP-ENV:Header&gt;</span><br><span class="line">        &lt;wsa5:Action&gt;http://www.onvif.org/ver10/events/wsdl/EventPortType/GetServiceCapabilitiesResponse&lt;/wsa5:Action&gt;</span><br><span class="line">    &lt;/SOAP-ENV:Header&gt;</span><br><span class="line">    &lt;SOAP-ENV:Body&gt;</span><br><span class="line">        &lt;tev:GetServiceCapabilitiesResponse&gt;</span><br><span class="line">            &lt;tev:Capabilities </span><br><span class="line">            WSSubscriptionPolicySupport=&quot;false&quot; </span><br><span class="line">            WSPullPointSupport=&quot;true&quot; </span><br><span class="line">            WSPausableSubscriptionManagerInterfaceSupport=&quot;false&quot; </span><br><span class="line">            MaxNotificationProducers=&quot;0&quot; </span><br><span class="line">            MaxPullPoints=&quot;10&quot; </span><br><span class="line">            PersistentNotificationStorage=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/tev:GetServiceCapabilitiesResponse&gt;</span><br><span class="line">    &lt;/SOAP-ENV:Body&gt;</span><br><span class="line">&lt;/SOAP-ENV:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>不重要，重要的是服务器请求。</code></pre><h2 id="3-2、Capabilities-API"><a href="#3-2、Capabilities-API" class="headerlink" title="3-2、Capabilities API"></a>3-2、Capabilities API</h2><pre><code>一系列获取设备能力的APIGetServices #获取dev支持的服务，可附加服务能力集+设备能力集GetServices -&gt; GetServiceCapabilities-&gt; GetCapabilities</code></pre><p>例子：如下报文描述了设备若干能力集，可<br>以包括tds作用域下的能力也包括其他作用域能力集<br><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/onvif%E5%8D%8F%E8%AE%AE/Capabilities.png"></p><h3 id="3-2-1、GetServiceCapabilities-获取网络服务能力集"><a href="#3-2-1、GetServiceCapabilities-获取网络服务能力集" class="headerlink" title="3-2-1、GetServiceCapabilities 获取网络服务能力集"></a>3-2-1、GetServiceCapabilities 获取网络服务能力集</h3><pre><code>注：必须实现，若实现GetServices注：ONVIF网络服务能力集分类如下：CapabilitiesremarkNetworkCapabilities网络能力SecurityCapabilities安全能力SystemCapabilities系统能力MiscCapabilities其他能力</code></pre><h3 id="3-2-2、GetCapabilities-获取设备能力集"><a href="#3-2-2、GetCapabilities-获取设备能力集" class="headerlink" title="3-2-2、GetCapabilities #获取设备能力集"></a>3-2-2、GetCapabilities #获取设备能力集</h3><pre><code>注：必须实现，若实现GetServices注：ONVIF能力分类如下：ServiceremarkAnalytics视频分析Device设备Events事件处理Imaging图像设置Media媒体设置PTZ摄像头云台控制</code></pre><h2 id="3-3、-Network-API"><a href="#3-3、-Network-API" class="headerlink" title="3-3、 Network API"></a>3-3、 Network API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">GetHostname #返回主机域名，注：域名可以是从DHCP获取的</span><br><span class="line"></span><br><span class="line">SetHostname #设置主机域名，注：主机域名可以从DHCP获取，若设备具有HostnameFromDHCP能力，此时只需要提交空的 Name 字段</span><br><span class="line"></span><br><span class="line">SetHostnameFromDHCP #设置设备是否从DHCP获取域名功能</span><br><span class="line">GetDNS #获取DNS设置，获取包括DHCP开关、搜索域（不明）、DHCP获取的DNS服务IP列表（要求DHCP开关必须开启）、手动DNS服务IP列表</span><br><span class="line"></span><br><span class="line">SetDNS #设置DNS，包括开启DHCP开关、设置搜索域、手动设置DNS服务。错误码（忽略常规错误码）：sender(指收到错误码的位请求发送方)-无效参数-IP地址无效（应该是指手动配置的DNS服务IP无效）</span><br><span class="line">GetNTP #获取NTP(网络时间协议) 配置，获取包括NTP服务IP的DHCP开关、DHCP NTP IP列表、手动NTP IP列表</span><br><span class="line"></span><br><span class="line">SetNTP #配置NTP，包括DHCP开关、手动NTP服务IP列表，错误码：sender-无效参数-设备的当前时间格式要求配置NTP服务</span><br><span class="line"></span><br><span class="line">GetDynamicDNS #获取动态DNS配置（要求Dev支持DynDNS能力），包括更新规则、DNS名（当DNS主动更新）、DNS保活时间（当DNS主动更新，原理类似UDP P2P保活）</span><br><span class="line"></span><br><span class="line">SetDynamicDNS #设置上述属性，要求设备支持 [RFC 2136] and [RFC 4702]标准，即DynDNS能力</span><br><span class="line"></span><br><span class="line">GetNetworkInterfaces #获取API属性（比如API是否启用、连接设置、MTU分包策略、IPv4/IPv6设置）列表，参考：tt:NetworkInterfaceInfo</span><br><span class="line"></span><br><span class="line">SetNetworkInterfaces #配置设备支持的API属性，配置成功后，如果返回属性RebootNeeded为true,则表明配置需要重启设备后生效（比如IP地址），这时候需要向设备发送SystemReboot请求；若属性为false,则表明配置立即生效。</span><br><span class="line"></span><br><span class="line">GetNetworkProtocols #获取应用层网络协议（ONVIF18.12支持HTTP\HTTPS\RTP）</span><br><span class="line"></span><br><span class="line">SetNetworkProtocols #配置应用层协议，与上述协议成对</span><br><span class="line"></span><br><span class="line">GetNetworkDefaultGateway #返回手动配置的默认网关IP</span><br><span class="line"></span><br><span class="line">SetNetworkDefaultGateway #设置默认网关</span><br><span class="line"></span><br><span class="line">GetZeroConfiguration  #从设备获取zero-configuration（设备自动配置）相关参数，设备如果支持RFC3927标准，请求返回 IPv4 zero configuration address 和 status（应该指 InterfaceToken 字段）</span><br><span class="line"></span><br><span class="line">SetZeroConfiguration #配置设备zero-configuration相关参数，要求设备支持RFC3927标准，且支持ZeroConfiguration 能力</span><br><span class="line"></span><br><span class="line">GetIPAddressFilter #获取设备IP过滤规则（要求设置支持 IPFilter 能力）</span><br><span class="line"></span><br><span class="line">AddIPAddressFilter #增加设备IP过滤规则，禁止那些IP访问、允许那些IP访问</span><br><span class="line"></span><br><span class="line">RemoveIPAddressFilter #删除设备IP过滤规则IEEE 802.11 configuration #IEEE 802.11系列配置项（要求设备支持IEEE 802.11标准（wifi）具有Dot11Configuration 能力）</span><br><span class="line">参考：[IEEE 802.11]简介:https://blog.csdn.net/f2157120/article/details/80831211</span><br><span class="line">ONVIF要求能够对设备进行如下配置：（具体方式ONVIF不做限制）</span><br><span class="line">    SSID</span><br><span class="line">    Station mode</span><br><span class="line">    Multiple wireless network configuration</span><br><span class="line">    Security configuration</span><br><span class="line"></span><br><span class="line">GetDot11Capabilities #获取设备支持的Dot11能力，IEEE 802.11定义了TKIP、ScanAvailableNetworks 、MultipleConfiguration 、AdHocStationMode 、WEP 5种能力</span><br><span class="line"></span><br><span class="line">GetDot11Status #获取无线网状态</span><br><span class="line"></span><br><span class="line">ScanAvailableDot11Networks #扫描可用Dot11局域网，就是手机wifi网络扫描功能</span><br></pre></td></tr></table></figure><h2 id="3-4、System-API"><a href="#3-4、System-API" class="headerlink" title="3-4、System API"></a>3-4、System API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">GetDeviceInformation #获取设备的制造商、软件模型、固件版本、序列号、硬件id</span><br><span class="line"></span><br><span class="line">GetSystemUris  #获取从Dev提取日志、诊断信息、系统备份信息的url</span><br><span class="line"></span><br><span class="line">GetSystemBackup #从Dev获取系统备份（要求Dev具备SystemBackup能力，API已被弃用，替代API参考GetSystemUris 和 StartSystemRestore）系统备份可以用于回复设备的配置，注恢复设备的IP配置可能不同。系统备份文件的传输协议 为[MTOM]</span><br><span class="line"></span><br><span class="line">RestoreSystem #恢复系统备份（要求Dev具备SystemBackup能力，API已被弃用，替代API参考GetSystemUris 和 StartSystemRestore）系统备份文件的传输协议 为[MTOM]</span><br><span class="line"></span><br><span class="line">StartSystemRestore #恢复系统备份，Dev返回上传备份数据的URL及上传有效时间（避免客户端恶意占用上传网络资源）上传并恢复备份步骤</span><br><span class="line"></span><br><span class="line">GetSystemDateAndTime  #获取系统时间，会表明时间来自手动设置或NTP（此时要求SetNTP、GetNTP有效）、夏至时开关、时区、UTC时间、Dev本地时间。注：虽然UTC时间格式为可选但是为了向后兼容，设备shall提供UTC时间。</span><br><span class="line"></span><br><span class="line">SetSystemDateAndTime  #设置系统时间，GetSystemDateAndTime成对</span><br><span class="line"></span><br><span class="line">SetSystemFactoryDefault #恢复出厂设置，设备必须支持软、硬件初上设置。注：ONVIF对软件出厂设置未做定义，要是要求设备软出厂恢复后之前的IP仍能可达。这表明软出厂恢复时要求网络设置：IP地址、子网及网关设置、DHCP设置被保持。防止操作后设备丢失！</span><br><span class="line"></span><br><span class="line">UpgradeSystemFirmware  #固件升级（API已遗弃），升级包通过MTOM协议传输，同样要求网络设置：IP地址、子网及网关设置、DHCP设置被保持</span><br><span class="line"></span><br><span class="line">StartFirmwareUpgrade #固件升级，具体的固件数据格式ONVIF不做定义，若上传的固件数据无效，Dev返回Http状态码&quot;415 Unsupported Media Type&quot;，若升级失败适应为Dev故障则返回Http状态码&quot;500 Internal Server Error&quot;。POST数据时，Content-Type字段要求&quot;application/octet stream&quot;。同样要求升级后网络配置不变。上传文件及升级操作步骤</span><br><span class="line"></span><br><span class="line">GetSystemLog #获取日志（可选系统日志、客户端访问日志），传输遵守[MTOM]，具体日志格式ONVIF不做规定。获取日志的url从GetSystemUris 取得</span><br><span class="line"></span><br><span class="line">GetSystemSupportInformation  #获取系统诊断信息，设备可选传回二进制数据或文本数据，传输遵守[MTOM]，具体日志格式ONVIF不做规定。获取日志的url从GetSystemUris 取得</span><br><span class="line"></span><br><span class="line">SystemReboot  #设备重启</span><br><span class="line"></span><br><span class="line">GetScopes  #获取scope相关参数（scope用于匹配设备发现probe message），返回固定scope和可配置scope</span><br><span class="line"></span><br><span class="line">SetScopes  #重置可配scope，注：会覆盖现有的所有可配scope!，支持多个scope,用列表下标作为索引号</span><br><span class="line"></span><br><span class="line">AddScopes #为已有可配scope增加scope url参数，用列表下标作为scope索引</span><br><span class="line"></span><br><span class="line">RemoveScopes #为已有可配scope删除scope url参数，用列表下标作为scope索引</span><br><span class="line"></span><br><span class="line">GetDiscoveryMode #获取设备发现模式(可发现、不可发现)</span><br><span class="line"></span><br><span class="line">SetDiscoveryMode  #设置设备发现模式</span><br><span class="line"></span><br><span class="line">GetGeoLocation  #获取地理信息，（要求设备支持 GeoLocationEntities 能力，若设备支持AutoGeo能力AutoGeo条目有效）地理信息条目包括（设备不一定要支持全部地理信息条目）</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">SetGeoLocation #改变地理信息条目配置，成功设置后，会影响GetGeoLocation 返回信息</span><br><span class="line"></span><br><span class="line">DeleteGeoLocation #删除地理信息条目，删除后GetGeoLocation 不再显示</span><br></pre></td></tr></table></figure><h2 id="3-5、Security-API"><a href="#3-5、Security-API" class="headerlink" title="3-5、Security API"></a>3-5、Security API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GetAccessPolicy #获取设备访问规则（二进制数据），包括用户级别、服务访问权限信息，若设备支持 SetAccessPolicy ，则必须实现本API。</span><br><span class="line"></span><br><span class="line">SetAccessPolicy  #设置访问规则</span><br><span class="line"></span><br><span class="line">GetUsers  #获取用户信息列表（不包含证据或密码）</span><br><span class="line"></span><br><span class="line">CreateUsers #新建用户，需要输入用户名、密码、用户级别</span><br><span class="line"></span><br><span class="line">DeleteUsers  #删除用户，根据用户名</span><br><span class="line"></span><br><span class="line">SetUser #改变用户设置，（用户名不能变，密码、级别可以变），重置密码时如果密码太简单设备返回ter:PasswordTooWeak错误码</span><br><span class="line"></span><br><span class="line">GetRemoteUser #获取远程用户(远程用户是什么用户？和普通用户有什么区别？)列表，（要求设备支持RemoteUserHandling 能力）</span><br><span class="line"></span><br><span class="line">SetRemoteUser #设置远程用户（The user is only valid for the WS-UserToken profile or as a HTTP / RTSP user）</span><br><span class="line"></span><br><span class="line">GetEndpointReference #获取设备服务端引用属性（服务的GUID），从文档中描述看，这个GUID可以用于计算远程用户操作的密码。</span><br></pre></td></tr></table></figure><h2 id="3-6、I-O-API"><a href="#3-6、I-O-API" class="headerlink" title="3-6、I&#x2F;O API"></a>3-6、I&#x2F;O API</h2><pre><code>    本节I/O相关的接口，主要用于保证后端兼容性。控制、获取IO端口的状态。更广泛的IO接口参考ONVIF Device IO Specification。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GetRelayOutputs #获取可用relay(什么是relay输出?可能是类似NVR通道的概念)输出列表</span><br><span class="line">SetRelayOutputSettings  #设置relay输出</span><br></pre></td></tr></table></figure><pre><code>好烦，不懂。</code></pre><h2 id="3-7、辅助外设"><a href="#3-7、辅助外设" class="headerlink" title="3-7、辅助外设"></a>3-7、辅助外设</h2><pre><code>SendAuxiliaryCommand #发送设备辅助外设控制指令，比如控制红外线照明灯、加热器、雨刮器、温度计等请求报文类型tt:AuxiliaryData实际是一个xsd字符串，onvif不规定指令的风格，但必须复合格式&quot;tt:command|parameter&quot;，如：</code></pre><p><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/onvif%E5%8D%8F%E8%AE%AE/%E8%BE%85%E5%8A%A9%E5%A4%96%E8%AE%BE.png"></p><h2 id="3-8、存储配置"><a href="#3-8、存储配置" class="headerlink" title="3-8、存储配置"></a>3-8、存储配置</h2><p>以下接口允许客户端对设备数据存储进行设置，<br>可以参考 DAS, NAS, 和CDMI Server的存储配置。<br>要求设备具有Storage Configuration能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GetStorageConfigurations #获取所有存储配置项（不太明白这个存储配置指什么？）</span><br><span class="line">应该是客户端去获取服务端的设置状态</span><br><span class="line"></span><br><span class="line">CreateStorageConfiguration #新建存储配置</span><br><span class="line"></span><br><span class="line">GetStorageConfiguration #通过tt:ReferenceTokentt:ReferenceToken获取存储配置</span><br><span class="line"></span><br><span class="line">SetStorageConfiguration #重置已有的配置</span><br><span class="line"></span><br><span class="line">DeleteStorageConfiguration #删除配置</span><br></pre></td></tr></table></figure><h2 id="3-9、设备监控事件"><a href="#3-9、设备监控事件" class="headerlink" title="3-9、设备监控事件"></a>3-9、设备监控事件</h2><pre><code>设备主动上报运行状态的事件</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">tns1:Monitoring/ProcessorUsage // 上报设备处理器实时信息，Source应该是用来描述Data是什么</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/LinkStatus //上报设备的连接状态</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/UploadStatus // 当设备正在升级固件或系统时，上报升级状态，进度 注：设备上报时时间格式复合UTC的格林尼治标准</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/OperatingTime/DefinedLimitReached // 到达操作时限时上报</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/OperatingTime/MeanTimeBetweenFailuresDefaultLimitReached //MTBF（平均故障间隔时间）时限时上报，设备故障状态，用于计算设备无故障运行时间</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/OperatingTime/MeanTimeBetweenFailuresOperationLimitReached //MTBF 操作时限时上报</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/OperatingTime/LastReset //恢复出厂前上报</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/OperatingTime/LastReboot //reboot前上报</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/OperatingTime/LastClockSynchronization //时钟同步后上报，由 NTP message或SetSystemDateAndTime call引发</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/Maintenance/Last //设备上报最后保持激活状态的时间（设备之后应该是休眠）</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/Maintenance/NextScheduled //上报下次激活的时间</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/Backup/Last //设备恢复备份后上报</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/AreaOfOperation/OutsideCertifiedArea //当设备被认证为不因为外界原因而松动时上报（没明白啥意思）</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/AreaOfOperation/OutsideConfiguredArea //当设备被配置为不因为外界原因而松动时上报</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/EnvironmentalConditions/RelativeHumidity //上报湿度信息，要求设备支持环境监测能力</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/EnvironmentalConditions/Temperature //上报温度信息，上报策略可以是6s/次或温差大于5%时，防止引发“事件洪水”</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/BatteryCapacity //上报剩余电池量,recommended to use a 2% change</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/AsynchronousOperationStatus //上报异步操作的进度。Token 字段用标识异步操作，区分同一类型一步操作的不同会话； OperationName 操作名； ServiceName 异步操作的服务名；OperationName 和ServiceName 可用于区别不同的异步操作； Progress  字段展示操作执行进度[0.0, 1.0]； Error 字段展示操作错误，错误码标准要求符合soapenv:Fault</span><br><span class="line"></span><br><span class="line">tns1:Device/OperationMode/ShutdownInitiated //关机前发送</span><br><span class="line"></span><br><span class="line">tns1:Device/OperationMode/UploadInitiated //升级开始前发送</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/Washer/LiquidLow //上报水箱液体等级</span><br><span class="line"></span><br><span class="line">tns1:Device/HardwareFailure/FanFailure //散热风扇故障</span><br><span class="line"></span><br><span class="line">tns1:Device/HardwareFailure/PowerSupplyFailure //供电故障</span><br><span class="line"></span><br><span class="line">tns1:Device/HardwareFailure/StorageFailure //存储设备故障</span><br><span class="line"></span><br><span class="line">tns1:Device/HardwareFailure/TemperatureCritical //设备温度过载报警</span><br><span class="line"></span><br><span class="line">tns1:Monitoring/GeoLocation //上报地理位置（针对便携式设备）</span><br></pre></td></tr></table></figure><h1 id="4、事件通知"><a href="#4、事件通知" class="headerlink" title="4、事件通知"></a>4、事件通知</h1><pre><code>&quot;设备事件&quot;是设备的主动活动或者检测到有事发生时产生，当客户端定于某种类型的事件后，当事件产生时设备以某种形式推送消息给客户端。事件的处理，在[WS-BaseNotification]和[WS-Topics] 规范基础上扩展事件订阅/通知方式:10.1 Pull-Point Notification（拉模式通知）</code></pre><h2 id="4-1、Pull-Point-Notification（拉模式通知）"><a href="#4-1、Pull-Point-Notification（拉模式通知）" class="headerlink" title="4-1、Pull-Point Notification（拉模式通知）"></a>4-1、Pull-Point Notification（拉模式通知）</h2><p><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/onvif%E5%8D%8F%E8%AE%AE/%E6%8B%89%E6%A8%A1%E5%BC%8F%E9%80%9A%E7%9F%A5.png"></p><pre><code>    从时序图可以看出，事件通知并不是设备主动上报而是需要客户端发送PullMessages拉取。这种方式无需在客户端和设备间维护链路，但要求客户端能够主动连接设备，当设备IP不固定的时候（比如Iot场景下），拉模式通知往往需要在设备主动建立交互之后才能进行，这导致这种场景下通知不够实时。1、client通过CreatePullPointSubscriptionRequest向device申请PullPointSubscription(拉订阅点)。这个request包含了此订阅的详细描述信息。并且与the Basic Notification Interface不同之处就是此处需要省略consumerReference。2、当subscribe被接受的时候device评估此订阅后返回CreatePullPointSubscriptionResponse或者返回一个错误代码。3、订阅被接受后，反馈的response需要包含SubscriptionManager的WS-EndpointReference. WS-Endpoint必须提供PullMessage操作，Pullmessage用于客户端检索通知信息，以及由订阅管理manager接口去描述WS-BaseeNotification。Base Subscription Manager 接口包含PullMessage,Renew,Unsubscribe 等操作。交互序列如上图。PullMessage包含Timeout以及MessageLimit 参数。4、一旦有来自client的查询通知则device必须立即响应，如果没有则device一直保持等待client所订阅的通知到来或者等待超时发生。一般情况下至少包括response，且通知个数是被指定的。client在发出的一个PullMessagesRequest并收到PullMessagesResponse后既可以实时轮询通知接口(类似于一问一答式的服务)。5、如果在CreatePullPointSubscriptionRequest中未指定结束或者相关结束时间，则每个PullMessagesRequest理解为保持激活状态等待相应的PullPointSubscription.并且结束时间会根据相关联的结束时间或者装置内置数值进行再计算。为了通知client去更新结束时PullMessageResponse必须包含CurrentTime以及terminalTime选项。当PullMessagesRequest处于激活状态并等待相应的PullPointSubscription，此时由WS-BaseNotification定义的RenewRequest不能被Client,因此device需要支持PullPointSubscription。（在没有订阅的前提下发送PullMessagesRequest,需要等待PullPointSubscription去创建订阅完成才能继续运行）6、如果device支持通知持续保存，则WS-Endpoint必须支持Seek操作，其支持将pull指针重新拉回原位置。为防止将指针的放置位置超出了buffer的起始位置，第一次调用PullMessage要从buffer的起始位置开始。SeekRequest包含了UtcTime参数，UtcTime参数必须NotificationMessage中的属性相匹配。当使用seek，则pull指针要放置在包含NotificationMessage的且其UtcTime少于等于seek参数的buffer中。SeekRequest包含一个可选的对立参数，这个参数可以将PullMessageResquest的pull方向反向。</code></pre><p>接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CreatePullPointSubscription //创建订阅，请求中可以指定要订阅的事件类型，订阅持续事件</span><br><span class="line"></span><br><span class="line">PullMessages //拉取事件</span><br><span class="line"></span><br><span class="line">Renew //要求设备支持MaxNotificationProducers能力，可能是重置订阅，具体用法不清楚</span><br><span class="line"></span><br><span class="line">Unsubscribe //取消所有订阅</span><br><span class="line"></span><br><span class="line">Seek //如果设备支持时间存储，则应该支持事件检索</span><br></pre></td></tr></table></figure><h2 id="4-2、Basic-Notification（WS-BaseNotification通知）"><a href="#4-2、Basic-Notification（WS-BaseNotification通知）" class="headerlink" title="4-2、Basic Notification（WS-BaseNotification通知）"></a>4-2、Basic Notification（WS-BaseNotification通知）</h2><p><img src="/img/5_%E9%9F%B3%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE/onvif%E5%8D%8F%E8%AE%AE/WS-BaseNotification%E9%80%9A%E7%9F%A5.png"></p><pre><code>从时序图即可看出，这种消息通知方式，是设备主动的，要求设备能够主动连接设备。或者TCP长连接，或者通过UDP链路保活，或者client IP固定。从时序图即可看出，这种消息通知方式，是设备主动的，要求设备能够主动连接设备。或者TCP长连接，或者通过UDP链路保活，或者client IP固定。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pcm音频格式详解</title>
      <link href="/posts/d3ea8c5e.html"/>
      <url>/posts/d3ea8c5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、pcm是什么？"><a href="#1、pcm是什么？" class="headerlink" title="1、pcm是什么？"></a>1、pcm是什么？</h1><p>pcm是脉冲编码调制，是数字音频的存储格式。</p><h1 id="2、pcm的组成"><a href="#2、pcm的组成" class="headerlink" title="2、pcm的组成"></a>2、pcm的组成</h1><p>pcm音频文件由两部分组成：</p><ol><li>头部信息</li><li>音频数据</li></ol><h2 id="2-1、头部信息"><a href="#2-1、头部信息" class="headerlink" title="2-1、头部信息"></a>2-1、头部信息</h2><p>头部信息中包含了音频文件的采样率、声道数等信息，用于描述音频文件的属性。</p><h2 id="2-2、音频数据"><a href="#2-2、音频数据" class="headerlink" title="2-2、音频数据"></a>2-2、音频数据</h2><p>音频数据是实际的波形数据，以二进制形式存储在文件中。</p><h1 id="3、pcm的采样率"><a href="#3、pcm的采样率" class="headerlink" title="3、pcm的采样率"></a>3、pcm的采样率</h1><p>采样率是指每秒从录音设备或声音文件里采样的次数，它描述了音频文件的长度。</p><p>采样率越高，音频文件的长度就越长。<br>采样率越低，音频文件的长度就越短。</p><p>常见的采样率有：</p><ol><li>8kHz：电话</li><li>16kHz：CD</li><li>22.05kHz：低音炮</li><li>44.1kHz：CD</li><li>48kHz：DVD</li></ol><p>采样率越高，音质就越好。<br>采样率越低，音质就越差。</p><p>采样率越高，文件大小就越大。<br>采样率越低，文件大小就越小。</p><p>用高于采样率的播放器播放高于采样率的音频文件，会降低音质。声音比较尖锐。<br>用低于采样率的播放器播放低于采样率的音频文件，会降低音质。声音比较模糊、低沉。</p><h1 id="4、pcm的采样位数"><a href="#4、pcm的采样位数" class="headerlink" title="4、pcm的采样位数"></a>4、pcm的采样位数</h1><p>采样位数是指每个采样点占用的二进制位数。<br>常见的采样位数有：</p><ol><li>8位：表示每个采样点占用的二进制位数为8位</li><li>16位：表示每个采样点占用的二进制位数为16位</li><li>24位：表示每个采样点占用的二进制位数为24位</li><li>32位：表示每个采样点占用的二进制位数为32位<br>采样位数越高，音质越好。<br>采样位数越低，音质就越差。<br>采样位数越高，文件大小就越大。<br>采样位数越低，文件大小就越小。</li></ol><h1 id="5、pcm的声道数"><a href="#5、pcm的声道数" class="headerlink" title="5、pcm的声道数"></a>5、pcm的声道数</h1><p>声道数是描述音频文件中的声音来源和数量的术语。</p><ol><li>单声道：只有一个声音源</li><li>双声道：有两个声音源</li></ol><h1 id="6、文件大小"><a href="#6、文件大小" class="headerlink" title="6、文件大小"></a>6、文件大小</h1><p>文件大小 &#x3D; 采样率 * 时长 * 声道数 * 采样位数 &#x2F; 8</p><p>当送数据播放时，如果送的太快，就会造成声音的撕裂。<br>采样8000Hz，16位，双声道，时长5s的文件大小 &#x3D; 8000 * 16 * 2 * 5 &#x2F; 8 &#x3D; 320kb<br>可以将16000，转换成8000，只需要将每两个字节删掉一个就可以实现。</p><p>双声道有存储顺序问题，需要具体分析。</p><h1 id="7、pcm的编码格式"><a href="#7、pcm的编码格式" class="headerlink" title="7、pcm的编码格式"></a>7、pcm的编码格式</h1><p>pcm音频文件一般不直接播放，需要先进行编码，常见的编码格式有：</p><ol><li>WAV：微软公司开发的音频文件格式</li><li>AAC：高级音频编码</li><li>MP3：高压缩比音频编码</li><li>OGG：开源音频编码</li><li>FLAC：无损音频编码</li><li>AMR：音频码率压缩格式</li></ol><p>扩展：<br>g711：G.711是ITU-T语音编码的推荐标准之一。<br>g711采样率：8kHz<br>g711采样位数：8位<br>g711声道数：单声道<br>g711编码格式：PCM</p><p>调试音频用0db音频文件调试<br>相关软件Cool Edit Pro。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>soap协议</title>
      <link href="/posts/91d9ae79.html"/>
      <url>/posts/91d9ae79.html</url>
      
        <content type="html"><![CDATA[<h1 id="SOAP-构建模块"><a href="#SOAP-构建模块" class="headerlink" title="SOAP 构建模块"></a>SOAP 构建模块</h1><pre><code>1、一条 SOAP 消息就是一个普通的 XML 文档，包含下列元素：2、必需的 Envelope 元素，可把此 XML 文档标识为一条 SOAP 消息3、可选的 Header 元素，包含头部信息4、必需的 Body 元素，包含所有的调用和响应信息5、可选的 Fault 元素，提供有关在处理此消息所发生错误的信息所有以上的元素均被声明于针对 SOAP 封装的默认命名空间中http://www.w3.org/2001/12/soap-envelope以及针对 SOAP 编码和数据类型的默认命名空间：http://www.w3.org/2001/12/soap-encoding</code></pre><h1 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h1><pre><code>这里是一些重要的语法规则：1、SOAP 消息必须用 XML 来编码2、SOAP 消息必须使用 SOAP Envelope 命名空间3、SOAP 消息必须使用 SOAP Encoding 命名空间4、SOAP 消息不能包含 DTD 引用5、SOAP 消息不能包含 XML 处理指令</code></pre><h1 id="SOAP-消息的基本结构"><a href="#SOAP-消息的基本结构" class="headerlink" title="SOAP 消息的基本结构"></a>SOAP 消息的基本结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Header&gt;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&lt;/soap:Header&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Body&gt;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  &lt;soap:Fault&gt;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">  &lt;/soap:Fault&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><h1 id="强制使用的-SOAP-的-Envelope-元素是-SOAP-消息的根元素。"><a href="#强制使用的-SOAP-的-Envelope-元素是-SOAP-消息的根元素。" class="headerlink" title="强制使用的 SOAP 的 Envelope 元素是 SOAP 消息的根元素。"></a>强制使用的 SOAP 的 Envelope 元素是 SOAP 消息的根元素。</h1><h2 id="SOAP-Envelope-元素"><a href="#SOAP-Envelope-元素" class="headerlink" title="SOAP Envelope 元素"></a>SOAP Envelope 元素</h2><pre><code>必需的 SOAP 的 Envelope 元素是 SOAP 消息的根元素。它可把 XML 文档定义为 SOAP 消息。请注意 xmlns:soap 命名空间的使用。它的值应当始终是：http://www.w3.org/2001/12/soap-envelope并且它可把封装定义为 SOAP 封装：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">  Message information goes here</span><br><span class="line">  ...</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><h2 id="xmlns-soap-命名空间"><a href="#xmlns-soap-命名空间" class="headerlink" title="xmlns:soap 命名空间"></a>xmlns:soap 命名空间</h2><pre><code>SOAP 消息必须拥有与命名空间 &quot;http://www.w3.org/2001/12/soap-envelope&quot; 相关联的一个 Envelope 元素。如果使用了不同的命名空间，应用程序会发生错误，并抛弃此消息。</code></pre><p><img src="https://img-blog.csdnimg.cn/5817bb45938c48408a1212733f0d2939.png"><br><img src="https://img-blog.csdnimg.cn/dd85b1ac04f244ba815b95d4e74ce8f2.png"></p><pre><code>否则可能导致命名空间无法解析导致错误</code></pre><h2 id="encodingStyle-属性"><a href="#encodingStyle-属性" class="headerlink" title="encodingStyle 属性"></a>encodingStyle 属性</h2><pre><code>SOAP 的 encodingStyle 属性用于定义在文档中使用的数据类型。此属性可出现在任何SOAP元素中，并会被应用到元素的内容及元素的所有子元素上。SOAP 消息没有默认的编码方式。</code></pre><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">soap:encodingStyle=&quot;URI&quot;</span><br><span class="line">实例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line">...</span><br><span class="line">Message information goes here</span><br><span class="line">...</span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><h2 id="可选的-SOAP-Header-元素包含头部信息。"><a href="#可选的-SOAP-Header-元素包含头部信息。" class="headerlink" title="可选的 SOAP Header 元素包含头部信息。"></a>可选的 SOAP Header 元素包含头部信息。</h2><pre><code>    SOAP Header 元素可选的SOAP Header元素可包含有关 SOAP 消息的应用程序专用信息（比如认证、支付等）。如果 Header 元素被提供，则它必须是 Envelope 元素的第一个子元素。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">注释：所有 Header 元素的直接子元素必须是合格的命名空间。</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Header&gt;</span><br><span class="line">&lt;m:Trans</span><br><span class="line">xmlns:m=&quot;http://www.w3school.com.cn/transaction/&quot;</span><br><span class="line">soap:mustUnderstand=&quot;1&quot;&gt;234&lt;/m:Trans&gt;</span><br><span class="line">&lt;/soap:Header&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>上面的例子包含了一个带有一个 &quot;Trans&quot; 元素的头部，它的值是 234，此元素的 &quot;mustUnderstand&quot; 属性的值是 &quot;1&quot;。SOAP 在默认的命名空间中 (&quot;http://www.w3.org/2001/12/soap-envelope&quot;) 定义了三个属性。这三个属性是：actor、mustUnderstand 以及encodingStyle。这些被定义在SOAP头部的属性定义了容器如何对SOAP消息进行处理。</code></pre><p><img src="https://img-blog.csdnimg.cn/c2507fcd67ef414692e15ed3d2e80102.png"></p><h2 id="actor-属性"><a href="#actor-属性" class="headerlink" title="actor 属性"></a>actor 属性</h2><pre><code>通过沿着消息路径经过不同的端点，SOAP 消息可从某个发送者传播到某个接收者。并非 SOAP 消息的所有部分均打算传送到 SOAP 消息的最终端点，不过，另一个方面，也许打算传送给消息路径上的一个或多个端点。SOAP的actor 属性可被用于将 Header 元素寻址到一个特定的端点。soap 消息在发往最终目标的途中可能会经过许多中间节点，这些中间节点既能接收又能转发soap消息。并不是soap消息的所有部分都发给最终目标节点，其中一 部分可能由消息路径中的中间节点进行处理。actor属性就是用来指定soap报头条目所定向的节点。它所属的命名空间 为&quot;http://www.w3.org/2001/12/soap-envelope&quot;，在使用时必须使用命名空间对其进行限定。actor属性值的类 型为anyURI，它指定了一个soap节点所扮演的角色。省略actor属性的报头条目隐含地定向到最终soap接收者，属性值为空等效于完全省略该属 性。如果报头条目中的soap actor与某个soap节点的角色匹配(没有actor属性时，与最终接收者匹配)，就认为这个报头条目定向到这个soap节点上。 在 soap消息处理过程中，soap节点起到一个或多个actor的作用，其中每一个都通过URI指出。每一个soap节点都必须完 成&quot;http://www.w3.org/2001/12/soap-envelope/actor/next&quot;所指定的actor的作用，并且可以完成 其他0个或多个actor的作用。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">soap:actor=&quot;URI&quot; </span><br><span class="line">实例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Header&gt;</span><br><span class="line">&lt;m:Trans</span><br><span class="line">xmlns:m=&quot;http://www.w3school.com.cn/transaction/&quot;</span><br><span class="line">soap:actor=&quot;http://www.w3school.com.cn/appml/&quot;&gt;</span><br><span class="line">234</span><br><span class="line">&lt;/m:Trans&gt;</span><br><span class="line">&lt;/soap:Header&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><h2 id="mustUnderstand-属性"><a href="#mustUnderstand-属性" class="headerlink" title="mustUnderstand 属性"></a>mustUnderstand 属性</h2><pre><code>SOAP 的 mustUnderstand 属性可用于标识标题项对于要对其进行处理的接收者来说是强制的还是可选的。假如您向 Header 元素的某个子元素添加了 &quot;mustUnderstand=&quot;1&quot;，则它可指示处理此头部的接收者必须认可此元素。假如此接收者无法认可此元素，则在处理此头部时必须失效。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">soap:mustUnderstand=&quot;0|1&quot;</span><br><span class="line">实例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Header&gt;</span><br><span class="line">&lt;m:Trans</span><br><span class="line">xmlns:m=&quot;http://www.w3school.com.cn/transaction/&quot;</span><br><span class="line">soap:mustUnderstand=&quot;1&quot;&gt;</span><br><span class="line">234</span><br><span class="line">&lt;/m:Trans&gt;</span><br><span class="line">&lt;/soap:Header&gt;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>之前工作曾遇到这个问题：</code></pre><p><img src="https://img-blog.csdnimg.cn/bdc737f10b284dd783f7ebd0a8dcc19d.png"></p><pre><code>不过这里主要是空间名字不正确。</code></pre><h2 id="SOAP-Body-元素"><a href="#SOAP-Body-元素" class="headerlink" title="SOAP Body 元素"></a>SOAP Body 元素</h2><pre><code>    必需的 SOAP Body 元素可包含打算传送到消息最终端点的实际 SOAP 消息。SOAP Body 元素的直接子元素可以是合格的命名空间。SOAP 在默认的命名空间中(&quot;http://www.w3.org/2001/12/soap-envelope&quot;)定义了 Body 元素内部的一个元素。即 SOAP 的 Fault 元素，用于指示错误消息。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Body&gt;</span><br><span class="line">   &lt;m:GetPrice xmlns:m=&quot;http://www.w3school.com.cn/prices&quot;&gt;</span><br><span class="line">      &lt;m:Item&gt;Apples&lt;/m:Item&gt;</span><br><span class="line">   &lt;/m:GetPrice&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><pre><code>上面的例子请求苹果的价格。请注意，上面的 m:GetPrice 和 Item 元素是应用程序专用的元素。它们并不是 SOAP 标准的一部分。而一个 SOAP 响应应该类似这样：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;soap:Body&gt;</span><br><span class="line">   &lt;m:GetPriceResponse xmlns:m=&quot;http://www.w3school.com.cn/prices&quot;&gt;</span><br><span class="line">      &lt;m:Price&gt;1.90&lt;/m:Price&gt;</span><br><span class="line">   &lt;/m:GetPriceResponse&gt;</span><br><span class="line">&lt;/soap:Body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><h2 id="SOAP-Fault-元素"><a href="#SOAP-Fault-元素" class="headerlink" title="SOAP Fault 元素"></a>SOAP Fault 元素</h2><pre><code>可选的 SOAP Fault 元素用于指示错误消息。如果已提供了 Fault 元素，则它必须是 Body 元素的子元素。在一条 SOAP 消息中，Fault 元素只能出现一次。</code></pre><p>SOAP 的 Fault 元素拥有下列子元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子元素       描述</span><br><span class="line">&lt;faultcode&gt;  供识别故障的代码</span><br><span class="line">&lt;faultstring&gt;可供人阅读的有关故障的说明</span><br><span class="line">&lt;faultactor&gt;有关是谁引发故障的信息</span><br><span class="line">&lt;detail&gt;存留涉及 Body 元素的应用程序专用错误信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SOAP-Fault-代码"><a href="#SOAP-Fault-代码" class="headerlink" title="SOAP Fault 代码"></a>SOAP Fault 代码</h2><pre><code>在下面定义的 faultcode 值必须用于描述错误时的 faultcode 元素中：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误描述</span><br><span class="line">VersionMismatchSOAP Envelope 元素的无效命名空间被发现</span><br><span class="line">MustUnderstandHeader 元素的一个直接子元素（带有设置为 &quot;1&quot; 的 mustUnderstand 属性）无法被理解。</span><br><span class="line">Client消息被不正确地构成，或包含了不正确的信息。</span><br><span class="line">Server服务器有问题，因此无法处理进行下去。</span><br></pre></td></tr></table></figure><h1 id="SOAP-HTTP-Binding"><a href="#SOAP-HTTP-Binding" class="headerlink" title="SOAP HTTP Binding"></a>SOAP HTTP Binding</h1><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><pre><code>HTTP 在 TCP/IP 之上进行通信。HTTP 客户机使用 TCP 连接到 HTTP 服务器。在建立连接之后，客户机可向服务器发送 HTTP 请求消息：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /item HTTP/1.1</span><br><span class="line">Host: 189.123.345.239</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 200</span><br></pre></td></tr></table></figure><pre><code>随后服务器会处理此请求，然后向客户机发送一个 HTTP 响应。此响应包含了可指示请求状态的状态代码：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 200</span><br></pre></td></tr></table></figure><pre><code>在上面的例子中，服务器返回了一个 200 的状态代码。这是 HTTP 的标准成功代码。假如服务器无法对请求进行解码，它可能会返回类似这样的信息：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400 Bad Request</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><pre><code>SOAP HTTP BindingSOAP 方法指的是遵守 SOAP 编码规则的 HTTP 请求/响应。HTTP + XML = SOAPSOAP 请求可能是 HTTP POST 或 HTTP GET 请求。HTTP POST 请求规定至少两个 HTTP 头：Content-Type 和 Content-Length。</code></pre><h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><pre><code>SOAP 的请求和响应的 Content-Type 头可定义消息的 MIME 类型，以及用于请求或响应的 XML 主体的字符编码（可选）。</code></pre><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: MIMEType; charset=character-encoding </span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /item HTTP/1.1</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br></pre></td></tr></table></figure><h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><pre><code>SOAP 的请求和响应的 Content-Length 头规定请求或响应主体的字节数。</code></pre><p>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: bytes </span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /item HTTP/1.1</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: 250</span><br></pre></td></tr></table></figure><h1 id="一个-SOAP-实例"><a href="#一个-SOAP-实例" class="headerlink" title="一个 SOAP 实例"></a>一个 SOAP 实例</h1><pre><code>在下面的例子中，一个 GetStockPrice 请求被发送到了服务器。此请求有一个 StockName 参数，而在响应中则会返回一个 Price 参数。此功能的命名空间被定义在此地址中： &quot;http://www.example.org/stock&quot;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SOAP 请求：</span><br><span class="line">POST /InStock HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: nnn</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">    &lt;m:GetStockPrice&gt;</span><br><span class="line">      &lt;m:StockName&gt;IBM&lt;/m:StockName&gt;</span><br><span class="line">    &lt;/m:GetStockPrice&gt;</span><br><span class="line">  &lt;/soap:Body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SOAP 响应：</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/soap+xml; charset=utf-8</span><br><span class="line">Content-Length: nnn</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;soap:Envelope</span><br><span class="line">xmlns:soap=&quot;http://www.w3.org/2001/12/soap-envelope&quot;</span><br><span class="line">soap:encodingStyle=&quot;http://www.w3.org/2001/12/soap-encoding&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;soap:Body xmlns:m=&quot;http://www.example.org/stock&quot;&gt;</span><br><span class="line">    &lt;m:GetStockPriceResponse&gt;</span><br><span class="line">      &lt;m:Price&gt;34.5&lt;/m:Price&gt;</span><br><span class="line">    &lt;/m:GetStockPriceResponse&gt;</span><br><span class="line">  &lt;/soap:Body&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p><code>目前onvif代码主流生成方式gsoap</code><br>也有自己写的、还有的是sdk方式。<br>本篇完结</p>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wsdl接口</title>
      <link href="/posts/ce15fa91.html"/>
      <url>/posts/ce15fa91.html</url>
      
        <content type="html"><![CDATA[<h1 id="wsdl文档"><a href="#wsdl文档" class="headerlink" title="wsdl文档"></a>wsdl文档</h1><pre><code>WSDL 文档仅仅是一个简单的 XML 文档。它包含一系列描述某个 web service 的定义。</code></pre><h2 id="WSDL-文档结构"><a href="#WSDL-文档结构" class="headerlink" title="WSDL 文档结构"></a>WSDL 文档结构</h2><pre><code>WSDL 文档是利用这些主要的元素来描述某个 web service 的：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">元素定义</span><br><span class="line">&lt;portType&gt;web service 执行的操作</span><br><span class="line">&lt;message&gt;web service 使用的消息</span><br><span class="line">&lt;types&gt;web service 使用的数据类型</span><br><span class="line">&lt;binding&gt;web service 使用的通信协议</span><br></pre></td></tr></table></figure><pre><code>一个 WSDL 文档的主要结构是类似这样的：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;definitions&gt;</span><br><span class="line"></span><br><span class="line">&lt;types&gt;</span><br><span class="line">   definition of types........</span><br><span class="line">&lt;/types&gt;</span><br><span class="line"></span><br><span class="line">&lt;message&gt;</span><br><span class="line">   definition of a message....</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;portType&gt;</span><br><span class="line">   definition of a port.......</span><br><span class="line">&lt;/portType&gt;</span><br><span class="line"></span><br><span class="line">&lt;binding&gt;</span><br><span class="line">   definition of a binding....</span><br><span class="line">&lt;/binding&gt;</span><br><span class="line"></span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure><pre><code>WSDL 文档可包含其它的元素，比如 extension 元素，以及一个 service 元素，此元素可把若干个 web services 的定义组合在一个单一的 WSDL 文档中。</code></pre><h2 id="WSDL-端口"><a href="#WSDL-端口" class="headerlink" title="WSDL 端口"></a>WSDL 端口</h2><pre><code>&lt;portType&gt; 元素是最重要的 WSDL 元素。它可描述一个 web service、可被执行的操作，以及相关的消息。可以把 &lt;portType&gt; 元素比作传统编程语言中的一个函数库（或一个模块、或一个类）</code></pre><h2 id="WSDL-消息"><a href="#WSDL-消息" class="headerlink" title="WSDL 消息"></a>WSDL 消息</h2><pre><code>&lt;message&gt; 元素定义一个操作的数据元素。每个消息均由一个或多个部件组成。可以把这些部件比作传统编程语言中一个函数调用的参数。</code></pre><h2 id="WSDL-types"><a href="#WSDL-types" class="headerlink" title="WSDL types"></a>WSDL types</h2><pre><code>&lt;types&gt; 元素定义 web service 使用的数据类型。为了最大程度的平台中立性，WSDL 使用 XML Schema 语法来定义数据类型。</code></pre><h2 id="WSDL-Bindings"><a href="#WSDL-Bindings" class="headerlink" title="WSDL Bindings"></a>WSDL Bindings</h2><pre><code>&lt;binding&gt; 元素为每个端口定义消息格式和协议细节。</code></pre><h2 id="WSDL-实例"><a href="#WSDL-实例" class="headerlink" title="WSDL 实例"></a>WSDL 实例</h2><pre><code>这是某个 WSDL 文档的简化的片段：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;message name=&quot;getTermRequest&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;term&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;message name=&quot;getTermResponse&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;value&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;portType name=&quot;glossaryTerms&quot;&gt;</span><br><span class="line">  &lt;operation name=&quot;getTerm&quot;&gt;</span><br><span class="line">        &lt;input message=&quot;getTermRequest&quot;/&gt;</span><br><span class="line">        &lt;output message=&quot;getTermResponse&quot;/&gt;</span><br><span class="line">  &lt;/operation&gt;</span><br><span class="line">&lt;/portType&gt;</span><br></pre></td></tr></table></figure><pre><code>在这个例子中，&lt;portType&gt; 元素把 &quot;glossaryTerms&quot; 定义为某个端口的名称，把 &quot;getTerm&quot; 定义为某个操作的名称。操作 &quot;getTerm&quot; 拥有一个名为 &quot;getTermRequest&quot; 的输入消息，以及一个名为 &quot;getTermResponse&quot; 的输出消息。&lt;message&gt; 元素可定义每个消息的部件，以及相关联的数据类型。对比传统的编程，glossaryTerms 是一个函数库，而 &quot;g etTerm&quot; 是带有输入参数 &quot;getTermRequest&quot; 和返回参数 getTermResponse 的一个函数。</code></pre><h1 id="WSDL-端口可描述由某个-web-service-提供的界面（合法操作）。"><a href="#WSDL-端口可描述由某个-web-service-提供的界面（合法操作）。" class="headerlink" title="WSDL 端口可描述由某个 web service 提供的界面（合法操作）。"></a>WSDL 端口可描述由某个 web service 提供的界面（合法操作）。</h1><h2 id="WSDL-端口-1"><a href="#WSDL-端口-1" class="headerlink" title="WSDL 端口"></a>WSDL 端口</h2><pre><code>&lt;portType&gt; 元素是最重要的 WSDL 元素。它可描述一个 web service、可被执行的操作，以及相关的消息。端口定义了指向某个 web service 的连接点。可以把该元素比作传统编程语言中的一个函数库（或一个模块、或一个类），而把每个操作比作传统编程语言中的一个函数。</code></pre><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><pre><code>请求-响应是最普通的操作类型，不过 WSDL 定义了四种类型：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型定义</span><br><span class="line">One-way此操作可接受消息，但不会返回响应。</span><br><span class="line">Request-response此操作可接受一个请求并会返回一个响应</span><br><span class="line">Solicit-response此操作可发送一个请求，并会等待一个响应。</span><br><span class="line">Notification此操作可发送一条消息，但不会等待响应。</span><br></pre></td></tr></table></figure><h2 id="One-Way-操作"><a href="#One-Way-操作" class="headerlink" title="One-Way 操作"></a>One-Way 操作</h2><p>一个 one-way 操作的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;message name=&quot;newTermValues&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;term&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">   &lt;part name=&quot;value&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;portType name=&quot;glossaryTerms&quot;&gt;</span><br><span class="line">   &lt;operation name=&quot;setTerm&quot;&gt;</span><br><span class="line">      &lt;input name=&quot;newTerm&quot; message=&quot;newTermValues&quot;/&gt;</span><br><span class="line">   &lt;/operation&gt;</span><br><span class="line">&lt;/portType &gt;</span><br></pre></td></tr></table></figure><pre><code>在这个例子中，端口 &quot;glossaryTerms&quot; 定义了一个名为 &quot;setTerm&quot; 的 one-way 操作。这个 &quot;setTerm&quot; 操作可接受新术语表项目消息的输入，这些消息使用一条名为 &quot;newTermValues&quot; 的消息，此消息带有输入参数 &quot;term&quot; 和 &quot;value&quot;。不过，没有为这个操作定义任何输出。</code></pre><h2 id="Request-Response-操作"><a href="#Request-Response-操作" class="headerlink" title="Request-Response 操作"></a>Request-Response 操作</h2><pre><code>一个 request-response 操作的例子：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;message name=&quot;getTermRequest&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;term&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;message name=&quot;getTermResponse&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;value&quot; type=&quot;xs:string&quot;/&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;portType name=&quot;glossaryTerms&quot;&gt;</span><br><span class="line">  &lt;operation name=&quot;getTerm&quot;&gt;</span><br><span class="line">    &lt;input message=&quot;getTermRequest&quot;/&gt;</span><br><span class="line">    &lt;output message=&quot;getTermResponse&quot;/&gt;</span><br><span class="line">  &lt;/operation&gt;</span><br><span class="line">&lt;/portType&gt;</span><br></pre></td></tr></table></figure><pre><code>在这个例子中，端口 &quot;glossaryTerms&quot; 定义了一个名为 &quot;getTerm&quot; 的 request-response 操作。&quot;getTerm&quot; 操作会请求一个名为 &quot;getTermRequest&quot; 的输入消息，此消息带有一个名为 &quot;term&quot; 的参数，并将返回一个名为 &quot;getTermResponse&quot; 的输出消息，此消息带有一个名为 &quot;value&quot; 的参数。</code></pre><h2 id="绑定到-SOAP"><a href="#绑定到-SOAP" class="headerlink" title="绑定到 SOAP"></a>绑定到 SOAP</h2><pre><code>一个 请求 - 响应 操作的例子：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;message name=&quot;getTermRequest&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;term&quot; type=&quot;xs:string&quot; /&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;message name=&quot;getTermResponse&quot;&gt;</span><br><span class="line">   &lt;part name=&quot;value&quot; type=&quot;xs:string&quot; /&gt;</span><br><span class="line">&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;portType name=&quot;glossaryTerms&quot;&gt;</span><br><span class="line">  &lt;operation name=&quot;getTerm&quot;&gt;</span><br><span class="line">      &lt;input message=&quot;getTermRequest&quot; /&gt;</span><br><span class="line">      &lt;output message=&quot;getTermResponse&quot; /&gt;</span><br><span class="line">  &lt;/operation&gt;</span><br><span class="line">&lt;/portType&gt;</span><br><span class="line"></span><br><span class="line">&lt;binding type=&quot;glossaryTerms&quot; name=&quot;b1&quot;&gt;</span><br><span class="line">&lt;soap:binding style=&quot;document&quot;</span><br><span class="line">transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt;</span><br><span class="line">  &lt;operation&gt;</span><br><span class="line">    &lt;soap:operation</span><br><span class="line">     soapAction=&quot;http://example.com/getTerm&quot; /&gt;</span><br><span class="line">    &lt;input&gt;</span><br><span class="line">      &lt;soap:body use=&quot;literal&quot; /&gt;</span><br><span class="line">    &lt;/input&gt;</span><br><span class="line">    &lt;output&gt;</span><br><span class="line">      &lt;soap:body use=&quot;literal&quot; /&gt;</span><br><span class="line">    &lt;/output&gt;</span><br><span class="line">  &lt;/operation&gt;</span><br><span class="line">&lt;/binding&gt;</span><br></pre></td></tr></table></figure><h3 id="binding-元素有两个属性-name-属性和-type-属性"><a href="#binding-元素有两个属性-name-属性和-type-属性" class="headerlink" title="binding 元素有两个属性 - name 属性和 type 属性"></a>binding 元素有两个属性 - name 属性和 type 属性</h3><pre><code>name 属性定义 binding 的名称，而 type 属性指向用于 binding 的端口，在这个例子中是 &quot;glossaryTerms&quot; 端口。</code></pre><h3 id="soap-binding-元素有两个属性-style-属性和-transport-属性。"><a href="#soap-binding-元素有两个属性-style-属性和-transport-属性。" class="headerlink" title="soap:binding 元素有两个属性 - style 属性和 transport 属性。"></a>soap:binding 元素有两个属性 - style 属性和 transport 属性。</h3><pre><code>style 属性可取值 &quot;rpc&quot; 或 &quot;document&quot;。在这个例子中我们使用 document。transport 属性定义了要使用的 SOAP 协议。在这个例子中我们使用 HTTP。</code></pre><h3 id="operation-元素定义了每个端口提供的操作符。"><a href="#operation-元素定义了每个端口提供的操作符。" class="headerlink" title="operation 元素定义了每个端口提供的操作符。"></a>operation 元素定义了每个端口提供的操作符。</h3><pre><code>对于每个操作，相应的 SOAP 行为都需要被定义。同时您必须如何对输入和输出进行编码。在这个例子中我们使用了 &quot;literal&quot;。</code></pre><h1 id="w3c工作草案"><a href="#w3c工作草案" class="headerlink" title="w3c工作草案"></a>w3c工作草案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:definitions name=&quot;nmtoken&quot;? targetNamespace=&quot;uri&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;import namespace=&quot;uri&quot; location=&quot;uri&quot;/&gt; *</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:types&gt; ?</span><br><span class="line">        &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">        &lt;xsd:schema .... /&gt; *</span><br><span class="line">    &lt;/wsdl:types&gt;</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:message name=&quot;ncname&quot;&gt; *</span><br><span class="line">        &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">        &lt;part name=&quot;ncname&quot; element=&quot;qname&quot;? type=&quot;qname&quot;?/&gt; *</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:portType name=&quot;ncname&quot;&gt; *</span><br><span class="line">        &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">        &lt;wsdl:operation name=&quot;ncname&quot;&gt; *</span><br><span class="line">            &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">            &lt;wsdl:input message=&quot;qname&quot;&gt; ?</span><br><span class="line">                &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">            &lt;/wsdl:input&gt;</span><br><span class="line">            &lt;wsdl:output message=&quot;qname&quot;&gt; ?</span><br><span class="line">                &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">            &lt;/wsdl:output&gt;</span><br><span class="line">            &lt;wsdl:fault name=&quot;ncname&quot; message=&quot;qname&quot;&gt; *</span><br><span class="line">                &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">            &lt;/wsdl:fault&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:portType&gt;</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:serviceType name=&quot;ncname&quot;&gt; *</span><br><span class="line">        &lt;wsdl:portType name=&quot;qname&quot;/&gt; +</span><br><span class="line">    &lt;/wsdl:serviceType&gt;</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:binding name=&quot;ncname&quot; type=&quot;qname&quot;&gt; *</span><br><span class="line">        &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">        &lt;-- binding details --&gt; *</span><br><span class="line">        &lt;wsdl:operation name=&quot;ncname&quot;&gt; *</span><br><span class="line">            &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">            &lt;-- binding details --&gt; *</span><br><span class="line">            &lt;wsdl:input&gt; ?</span><br><span class="line">                &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">                &lt;-- binding details --&gt;</span><br><span class="line">            &lt;/wsdl:input&gt;</span><br><span class="line">            &lt;wsdl:output&gt; ?</span><br><span class="line">                &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">                &lt;-- binding details --&gt; *</span><br><span class="line">            &lt;/wsdl:output&gt;</span><br><span class="line">            &lt;wsdl:fault name=&quot;ncname&quot;&gt; *</span><br><span class="line">                &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">                &lt;-- binding details --&gt; *</span><br><span class="line">            &lt;/wsdl:fault&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:binding&gt;</span><br><span class="line"></span><br><span class="line">    &lt;wsdl:service name=&quot;ncname&quot; serviceType=&quot;qname&quot;&gt; *</span><br><span class="line">        &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">        &lt;wsdl:port name=&quot;ncname&quot; binding=&quot;qname&quot;&gt; *</span><br><span class="line">            &lt;wsdl:documentation .... /&gt; ?</span><br><span class="line">            &lt;-- address details --&gt;</span><br><span class="line">        &lt;/wsdl:port&gt;</span><br><span class="line">    &lt;/wsdl:service&gt;</span><br><span class="line"></span><br><span class="line">&lt;/wsdl:definitions&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg移植</title>
      <link href="/posts/3a597416.html"/>
      <url>/posts/3a597416.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、音视频入门"><a href="#1、音视频入门" class="headerlink" title="1、音视频入门"></a>1、音视频入门</h1><h2 id="1-1、视频"><a href="#1-1、视频" class="headerlink" title="1-1、视频"></a>1-1、视频</h2><ul><li><p>动画书<br>静态小人书，通过快速翻动，形成动态效果。— 视频原理</p></li><li><p>视频<br>将一些列的静态影像以电信号的方式进行动态捕捉</p></li></ul><h1 id="一、扩展ffmpeg"><a href="#一、扩展ffmpeg" class="headerlink" title="一、扩展ffmpeg"></a>一、扩展ffmpeg</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f v4l2 -r 30 -s 640x480 -i /dev/video0 -f alsa -ar 44100 -ac 2 -i default -c:v libx264 -preset medium -tune zerolatency -c:a aac -b:a 128k -f nut - | ffplay -</span><br></pre></td></tr></table></figure><h2 id="ffmpeg移植"><a href="#ffmpeg移植" class="headerlink" title="ffmpeg移植"></a>ffmpeg移植</h2><p>ffmpeg的移植依赖于x264和x265</p><h3 id="1、移植x264"><a href="#1、移植x264" class="headerlink" title="1、移植x264"></a>1、移植x264</h3><p>下载源码，创建build.sh脚本，内容如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">make clean</span><br><span class="line">path=&quot;/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin&quot;</span><br><span class="line">set_path=$&#123;PWD&#125;/../</span><br><span class="line">export PATH=$&#123;path&#125;:$PATH</span><br><span class="line">arm-none-linux-gnueabihf-gcc --version</span><br><span class="line"></span><br><span class="line">./configure \</span><br><span class="line">        --cross-prefix=arm-none-linux-gnueabihf- \</span><br><span class="line">        --prefix=$&#123;set_path&#125; \</span><br><span class="line">    --host=arm-none-linux-gnueabihf \</span><br><span class="line">    --enable-shared \</span><br><span class="line">    --enable-static</span><br><span class="line"></span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><code>--enable-static</code>没有会出现无法找到x264。</p><h3 id="2、移植x265"><a href="#2、移植x265" class="headerlink" title="2、移植x265"></a>2、移植x265</h3><ul><li><p>安装需要的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install yasm cmake cmake-curses-gui</span><br></pre></td></tr></table></figure></li><li><p>在build文件夹下有一个arm-linux文件夹，在里面有一个crosscompile.cmake文件，这个是交叉编译的配置文件。<br>修改这个文件如下。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMake toolchain file <span class="keyword">for</span> cross compiling x265 <span class="keyword">for</span> ARM <span class="built_in">arch</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This feature is only supported as experimental. Use with caution.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Please report bugs on bitbucket</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run cmake with: cmake -DCMAKE_TOOLCHAIN_FILE=crosscompile.cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> ../../source &amp;&amp; ccmake ../../source</span></span><br><span class="line"></span><br><span class="line">set(CROSS_COMPILE_ARM 1)</span><br><span class="line">set(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line">set(CMAKE_SYSTEM_PROCESSOR armv7)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify the cross compiler</span></span><br><span class="line">set(CMAKE_C_COMPILER /home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gcc)</span><br><span class="line">set(CMAKE_CXX_COMPILER /home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-g++)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">specify the target environment</span></span><br><span class="line">SET(CMAKE_FIND_ROOT_PATH /home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/arm-none-linux-gnueabihf)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>CMAKE_FIND_ROOT_PATH 指定交叉编译工具链的一些库路径。</li></ul><p><code>要修改编译脚本中cmake -DCMAKE_TOOLCHAIN_FILE=./crosscompile.cmake -G &quot;Unix Makefiles&quot; ../../source &amp;&amp; ccmake .</code><br>将*.cmake改成自己的路径。这很重要，不然传参可能出错。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BIN_INSTALL_DIR                  bin                                                                                                        </span><br><span class="line">CHECKED_BUILD                    OFF                                                                                                        </span><br><span class="line">CMAKE_BUILD_TYPE                 Release                                                                                                    </span><br><span class="line">CMAKE_INSTALL_PREFIX             /usr/local/x265    （这是本人设置的安装路径，可修改为你需要的安装路径）                                                                                       </span><br><span class="line">DETAILED_CU_STATS                OFF                                                                                                        </span><br><span class="line">ENABLE_AGGRESSIVE_CHECKS         OFF                                                                                                        </span><br><span class="line">ENABLE_ASSEMBLY                  ON                                                                                                         </span><br><span class="line">ENABLE_CLI                       ON                                                                                                         </span><br><span class="line">ENABLE_HDR10_PLUS                OFF                                                                                                        </span><br><span class="line">ENABLE_LIBNUMA                   ON                                                                                                         </span><br><span class="line">ENABLE_PIC                       OFF                                                                                                        </span><br><span class="line">ENABLE_PPA                       OFF                                                                                                        </span><br><span class="line">ENABLE_SHARED                    OFF    （这里默认是开启的，生成动态库，根据需要设置）                                                                                                        </span><br><span class="line">ENABLE_TESTS                     OFF                                                                                                        </span><br><span class="line">ENABLE_VTUNE                     OFF                                                                                                        </span><br><span class="line">FSANITIZE                                                                                                                                   </span><br><span class="line">LIBDL                            /opt/FriendlyARM/toolschain/4.5.1/arm-none-linux-gnueabi/sys-root/usr/lib/libdl.so    （不要漏了这个库，根据实际路径设置）                        </span><br><span class="line">LIB_INSTALL_DIR                  lib                                                                                                        </span><br><span class="line">NASM_EXECUTABLE                  /usr/bin/yasm    （yasm文件，在本文开头第一步已经安装好了）                                                                                              </span><br><span class="line">NO_ATOMICS                       OFF                                                                                                        </span><br><span class="line">NUMA_ROOT_DIR                    NUMA_ROOT_DIR-NOTFOUND                                                                                     </span><br><span class="line">STATIC_LINK_CRT                  OFF                                                                                                        </span><br><span class="line">WARNINGS_AS_ERRORS               OFF   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>源码默认支持软件浮点，修改为硬件浮点，需要修改cmake</code></p><p>执行脚本，make</p><p>安装make install</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3、最后移植ffmpeg"><a href="#3、最后移植ffmpeg" class="headerlink" title="3、最后移植ffmpeg"></a>3、最后移植ffmpeg</h3><p>下载源码github</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/FFmpeg/FFmpeg.git</span><br></pre></td></tr></table></figure><p>配置编译<br>这里有要加的–pkg-config&#x3D;”pkg-config –static”,不加这个通不过编译，出现x264和x265的依赖问题.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--pkg-config=&quot;pkg-config --static&quot; </span><br></pre></td></tr></table></figure><p>配置上x265的路径，不然会报找不到x265的错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PKG_CONFIG_PATH=$&#123;x265_path&#125;/lib/pkgconfig </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &quot;arm-build&quot; ]; then</span><br><span class="line">make clean</span><br><span class="line">path=&quot;/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin&quot;</span><br><span class="line">set_out_path=$&#123;PWD&#125;/../</span><br><span class="line">x264_path=/home/ygc/Desktop/project/myproject/app-src/project/test/ffmpeg/x264_build/</span><br><span class="line">x265_path=/home/ygc/Desktop/project/myproject/app-src/project/test/ffmpeg/x265_build/out</span><br><span class="line">echo $&#123;path&#125;</span><br><span class="line">echo $&#123;set_path&#125;</span><br><span class="line"></span><br><span class="line">export PKG_CONFIG_PATH=$&#123;x264_path&#125;/lib/pkgconfig:$PKG_CONFIG_PATH</span><br><span class="line">echo &quot;PKG_CONFIG_PATH is now: $PKG_CONFIG_PATH&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure --cross-prefix=arm-linux-gnueabihf- --enable-cross-compile --target-os=linux --cc=arm-linux-gnueabihf-gcc --<span class="built_in">arch</span>=arm --prefix=/home/xfy/FFmpeg/ffmpeg_install --enable-shared --disable-static --enable-gpl --enable-nonfree --disable-ffplay --enable-swscale --enable-pthreads --disable-armv5te --disable-armv6 --disable-armv6t2 --disable-x86asm --disable-stripping --enable-libx264 --extra-cflags=-I/home/xfy/FFmpeg/x264_install/include --extra-ldflags=-L/home/xfy/FFmpeg/x264_install/lib --extra-libs=-ldl</span></span><br><span class="line"></span><br><span class="line">export PKG_CONFIG_PATH=/home/ygc/Desktop/project/myproject/app-src/project/test/ffmpeg/x264_build/lib/pkgconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加 x265 的 pkg-config 路径</span></span><br><span class="line">export PKG_CONFIG_PATH=$&#123;x265_path&#125;/lib/pkgconfig</span><br><span class="line">pkg-config --modversion x264</span><br><span class="line">pkg-config --exists x264 &amp;&amp; pkg-config --cflags --libs x264</span><br><span class="line"></span><br><span class="line">ls $&#123;x264_path&#125;/include/x264.h</span><br><span class="line">ls $&#123;x264_path&#125;/lib/libx264.so</span><br><span class="line">ls $&#123;x264_path&#125;/lib/pkgconfig/x264.pc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure \</span></span><br><span class="line"><span class="language-bash">     ./configure \</span></span><br><span class="line"><span class="language-bash">    --prefix=<span class="variable">$&#123;set_out_path&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    --enable-cross-compile \</span></span><br><span class="line"><span class="language-bash">    --pkg-config=<span class="string">&quot;pkg-config --static&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --cross-prefix=<span class="variable">$&#123;path&#125;</span>/arm-none-linux-gnueabihf- \</span></span><br><span class="line"><span class="language-bash">    --extra-cflags=<span class="string">&quot;-I<span class="variable">$&#123;x264_path&#125;</span>/include -I<span class="variable">$&#123;x265_path&#125;</span>/include&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --extra-ldflags=<span class="string">&quot;-L<span class="variable">$&#123;x264_path&#125;</span>/lib -L<span class="variable">$&#123;x265_path&#125;</span>/lib&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    --<span class="built_in">arch</span>=arm \</span></span><br><span class="line"><span class="language-bash">    --disable-x86asm \</span></span><br><span class="line"><span class="language-bash">    --cc=arm-none-linux-gnueabihf-gcc \</span></span><br><span class="line"><span class="language-bash">    --target-os=linux \</span></span><br><span class="line"><span class="language-bash">    --enable-gpl \</span></span><br><span class="line"><span class="language-bash">    --enable-libx264 \</span></span><br><span class="line"><span class="language-bash">    --enable-shared \</span></span><br><span class="line"><span class="language-bash">    --disable-static \</span></span><br><span class="line"><span class="language-bash">    --enable-libx265 \</span></span><br><span class="line"><span class="language-bash">    --extra-libs=-ldl</span></span><br><span class="line">    make -j$(nproc)</span><br><span class="line">    sudo make install</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$1&quot; = &quot;x86-build&quot; ]; then</span><br><span class="line">make clean</span><br><span class="line">set_path=$&#123;PWD&#125;/../</span><br><span class="line">echo $&#123;set_path&#125;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nasm libfdk-aac-dev libx264-dev libx265-dev libvpx-dev libmp3lame-dev libopus-dev</span><br><span class="line">./configure \</span><br><span class="line">    --prefix=$&#123;set_path&#125; \</span><br><span class="line">    --enable-gpl \</span><br><span class="line">    --enable-libx264 \</span><br><span class="line">    --enable-libx265 \</span><br><span class="line">    --enable-libvpx \</span><br><span class="line">    --enable-libfdk-aac \</span><br><span class="line">    --enable-nonfree \</span><br><span class="line">    --enable-libmp3lame \</span><br><span class="line">    --enable-libopus</span><br><span class="line">    make -j$(nproc)</span><br><span class="line">    sudo make install</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI人工智能深度学习-视觉基础</title>
      <link href="/posts/73778e8c.html"/>
      <url>/posts/73778e8c.html</url>
      
        <content type="html"><![CDATA[<h1 id="准备篇"><a href="#准备篇" class="headerlink" title="准备篇"></a>准备篇</h1><p>rk的sdk编译后，buildrootd的output生成了两个目录，<code>alientek_rv1126</code>存<br>放的是文件系统镜像和交叉编译工具，而<code>alientek_rv1126_recovery</code>存放的<br>是内核kerner,设备树dtb,ramdisk组成的根文件系统。<br>alientek_rv1126的build中的文件是从buildroot中的dl中解压过去的。     </p><p><img src="../../..../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/rk%E4%B8%AD%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.png" alt="物理分区">      </p><ul><li>rv1126进行学习</li></ul><h1 id="1、-图像相关知识点"><a href="#1、-图像相关知识点" class="headerlink" title="1、 图像相关知识点"></a>1、 图像相关知识点</h1><h2 id="1-1、-RKAIQ宏定义"><a href="#1-1、-RKAIQ宏定义" class="headerlink" title="1-1、 RKAIQ宏定义"></a>1-1、 RKAIQ宏定义</h2><pre><code>    图像传感器获取的数据是raw数据，没有经过任何处理的图像数据。是光源信号转化为数字信号最原始的数据，如果raw图像没有经过任何的优化，没有经过任何的处理，是无法被人类查阅的。    raw数据是无损画质的图像，但是占的空间很大</code></pre><h2 id="1-2、文件系统分区"><a href="#1-2、文件系统分区" class="headerlink" title="1-2、文件系统分区"></a>1-2、文件系统分区</h2><p>文件系统可以使用ls &#x2F;dev查看，文件分区分为用户层区和保存一些签名的，内<br>核ubot相关的分区，<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png" alt="物理分区"><br>在linux系统中可以采用以下的方式查看分区信息     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">一、查看设备节点 `ls /dev/`</span><br><span class="line"></span><br><span class="line">二、使用命令 `lsblk`</span><br><span class="line"></span><br><span class="line">三、`fdisk -l`` 查看（UDA）分区列表</span><br><span class="line"></span><br><span class="line">四、查看（UDA）分区情况 `cat /proc/partitions` 或者 `fdisk /proc/partitions`</span><br><span class="line"></span><br><span class="line">五、查看已经挂载的文件系统磁盘占用情况`df -h`</span><br><span class="line"></span><br><span class="line">六、查看已挂载的文件系统格式`df -h -T`</span><br><span class="line"></span><br><span class="line">七、查看对应分区的文件系统的格式`fsck -N /dev/mmcblk0p1`</span><br><span class="line"></span><br><span class="line">八、查看文件系统的分区表 `vi /etc/fstab`</span><br><span class="line"></span><br><span class="line">九、也可以采用 `more /etc/fstab`</span><br><span class="line"></span><br><span class="line">十、也可以采用`mount`查看</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rk1126的分区文件parameter.txt存放在sdk中的rockdev中，</p><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/parameter.png">     </p><pre><code>    CMDLINE为分区的配置。 分区表的格式为： 分区大小@所在地址（分区名） 最后的-@所在地址（分区名：grow）的&quot;-&quot;代表将剩余的内存留给该分区，&quot;grow&quot;的写法只能放在CMDLINE最后。</code></pre><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E5%88%86%E5%8C%BA%E6%96%87%E4%BB%B6parameter.png">     </p><pre><code>    `blkid`可以查看分区的uuid</code></pre><h3 id="1-2-1、尝试修改分区"><a href="#1-2-1、尝试修改分区" class="headerlink" title="1-2-1、尝试修改分区"></a>1-2-1、尝试修改分区</h3><p>添加一个分区<br>第一步：修改分区文件parameter.txt文件。<br>第二步：烧录系统<br>第三步：格式化分区（格式化为某种格式的文件系统）<br>第四步：查看是否格式化成功<br>第五步：挂载    </p><h3 id="1-2-2、镜像烧录"><a href="#1-2-2、镜像烧录" class="headerlink" title="1-2-2、镜像烧录"></a>1-2-2、镜像烧录</h3><p><code>在添加配置文件的时候，注意镜像存在的位置，配置文件添加上后，后面的镜像地址不一定是对的。</code></p><p><code>loader需要注意的是在编译出来的文件中并没有，镜像名字叫做MiniLoaderAll.bin，是二进制文件。</code></p><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/MiniLoaderAll.png"></p><pre><code>    这个配置文件的修改方法是导入完配置后，修改自己镜像路径，然后在导出自    己的配置。</code></pre><p> <img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9.png">   </p><ul><li>烧写有两种模式：“LOADER”和“MASKROM，LOADER是使用uboot为基础的。<br>更改分区一定要是用MASKROM模式。</li></ul><p>烧录完成后，就能在&#x2F;dev下看到新增加的分区，<br>使用fdisk -l可以看到分区的名字。<br>这个时候就完成了上面所说的第二步，<br>如果这个时候去挂在，很大概率是挂在不上的，<br>这里使用fsck -N &#x2F;dev&#x2F;mmcblk0p10看下设置的分区的格式，       </p><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E5%88%86%E5%8C%BA%E6%9F%A5%E8%AF%A2.png">          </p><ul><li>格式化</li></ul><p>使用mkfs.xxx -F &#x2F;dev&#x2F;mmcblk0p10进行格式化操作。     </p><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E6%A0%BC%E5%BC%8F%E5%8C%96.png"></p><ul><li>挂载</li></ul><p>mkdir XXX<br>mount &#x2F;dev&#x2F;mmcblk0p10 xxx<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E6%8C%82%E8%BD%BD.png">       </p><h2 id="1-3、开机自启动"><a href="#1-3、开机自启动" class="headerlink" title="1-3、开机自启动"></a>1-3、开机自启动</h2><p>linux启动第一个运行的进程是init,它是所有进程的父进程，程序最先启动的就是它，<br>命令在&#x2F;sbin&#x2F;init，它启动之后要去读&#x2F;etc&#x2F;inittab配置文件     。<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/inittab.png"><br>&#x2F;etc&#x2F;inittab文件的语法格式<br><code>标签：运行级别：操作：进程</code><br>label:runlevel:action:process<br>label登记项标识符，表示输入的值     </p><table><thead><tr><th align="center">标示项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">用来定义缺省的init运行级别（runlevel）</td></tr><tr><td align="center">si</td><td align="center">系统初始化的进程</td></tr><tr><td align="center">ln</td><td align="center">指明该进程可以使用的runlevel的级别 （级别为0-6，共7个运行级别）</td></tr><tr><td align="center">ud</td><td align="center">升级进程的ud值可以唤醒&#x2F;sbin&#x2F;update进程，该进程为了保持磁盘的完整性，对磁盘进行i&#x2F;o操作前清空了整个的i&#x2F;o缓冲区</td></tr><tr><td align="center">ca</td><td align="center">当按下ctrl+alt+del时运行的进程</td></tr><tr><td align="center">pf</td><td align="center">当ups表明断电时运行的进程</td></tr><tr><td align="center">pr</td><td align="center">在系统真正关闭之前，ups发出电源恢复信号时需要运行的程序</td></tr><tr><td align="center">x</td><td align="center">将系统转入x终端时需要运行的程序</td></tr></tbody></table><p>runlevel运行级别</p><table><thead><tr><th align="center">级别</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">runlevel 0</td><td align="center">系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动</td></tr><tr><td align="center">runlevel 1</td><td align="center">单用户工作模式，root权限，用于系统维护，禁止远程登陆</td></tr><tr><td align="center">runlevel 2</td><td align="center">多用户工作模式（但不支持NFS），命令行模式登录</td></tr><tr><td align="center">runlevel 3</td><td align="center">完全的多用户工作模式（有NFS），命令行模式登录</td></tr><tr><td align="center">runlevel 4</td><td align="center">系统未使用的模式。保留</td></tr><tr><td align="center">runlevel 5</td><td align="center">x11图形模式，登陆后进入图形GUI模式</td></tr><tr><td align="center">runlevel 6</td><td align="center">系统正常关闭并且重启，默认运行级别不能设置为6，否则不能正常启动</td></tr></tbody></table><p>开发板的文件系统没有设置有文件级别，可以尝试到ubuntu下查看。<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/ubuntu%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB.png">       </p><p>使用<code>runlevel</code>这个命令可以查看当前的系统处于什么模式下。<br>在开发版中，可以不对上面的两项进行设置。 （两项主要时label和runlevel两项）    </p><p>action操作      </p><table><thead><tr><th align="center">标示项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">boot</td><td align="center">只在系统运行时启动</td></tr><tr><td align="center">bootwait</td><td align="center">在系统启动运行时，系统启动后，当第一次从单用户模式</td></tr><tr><td align="center">sysinit</td><td align="center">在运行boot或者bootwait进程之前运行，指定的进程在访问控制台之前执行（为init提供初始化命令的路径）</td></tr><tr><td align="center">respawn</td><td align="center">不管何时终止都重新启动进程 （每当相应的进程终止执行便会重新启动）</td></tr><tr><td align="center">shutdown</td><td align="center">当关机时要运行的进程</td></tr><tr><td align="center">ctrlaltdel</td><td align="center">当ctrl + alt + del 三个键同时按下时运行</td></tr><tr><td align="center">wait</td><td align="center">告诉init 必须等到相应的进程完成之后才能继续执行</td></tr></tbody></table><p>process进程<br>意思就是一些可执行的文件，或者命令什么的。      </p><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/1126%E7%9A%84inittab.png"><br>第一个，挂在proc文件系统。通过这个proc文件系统，内核和用户就可以通讯了。<br>第二个，重新挂在，权限可读可写，挂载在根文件目录。<br>这里的mount -a 2 &gt; &#x2F;dev&#x2F;null 相当于黑洞，2是标准输出，定向到&#x2F;dev&#x2F;null，意思就是丢弃。<br>::sysinit &#x2F;bin&#x2F;hostname -F &#x2F;etc&#x2F;hostname 显示主机名。<br>::respawn :&#x2F;bin&#x2F;sh  作用是初始化shell终端。<br>::sysinit:&#x2F;etc&#x2F;init.d&#x2F;rcS在访问控制台之前先访问这个脚本(重点)。   </p><p>而关机的操作就是下面的stuff to do before rebooting<br>操作代号为shutdown<br>::shutdown: &#x2F;etc&#x2F;init.d&#x2F;rcK  关机的时候要执行这个脚本。<br>::shutdown: &#x2F;sbin&#x2F;swapoff -a 在linux下内存管理，必须使用交换区来使用虚拟内存，这个命令就是关闭虚拟内存。<br>如果需要打开交换区，使用的命令是swapon命令<br>::shutdown: &#x2F;bin&#x2F;umont -a -r 表示在关机的时候要卸载所有的内存。      </p><ul><li>而在于init.d目录下，在inittab中有开机的时候会区执行一个脚本。<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC.png"><br>上图ubutnu系统中，以s开头的代表开机时要运行的脚本，以k开头代表关机时要运行的脚本。<br>格式是k&#x2F;s+数字+字符串.sh，这里数字很重要，代表运行的优先级，数字越小优先级越高，如果优先级相同，<br>则使用后面字符串的ascii码值，码值越小，运行级别越高。从脚本的字符串可以看出运行脚本的作用。</li></ul><p>一般执行完更改的操作后，要使用sync同步一下缓存。<br>系统中有一个守护进程，start-stop-daemon这个命令就是开启守护进程。<br>&#x2F;sbin&#x2F;ifup 这个命令一般是用来启动网络的，这些命令一般在系统启动后的开机脚本中都会用到。  </p><ul><li>扩展<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">start-stop-daemon</span><br><span class="line">start-stop-daemon是OpenRC计划的一部分，这个程序最先出现在Debian系的Linux发行版中，这里有个比较古老的手册页面，更详细更直观的办法当然是通过man start-stop-daemon来查看手册了。</span><br><span class="line"></span><br><span class="line">start-stop-daemon最基本的两个功能就是--start和--stop，简写为-S和-K，然后再加上一个-s|--signal来给进程发送信号，功德圆满。</span><br><span class="line"></span><br><span class="line">-x, --exec daemon，daemon就是真正要执行的进程脚本，比方说启动nginx，那么就是start-stop-daemon -x nginx</span><br><span class="line">-p, --pidfile pidfile，指定pid文件，至于pid文件的用途就多了，stop,status都少不了它。</span><br><span class="line">-n, --name，如果没有指定pid文件，那么就要通过指定name来停止进程了。</span><br><span class="line">-u, --user user[:group]，指定脚本用哪个用户或用户组执行，init脚本是必须使用root权限来执行的，但是它fork出来的子进程我们一般会选择一个权限较低的用户。</span><br><span class="line">-b, --background，强制脚本在后台执行。</span><br><span class="line">-m, --make-pidfile，这个一般和-b配合，用于生成pid文件</span><br><span class="line">-d, --chdir path，切换进程的主目录，这个在构建守护进程的时候是很常用的。</span><br><span class="line">-r, --chroot path，在某些安全性要求较高的情况下，我们就需要用到chroot将进程工作环境与物理环境完全隔离开来。</span><br><span class="line">-1, --stdout logfile，将标准输出记录到log文件，与之相对应的就是-2, --stderr标准错误流。</span><br><span class="line">-w, --wait milliseconds，进程启动后，有这个参数会等待几毫秒来检测进程是否仍然存活。</span><br><span class="line">-x daemon后面跟的执行脚本必须只能是一个文件名，有些程序运行时还需要指定一些参数，比如nginx -c file来指定nginx的配置文件，使用start-stop-daemon -x &quot;nginx -c file&quot;是会报错的，这些程序内的参数以另一种方式加载，start-stop-daemon -x daemon -- $ARGV，这里的双横线--后面跟的所有参数就会被带到程序中了，比如start-stop-daemon -x nginx -c /etc/nginx.conf</span><br></pre></td></tr></table></figure></li><li>这些文件是通过rcS文件被启动起来的，而rcS文件是通过开机的启动配置，inittab中定义的。   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@ATK-DLRV1126:/etc/init.d]# cat rcS</span><br><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Start all init scripts in /etc/init.d</span><br><span class="line"># executing them in numerical order.</span><br><span class="line">#</span><br><span class="line">for i in /etc/init.d/S??* ;do   #这里就是取遍历启动文件，以大S开头的文件</span><br><span class="line"></span><br><span class="line">     # Ignore dangling symlinks (if any).</span><br><span class="line">     [ ! -f &quot;$i&quot; ] &amp;&amp; continue</span><br><span class="line"></span><br><span class="line">     case &quot;$i&quot; in</span><br><span class="line">        *.sh)</span><br><span class="line">            # Source shell script for speed.</span><br><span class="line">            (</span><br><span class="line">                trap - INT QUIT TSTP</span><br><span class="line">                set start   </span><br><span class="line">                . $i      </span><br><span class="line">            )</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            # No sh extension, so fork subprocess.</span><br><span class="line">            $i start</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>同样的。rcK文件同样类似如此。</li></ul><p><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png">   </p><h2 id="1-4、利用开机自启动，实现静态ip的设置"><a href="#1-4、利用开机自启动，实现静态ip的设置" class="headerlink" title="1-4、利用开机自启动，实现静态ip的设置"></a>1-4、利用开机自启动，实现静态ip的设置</h2><ul><li>扩展网络相关点<br>linux下，网络的dns放在了&#x2F;etc&#x2F;resolv.conf文件中。<br>对于网络的设置，在设置这些之前，需要关闭connman服务，否则可能导致修改不生效。<br>网络网卡也是在初始中启动的（需注意）。</li><li>设置静态ip<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">        printf &quot;stop connman: &quot;</span><br><span class="line">        /etc/init.d/S45connman stop</span><br><span class="line">        echo &quot;stop connman ok!&quot;</span><br><span class="line">        echo &quot;nameserver 8.8.8.8&quot;&gt;&gt; /etc/resolv.conf</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        printf &quot;nothing ... &quot;</span><br><span class="line">        echo &quot;.........&quot;</span><br><span class="line">        ;;   //注意这里的分号        </span><br><span class="line">  *)</span><br><span class="line">        echo &quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit $?</span><br><span class="line">```    </span><br><span class="line">在/etc/init.d下，按照规则，创建个脚本，让它开机运行。     </span><br><span class="line"></span><br><span class="line">在启动文件中，有一个/sbin/ifup -a，这个命令就是去解析下面要说的文件。   </span><br><span class="line">* 配置/etc/network/interfaces         </span><br><span class="line">这个配置主要有几个参数     </span><br><span class="line"></span><br><span class="line">| 参数 | 作用 |  </span><br><span class="line">| :--------: | :--------:|      </span><br><span class="line">| auto | 开机启用loopback网卡 |</span><br><span class="line">| iface lo inet loopback | 将lo接口设置为一个本地回环（loopback）地址 |</span><br><span class="line">|  |  建议：不同的接口之间配置部分必须留有一个空格  |</span><br><span class="line">| auto eth0 |  开机启用eth0网卡   |</span><br><span class="line">| iface eth0 inet static |  指出eth0接口使用静态（static）IP地址 |</span><br><span class="line">| address 192.168.6.100 | 所设置的eth0的静态IP地址 |</span><br><span class="line">| network 192.168.6.0 | 网段 |</span><br><span class="line">| netmask 255.255.255.0 | 子掩码 |</span><br><span class="line">| broadcast 192.168.0.255 | 广播地址 |</span><br><span class="line">| gateway 192.168.6.1 | 网关 | </span><br><span class="line"></span><br><span class="line">* 扩展 1    </span><br><span class="line">shell命令 ip a可以查看网络     </span><br><span class="line">route -n 可以查看网关     </span><br><span class="line">cat /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">* 扩展 2    </span><br><span class="line">  同样是去配置/etc/network/interfaces         </span><br><span class="line">              </span><br><span class="line">| 参数  |  作用  |         </span><br><span class="line">| :-----: | :-----: |            </span><br><span class="line">| auto lo | 开机启用loopback网卡 |                      </span><br><span class="line">| iface lo inet loopback | 将lo接口设置为一个本地回环（loopback）地址 |</span><br><span class="line">| |建议： 不同的接口之间配置部分必须留一个空格 |</span><br><span class="line">| auto eth0 | 开机启用eth0 网卡 |</span><br><span class="line">|  iface eth0 inet dhcp  |   指出eth0接口使用动态（dhcp）IP地址   |</span><br><span class="line"></span><br><span class="line">有的开发板没有这个文件，例如富瀚，但是可以配置udhcpc代替。</span><br><span class="line"></span><br><span class="line">* 扩展 3       </span><br><span class="line">  同样的。网卡可以设置两个ip地址。     </span><br><span class="line"> </span><br><span class="line"> | 参数  |  作用  |</span><br><span class="line"> | :-----:| :------: |</span><br><span class="line"> | 这里接着上面写     |</span><br><span class="line"> | auto eth0:1 | 注意 这里有冒号  这里可以与第一行合并为一行auto eth0 eth0:1 | </span><br><span class="line"> | iface eth0:1 inet static|    </span><br><span class="line"> |address xxx xxx|</span><br><span class="line"> | 其它类似 |</span><br><span class="line"></span><br><span class="line">* 扩展 4    </span><br><span class="line">     同样是去配置/etc/network/interfaces 还有一些高级的操作。可以去执行一些shell命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 选项 | 描述 |</span><br><span class="line">| :-----: | :------|</span><br><span class="line">| pre-up | 网卡启用前的动作 |</span><br><span class="line">| up | 网卡启用时候的动作 |</span><br><span class="line">| post-up | 网卡启用后的动作 |</span><br><span class="line">| pre-down | 网卡关闭前的动作 |</span><br><span class="line">| down | 网卡关闭时动作 |</span><br><span class="line">| post-down | 网卡关闭后动作 |</span><br><span class="line"></span><br><span class="line">例如:           </span><br><span class="line">1、设置dns     </span><br><span class="line">post-up echo &quot;nameserver 8.8.8.8&quot;&gt;&gt;/etc/resolv.conf        </span><br><span class="line"></span><br><span class="line">2、设置默认网关      </span><br><span class="line">post-up echo ip route add default via 192.168.6.1      </span><br><span class="line"></span><br><span class="line">3、网卡关闭后删除配置的默认网关      </span><br><span class="line">down route del default gw 192.168.6.1       </span><br><span class="line"></span><br><span class="line">或者另一种方式：</span><br></pre></td></tr></table></figure>auto eth0<br>iface eth0 inet manual<br>up ifconfig $IFACE 0.0.0.0 up<br>up &#x2F;demo&#x2F;ip.sh<br>down ifconfig $IFACE down</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/demo/ip.sh文件的内容    </span><br></pre></td></tr></table></figure><p>#!&#x2F;bin&#x2F;sh<br>ifconfig eth0 192.168.6.100 netmask 255.255.255.0 broadcast 192.168.0.25 gateway 192.168.1.1 route add default gw 192.168.6.1 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 2、RKMediak框架及其例程介绍     </span><br><span class="line">RKMedia是RK提供的一种多媒体处理方案，可以实现音视频捕获，音视频输出，音视频编解码等功能。   </span><br><span class="line">![](../../../img/6_AI-深度学习/AI视觉/RKMeidia的模块图.png)  </span><br><span class="line"></span><br><span class="line">如MPP主要用于视频的编解码。    </span><br><span class="line"> docs/Common/DISPLAY 中 Rockchip_Developer_Guide_HDMI_CN.pdf记录了hdmi相关信息。（很重要，对lc850开发，客户需要edid支持。相关点内容里面有）。</span><br><span class="line"></span><br><span class="line">## 1、sdk中RKMedia例程介绍   </span><br><span class="line">RKMedia在sdk中的源码目录： external/rkmedia/exdample ，里面存放了rk的例程。</span><br><span class="line"></span><br><span class="line">sdk一键编译后（./build.sh）后，自动编译了RKMedia了：     </span><br><span class="line">放置在buildroot/output/alientek_rv1126/build/rkmedia.     </span><br><span class="line">可执行文件就在这个目录下buildroot/output/alientek_rv1126/build/rkmedia/examales</span><br><span class="line">打包过的rkmedia文件存放在上面的...../oem/usr/bin中。</span><br><span class="line"></span><br><span class="line">1、在终端里输入&quot;rkmedia_&quot;,再按TAB键，可以显示命令。    </span><br><span class="line">2、终端里输入&quot;rkmedia_vi_vo_test --help&quot;可以查看命令的使用 。  （在例程中代码中有说明，可以到例程代码中查看）</span><br><span class="line">3、通过rkmedia代码查看命令的使用和例程功能。</span><br><span class="line">![](../../../img/6_AI-深度学习/AI视觉/rkmedia_vi_vo_test例程示例.png)  </span><br><span class="line"></span><br><span class="line">* 扩展 </span><br><span class="line">  认识iq文件。正点原子的开发板的iq文件在/etc/iqfiles目录下：</span><br></pre></td></tr></table></figure><p>imx355_…….xml<br>imx415_………xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">![](../../../img/6_AI-深度学习/AI视觉/iq文件作用.png)  </span><br><span class="line"></span><br><span class="line">raw数据不符合人眼效果，使用rkaiq去矫正，矫正需要iq文件。            </span><br><span class="line">iq： image quality 图像质量           </span><br><span class="line">isp： image signal processor 图像信号处理器      </span><br><span class="line">image signal process 图像信号处理器    </span><br><span class="line"></span><br><span class="line">`注意，在rv1126上所使用的imx415和；335摄像头，需要通过rkmedia摄像头来调用`</span><br><span class="line">`,因为两个设想头输出的是最原始的raw数据`    </span><br><span class="line">有一个岗位，iq tuning工程师，就是专门调整摄像头的。   </span><br><span class="line">xml参数配置文件就是iq工程师调试的。  </span><br><span class="line"></span><br><span class="line">测试例程需要注意的点 ：1、如果开启了正点原子的出场app占用了摄像头应用(isp</span><br><span class="line">占用)，请先关闭应用以后再测试其他摄像头应用，否则运行其他摄像头应用会报错。    </span><br><span class="line">![](../../../img/6_AI-深度学习/AI视觉/ips被正点原子占用.png)       </span><br><span class="line"></span><br><span class="line">2、不能在开启ispserver服务的时候又指定iqfiles，会报错。两者存在冲突。二者选一个，sensor为非HDR模式时，可开启ispserver，sensor为HDR模式时。需要指定iqfiles。           </span><br><span class="line">### 2-1-1、查看ispserver</span><br><span class="line"> 服务是否已经开启了：</span><br><span class="line"> ps -aux |grep ispserver     </span><br><span class="line"> 开启ispserver服务： </span><br><span class="line"> ispserveer --no-sync-db &amp; //表示不开启数据库服务dbserver   </span><br><span class="line"> 或者 /usr/bin/ispserver &amp; //可能会开启dbserver     </span><br><span class="line"></span><br><span class="line">注意 ： 如果开启了摄像头应用（mediaserver）,请先将其关闭后才可以使用RKmedia抓取图片。    </span><br><span class="line">开启和关闭mediaserver的脚本在开发板的/oem目录下：    </span><br><span class="line">```shell</span><br><span class="line">开启摄像头应用（mediaserver）</span><br><span class="line">/oem/RKLunch.sh &amp; //主要使用在ipc开发中的     </span><br><span class="line"></span><br><span class="line">关闭摄像头应用（mediaserver）</span><br><span class="line">/oem/RKLunch-stop.sh</span><br></pre></td></tr></table></figure><h3 id="2-1-2-、iq文件"><a href="#2-1-2-、iq文件" class="headerlink" title="2-1-2 、iq文件"></a>2-1-2 、iq文件</h3><p><code>在不使用ispserver时，那就指定iq文件，指定iq文件时，需要使用sample_common.h和sample_commom_isp.c来对ISP进行初始化。</code><br>参考rkmedia_vi_vo_test.c中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;#Rkaiq XML DirPath: %s\n&quot;</span>, iq_file_dir);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;#bMultictx: %d\n\n&quot;</span>, bMultictx);</span><br><span class="line"> <span class="type">rk_aiq_working_mode_t</span> hdr_mode = RK_AIQ_WORKING_MODE_NORMAL;</span><br><span class="line"> <span class="type">int</span> fps = <span class="number">30</span>;</span><br><span class="line"> SAMPLE_COMM_ISP_Init(s32CamId, hdr_mode, bMultictx, iq_file_dir);  <span class="comment">//初始化isp </span></span><br><span class="line"> SAMPLE_COMM_ISP_Run(s32CamId); <span class="comment">//运行isp</span></span><br><span class="line"> SAMPLE_COMM_ISP_SetFrameRate(s32CamId, fps);<span class="comment">//设置帧率</span></span><br></pre></td></tr></table></figure><p>ips相关文档放在内核doc中。Rockchip_Development_Guide_ISP2x_CN_v1.6.4。<br>这个例程rkmedia_vi_vo_test要测试的话，必须指定iq文件。<br>上面两种方法，都可以。</p><h1 id="3、编译rkmeida"><a href="#3、编译rkmeida" class="headerlink" title="3、编译rkmeida"></a>3、编译rkmeida</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//选择环境变量 RV1126_RV1109</span><br><span class="line">source envsetup.sh alientek_rv1126</span><br><span class="line"></span><br><span class="line">//清除刚刚编译的rkmedia</span><br><span class="line">make rkmeida-dirclean</span><br><span class="line"></span><br><span class="line">//重新编译rkmeida, 去buildroot里的out中找</span><br><span class="line">make rkmedia</span><br><span class="line"></span><br><span class="line">//打包到文件系统里面（oem.img）</span><br><span class="line">./build.sh rootfs</span><br><span class="line"></span><br><span class="line">//重新烧写oem.img,若有其他包有配置更新，则需要重新烧写rootfs.img</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在&#x2F;rv1126&#x2F;sdk&#x2F;buildroot&#x2F;output&#x2F;alientek_rv1126&#x2F;build&#x2F;rkmedia&#x2F;examples修改例程，然后make -j12就可以编译得到例程的可执行程序，这里的例程代码和external下的类似，猜测这里的代码是哪里拷贝过来的，目前我没有验证。<br>总体步骤总结：<br>在sdk源码buildroot&#x2F;output&#x2F;alientek_rv1126&#x2F;build&#x2F;rkmedia&#x2F;examples下操作：<br>1、修改对应的.c文件。例如rkmedia_vi_vo_test.c。<br>2、保存修改，退出编辑后，直接make。<br>3、注意环境变量，如果环境变量变了，应该回到sdk源码根目录下执行source envsetup.sh alientek_rv1126指定环境变量。<br>4、使用adb命令或者scp命令拷贝（开发板需要网络连接）到开发板下。</p><p>sdk配置文件下查看RKMedia的配置:buildroot&#x2F;configs&#x2F;alientek_rv1126_defconfig<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/%E7%BC%96%E8%AF%91rkmedia%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"><br>文件系统相关的配置。             </p><ul><li>查看和修改RKmedia的配置<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//选择环境变量 envsetup.sh alientek_rv1126</span><br><span class="line">source envsetup.sh alientek_rv1126</span><br><span class="line">//打开buildroot的menuconfig配置菜单界面</span><br><span class="line">make menuconfig</span><br><span class="line">//保存配置文件到buildroot/configs/alientek_rv1126_defconfig</span><br><span class="line">make savedefconfig</span><br><span class="line">//编译文件系统里面</span><br><span class="line">./build.sh rootfs</span><br></pre></td></tr></table></figure><code>在配置菜单中按下键盘的/按键可以进行搜索</code><br>编译文件系统的同时他会去编译Rkmedia。</li></ul><h1 id="4、mipi屏幕"><a href="#4、mipi屏幕" class="headerlink" title="4、mipi屏幕"></a>4、mipi屏幕</h1><p>在提供的文档中有屏幕的驱动参考和介绍。<br>命令行输入fbset可以查看屏幕的分辨率。<br>1、正点原子的这块屏幕不需要校准。<br>2、触摸输入测试。<br>3、也可以通过RKmedia例程，摄像头捕获屏幕显示 rkmedia_vi_vo_test -a &#x2F;etc&#x2F;iqfiles&#x2F;  -h 1280 -w 720</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取input event事件的值</span></span><br><span class="line">evtest <span class="comment">//然后选择1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>紧接上面第三条：4、测试也可以通过modetest命令进行测试。<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/RKMeidia%E7%9A%84%E6%A8%A1%E5%9D%97%E5%9B%BE.png"><br>在图中的drm模块，是linux下的一个图形显示框架，也是现在主流的图形显示框架，rkmeida就是通过drm去工作的。<br>在开发板上有libdrm的库。使用find &#x2F; -name <em>libdrm</em>可以搜过到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VO_CHN_ATTR_S stVoAttr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// VO[0] for primary plane</span></span><br><span class="line">stVoAttr.pcDevNode = <span class="string">&quot;/dev/dri/card0&quot;</span>;</span><br><span class="line">stVoAttr.emPlaneType = VO_PLANE_PRIMARY;</span><br><span class="line">stVoAttr.enImgType = IMAGE_TYPE_RGB888;</span><br></pre></td></tr></table></figure><p>上面就显示了用到drm的card0设备，例子rkmedia_vi_vo_test。</p><p>而回到modetest这个命令</p><table><thead><tr><th align="center">查询选项参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-p</td><td align="center">列出CRTCs和planes，CRTCs表示VOT（Vide Output Processor）,planes表示图层</td></tr><tr><td align="center">-e</td><td align="center">查询输出转换器，Encoder表示输出转换器，如RGB、LVDS、DSI等接口（显示接口，类似hdmi等）</td></tr><tr><td align="center">-f</td><td align="center">列出framebuffers</td></tr><tr><td align="center">-c</td><td align="center">查询Connerctor（连接设备）</td></tr><tr><td align="center">就是表示输出转换器和显示面板交互的部分</td><td align="center"></td></tr><tr><td align="center">CRTCs一个屏幕只有一个。</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">通用参数选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">使能原子操作</td></tr><tr><td align="center">-d</td><td align="center">模式设置后放置主控器</td></tr><tr><td align="center">-f</td><td align="center">列出framebuffers</td></tr><tr><td align="center">-c</td><td align="center">查询Connerctor(连接装备)</td></tr><tr><td align="center">-M</td><td align="center">设置驱动，比如rk的就是rockchip</td></tr><tr><td align="center">-D</td><td align="center">指定对应的ID号</td></tr></tbody></table><table><thead><tr><th align="center">测试参数选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-P</td><td align="center">解析plane参数</td></tr><tr><td align="center">-S</td><td align="center">解析connector参数</td></tr><tr><td align="center">-C</td><td align="center">测试光标</td></tr><tr><td align="center">-V</td><td align="center">测试同步翻页（垂直同步vsync）</td></tr><tr><td align="center">-W</td><td align="center">解析property</td></tr></tbody></table><p>*测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modetest --help //查看帮助</span><br><span class="line">modetest -M rockchip 或者 modetest //查看当前系统DRM情况</span><br><span class="line">modetest -M rockchip|cut -f1|grep -E ^[0-9A-Z] //查看各个模块的id</span><br><span class="line">modetest -M rockchip -s 56@53:720x1280@RG24 //屏幕显示测试</span><br><span class="line">modetest -M rockchip -D 0 -a -s 56@53:720X1280 -P 52@53:720x1280</span><br></pre></td></tr></table></figure><ul><li><code>扩展：shell命令对于参数，&lt;&gt;表示必填像，[]表示可填，使用--help查看</code></li></ul><h1 id="5、摄像头"><a href="#5、摄像头" class="headerlink" title="5、摄像头"></a>5、摄像头</h1><p> 摄像头详细参数看文档<br> 在rkmedia的rkmedia_vi_vo_test.c中存在一个RGA示范用例<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RngInfo.u8Enable = 1;</span><br><span class="line">RK_MPI_VI_RGN_SetCover(s32CamId, 1, &amp;RngInfo, &amp;CoverInfo);</span><br><span class="line"></span><br><span class="line">// rga0 for primary plane</span><br><span class="line">RGA_ATTR_S stRgaAttr;</span><br><span class="line">memset(&amp;stRgaAttr, 0, sizeof(stRgaAttr));</span><br><span class="line">stRgaAttr.bEnBufPool = RK_TRUE;</span><br><span class="line">stRgaAttr.u16BufPoolCnt = 3;</span><br><span class="line">stRgaAttr.u16Rotaion = 90;</span><br><span class="line">stRgaAttr.stImgIn.u32X = 0;</span><br><span class="line">stRgaAttr.stImgIn.u32Y = 0;</span><br><span class="line">stRgaAttr.stImgIn.imgType = IMAGE_TYPE_NV12;</span><br><span class="line">stRgaAttr.stImgIn.u32Width = video_width;</span><br><span class="line">stRgaAttr.stImgIn.u32Height = video_height;</span><br><span class="line">stRgaAttr.stImgIn.u32HorStride = video_width;</span><br><span class="line">stRgaAttr.stImgIn.u32VirStride = video_height;</span><br><span class="line">stRgaAttr.stImgOut.u32X = 0;</span><br><span class="line">stRgaAttr.stImgOut.u32Y = 0;</span><br></pre></td></tr></table></figure><br> 这里的90是利用了RGA功能图形硬件加速做的旋转。<br> 板子有两个摄像头插槽。</p><h1 id="6、AI模型运行流程"><a href="#6、AI模型运行流程" class="headerlink" title="6、AI模型运行流程"></a>6、AI模型运行流程</h1><p> <img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/AI%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B.png"><br> 假设 ：AI网络模型在pc端运行，运行的模型效果比较理想，也就是<code>测试集</code>的<code>损失值比较低</code>，正确率比较高。说明模型的泛化能力比较好。这个时候就需要转化操作。<br> 就是将pc端的网络模型转化为RKNN模型。应为rk的npu不能运行其他框架的模型，只能运行rknn模型。通过RKNN toolkit将模型转化，然后使用这个工具<br> 进行仿真（主要看内存，cpu情况），然后部署到板子上，<br>  <img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/AI%E4%BE%8B%E7%A8%8B%E6%8F%8F%E8%BF%B0.png"> </p><h2 id="6-1、rv1126芯片介绍"><a href="#6-1、rv1126芯片介绍" class="headerlink" title="6-1、rv1126芯片介绍"></a>6-1、rv1126芯片介绍</h2><p>内嵌了硬件视频编码器，由risc-v mcufastboot快速启动。<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/1126%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%9B%BE.png"><br>软件解码和硬件解码区别。软件解码靠cpu，简称软解。同样的，软件编码也是采用cpu处理。而硬件编解码。就是采用硬件或者模块解码。类似gpu。<br>芯片有通用型和专用型之分，imx6u就是通用控制，在汽车电子行业用的比较多，1126在音视频AI中用的多。<br>1126支持很多深度学习框架。</p><ul><li>AI例程主要包括三个来源，1、基于RockX进行开发，但是无法获知源码，无法进行更改，2、rockface，要钱不开源。3、采用预训练模型。采用自训练模型。<br>一个模型相关的参数，输入输出，均值，标准差，欧式距离，余弦距离，阈值。<br>rockx发布的<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/rockx%E4%BE%8B%E7%A8%8B.png"></li></ul><p>下面是预训练模型发布的<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/rockx%E4%BE%8B%E7%A8%8B1.png"></p><p>下面是开源的AI模型<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/rockx%E4%BE%8B%E7%A8%8B1.png"></p><h2 id="6-2、-学习AI必备"><a href="#6-2、-学习AI必备" class="headerlink" title="6-2、 学习AI必备"></a>6-2、 学习AI必备</h2><p>1、入门python<br>2、学习一种传统图像处理&#x2F;开源计算机视觉库<br>opencv 、matlab、dlib（人脸识别算法库）<br>3、具有一些高等数学基础<br>导数、偏导数、梯度、微积分、卷积、高斯滤波、概率统计、正态分布、均匀分布、熵、激活函数、方差、回归分析、聚类算法、贝叶斯算法、线性代数等<br>4、选择一种深度学习框架<br>tensorflow tensorflow lite 、pytorch、 caffe等<br>5、UI界面开发学习<br>qt<br>6、其他学习<br>数据库<br>sqlite3  mysql</p><p>基于平台进行开发，rk平台的文件系统时buildroot文件系统。在其他模型通过RKNN Toolkit进行转换后，使用RkNN C API进行调用。 </p><ul><li>交叉编译器我放到了&#x2F;home&#x2F;ygc&#x2F;Desktop&#x2F;linux-gcc下</li></ul><p> 节点1.5第6.37秒</p>]]></content>
      
      
      <categories>
          
          <category> AI-深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI人工智能深度学习-正式篇</title>
      <link href="/posts/1ee5af06.html"/>
      <url>/posts/1ee5af06.html</url>
      
        <content type="html"><![CDATA[<p><code>对与3568没有rkmedia但是有rockit</code></p><h1 id="1、RK宏定义"><a href="#1、RK宏定义" class="headerlink" title="1、RK宏定义"></a>1、RK宏定义</h1><p>ips模块，有一些芯片内部是有isp模块，有的没有，例如imx6u，一种是编写软件转换，还有也可以找isp芯片。有的摄像头带有isp模块，如ov5640，有的不带im415，不带的无法直接出图。要使用isp，就需要加载rkaiq模块，aiq模块在cmake中定义。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(USE_RKAIQ)</span><br><span class="line">    <span class="keyword">find_package</span>(RkAiq REQUIRED)</span><br><span class="line">    <span class="keyword">include_directories</span>(<span class="variable">$&#123;RKAIQ_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">    <span class="keyword">add_definitions</span>(-DRKAIQ)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><p>bayer raw 数据，raw数据，同一个意思，因为摄像头拍摄用到了拜耳阵列。拜耳格式有四种BGGR、RGGB、GBRG、GRBG四种。<br>码流：简称视频流<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E8%A7%86%E8%A7%89/RKMeidia%E7%9A%84%E6%A8%A1%E5%9D%97%E5%9B%BE.png"><br>isp和ispp就是rkisp2.0模块<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%AD%A3%E5%BC%8F%E7%AF%87/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%B1%82%E7%9A%84%E5%A4%84%E7%90%86.png"><br>摄像头拍摄到数据，利用iq文件进行初步调整，得到流到&#x2F;dev&#x2F;videoX。<br>RKMedia的rga模块和linux-rga模块一样，是RKMedia去封装linux-rga得到的rga模块。<br>RKMedia是数据流的精确加工。<br>对于视频编码处理的模块。RK的叫做RKMpp，海思芯片的叫做HiMpp。<br>通用邻域，后面需要学习FFMPEG,gstreamer</p><h1 id="2、Stride的概念"><a href="#2、Stride的概念" class="headerlink" title="2、Stride的概念"></a>2、Stride的概念</h1><p>图像的stride（跨度、跨距、步长、步幅），表示在内存中每行像素所占的字节数<br>注意：stride能被16整除！<br>stride一定会大于或者等于图像的宽度。<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%AD%A3%E5%BC%8F%E7%AF%87/stride.png"><br>上图的n代表位宽，可以是8、16、32，列入rgb24的像素位宽就是24位。<br>对齐：硬件为了快速访问内存，跨行地址，所以要进行对齐。stride能被16整除，这里的整除16，就是对齐系数<br>例如1280跨度，stride就为1280，可以被16整除，只需一行一行读取，而如果是1080，则无法被16整除，1072可以被16整除，所以情况就是，先读取1072个长度，然后读取后8个和下一行的1064个，类似下去就会导致花屏。而如果stride大于了图像宽度，就可以避免这个问题，虽然会浪费一定的内存<br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%AD%A3%E5%BC%8F%E7%AF%87/stride1.png"><br><img src="../../../img/6_AI-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/AI%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%AD%A3%E5%BC%8F%E7%AF%87/stride2.png">  </p><ul><li>举例<br>在RKMedia下，设置采集的图像的宽度能被16整除。且stride &#x3D; 图像的宽度即可<br>即：<br>图像buff宽度 &#x3D; stride 宽度<br>stride 宽度 &#x2F;16 &#x3D; 整数NQQ</li></ul><p>视频配套文档还没有下载</p>]]></content>
      
      
      <categories>
          
          <category> AI-深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LC850项目</title>
      <link href="/posts/21fffa81.html"/>
      <url>/posts/21fffa81.html</url>
      
        <content type="html"><![CDATA[<ul><li>资料</li></ul><p>提交配置环境： dev container   ：.devcontainer&#x2F;devcontainer.json<br>提交clone 代码<br>提交脚本位置：0_Misc&#x2F;mybuild.sh<br>提交完整编译：.&#x2F;0_Misc&#x2F;mybuild.sh<br>提交清除所有编译：rm -rf buildroot&#x2F;output&#x2F;<br>提交编译出来的固件在 IMAGE&#x2F;<br>提交模块化编译<br>提交方法1  此方法只支持  app&#x2F;  extern&#x2F; 目录<br>提交.&#x2F;build.sh external&#x2F;deviceio_release&#x2F;  先编译模块<br>提交.&#x2F;0_Misc&#x2F;mybuild.sh 再打包<br>提交方法2  buildroot&#x2F;package&#x2F;app2-mqtt-uart&#x2F;src&#x2F;app2-mqtt-uart.c<br>提交cd buildroot&#x2F;output&#x2F;rockchip_rk3568_uvc&#x2F;<br>提交make app2-mqtt-uart-rebuild<br>提交.&#x2F;0_Misc&#x2F;mybuild.sh 再打包 ，全部烧录<br>提交或者  adb push 单独模块到系统 &#x2F;usr&#x2F;bin&#x2F;install -m 755 -D &#x2F;workspaces&#x2F;c_rk3568_linux&#x2F;buildroot&#x2F;output&#x2F;rockchip_rk3568_uvc&#x2F;build&#x2F;app2-mqtt-uart&#x2F;app2-mqtt-uart &#x2F;workspaces&#x2F;c_rk3568_linux&#x2F;buildroot&#x2F;output&#x2F;         rockchip_rk3568_uvc&#x2F;target&#x2F;usr&#x2F;bin&#x2F;app2-mqtt-uart<br>提交.&#x2F;adb.exe push  c:\xxxusr\app2-mqtt-uart&#x2F;usr&#x2F;bin&#x2F;    app2-mqtt-uart       </p><p>方法3<br>.&#x2F;build.sh external&#x2F;deviceio_release&#x2F;  先编译模块<br>替换对应的模块文件<br> 提交AF  MCU 获取 马达位置<br>提交代码同步 ，git pull<br>提交代码提交， git add xxxfile ; git commit -m “fix xxx bug”; git push<br>提交相关代码路径<br>提交遥控器相关代码：external&#x2F;deviceio_release&#x2F;test&#x2F;app1&#x2F;app1_ble.c  ： app1_ble_send_data， app1_ble_recv_data_callback<br>提交板载按键代码：buildroot&#x2F;package&#x2F;input-event-daemon&#x2F;src-v0.1.3&#x2F;input-event-daemon.c  publish_key<br>提交发送 指令到 AF MCU （刘工）buildroot&#x2F;package&#x2F;app2-mqtt-uart&#x2F;src&#x2F;app2-mqtt-uart.c  on_message -&gt; write 到 串口 “&#x2F;dev&#x2F;ttyS3”<br>提交遥控器调节各种效果，external&#x2F;isp2-ipc&#x2F;server&#x2F;app3&#x2F;app3_cam_para_modify.c  app_do_cmd<br>提交保存参数 external&#x2F;isp2-ipc&#x2F;server&#x2F;app3&#x2F;app3_cfg.c<br>提交更新王工的效果IQ文件：external&#x2F;camera_engine_rkaiq&#x2F;iqfiles&#x2F;isp21&#x2F;os08a20_RS-8MTP659-V1_default.json<br>提交 find | grep os08a10_RS-8MTP659-V1_default.json<br>提交.\adb.exe push ‘C:\Users\18825\Desktop\08A20-IQ-Change-Test.json’   &#x2F;etc&#x2F;iqfiles&#x2F;os08a10_RS-8MTP659-V1_default.json<br>提交开机图片：<br>提交kernel&#x2F;logo_kernel.bmp<br>提交kernel&#x2F;logo.bmp<br>何鹏 2023年6月离职<br>微信：18319047020<br>QQ：3586705670<br>2023年6月欧俊庭接手负责LC850项目。目前联系不上。由于欧工是新手，项目<br>主要还是何鹏完成。<br>他们项目进展，完成蓝牙遥控按键控制，其他基本属于无进展。<br>2023年12月欧工离职，项目由我接手。问题表：<br>LC850问题点：<br>1，多次重启设备偶现不启动，或启动后图像偏暗（1、2同样问题）<br>2，UVCDMI同时接入，关闭UVC端视频，HDMI图像卡住（uvc断开，芯片掉电导<br>致原始视频数据流中断，我有想法需要验证可行性）<br>3，曝光模式手动模式图像暗（sdk问题）<br>5，恢复默认值图像颜色不对（我已经解决）<br>6，锐度只有2档有效（sdk问题）<br>4，遥控器反转无效(sdk)<br>7，苹果端UVC图像比较暗，（应该是判断曝光模式错误，切换手动再切回自<br>动，图像正常）<br>8，YY开播软件测试，摄像头默认采集模式MJPEG,分辨率1920*1080，帧率30<br>帧，图像卡顿，重新设置一次MJPEG后图像流畅<br>9，多次开启&#x2F;关闭YY开播软件，图像丢失<br>10，使用遥控器开关机键和设备按键开关机键状态不同，设备触发关机键设备<br>关机，遥控器触发关机键设备待机（我已经解决）<br>11，231106版本软件设备开关机键开不了机（我已经解决）<br>12，图像效果需要重新调整（我已经解决）       </p><hr><p>Buildroot MQTT mosquitto - 多模块通信，板载按键，蓝牙遥控器，ISP,<br>HDMI<br>查看服务器的状态：<br>mosquitto_sub -v -t ‘$SYS&#x2F;#’ -h localhost -p 1883<br>详细详细调试信息-d，每输入一次回车则publish一次-l:<br>mosquitto_pub -d -t afmcu&#x2F;write&#x2F;uvc -l<br>订阅并显示详细消息：<br>mosquitto_sub -d  -t afmcu&#x2F;write&#x2F;#<br>电脑打开UVC时 每帧发送sharpness值用于调AF，曝光增益用于调自动光圈<br>sp&#x2F;sharpness<br>isp&#x2F;exp_gain<br>打开HDMI时每帧发送触发，(目前通过文件触发)<br>hdmi&#x2F;frame_trigger<br>物理按键发送AF等调节指令：<br>input-event-daemon 中只负责报哪个按键按下或抬起<br>topic: board_key&#x2F;up,board_key&#x2F;down, board_key&#x2F;left, board_key&#x2F;right,    board_key&#x2F;center<br>value:0,1</p><table><thead><tr><th align="center">物理按键 topic</th><th align="center">值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">board_key&#x2F;OnOff</td><td align="center">1，0</td><td align="center">按下（1）抬起（0）</td></tr><tr><td align="center">board_key&#x2F;zoom</td><td align="center">+1，-1</td><td align="center">聚焦+（+1），聚焦-（-1）</td></tr><tr><td align="center">board_key&#x2F;focus</td><td align="center">+1，-1</td><td align="center">聚焦+（+1），聚焦-（-1）</td></tr><tr><td align="center">board_key&#x2F;center_key</td><td align="center">1，0</td><td align="center">按下（1）抬起(0)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> AI-深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常见的总线和通讯方式</title>
      <link href="/posts/9efdaa58.html"/>
      <url>/posts/9efdaa58.html</url>
      
        <content type="html"><![CDATA[<h1 id="I2C-总线"><a href="#I2C-总线" class="headerlink" title="I2C 总线"></a>I2C 总线</h1><p>I2C（Inter-Integrated Circuit，集成电路间通讯）是一种用于在多个集成电路之间进行数据交换的协议，它使用 two-wire（两线）通信协议，通常由两个 GPIO（通用输入输出）引脚组成，通常为 SDA（数据线）和 SCL（时钟线）。I2C 总线具有以下特点：</p><ul><li>半双工通信：在同一时间内，数据线（SDA）只能由一个设备控制。<br>以下是一次典型的 I2C 数据传输流程（包含 8 位数据帧）：</li><li>起始条件：主设备发起起始信号，表示数据传输开始。</li><li>从机地址：主设备发送 7 位的从机地址和 1 位的读写位（0 表示写，1 表示读）。</li><li>应答信号：从设备接收到地址后，会发送一个应答位（ACK）表示已正确接收。</li><li>数据传输：主设备或从设备开始传输 8 位的数据。</li><li>应答信号：每传输完 8 位数据，接收方会发送一个应答位。</li><li>停止条件：主设备发起停止信号，表示数据传输结束。</li></ul><p><img src="./../../../../img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%BB%E7%BA%BF%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F/I2C/1%E3%80%81%E8%AF%BB%E5%86%99%E5%AD%98%E5%82%A8%E5%99%A8%E4%BE%8B%E5%AD%90.png"><br>如果通讯过程中如果从机反应比较慢，这时候从机是可以把时钟线拉低来让主机等待的，很多拿GPIO模拟的I2C都没实现。还有就是I2C总线是允许多主机的，多主机如何避免冲突等等。实际使用中，像STM32出现I2C控制器异常，直接将外设复位可能都无法恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;reg51.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 I2C 总线的 SDA 和 SCL 引脚</span></span><br><span class="line">sbit SDA = P2^<span class="number">0</span>;</span><br><span class="line">sbit SCL = P2^<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延时函数，用于产生适当的时钟周期</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> us)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C 起始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">()</span> &#123;</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// I2C 停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">()</span> &#123;</span><br><span class="line">    SDA = <span class="number">0</span>;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SDA = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送应答信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendACK</span><span class="params">(bit ack)</span> &#123;</span><br><span class="line">    SDA = ack;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收应答信号</span></span><br><span class="line">bit <span class="title function_">I2C_RecvACK</span><span class="params">()</span> &#123;</span><br><span class="line">    bit ack;</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    ack = SDA;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送一个字节的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        SDA = (dat &amp; <span class="number">0x80</span>) &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        delay_us(<span class="number">5</span>);</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收一个字节的数据</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">I2C_RecvByte</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i, dat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        dat |= SDA;</span><br><span class="line">        delay_us(<span class="number">5</span>);</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数示例，向从设备发送一个字节数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sendData = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 I2C 通信</span></span><br><span class="line">    I2C_Start();</span><br><span class="line">    <span class="comment">// 发送从设备地址（假设为 0xA0，写操作）</span></span><br><span class="line">    I2C_SendByte(<span class="number">0xA0</span>);</span><br><span class="line">    <span class="comment">// 检查应答信号</span></span><br><span class="line">    <span class="keyword">if</span>(I2C_RecvACK() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        I2C_SendByte(sendData);</span><br><span class="line">        <span class="comment">// 检查应答信号</span></span><br><span class="line">        <span class="keyword">if</span>(I2C_RecvACK() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 发送停止信号</span></span><br><span class="line">            I2C_Stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ul><li>引脚定义：SDA 和 SCL 分别定义为 P2.0 和 P2.1 引脚，你可以根据实际情况修改。</li><li>延时函数：delay_us 函数用于产生适当的时钟周期，确保 I2C 通信的时序要求。</li><li>起始信号：I2C_Start 函数通过将 SDA 和 SCL 置高，然后将 SDA 拉低来产生起始信号。</li><li>停止信号：I2C_Stop 函数通过将 SDA 拉低，SCL 置高，然后将 SDA 拉高来产生停止信号。</li><li>应答信号：I2C_SendACK 函数用于发送应答信号，I2C_RecvACK 函数用于接收应答信号。</li><li>数据发送和接收：I2C_SendByte 函数用于发送一个字节的数据，I2C_RecvByte 函数用于接收一个字节的数据。</li><li>主函数：在 main 函数中，演示了如何向从设备发送一个字节的数据，包括起始信号、发送从设备地址、发送数据和停止信号。</li></ul><h2 id="1-2、硬件I2C"><a href="#1-2、硬件I2C" class="headerlink" title="1-2、硬件I2C"></a>1-2、硬件I2C</h2><ul><li>在使用硬件 I2C（Inter - Integrated Circuit）接口时，通常需要配置以下几类重要参数：<br>通信速率<br>I2C 总线支持多种通信速率模式，不同的应用场景可能需要不同的速率，常见的配置选项有：</li><li>标准模式（Standard Mode）：速率为 100 kbps，这是最常用的速率，适用于大多数对通信速度要求不高的场合，比如连接一些传感器、EEPROM 等设备。</li><li>快速模式（Fast Mode）：速率可达 400 kbps，能提供相对较快的数据传输速度，在一些对数据更新频率有一定要求的系统中使用，例如某些高速 ADC 芯片的通信。</li><li>快速模式 +（Fast Mode Plus）：速率最高可到 1 Mbps，进一步提升了数据传输效率，适用于对数据实时性要求较高的场景。</li><li>高速模式（High - Speed Mode）：速率能达到 3.4 Mbps，用于对通信速度有极高要求的特殊应用。</li></ul><p><strong>从机地址</strong><br>在 I2C 总线上，每个从设备都有一个唯一的 7 位或 10 位地址，主设备通过该地址来选择与之通信的从设备。配置时需要明确以下内容：</p><ul><li>地址位数：确定使用 7 位地址还是 10 位地址模式。大多数 I2C 设备采用 7 位地址，而 10 位地址模式主要用于需要更多从设备地址的复杂系统。<br>具体地址值：根据从设备的数据手册，获取其实际的地址值，并在硬件 I2C 配置中进行设置。<br>时钟极性（CPOL）和时钟相位（CPHA）<br>这两个参数用于定义 I2C 总线时钟信号的特性，它们共同决定了数据采样和变化的时刻：</li><li>时钟极性（CPOL）：指定时钟信号的空闲状态电平。当 CPOL &#x3D; 0 时，时钟信号空闲时为低电平；当 CPOL &#x3D; 1 时，时钟信号空闲时为高电平。</li><li>时钟相位（CPHA）：决定数据采样和变化的时刻。当 CPHA &#x3D; 0 时，数据在时钟信号的第一个边沿（上升沿或下降沿，取决于 CPOL）采样；当 CPHA &#x3D; 1 时，数据在时钟信号的第二个边沿采样。</li></ul><p><strong>应答机制</strong><br>I2C 通信中，接收方在接收到每个字节后需要发送一个应答信号（ACK）或非应答信号（NACK）来表示是否成功接收数据，需要配置以下方面：</p><ul><li>应答使能：开启或关闭应答功能，一般情况下需要使能该功能以确保通信的可靠性。</li><li>应答判断：在主设备接收数据时，需要判断从设备返回的应答信号是 ACK 还是 NACK，以决定后续的操作。</li></ul><p><strong>中断配置</strong><br>为了提高系统的实时性和效率，可以配置硬件 I2C 的中断功能：</p><ul><li>中断使能：开启相应的中断源，如数据传输完成中断、应答错误中断等。</li><li>中断优先级：设置不同中断的优先级，确保重要的中断能够及时得到处理。</li></ul><p><strong>数据缓冲区</strong><br>硬件 I2C 通常配备有数据缓冲区，用于临时存储发送和接收的数据，需要进行如下配置：</p><ul><li>缓冲区大小：根据实际应用需求，选择合适的缓冲区大小，以满足数据传输的要求。</li><li>缓冲区操作：配置数据的写入和读取方式，例如是采用 DMA（直接内存访问）方式还是 CPU 直接操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝牙</title>
      <link href="/posts/5d669232.html"/>
      <url>/posts/5d669232.html</url>
      
        <content type="html"><![CDATA[<h1 id="角色认识"><a href="#角色认识" class="headerlink" title="角色认识"></a>角色认识</h1><p>master 和slave属于建立连接之后的概念，一旦建立连接，scanner角色变为master，advertiser变为slave。 根据应用场景的需求,一个设备可以是master，也可以是slave或者二者兼备。 初始化建立连接的设备称为master，负责广播的并接收连接请求的设备称为slave。</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mqtt</title>
      <link href="/posts/a100fb72.html"/>
      <url>/posts/a100fb72.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、mqtt由来"><a href="#1、mqtt由来" class="headerlink" title="1、mqtt由来"></a>1、mqtt由来</h1><p>解决问题：<br>1、服务器必须实现的千万客户端的接入。<br>2、单次数据量比较小，但不能出错。<br>3、必须能够是适应高延迟，断网等不可靠风险。<br>4、根据数据的重要程度和特性，设置不同等级的服务质量。(QoS0、QoS1、QoS2三种)<br>5、可以保持长连接。<br>6、低功耗场合不适合。<br>7、建立在tcp上，非常可靠。    </p><h2 id="1-1、关于第四条做说明"><a href="#1-1、关于第四条做说明" class="headerlink" title="1-1、关于第四条做说明"></a>1-1、关于第四条做说明</h2>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="/posts/50daec4.html"/>
      <url>/posts/50daec4.html</url>
      
        <content type="html"><![CDATA[<p><code>下面出现代码均为c语言</code></p><h1 id="1、计算机网络发展"><a href="#1、计算机网络发展" class="headerlink" title="1、计算机网络发展"></a>1、计算机网络发展</h1><ul><li>最早的计算机网络是ARPA，但是最早的ARPA无法连接不同类型的计算机和不同的操作系统。</li></ul><h2 id="1-1、数据交换"><a href="#1-1、数据交换" class="headerlink" title="1-1、数据交换"></a>1-1、数据交换</h2><ul><li>通过标有地址的分组进行路由选择传输数据，使得通信通道仅在传送期间被占用的一种交换方式。</li></ul><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ARPA.png"></p><h2 id="1-2、交换方式"><a href="#1-2、交换方式" class="headerlink" title="1-2、交换方式"></a>1-2、交换方式</h2><p>•交换的方式为存储转发，节点收到分组，先暂时存储下来，再检查它的头部，然后按照首部中的地址，找到合适的节点转发出去。</p><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F.png"></p><h3 id="1-2-3、特点"><a href="#1-2-3、特点" class="headerlink" title="1-2-3、特点"></a>1-2-3、特点</h3><p>1、以分组作为传输单位。</p><p>2、独立选择转发路由。</p><p>3、逐段占用，动态分配传输带宽。</p><h2 id="1-3、发展过程"><a href="#1-3、发展过程" class="headerlink" title="1-3、发展过程"></a>1-3、发展过程</h2><p>•从单个ARPA发展为tcp&#x2F;ip的ARPAnei的标注协议。</p><h1 id="2、英特网的结构"><a href="#2、英特网的结构" class="headerlink" title="2、英特网的结构"></a>2、英特网的结构</h1><h2 id="2-1、三级结构英特网"><a href="#2-1、三级结构英特网" class="headerlink" title="2-1、三级结构英特网"></a>2-1、三级结构英特网</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%93%E6%9E%84.png"></p><p>•每个国家都有一个主干网，然后层级下发。</p><h2 id="2-2、多级英特网"><a href="#2-2、多级英特网" class="headerlink" title="2-2、多级英特网"></a>2-2、多级英特网</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%A7%E5%9B%A0%E7%89%B9%E7%BD%91%E7%BB%93%E6%9E%84.png"></p><h1 id="3、TCP-IP协议族"><a href="#3、TCP-IP协议族" class="headerlink" title="3、TCP&#x2F;IP协议族"></a>3、TCP&#x2F;IP协议族</h1><h2 id="3-1、分层结构"><a href="#3-1、分层结构" class="headerlink" title="3-1、分层结构"></a>3-1、分层结构</h2><p>•由来：主要是为了解决不同计算机之间和不同操作系统直接的差异，就进行分层，只需要保证某些层次是一样的，<br>就可以进行通讯。<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>•最早的分层体系是osi开放系统互联模型，是由国际化标准组织（iso）指定，由于osi过于<br>复杂，所以到现在也没有使用，而是使用的是TCP&#x2F;IP协议族。</p><p>•应用层：应用程序沟通的 例如：FTP、HTTP、Telnet等。</p><p>•FTP：文件传输协议，如app的上传和下载功能。</p><p>•HTTP：超文本协议，通过浏览器访问其他网站，必须通过http协议。</p><p>•传输层：提供程序间数据的传输逻辑通讯，例如TCP、UDP。</p><p>•网络层：提供基本的数据包传送功能，最大可能的能让每个数据报都能到达主机，例如IP、ICMP等。</p><p>•IP：用来找到目的主机。</p><p>•链路层：负责数据帧的发送和接收。一个数据称为一帧数据。</p><p>•每层完成自己的任务，最终完成不同层次的处理完成数据的收发。<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p>•上图的ARP协议是通过对方的ip地址找对方MAC地址，<br>而RARP则是通过MAC地址找ip地址。</p><p>•数据是从应用层到传输层，一直到链路层，<br>整体把数据交给链路层之后，将数据传给对方，<br>然后最后层层解封。</p><h2 id="3-2、-IP协议"><a href="#3-2、-IP协议" class="headerlink" title="3-2、 IP协议"></a>3-2、 IP协议</h2><p>•特指为实现一个相互连接的网络系统上从源地址到<br>目的地传输数据包所提供的必要协议。<br>也称为网际协议。</p><p>•特点：不可靠：它不能保证IP数据包能成功地到达它的目的地，<br>仅提供尽力而为的传输服务。</p><p>•无连接：IP并不维护任何关于后续数据包的状态信息。<br>每个数据包的处理是相互独立的。<br>IP数据包可以不按发送顺序接收<br>IP数据包中含有发送它主机的IP地址（源地址）和接收它主机的IP地址（目的地址）。</p><h2 id="3-3、tcp协议简介"><a href="#3-3、tcp协议简介" class="headerlink" title="3-3、tcp协议简介"></a>3-3、tcp协议简介</h2><p>•tcp协议是面向连接的，可靠的传输层通讯协议。</p><p>•功能：提供不同主机上的进程间通讯。</p><p>•特点：<br>1、建立链接-&gt;使用链接-&gt;释放链接（虚电路）。</p><p>2、tcp数据包中包含序号和确认序号。</p><p>3、对包经行排序并检错，而损坏的包可以被重传。</p><p>•服务对象<br>需要高度可靠并面向连接的服务。<br>如：http、ftp、smtp等。<br>smtp为简单邮件传输协议。</p><h2 id="3-4、udp协议简介"><a href="#3-4、udp协议简介" class="headerlink" title="3-4、udp协议简介"></a>3-4、udp协议简介</h2><p>•udp是一种面向无连接的传输层通讯协议。也称用户数据报协议。</p><p>•功能：<br>提供不同主机上的进程间通讯。</p><p>•特点：<br>1、发送数据前不需要建立链接。  </p><p>2、不对数据包的顺序进行检查。</p><p>3、没有错误检测和重传机制。</p><p>•服务对象：<br>主要用于查询应答服务。<br>如：nfs、ntp、dns等</p><h2 id="3-5、mac地址"><a href="#3-5、mac地址" class="headerlink" title="3-5、mac地址"></a>3-5、mac地址</h2><p>•mac地址类似于身份证号。出场的时候标出，理论上全球唯一。</p><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/mac%E5%9C%B0%E5%9D%80%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>•组成：以太网内的MAC地址是一个48bit的值。mac地址是可以修改的，但是一般情况下不建议修改mac地址。</p><p>•总共分成6组，通过 : 隔开，前三组称为厂商ID，后三组称为设备ID。</p><p>•如果是我们自己识别的话是分组识别，如果是输入给计算机的话就是48位的值。</p><h2 id="3-6、ip地址"><a href="#3-6、ip地址" class="headerlink" title="3-6、ip地址"></a>3-6、ip地址</h2><p>•ip地址是一种internet上的主机编址，也称为网际协议地址。</p><p>•ip地址在网络中具有唯一标识。</p><h3 id="3-6-1、IP地址的分类"><a href="#3-6-1、IP地址的分类" class="headerlink" title="3-6-1、IP地址的分类"></a>3-6-1、IP地址的分类</h3><p>•ipv4，占32位</p><p>•ipv6，占128位</p><h4 id="3-6-1-1、ipv4组成"><a href="#3-6-1-1、ipv4组成" class="headerlink" title="3-6-1-1、ipv4组成"></a>3-6-1-1、ipv4组成</h4><p>•ipv4一般使用点分十进制字符串来标识，如192.168.1.135。</p><h3 id="3-6-2、ip组成"><a href="#3-6-2、ip组成" class="headerlink" title="3-6-2、ip组成"></a>3-6-2、ip组成</h3><p>•使用32位，有{网络id，主机id}两部分组成</p><p>•子网：IP地址中由1覆盖的连续位</p><p>•主机：由ip地址中0覆盖的连续位</p><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ip%E7%BB%84%E6%88%90.png"></p><p>•子网ID不同的网络不能直接通讯，如果要通讯要通过路由器转发。</p><p>•主机id全为0表示网段地址。</p><p>•主机id全为1的ip地址表示该网段的广播地址。</p><p>•如192.168.1.0为表示网段，192.168.1.255为广播地址。</p><h3 id="3-6-3、ipv4的地址分类（依据前8位进行区分）"><a href="#3-6-3、ipv4的地址分类（依据前8位进行区分）" class="headerlink" title="3-6-3、ipv4的地址分类（依据前8位进行区分）"></a>3-6-3、ipv4的地址分类（依据前8位进行区分）</h3><p>•A类地址：默认8位子网id，<br>第一位为0，前8位00000000 - 0111 1111，<br>范围0.x.x.x - 127.x.x.x</p><p>•B类地址：默认16位子网id，<br>前两位为10，前8位1000 0000  -  1011 1111，<br>范围128.x.x.x  -  191.x.x.x</p><p>•C类地址：默认24位子网id，<br>前三位为110，前8位为1100 0000   -  1101 1111 ，<br>范围192 .x.x.x  -  223.x.x.x</p><p>•D类地址：前四位为1110，<br>多播地址，前8位1110 0000 -  1110 1111，<br>范围224.x.x.x  -  239.x.x.x</p><p>•E类地址：前五位为1111 0，<br>保留为今后使用，前八位为1111 0000  -  1111 1111 ，<br>范围240 .x.x.x -  255.x.x.x</p><p>•ip地址特点：<br>子网ID不同的网络不能直接通信，<br>如果要通信则需要路由器转发<br>主机ID全为0的IP地址表示网段地址<br>主机ID全为1的IP地址表示该网段的广播地址。</p><h3 id="3-6-4、私有ip"><a href="#3-6-4、私有ip" class="headerlink" title="3-6-4、私有ip"></a>3-6-4、私有ip</h3><p>•公有ip(可直接联网)：<br>经由internet同意规划的ip。</p><p>•私有ip（不可直接连接internet）：<br>主要用于局域网络内的主机联机规划。</p><p>​<img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/ip%E7%B1%BB%E5%9E%8B.png"></p><h3 id="3-6-5、回环ip地址"><a href="#3-6-5、回环ip地址" class="headerlink" title="3-6-5、回环ip地址"></a>3-6-5、回环ip地址</h3><p>•通常127.0.0.1称为回环地址</p><p>•功能：<br>主要是测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和ip协议的安装没有问题。</p><p>•注意：<br>127.0.0.1—-127.255.255.254中的任何地址都将回环到本机的地址中，不属于任何一个有类别的地址类，<br>它代表着设备的本地接口。</p><h3 id="3-6-6、子网掩码"><a href="#3-6-6、子网掩码" class="headerlink" title="3-6-6、子网掩码"></a>3-6-6、子网掩码</h3><p>•子网掩码又称为网络掩码、地址掩码是一个有32位由1和0组成的数值，并且1和0分别连续。</p><p>•作用：</p><p>​用于指明ip地址中那些是子网，那些是主机号。</p><p>•特点：</p><p>​必须结合ip地址一起使用，不能单独存在。</p><p>​ip地址中由子网掩码中1覆盖的连续位为子网id，其余为主机id。</p><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png"></p><h2 id="3-7、端口"><a href="#3-7、端口" class="headerlink" title="3-7、端口"></a>3-7、端口</h2><h3 id="3-7-1、端口概述"><a href="#3-7-1、端口概述" class="headerlink" title="3-7-1、端口概述"></a>3-7-1、端口概述</h3><p>•tcp&#x2F;ip采用端口标识通信进程，用于区分一个系统里的多个进程。</p><p>•特点：<br>1、对于同一个端口，在不同的系统中对应着不同的进程。</p><p>2、对于同一个系统，一个端口只能被一个进程拥有。</p><p>3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，<br>进程送交传输层的数据也通过该端口被送出。</p><h3 id="3-7-2、端口号"><a href="#3-7-2、端口号" class="headerlink" title="3-7-2、端口号"></a>3-7-2、端口号</h3><p>•类似pid标识一个进程：在网络程序中，用端口号（port）来标识一个运行的网络程序。</p><p>•特点<br>1、端口号是无符号短整型的类型。</p><p>2、每个端口都拥有一个端口号。</p><p>3、TCP、UDP维护各自的端口号。</p><p>4、网络应用程序至少要占用一个端口号，也可以占用多个端口号。</p><p>•知名端口（1-1023）<br>由互联网数字分配机构根据用户需求进行同意分配。<br>如：ftp –21，http—-80等<br>服务器通常使用的范围；若强制使用，须加root特权</p><p>• 动态端口（1024 -65535）<br>应用程序通常使用的范围。<br>注意：端口号类似于进程号，同一时刻只能标记一个进程。<br>可以重复使用。</p><p>​<img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png"></p><h3 id="3-7-3、链路层封包格式"><a href="#3-7-3、链路层封包格式" class="headerlink" title="3-7-3、链路层封包格式"></a>3-7-3、链路层封包格式</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B0%81%E5%8C%85%E6%A0%BC%E5%BC%8F.png"></p><p>• 目的地址：目的mac地址</p><p>• 源地址：源mac地址</p><p>• 类型：<br>以太网后面跟的是那个协议，占两个字节<br>0x0800 ip协议（对应到网络层）<br>0x0806 arp协议<br>0x835 rarp协议</p><p>• 注意：</p><p>1、IEEE802.2&#x2F;802.3封装常用的无线</p><p>2、以太网封装常用在线局域网</p><h3 id="3-7-4、网络层的数据报封装"><a href="#3-7-4、网络层的数据报封装" class="headerlink" title="3-7-4、网络层的数据报封装"></a>3-7-4、网络层的数据报封装</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%B0%81%E5%8C%85.png"></p><p>•当协议改为6，或者17后，ip数据报后面紧跟的就是udp数据报或者tcp数据报。</p><h2 id="3-8、c-s架构"><a href="#3-8、c-s架构" class="headerlink" title="3-8、c&#x2F;s架构"></a>3-8、c&#x2F;s架构</h2><p>•无论是tcp还是udp，都是通过c&#x2F;s架构运行的，client客户端，server服务器端。服务器是被动运行的，<br>客户端是主动运行的。<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/cs%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>•server工作过程：<br>打开一通信通道并告知本地主机，它愿意在一特定端口（如80）上接收客户请求，<br>等待客户请求到达该端口，受客户请求，并发送应答信号，激活一新的线程处理客<br>户的这个请求，服务完成后，关闭新线程的客户的通信链路。</p><p>•client工作过程:<br>打开一通信通道并连接到服务器特定的端口，并向服务器发出服务请求，等待并接<br>收应答，根据需要继续提出请求，请求结束后关闭通信通道并终止。</p><h1 id="4、字节序、地址转换"><a href="#4、字节序、地址转换" class="headerlink" title="4、字节序、地址转换"></a>4、字节序、地址转换</h1><p>•多数据的存储顺序称之为字节序</p><p>•分类：<br>大端格式：将高位字节数据存储低地址<br>小端格式：将低位字节数据存储在低地址</p><p>•注意：<br>lsb：低地址<br>msb：高地址</p><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%AD%97%E8%8A%82%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>•如何判断存储字节序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union k&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union k j;</span><br><span class="line">j.a = 0x12345678;</span><br><span class="line">printf(&quot;j.b = %#x\r\n&quot;,j.b);</span><br><span class="line">if(j.b == 0x78)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;小端存储\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">j.b = 0x78</span><br><span class="line">小端存储</span><br></pre></td></tr></table></figure><p>一个地址位存储一个字节，一个字节8位。</p><h2 id="4-1、字序转换"><a href="#4-1、字序转换" class="headerlink" title="4-1、字序转换"></a>4-1、字序转换</h2><p>•特点：</p><p>1、协议指定了通讯字节序为大端存储。</p><p>2、只有在多字节数据处理的时候才需要考虑字节序。</p><p>3、运行在同一台计算机上的进程互相通讯时，一般不用考虑字节序。</p><p>4、异构计算机之间的通讯，需要转换自己的字节序为网络字节序。</p><p>在需要字节序转换的时候一般调用特定字节序转换函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">host ‐‐&gt; network</span><br><span class="line">1 ‐‐ htonl</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">uint32_t htonl(uint32_t hostint32);</span><br><span class="line">功能:</span><br><span class="line">将32位主机字节序数据转换成网络字节序数据</span><br><span class="line">参数：</span><br><span class="line">hostint32：待转换的32位主机字节序数据</span><br><span class="line">返回值：</span><br><span class="line"> 成功：返回网络字节序的值</span><br><span class="line"></span><br><span class="line"> 2 ‐‐ htons</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> uint16_t htons(uint16_t hostint16);</span><br><span class="line"> 功能：</span><br><span class="line"> 将16位主机字节序数据转换成网络字节序数据</span><br><span class="line"> 参数：</span><br><span class="line"> uint16_t：unsigned short int</span><br><span class="line"> hostint16：待转换的16位主机字节序数据</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回网络字节序的值</span><br><span class="line"></span><br><span class="line"> network ‐‐&gt; host</span><br><span class="line"> 3 ‐‐ ntohl</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> uint32_t ntohl(uint32_t netint32);</span><br><span class="line"> 功能：</span><br><span class="line"> 将32位网络字节序数据转换成主机字节序数据</span><br><span class="line"> 参数：</span><br><span class="line"> uint32_t： unsigned int</span><br><span class="line"> netint32：待转换的32位网络字节序数据</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回主机字节序的值</span><br><span class="line"></span><br><span class="line"> 4 ‐‐ ntohs</span><br><span class="line"> #include &lt;arpa/inet.h&gt;</span><br><span class="line"> uint16_t ntohs(uint16_t netint16);</span><br><span class="line"> 功能：</span><br><span class="line"> 将16位网络字节序数据转换成主机字节序数据</span><br><span class="line"> 参数：</span><br><span class="line"> uint16_t： unsigned short int</span><br><span class="line"> netint16：待转换的16位网络字节序数据</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回主机字节序的值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 0x12345678;</span><br><span class="line">short int b =0x1234;</span><br><span class="line">printf(&quot;%#x\n&quot;,htonl(a));</span><br><span class="line">printf(&quot;%#x\r\n&quot;,htons(b));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">0x78563412</span><br><span class="line">0x3412</span><br></pre></td></tr></table></figure><h2 id="4-2、地址转换"><a href="#4-2、地址转换" class="headerlink" title="4-2、地址转换"></a>4-2、地址转换</h2><p>•ip地址人为识别的时候是字符串。</p><p>•交给计算机识别时，要将它转化整型数据。<br>如192.168.3.104 </p><p>•交给计算机时，转化位四个字节的整型数据，以点好（.）为分割。</p><h3 id="4-2-1、转换函数1"><a href="#4-2-1、转换函数1" class="headerlink" title="4-2-1、转换函数1"></a>4-2-1、转换函数1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inet_pton函数</span><br><span class="line"></span><br><span class="line">字符串ip转整型数据</span><br><span class="line"></span><br><span class="line">inet_ntop函数</span><br><span class="line">整型数据转字符串格式IP地址 </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">/****************将字符串地址转化为电脑能识别的无符号整形数据**********************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ip[] = &quot;192.168.3.103&quot;;</span><br><span class="line">unsigned int unip = 0;</span><br><span class="line">unsigned int *nip = NULL;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;unip);</span><br><span class="line">printf(&quot;%d\r\n&quot;,unip);/******       一个字节一个字节的取出，不然看不懂       *********/</span><br><span class="line">nip = &amp;unip;</span><br><span class="line">printf(&quot;unip = %d.%d.%d.%d\r\n&quot;,*(nip),*(nip+1),*(nip+2),*(nip+3));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/////////////////////////////////</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">///////////////////////////////////////</span><br><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">1728293056</span><br><span class="line">unip = 1728293056.-1553161620.32767.959575536</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char nip[] = &#123;192,168,3,103&#125;;</span><br><span class="line">    char ip[16];</span><br><span class="line">    inet_ntop(AF_INET,&amp;nip,ip,16);</span><br><span class="line">printf(&quot;%s\r\n&quot;,ip);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    结果</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">192.168.3.103</span><br></pre></td></tr></table></figure><h4 id="地址转换："><a href="#地址转换：" class="headerlink" title="地址转换："></a>地址转换：</h4><p>•我们输入认为识别的ip地址是点分十进制的字符串形式，<br>但是计算机或者网络中识别的ip地址是整形数据，<br>所以需要转化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">字符串ip地址转整型数据</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int inet_pton(int family,const char *strptr, void *addrptr);</span><br><span class="line">功能：</span><br><span class="line">将点分十进制数串转换成32位无符号整数</span><br><span class="line">参数：</span><br><span class="line">family 协议族</span><br><span class="line">AF_INET IPV4网络协议</span><br><span class="line">AF_INET6 IPV6网络协议</span><br><span class="line"> strptr 点分十进制数串</span><br><span class="line"> addrptr 32位无符号整数的地址</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功返回1</span><br><span class="line"> 失败返回其它</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ip_str[]=&quot;192.168.3.103&quot;;</span><br><span class="line">unsigned int ip_int = 0;</span><br><span class="line">unsigned char *ip_p = NULL;</span><br><span class="line">//将点分十进制ip地址转化为32位无符号整形数据</span><br><span class="line"> inet_pton(AF_INET,ip_str,&amp;ip_int);</span><br><span class="line"></span><br><span class="line"> printf(&quot;ip_int = %d\n&quot;,ip_int);</span><br><span class="line"></span><br><span class="line"> ip_p = (char *)&amp;ip_int;</span><br><span class="line"> printf(&quot;in_uint = %d,%d,%d,%d\n&quot;,*ip_p,*(ip_p+1),*(ip_p+2),*</span><br><span class="line">(ip_p+3));</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="inet-ntop"><a href="#inet-ntop" class="headerlink" title="inet_ntop()"></a>inet_ntop()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">整型数据转字符串格式ip地址</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">const char *inet_ntop(int family, const void *addrptr,</span><br><span class="line">char *strptr, size_t len);</span><br><span class="line">功能：</span><br><span class="line">将32位无符号整数转换成点分十进制数串</span><br><span class="line">参数：</span><br><span class="line">family 协议族</span><br><span class="line">addrptr 32位无符号整数</span><br><span class="line"> strptr 点分十进制数串</span><br><span class="line"> len strptr缓存区长度</span><br><span class="line"> len的宏定义</span><br><span class="line"> #define INET_ADDRSTRLEN 16 //for ipv4</span><br><span class="line"> #define INET6_ADDRSTRLEN 46 //for ipv6</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功:则返回字符串的首地址</span><br><span class="line"> 失败:返回NULL</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">unsigned char ip_int[]=&#123;192, 168, 3, 103&#125;;</span><br><span class="line">char ip_str[16] = &quot;&quot;; //&quot;192.168.3.103&quot;</span><br><span class="line">inet_ntop(AF_INET, &amp;ip_int, ip_str, 16);</span><br><span class="line"> printf(&quot;ip_s = %s\n&quot;, ip_str);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2、转换函数2"><a href="#4-2-2、转换函数2" class="headerlink" title="4-2-2、转换函数2"></a>4-2-2、转换函数2</h3><p>•inet_addr和inet_ntoa用的更多。只能用在ipv4上。比较重要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这两个函数只能用在ipv4地址的转换</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">in_addr_t inet_addr(const char *cp);</span><br><span class="line">功能：将点分十进制ip地址转化为整形数据</span><br><span class="line">参数：</span><br><span class="line">cp：点分十进制的IP地址</span><br><span class="line">返回值：</span><br><span class="line"> 成功：整形数据</span><br><span class="line"></span><br><span class="line"> char *inet_ntoa(struct in_addr in);</span><br><span class="line"> 功能：将整形数据转化为点分十进制的ip地址</span><br><span class="line"> 参数：</span><br><span class="line"> in：保存ip地址的结构体</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：点分十进制的IP地址</span><br></pre></td></tr></table></figure><h1 id="5、udp"><a href="#5、udp" class="headerlink" title="5、udp"></a>5、udp</h1><p>•udp的应用：<br>dns域名解析，nfs网络文件系统，rtp流媒体</p><h2 id="5-1、网络编程接口socket"><a href="#5-1、网络编程接口socket" class="headerlink" title="5-1、网络编程接口socket"></a>5-1、网络编程接口socket</h2><pre><code>面向无连接的用户数据报协议，在传输数据前不需要先建立连接；目地主机的运输层收到UDP报文后，不需要给出任何确认UDP特点1、相比TCP速度稍快些2、简单的请求/应答应用程序可以使用UDP3、对于海量数据传输不应该使用UDP4、广播和多播应用必须使用UDPUDP应用DNS(域名解析)、NFS(网络文件系统)、RTP(流媒体)等一般语音和视频通话都是使用udp来通信的    socket作用：            提供不同主机上的进程之间的通讯    socket 特点：            1、socket也称“套接字”。            2、是一种文件描述符，            代表了一个个管道的端点。            3、类似对文件的操作一样，            可以使用read、write、close等函数对socket套接            字进行网络数据的收取和发送等操作。            4、得到socket套接字（描述符）的方法调用socket    socket分类：            1、SOCK_STREAM,流式套接字，用于tcp            2、SOCK_DGRAM,数据报套接字，用于udp                        3、SOCK_RAW,原始套接字，            对于其他层次的协议操作需要使用到这个类型</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/udp%E9%80%9A%E8%AE%AF%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><pre><code>    编程流程：    一、服务器：    1、创建套接字socket                                                                 2、将服务器的ip地址、端口号与套接字进行绑定bind    3、接收数据recvfrom    4、发送数据sendto    二、客户端：    1、创建套接字socket    2、发送数据sendto    3、接收数据recvfrom    4、关闭套接字close    服务器创建套接字默认属性是主动的，就是当发起服务请求；当作为服务器时，往往需要改成被动的。</code></pre><h3 id="5-1-1-创建socket套接字"><a href="#5-1-1-创建socket套接字" class="headerlink" title="5-1-1 创建socket套接字"></a>5-1-1 创建socket套接字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 创建socket套接字</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">功能：创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">domain：通信域，协议族</span><br><span class="line">AF_UNIX 本地通信</span><br><span class="line">AF_INET ipv4网络协议</span><br><span class="line">AF_INET6 ipv6网络协议</span><br><span class="line"> AF_PACKET 底层接口</span><br><span class="line"> type：套接字的类型</span><br><span class="line"> SOCK_STREAM 流式套接字（tcp）</span><br><span class="line"> SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line"> SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line"> protocol：附加协议，如果不需要，则设置为0</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：文件描述符</span><br><span class="line"> 失败：‐1</span><br><span class="line">特点：</span><br><span class="line">创建套接字时，系统不会分配端口</span><br><span class="line">创建的套接字默认属性是主动的，</span><br><span class="line">即主动发起服务的请求;当作为服务器时，</span><br><span class="line">往往需要修改为被动的</span><br></pre></td></tr></table></figure><pre><code>案例：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用socket函数创建套接字</span><br><span class="line">//创建一个用于UDP网络编程的套接字</span><br><span class="line"> int sockfd;</span><br><span class="line"> if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to socket&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;sockfd = %d\n&quot;, sockfd);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%88%9B%E5%BB%BAsocket%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h2 id="5-2、ipv4套接字的地址结构"><a href="#5-2、ipv4套接字的地址结构" class="headerlink" title="5-2、ipv4套接字的地址结构"></a>5-2、ipv4套接字的地址结构</h2><pre><code>    再网络编程中，    为了使不同格式的地址能够被传入套接字函数，    地址需要强制转换成通用套接字地址结构，    原因是因为不同的场合所使用的结构体不一样，    但是调用的函数却是同一个，    所以定义一个通用的结构体，    在指定场合使用时，    再根据要求传入指定的结构体就行。在网络编程中经常使用的结构体sockaddr_in</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">头文件#include &lt;netinet/in.h&gt;</span><br><span class="line">struct in_addr</span><br><span class="line">&#123;</span><br><span class="line">in_addr_t s_addr; //ip地址，4个字节</span><br><span class="line">&#125;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">sa_famila_t sin_family ;//协议族2个字节</span><br><span class="line">in_port sin_port ;//端口号 2个字节</span><br><span class="line">struct in_addr sin_addr;//ip地址 4个字节</span><br><span class="line">char sin_zero[8];填充不起什么作用 8字节</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面这个是通用结构体</span><br><span class="line">struct sockaddr</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sa_family; //2字节</span><br><span class="line">char sa_data[14]//14字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种地址结合"><a href="#两种地址结合" class="headerlink" title="两种地址结合"></a>两种地址结合</h4><pre><code>在定义源地址和目的地址结构的时候，选用struct sockaddr_in;例：struct sockaddr_in my_addr;当调用编程接口函数，且该函数需要传入地址结构时需要用struct sockaddr进行强制转换例：bind(sockfd,(struct sockaddr*)&amp;my_addr,sizeof(my_addr));    注意事项：    1、在定义源地址和目的地址结构的时候，选用struct  sockaddr_in。    如：struct sockaddr_in my_addr;    2、当调用编程接口函数，且该函数需要传入地址结构时需要用struct sockaddr进行强制转换。    如：bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(my_addr))</code></pre><h2 id="5-3、服务器向客户端发送数据"><a href="#5-3、服务器向客户端发送数据" class="headerlink" title="5-3、服务器向客户端发送数据"></a>5-3、服务器向客户端发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /******************  第二步 ：填充服务器网络信息结构体  sockaddr——in  *************/</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /************ ip地址转化为整形  ************/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h6 id="1、发送数据—sendto函数"><a href="#1、发送数据—sendto函数" class="headerlink" title="1、发送数据—sendto函数"></a>1、发送数据—sendto函数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,</span><br><span class="line">const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">功能：发送数据</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line">buf：要发送的数据</span><br><span class="line">len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> dest_addr：目的网络信息结构体（需要自己指定要给谁发送）</span><br><span class="line"> addrlen：dest_addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h2 id="5-4、绑定–bind函数"><a href="#5-4、绑定–bind函数" class="headerlink" title="5-4、绑定–bind函数"></a>5-4、绑定–bind函数</h2><pre><code>    由于服务器是被动的，    客户端时主动的，    客户端要找到服务器才能通讯，    一般不需要要bind绑定，    只有服务器才需要bind绑定。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：将套接字与网络信息结构体绑定</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line">addr：网络信息结构体</span><br><span class="line">通用结构体（一般不用）</span><br><span class="line">struct sockaddr</span><br><span class="line"> 网络信息结构体 sockaddr_in</span><br><span class="line"> #include &lt;netinet/in.h&gt;</span><br><span class="line"> struct sockaddr_in</span><br><span class="line"> addrlen：addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    给定的IP必须与服务器IP一致，不然就会发生报错。</code></pre><h2 id="5-5、接收数据-recvfrom"><a href="#5-5、接收数据-recvfrom" class="headerlink" title="5-5、接收数据-recvfrom"></a>5-5、接收数据-recvfrom</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</span><br><span class="line">struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line">功能：接收数据</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line">buf：保存接收的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> src_addr：源的网络信息结构体（自动填充，定义变量传参即可）</span><br><span class="line"> addrlen：src_addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：接收的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h2 id="5-6、客户端向服务器发送数据"><a href="#5-6、客户端向服务器发送数据" class="headerlink" title="5-6、客户端向服务器发送数据"></a>5-6、客户端向服务器发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 128</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************接收客户端发送的数据*********************/</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(recvfrom(sockfd,buf,N,0,(struct sockaddr *)&amp;clientaddr,&amp;addrlen) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;recvfrom_faile&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        /*******s_addr在计算机中是个32为的无符号的整数，需要转为点分十进制整数   inet_ntoa与其他转换函数不同，直接传结构体就可以*********/</span><br><span class="line">    printf(&quot;ip:%s  port:%d\r\n&quot;,inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));</span><br><span class="line">    printf(&quot;from client:%s\n&quot;,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-7、c-s架构"><a href="#5-7、c-s架构" class="headerlink" title="5-7、c&#x2F;s架构"></a>5-7、c&#x2F;s架构</h2><pre><code>•在上面两个例子中发送数据的是client，接收数据的是server，其实在网络开发中，client和server都可以收发数据，只是一般认为吧提供服务的一方称为server，接受服务的一方称为client。</code></pre><h2 id="5-8、udp客户端注意点"><a href="#5-8、udp客户端注意点" class="headerlink" title="5-8、udp客户端注意点"></a>5-8、udp客户端注意点</h2><pre><code>1、本地ip、本地端口（我是谁）。2、目的ip、目的端口（发给谁）。3、在客户端的代码中、本地port是我们调用sendto的时候linux系统自动给客户端分配的，分配端口的方式为随机分配，即每次运行系统给的port不一样。客户端信息可以指定，也可以不指定，一般不需要。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /*****  第二步 ：填充服务器网络信息结构体  sockaddr——in  *******/</span><br><span class="line">/******一般不需要******/</span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /******** ip地址转化为整形  *********/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-9、服务器注意点"><a href="#5-9、服务器注意点" class="headerlink" title="5-9、服务器注意点"></a>5-9、服务器注意点</h2><pre><code>1、服务器之所以bind是因为它的本地port需要固定，不能是随机的。2、服务器也可以主动给客户端发送信息。3、客户端也可以使用bind绑定，这样客户端的本地端口就固定了，但是一般不这样做。</code></pre><h2 id="5-10、TFTP协议"><a href="#5-10、TFTP协议" class="headerlink" title="5-10、TFTP协议"></a>5-10、TFTP协议</h2><pre><code>    tftp：简单文本传送协议（传输小文件，基于udp）。    ftp：文件传输协议（传输大文件，基于tcp）。        数据传输模式：    octet：二进制模式。    netascii：文本模式。    tftp协议：端口号port 69。    </code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TFTP%E4%B8%8B%E8%BD%BD%E6%B5%81%E7%A8%8B.png"></p><pre><code>tftp通讯总结：    1、服务器在69号端口等待客户端请求。    2、服务器若批准此请求，则使用临时端口与客户端进行通信。    3、每个数据包的编号都有变化（从1开始）。    4、每个数据包都要得到ACK的缺认，如果出现超时，则需要    重新发送最够的包（数据或者ACK）。    5、数据包的长度以521byte传输。    6、小于512byte的数据意味着传输结束。</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/TFTP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90.png"></p><pre><code>    以上的0代表的是‘\0’。不同的差错码对应不同的错误信息。</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E9%94%99%E8%AF%AF%E7%A0%81.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">错误码：</span><br><span class="line">0 未定义,参见错误信息</span><br><span class="line">1 File not found.</span><br><span class="line">2 Access violation.</span><br><span class="line">3 Disk full or allocation exceeded.</span><br><span class="line">4 illegal TFTP operation.</span><br><span class="line">5 Unknown transfer ID.</span><br><span class="line">6 File already exists.</span><br><span class="line">7 No such user.</span><br><span class="line">8 Unsupported option(s) requested.</span><br></pre></td></tr></table></figure><h2 id="5-11、使用TFTP下载"><a href="#5-11、使用TFTP下载" class="headerlink" title="5-11、使用TFTP下载"></a>5-11、使用TFTP下载</h2><pre><code>要求：使用tftp协议，下载server上的文件到本地。思路：    1、构造请求报文，发送到69端口。    2、等待服务器回应。    3、分析服务器回应。    4、接收数据，直到数据小于512字节。</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%BD%BF%E7%94%A8TFTP%E4%B8%8B%E8%BD%BD.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  /**** printf ***/</span><br><span class="line">#include &lt;stdlib.h&gt; /**  exit  **/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt; /** socket **/</span><br><span class="line">#include &lt;sys/socket.h&gt; /**  sockaddr_in **/</span><br><span class="line">#include &lt;arpa/inet.h&gt; /** htons inet_addr **/</span><br><span class="line">#include &lt;unistd.h&gt; /** close**/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">void download(int sockfd,struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[128] = &quot;&quot;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名:\r\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,filename);</span><br><span class="line">    unsigned char text[1024] = &quot;&quot;;</span><br><span class="line">    int text_len;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num =0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    /********* 构建发给服务器的tftp指令，如：01test.txt0octet0 ***************/</span><br><span class="line">    text_len = sprintf(text,&quot;%c%c%s%c%s%c&quot;,0,1,filename,0,&quot;octet&quot;,0);//////////////////</span><br><span class="line">    if(sendto(sockfd,text,text_len,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to sendto&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /*** 接收服务器发来的信息并处理****/</span><br><span class="line">        bytes = recvfrom(sockfd,text,sizeof(text),0,(struct sockaddr *)&amp;serveraddr,&amp;addrlen);</span><br><span class="line">        if(bytes == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;recvfrom_filed&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /*** 判断操作码*****/</span><br><span class="line">        if(text[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;error:%s\n&quot;,text+4);</span><br><span class="line">        return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(text[1] == 3)</span><br><span class="line">       &#123;</span><br><span class="line">         &#123;</span><br><span class="line">            if(flags == 0)/*** 创建文件的，flags为标志位，防止重复创建***/</span><br><span class="line">            &#123;/**创建文件***/</span><br><span class="line">                if((fd = open(filename,O_WRONLY | O_CREAT | O_TRUNC,0664)) &lt; 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;failed_open&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flags = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        /**  对比块编号和接收的数据大小并将文件内容写入文件***/</span><br><span class="line">        if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes == 516))/** 接收到的数据包还要加上操作码和块编号，所以是516 ***/</span><br><span class="line">            &#123;</span><br><span class="line">                num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen))</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to send&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes &lt; 516))/**判断是否是最后一次传输**/</span><br><span class="line">            &#123; </span><br><span class="line">                 num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">                   &#123;</span><br><span class="line">                        perror(&quot;failed_sento&quot;);</span><br><span class="line">                        exit(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                printf(&quot;文件下载完成\r\n&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125; </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /** 创建套接字 **/</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sockfd_fail\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*** 填充服务器信息结构体 **/</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);/*** tftp服务器端地址 ***/</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line">   // if(bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof(serveraddr)) == -1)</span><br><span class="line">   // &#123;</span><br><span class="line">    //    perror(&quot;bind_fail\r\n&quot;);</span><br><span class="line">   //    exit(1);   </span><br><span class="line">   // &#125;</span><br><span class="line">    /*** 下载 ***/</span><br><span class="line">    download(sockfd,serveraddr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>以下是上传服务器的代码</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">上传服务器</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERRLOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line"></span><br><span class="line">void do_help()</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">    printf(&quot;------ 1. 下载 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 2. 上传 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 3. 退出 ------\n&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_download(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    char data[1024] = &quot;&quot;;</span><br><span class="line">    int data_len;</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int recv_len;</span><br><span class="line"></span><br><span class="line">    //组数据并发送</span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 1, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收数据并分析处理</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %u\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;error: %s\n&quot;, data + 4);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(data[1] == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            //防止文件内容清空</span><br><span class="line">            if(flags == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                flags = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断数据包的编号是否是上一次的编号加1</span><br><span class="line">            if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len == 516)</span><br><span class="line">            &#123;</span><br><span class="line">                //向文件写入数据</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">            </span><br><span class="line">                //组数据发送给服务器</span><br><span class="line">                data[1] = 4; </span><br><span class="line">                if(sendto(sockfd, data, 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                num = ntohs(*(unsigned short *)(data + 2));</span><br><span class="line">            &#125;</span><br><span class="line">            //接收到的最后一次的数据</span><br><span class="line">            else if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len &lt; 516)</span><br><span class="line">            &#123;</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件下载成功\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_upload(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要上传的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    //打开文件并判断文件是否存在</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(filename, O_RDONLY)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(errno == ENOENT)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;文件%s不存在，请重新输入\n&quot;, filename);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //组数据并发送给服务器执行上传功能</span><br><span class="line">    char data[1024] = &#123;&#125;;</span><br><span class="line">    int data_len;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 2, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line"></span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收服务器发送的数据并分析处理</span><br><span class="line">    int recv_len;</span><br><span class="line">    int num = 0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %d\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 4 &amp;&amp; num == ntohs(*(unsigned short *)(data + 2)))</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            bytes = read(fd, data + 4, 512);</span><br><span class="line">            data[1] = 3;</span><br><span class="line">            *(unsigned short *)(data + 2) = htons(num);</span><br><span class="line"></span><br><span class="line">            if(bytes == 512)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件上传完毕\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    //创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line"></span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;----请输入help查看帮助信息----\n&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;&gt;&gt;&gt; &quot;);</span><br><span class="line"></span><br><span class="line">    char buf[N] = &#123;&#125;;</span><br><span class="line">NEXT:</span><br><span class="line">    fgets(buf, N, stdin);</span><br><span class="line">    buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">    if(strncmp(buf, &quot;help&quot;, 4) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        do_help();</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">        goto NEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;input&gt;&gt;&gt; &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        switch (num)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            do_download(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            do_upload(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            close(sockfd);</span><br><span class="line">            exit(0);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、udp广播"><a href="#6、udp广播" class="headerlink" title="6、udp广播"></a>6、udp广播</h1><p>•广播：<br>由一台主机向该主机所在子网内的所有主机发送数据的方式。<br>广播只能用 UDP 或原始 IP 实现， 不能用 TCP。</p><p>•用途：<br>单个服务器与多个客户主机通信时减少分组流通。<br>以下几个协议都用到广播<br>1、 地址解析协议（ARP）。<br>2、 动态主机配置协议（DHCP）。<br>3、 网络时间协议（NTP）。  </p><p>•特点：<br>1、 处于同一子网的所有主机都必须处理数据。<br>2、 UDP 数据包会沿协议栈向上一直到 UDP 层。<br>3、 运行音视频等较高速率工作的应用， 会带来大负担。<br>4、 局限于局域网内使用。  </p><p>•地址：<br>{网络 ID， 主机 ID}<br>网络 ID 表示由子网掩码中 1 覆盖的连续位。<br>主机 ID 表示由子网掩码中 0 覆盖的连续位。<br>定向广播地址： 主机 ID 全 1<br>1、 例： 对于 192.168.220.0&#x2F;24，<br>其定向广播地址为 192.168.220.255。<br>2、 通常路由器不转发该广播<br>受限广播地址： 255.255.255.255，<br>路由器从不转发该广播。  </p><p>•广播流程：<br>    发送者：<br>    第一步：创建套接字 socket()<br>    第二步：设置为允许发送广播权限 setsockopt()<br>    第三步：向广播地址发送数据 sendto()<br>    接收者：<br>    第一步：创建套接字 socket()<br>    第二步：将套接字与广播的信息结构体绑定 bind()<br>    第三步：接收数据 recvfrom()  </p><h2 id="6-1、单播"><a href="#6-1、单播" class="headerlink" title="6-1、单播"></a>6-1、单播</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%8D%95%E6%92%AD.png"></p><h2 id="6-2、广播"><a href="#6-2、广播" class="headerlink" title="6-2、广播"></a>6-2、广播</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B9%BF%E6%92%AD.png"></p><h2 id="6-3、广播流程"><a href="#6-3、广播流程" class="headerlink" title="6-3、广播流程"></a>6-3、广播流程</h2><p>•发送者：<br>        第一步：创建套接字 socket()<br>        第二步：设置为允许发送广播权限 setsockopt()<br>        第三步：向广播地址发送数据 sendto()<br>•接收者：<br>        第一步：创建套接字 socket()  <br>        第二步：将套接字与广播的信息结构体绑定 bind()<br>        第三步：接收数据 recvfrom()  </p><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B9%BF%E6%92%AD%E8%AE%BE%E7%BD%AE%E5%A5%97%E6%8E%A5%E5%AD%97.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">套接字选项</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int socket, int level, int option_name,</span><br><span class="line">const void *option_value, socklen_t option_len);</span><br><span class="line">功能：设置一个套接字的选项（属性）</span><br><span class="line">参数：</span><br><span class="line">socket：文件描述符</span><br><span class="line">level：协议层次</span><br><span class="line">SOL_SOCKET 套接字层次</span><br><span class="line">IPPROTO_TCP tcp层次</span><br><span class="line"> IPPROTO_IP IP层次</span><br><span class="line"> option_name：选项的名称</span><br><span class="line"> SO_BROADCAST 允许发送广播数据（SOL_SOCKET层次的）</span><br><span class="line"> option_value：设置的选项的值</span><br><span class="line"> int类型的值，存储的是bool的数据（1和0）</span><br><span class="line"> 0 不允许</span><br><span class="line"> 1 允许</span><br><span class="line"> option_len：option_value的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h3 id="6-3-1、发送者"><a href="#6-3-1、发送者" class="headerlink" title="6-3-1、发送者"></a>6-3-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//广播发送者代码实现</span><br><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(sendaddr);</span><br><span class="line">    int on = 1;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET , SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**SOL_SOCKET：协议层次**/</span><br><span class="line">    /** SO_BROADCAST：允许发送广播权限**/</span><br><span class="line">    /**on：设置是否允许，设置为1表示允许，0表示不允许**/</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST,&amp;on,sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sersockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**绑定广播结构体**/    </span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /**进行通讯**/</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,sizeof(buf),stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;; /**将输入完的数据用 \0 结尾**/</span><br><span class="line">        if(sendto(sockfd, buf, sizeof(buf), 0,(struct sockaddr *)&amp;sendaddr, addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-2、接收者"><a href="#6-3-2、接收者" class="headerlink" title="6-3-2、接收者"></a>6-3-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in broadrecv;</span><br><span class="line">    socklen_t socklen;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /**填充信息结构体**/</span><br><span class="line">    broadrecv.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    broadrecv.sin_family = AF_INET;</span><br><span class="line">    broadrecv.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    /**将信息结构体与结构体绑定**/</span><br><span class="line">    socklen = sizeof(broadrecv);</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;broadrecv,socklen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;/**这里还要在申请的原因是要那来接受发送者的信息**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, buf, sizeof(buf), 0 ,(struct sockaddr *)&amp;sendaddr, &amp;socklen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">       //     exit(1);</span><br><span class="line">        &#125; </span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;, inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><pre><code>    接收者只能有一个，发送者可以有多个。</code></pre><h1 id="7、多播"><a href="#7、多播" class="headerlink" title="7、多播"></a>7、多播</h1><h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7-1、概念"></a>7-1、概念</h2><p>•数据的收发只在同一分组中进行。所以多播又称之为组播。<br>    多播的特点：<br>        1、多播地址标示一组接口。<br>        2、多播可以用于广域网使用。<br>        3、在ipv4中，多播是可选的。<br>•广播和多播的区别：广播是向所有的人发送。而多播必须加入多播组</p><h2 id="7-1、多播地址"><a href="#7-1、多播地址" class="headerlink" title="7-1、多播地址"></a>7-1、多播地址</h2><pre><code>•ipv4的D类地址是多播地址。•多播地址向以太网mac地址的映射：</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png"></p><pre><code>    ipv4由32个字节构成，后23位组成以太网的都多播地址的底序23位，然后补一位0。    广播的发送者必须要设置允许发送广播，而多播必须加入多播组，才能接收到信息。</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%8F%91%E9%80%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p>•注意：mac地址后23位由ipv4的后23位构成，<br>    在接收者进行mac地址过滤的时候，进行的是不完全过滤，<br>    原因就在于23位前面有一位被指0，导致可能的错误，所以会在ipv4进行再次的过滤。<br>    比起广播，多播具有可控性，<br>    只有加入多播组的接收者才能接收数据。  </p><h2 id="7-2、多播的流程"><a href="#7-2、多播的流程" class="headerlink" title="7-2、多播的流程"></a>7-2、多播的流程</h2><p>•发送者：<br>        第一步：创建套接字socket。<br>        第二步：向多播地址发送数据sendto。<br>•接收者：<br>        第一步：创建套接字socket。<br>        第二步：设置为加入多播组setsockopt（）。<br>        第三步：将套接字与多播信息结构体绑定。<br>        第四步：接收数据。   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多播地址结构体名字</span><br><span class="line">struct in_addr；</span><br><span class="line"></span><br><span class="line">struct ip_mreq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%8F%82%E6%95%B0.png"><br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%92%AD%E5%8F%82%E6%95%B02.png"></p><h3 id="7-2-0、-多播套接口选项"><a href="#7-2-0、-多播套接口选项" class="headerlink" title="7-2-0、 多播套接口选项"></a>7-2-0、 多播套接口选项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int setsockopt(int socket, int level, int option_name,</span><br><span class="line">const void *option_value, socklen_t option_len);</span><br><span class="line">功能：设置一个套接字的选项（属性）</span><br><span class="line">参数：</span><br><span class="line">socket：文件描述符</span><br><span class="line">level：协议层次</span><br><span class="line">IPPROTO_IP IP层次</span><br><span class="line">option_name：选项的名称</span><br><span class="line"> IP_ADD_MEMBERSHIP 加入多播组</span><br><span class="line"> option_value：设置的选项的值</span><br><span class="line"> struct ip_mreq</span><br><span class="line"> &#123;</span><br><span class="line"> struct in_addr imr_multiaddr; //组播ip地址</span><br><span class="line"> struct in_addr imr_interface; //主机地址</span><br><span class="line"> INADDR_ANY 任意主机地址（自动获取你的主机地址）</span><br><span class="line"> &#125;;</span><br><span class="line"> option_len：option_value的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h3 id="7-2-1、发送者"><a href="#7-2-1、发送者" class="headerlink" title="7-2-1、发送者"></a>7-2-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using : %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**第一步，创建套接字**/</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    /********* ip地址必须设置为224.xxx.xxx.xxx 到239.... *********/</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    addrlen = sizeof(sendaddr);</span><br><span class="line">    /**发送数据**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, sizeof(buf),stdin);</span><br><span class="line">        buf[sizeof(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;sendaddr,addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2、接收者"><a href="#7-2-2、接收者" class="headerlink" title="7-2-2、接收者"></a>7-2-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in recaddr;</span><br><span class="line">    </span><br><span class="line">    /***创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /***加入多播组**/</span><br><span class="line">    struct ip_mreq mreq;</span><br><span class="line">    mreq.imr_multiaddr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    /** INADDR_ANY表示任意主机**/</span><br><span class="line">    mreq.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    if(setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_setsockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    recaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    recaddr.sin_family = AF_INET;</span><br><span class="line">    recaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    addrlen = sizeof(recaddr);</span><br><span class="line">    /**绑定组播信息结构体**/</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;recaddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /** 进行通信***/</span><br><span class="line">    char text[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, text, sizeof(text), 0 , (struct sockaddr *)&amp;sendaddr,&amp;addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;,inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8、tcp"><a href="#8、tcp" class="headerlink" title="8、tcp"></a>8、tcp</h1><h2 id="8-1、tcp与udp对比"><a href="#8-1、tcp与udp对比" class="headerlink" title="8-1、tcp与udp对比"></a>8-1、tcp与udp对比</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcp%E4%B8%8Eudp%E7%9A%84%E5%AF%B9%E6%AF%94.png"><br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcp%E4%B8%8Eudp%E7%9A%84%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94.png"></p><h2 id="8-2、流程"><a href="#8-2、流程" class="headerlink" title="8-2、流程"></a>8-2、流程</h2><p>•服务器：<br>    创建套接字socket（）。<br>        将套接字与服务器网络信息结构体绑定。<br>        将套接字设置为监听状态listen（）。<br>        阻塞等待客户端的连接请求accept（）。<br>        进行通信recv（）&#x2F;send（）。<br>        关闭套接字close（）。  </p><p>•客户端：<br>        创建套接字socket（）。<br>        发送客户端连接请求connect（）。<br>        进行通信send（）&#x2F;recv（）。<br>        关闭套接字close。   </p><pre><code>1、这里的socket的要使用的tcp的参数。2、connect作用是跟服务器建立连接，    连接成功后才可以进行tcp的数据传输。    连接成功后不会产生新的套接字。3、send函数，ssize_t send(int sockfd, const void *buf, size_t len, int flags);功能用于发送数据。    以下为各个函数的详细介绍：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int socket(int domain, int type, int protocol);</span><br><span class="line">功能：创建一个套接字，返回一个文件描述符</span><br><span class="line">参数：</span><br><span class="line">domain：通信域，协议族</span><br><span class="line">AF_UNIX 本地通信</span><br><span class="line">AF_INET ipv4网络协议</span><br><span class="line">AF_INET6 ipv6网络协议</span><br><span class="line"> AF_PACKET 底层接口</span><br><span class="line"> type：套接字的类型</span><br><span class="line"> SOCK_STREAM 流式套接字（tcp）</span><br><span class="line"> SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line"> SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line"> protocol：附加协议，如果不需要，则设置为0</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：文件描述符</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">connect：</span><br><span class="line">connect函数：</span><br><span class="line"> #include &lt;sys/types.h&gt; </span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"> 功能：给服务器发送客户端的连接请求</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符，socket函数的返回值</span><br><span class="line"> addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line"> addrlen：add的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>注意：    1、connect建立连接之后不会产生新的套接字    2、连接成功后才可以开始传输TCP数据    3、头文件：#include &lt;sys/socket.h&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">socket</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"> 功能：发送数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：发送的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>    注意：不能用tcp协议发送0长度的数据包。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">send：</span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"> 功能：发送数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line">客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：发送的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><p><code>不能用TCP协议发送0长度的数据包</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">recv：</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"> 功能：接收数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：保存接收到的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line">成功：接收的字节数</span><br><span class="line"> 失败：‐1</span><br><span class="line"> 如果发送端关闭文件描述符或者关闭进程，则recv函数会返回0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bind：</span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line"> 功能：将套接字与网络信息结构体绑定</span><br><span class="line"> 参数：</span><br><span class="line">sockfd：文件描述符，socket的返回值</span><br><span class="line"> addr：网络信息结构体</span><br><span class="line"> 通用结构体（一般不用）</span><br><span class="line"> struct sockaddr</span><br><span class="line"> 网络信息结构体 sockaddr_in</span><br><span class="line"> #include &lt;netinet/in.h&gt;</span><br><span class="line"> struct sockaddr_in</span><br><span class="line"> addrlen：addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">listen：</span><br><span class="line"> #include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int listen(int sockfd, int backlog);</span><br><span class="line"> 功能：将套接字设置为被动监听状态，这样做之后就可以接收到连接请求</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符，socket函数返回值</span><br><span class="line"> backlog：允许通信连接的主机个数，一般设置为5、10</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">accept：</span><br><span class="line"> #include &lt;sys/types.h&gt; /* See NOTES */</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line"> 功能：阻塞等待客户端的连接请求</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符，socket函数的返回值</span><br><span class="line"> addr：接收到的客户端的信息结构体（自动填充，定义变量即可）</span><br><span class="line"> addrlen：addr的长度</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：新的文件描述符（只要有客户端连接，就会产生新的文件描述符，</span><br><span class="line"> 这个新的文件描述符专门与指定的客户端进行通信的）</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h3 id="8-2-1、客户端"><a href="#8-2-1、客户端" class="headerlink" title="8-2-1、客户端"></a>8-2-1、客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">客户端代码示例</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /***SOCK_STREAM TCP的流式套接字***/</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t socklen;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    socklen = sizeof(serveraddr);</span><br><span class="line">    if(connect(sockfd,(struct sockaddr *)&amp;serveraddr,socklen) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_connect&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    fgets(buf, 128, stdin);</span><br><span class="line">    buf[sizeof(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">    if(send(sockfd, buf, 128, 0) == -1)</span><br><span class="line">    &#123; </span><br><span class="line">        perror(&quot;failed_send&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char text[128] = &quot;&quot;;</span><br><span class="line">    if(recv(sockfd, text, 128, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_recv&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;from server: %s\r\n&quot;,text);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-2、服务器"><a href="#8-2-2、服务器" class="headerlink" title="8-2-2、服务器"></a>8-2-2、服务器</h3><pre><code>做为TCP服务器需要具备那些条件1、让操作系统知道是一个服务器，而不是一个客户端。2、具备一个明知的地址。3、等待连接的到来。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">     if(argc &lt; 3)</span><br><span class="line">     &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     int sockfd;</span><br><span class="line">     sockfd = socket(AF_INET, SOCK_STREAM, 0);</span><br><span class="line">     if(sockfd &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     struct sockaddr_in serveraddr;</span><br><span class="line">     socklen_t socklen;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">     serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">     socklen = sizeof(serveraddr);</span><br><span class="line">     if(bind(sockfd,(struct sockaddr *)&amp;serveraddr,socklen))</span><br><span class="line">     &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     /***将套接字设置为监听状态***/</span><br><span class="line">     /***同一时刻连接的最大数量******/</span><br><span class="line">     if(listen(sockfd,10))</span><br><span class="line">     &#123;</span><br><span class="line">        perror(&quot;failed_listen&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     /****阻塞等待客户端的链接请求****/</span><br><span class="line">     int acceptfd;</span><br><span class="line">     struct sockaddr_in clientaddr;</span><br><span class="line">     acceptfd = accept(sockfd,(struct sockaddr *)&amp;clientaddr,&amp;socklen);</span><br><span class="line">     if(acceptfd == -1)</span><br><span class="line">     &#123;  </span><br><span class="line">        perror(&quot;failed_accept&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">     &#125;</span><br><span class="line">     /***打印连接的客户端信息****/</span><br><span class="line">     printf(&quot;ip:%s, port = %d&quot;,inet_ntoa(clientaddr.sin_addr),htons(clientaddr.sin_port));</span><br><span class="line">     /****进行通讯*******/</span><br><span class="line">     /**tcp服务器与客户端通信时，需要使用accept函数返回值***/</span><br><span class="line">    char buf[128] =  &quot;&quot;;</span><br><span class="line">    if(recv(acceptfd, buf, 128,0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_recv&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    strcat(buf,&quot;__ygc&quot;);</span><br><span class="line">    printf(&quot;from client : %s\r\n&quot;,buf);</span><br><span class="line">    if(send(acceptfd, buf, 128, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_send&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**关闭套接字**/</span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>运行是先运行服务器，进入阻塞等待连接等过程。然后在运行客户端。</code></pre><h2 id="8-3、-close关闭套接字"><a href="#8-3、-close关闭套接字" class="headerlink" title="8-3、 close关闭套接字"></a>8-3、 close关闭套接字</h2><p>•1、使用close函数即可关闭套接字<br><code>关闭一个代表已连接套接字将导致另一端接收到一个0长度的数据包（很重要）。</code><br>•2、做服务器时<br>1&gt;关闭监听套接字将导致服务器无法接收新的连接，但不会影响已经建立的连接。<br>（关闭sockfd，并不影响已经建立的连接）<br>2&gt;关闭accept返回的已连接套接字将导致它所代表的连接被关闭，但不会影响服务器的监听<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/close%E5%85%B3%E9%97%AD%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E7%9B%91%E5%90%AC.png"><br>•3、做客户端时<br>关闭连接就是关闭连接，不意味着其他</p><h2 id="8-4、三次握手"><a href="#8-4、三次握手" class="headerlink" title="8-4、三次握手"></a>8-4、三次握手</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><pre><code>相当于客户端向服务器说我要连接，服务器回答可以，然后接受连接，问客户端，你连接上了吗？客户端回答连接上了。</code></pre><h2 id="8-5、四次挥手"><a href="#8-5、四次挥手" class="headerlink" title="8-5、四次挥手"></a>8-5、四次挥手</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p><pre><code>（客户端说我要关闭了，服务器说知道了，    服务器又发那我也关了，客户端回答好的）</code></pre><h1 id="9、tpc并发服务器"><a href="#9、tpc并发服务器" class="headerlink" title="9、tpc并发服务器"></a>9、tpc并发服务器</h1><pre><code>TCP原本不是并发服务器，TCP服务器同一时间只能与一个客户端通信原始代码：</code></pre><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">//tcp服务器的实现</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line">#define ERR_LOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    int sockfd, acceptfd;</span><br><span class="line">    struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    //第一步：创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将套接字设置为允许重复使用本机地址或者设置为端口复用</span><br><span class="line">    int on = 1;</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二步：填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：将套接字设置为被动监听状态</span><br><span class="line">    if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第五步：阻塞等待客户端的连接请求</span><br><span class="line">    if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印客户端的信息</span><br><span class="line">    printf(&quot;%s -- %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    //第六步：进行通信</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        //注意：tcp中服务器与客户端通信时，一定要用accept函数的返回值来通信</span><br><span class="line">        if((bytes = recv(acceptfd, buf, N, 0)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(bytes == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;The client quited\n&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;from client: %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">        strcat(buf, &quot; ^_^&quot;);</span><br><span class="line">        if(send(acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //第七步：关闭套接字</span><br><span class="line">    close(acceptfd);</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 128  //这里的\是连接符，工作了这么久竟然不知</span><br><span class="line">#define ERR_LOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line"></span><br><span class="line">    //第一步：创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二步：填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    //第三步：发送客户端连接请求</span><br><span class="line">    if(connect(sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to connect&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：进行通信</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, N, stdin);</span><br><span class="line">        buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">        if(send(sockfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(recv(sockfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;from server: %s\n&quot;, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：关闭套接字</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>以上，代码可以证明测试。tcp并不是一个并发服务器，一次只能和一个客户端进行通信。原因：TCP不能实现并发的原因：由于TCP服务器端有两个读阻塞函数，accept和recv，两个函数需要先后运行，所以导致运行一个函数的时候另一个函数无法执行，所以无法保证一边连接客户端，一边与其他客户端通信如何实现TCP并发服务器：使用多进程实现TCP并发服务器使用多线程实现TCP并发服务器</code></pre><h2 id="9-1、使用进程实现并发服务器操作"><a href="#9-1、使用进程实现并发服务器操作" class="headerlink" title="9-1、使用进程实现并发服务器操作"></a>9-1、使用进程实现并发服务器操作</h2><pre><code>我们设想,要实现并发操作，这个进程fork在哪里去实现，将while的循环位置前移，进入父进程什么都不用去执行，目标只要创建一个子进程就足够。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int sockfd = socket()</span><br><span class="line">bind()</span><br><span class="line">listen()</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> acceptfd = accept() ;</span><br><span class="line">pid = fork();</span><br><span class="line">if(pid &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> else if(pid == 0)</span><br><span class="line"> &#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> recv()/send()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">这个是基本流程。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"></span><br><span class="line">//使用多进程实现TCP并发服务器</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line">#define ERR_LOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    wait(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    int sockfd, acceptfd;</span><br><span class="line">    struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    //第一步：创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将套接字设置为允许重复使用本机地址或者为设置为端口复用</span><br><span class="line">    int on = 1;</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第二步：填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第四步：将套接字设置为被动监听状态</span><br><span class="line">    if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //使用信号，异步的方式处理僵尸进程，如果出现子进程断开连接的情况，就进行回收进程资源</span><br><span class="line">    signal(SIGCHLD, handler);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        //第五步：阻塞等待客户端的连接请求</span><br><span class="line">        if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //打印客户端的信息</span><br><span class="line">        printf(&quot;%s -- %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        //使用fork函数创建子进程，父进程继续负责连接，子进程负责与客户端通信</span><br><span class="line">        pid_t pid;</span><br><span class="line">        if((pid = fork()) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERR_LOG(&quot;fail to fork&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(pid &gt; 0) //父进程负责执行accept，所以if语句结束后继续在accept函数的位置阻塞</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        else //子进程负责跟指定的客户端通信</span><br><span class="line">        &#123;</span><br><span class="line">            char buf[N] = &quot;&quot;;</span><br><span class="line">            ssize_t bytes;</span><br><span class="line">            while (1)</span><br><span class="line">            &#123;</span><br><span class="line">                if((bytes = recv(acceptfd, buf, N, 0)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else if(bytes == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;The client quited\n&quot;);</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    exit(0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                printf(&quot;from client: %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line">                strcat(buf, &quot; ^_^&quot;);</span><br><span class="line">                if(send(acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%B9%B6%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><pre><code>完美实现</code></pre><h2 id="9-2、使用多线程实现并发操作"><a href="#9-2、使用多线程实现并发操作" class="headerlink" title="9-2、使用多线程实现并发操作"></a>9-2、使用多线程实现并发操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    recv() / send()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sockfd = socket()</span><br><span class="line"> bind()</span><br><span class="line"> listen()</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    accept()</span><br><span class="line">    //只要有客户端连接上，则创建一个子线程与之通信</span><br><span class="line">    pthread_create(, , thread_fun, );</span><br><span class="line">    pthread_detach();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line"> #include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line"> #define N 128</span><br><span class="line"> #define ERR_LOG(errmsg) do&#123;\</span><br><span class="line"> perror(errmsg);\</span><br><span class="line"> exit(1);\</span><br><span class="line"> &#125;while(0)</span><br><span class="line"></span><br><span class="line"> typedef struct&#123;</span><br><span class="line"> struct sockaddr_in addr;</span><br><span class="line"> int acceptfd;</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> void *pthread_fun(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char buf[N] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> MSG msg = *(MSG *)arg;</span><br><span class="line"> while (1)</span><br><span class="line">    &#123;</span><br><span class="line">    if((bytes = recv(msg.acceptfd, buf, N, 0)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    else if(bytes == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;The client quited\n&quot;);</span><br><span class="line">        pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    if(strncmp(buf, &quot;quit&quot;, 4) == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;The client quited\n&quot;);</span><br><span class="line">        pthread_exit(NULL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;[%s - %d]: %s\n&quot;, inet_ntoa(msg.addr.sin_addr), ntohs(msg.addr.sin_port), buf);</span><br><span class="line"></span><br><span class="line">    strcat(buf, &quot; ^_^&quot;);</span><br><span class="line">    if(send(msg.acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0]);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> int sockfd, acceptfd;</span><br><span class="line"> struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line"> socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line"> //第一步：创建套接字</span><br><span class="line"> if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //将套接字设置为允许重复使用本机地址或者为设置为端口复用</span><br><span class="line"> int on = 1;</span><br><span class="line"> if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第二步：填充服务器网络信息结构体</span><br><span class="line"> serveraddr.sin_family = AF_INET;</span><br><span class="line"> serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line"> serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line"> //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line"> if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第四步：将套接字设置为被动监听状态</span><br><span class="line"> if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">     //第五步：阻塞等待客户端的连接请求</span><br><span class="line">     if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     //打印客户端的信息</span><br><span class="line">     //printf(&quot;%s -- %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">     //创建子线程与客户端进行通信</span><br><span class="line">     MSG msg;</span><br><span class="line">     msg.addr = clientaddr;</span><br><span class="line">     msg.acceptfd = acceptfd;</span><br><span class="line">     pthread_t thread;</span><br><span class="line">     if(pthread_create(&amp;thread, NULL, pthread_fun, &amp;msg) != 0)</span><br><span class="line">         &#123;</span><br><span class="line">         ERR_LOG(&quot;fail to pthread_create&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">     pthread_detach(thread);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="10、Web服务器"><a href="#10、Web服务器" class="headerlink" title="10、Web服务器"></a>10、Web服务器</h1><h2 id="10-1-web服务器简介"><a href="#10-1-web服务器简介" class="headerlink" title="10.1 web服务器简介"></a>10.1 web服务器简介</h2><p>•Web服务器又称WWW服务器、<br>网站服务器等。  </p><p>•特点：<br>使用HTTP协议与客户机浏览器进行信息交流不仅能存储信息，<br>还能在用户通过web浏览器提供的信息的基础上运行脚本和程序，<br>该服务器需可安装在UNIX、Linux或Windows等操作系统上，<br>著名的服务器有Apache、Tomcat、 IIS等。</p><h2 id="10-2-HTTP协议"><a href="#10-2-HTTP协议" class="headerlink" title="10.2 HTTP协议"></a>10.2 HTTP协议</h2><pre><code>Webserver—HTTP协议（超文本协议）概念：一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议特点：1、支持C/S架构2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径 ，常用方法:GET、POST3、无连接：限制每次连接只处理一个请求4、无状态：即如果后续处理需要前面的信息，它必须重传，这样可能导致每次连接传送的数据量会增大</code></pre><h2 id="10-3-Webserver通信过程"><a href="#10-3-Webserver通信过程" class="headerlink" title="10.3 Webserver通信过程"></a>10.3 Webserver通信过程</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/webserver%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png"></p><h2 id="10-4-Web编程开发"><a href="#10-4-Web编程开发" class="headerlink" title="10.4 Web编程开发"></a>10.4 Web编程开发</h2><p>•网页浏览（使用GET方式）<br>web服务器的ip地址是192.168.3.103，端口号是9999，要访问的网页是about.html<br>浏览器输入的格式为：<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/web%E7%BC%96%E6%88%90%E5%BC%80%E5%8F%91.png"><br>服务器收到的数据<br><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/web%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E5%A4%B4.png"></p><pre><code>服务器应答的格式：服务器接收到浏览器发送的数据之后，需要判断GET/后面跟的网页是否存在，如果存在则请求成功，发送指定的指令，并发送文件内容给浏览器，如果不存在，则发送请求失败的指令。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成功</span><br><span class="line">1 &quot;HTTP/1.1 200 OK\r\n&quot; \</span><br><span class="line">2 &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line">3 &quot;\r\n&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">失败</span><br><span class="line">1 &quot;HTTP/1.1 404 Not Found\r\n&quot; \</span><br><span class="line">2 &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line">3 &quot;\r\n&quot; \</span><br><span class="line">4 &quot;&lt;HTML&gt;&lt;BODY&gt;File not found&lt;/BODY&gt;&lt;/HTML&gt;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">案例</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> #include &lt;sys/stat.h&gt;</span><br><span class="line"> #include &lt;fcntl.h&gt;</span><br><span class="line"> #include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line"> #define N 1024</span><br><span class="line"> #define ERR_LOG(errmsg) do&#123;\</span><br><span class="line"> perror(errmsg);\</span><br><span class="line"> printf(&quot;%s ‐ %s ‐ %d\n&quot;, __FILE__, __func__, __LINE__);\</span><br><span class="line"> exit(1);\</span><br><span class="line"> &#125;while(0)</span><br><span class="line"></span><br><span class="line"> void *pthread_fun(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> int acceptfd = *(int *)arg;</span><br><span class="line"> char buf[N] = &quot;&quot;;</span><br><span class="line"> char head[]=&quot;HTTP/1.1 200 OK\r\n&quot; \</span><br><span class="line"> &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line"> &quot;\r\n&quot;;</span><br><span class="line"> char err[]= &quot;HTTP/1.1 404 Not Found\r\n&quot; \</span><br><span class="line"> &quot;Content‐Type: text/html\r\n&quot; \</span><br><span class="line"> &quot;\r\n&quot; \</span><br><span class="line"> &quot;&lt;HTML&gt;&lt;BODY&gt;File not found&lt;/BODY&gt;&lt;/HTML&gt;&quot;;</span><br><span class="line"></span><br><span class="line"> //接收浏览器通过http协议发送的数据包</span><br><span class="line"> if(recv(acceptfd, buf, N, 0) &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">     ERR_LOG(&quot;fail to recv&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;*****************************\n\n&quot;);</span><br><span class="line"> printf(&quot;%s\n&quot;, buf);</span><br><span class="line"> // int i;</span><br><span class="line"> // for(i = 0; i &lt; 200; i++)</span><br><span class="line"> // &#123;</span><br><span class="line"> // printf(&quot;[%c] ‐ %d\n&quot;, buf[i], buf[i]);</span><br><span class="line"> // &#125;</span><br><span class="line"> printf(&quot;\n*****************************\n&quot;);</span><br><span class="line"></span><br><span class="line"> //通过获取的数据包中得到浏览器要访问的网页文件名</span><br><span class="line"> //GET /about.html http/1.1</span><br><span class="line"> char filename[128] = &quot;&quot;;</span><br><span class="line"> sscanf(buf, &quot;GET /%s&quot;, filename); //sscanf函数与空格结束，所以直接可以获取文件名</span><br><span class="line"></span><br><span class="line"> if(strncmp(filename, &quot;HTTP/1.1&quot;, strlen(&quot;http/1.1&quot;)) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    strcpy(filename, &quot;about.html&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> printf(&quot;filename = %s\n&quot;, filename);</span><br><span class="line"></span><br><span class="line"> char path[128] = &quot;./sqlite/&quot;;</span><br><span class="line"> strcat(path, filename);</span><br><span class="line"></span><br><span class="line"> //通过解析出来的网页文件名，查找本地中有没有这个文件</span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(path, O_RDONLY)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    //如果文件不存在，则发送不存在对应的指令</span><br><span class="line">    if(errno == ENOENT)</span><br><span class="line">       &#123;</span><br><span class="line">       if(send(acceptfd, err, strlen(err), 0) &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">       ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       close(acceptfd);</span><br><span class="line">       pthread_exit(NULL);</span><br><span class="line">       &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to open&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //如果文件存在，先发送指令告知浏览器</span><br><span class="line"> if(send(acceptfd, head, strlen(head), 0) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //读取网页文件中的内容并发送给浏览器</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> char text[1024] = &quot;&quot;;</span><br><span class="line"> while((bytes = read(fd, text, 1024)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    if(send(acceptfd, text, bytes, 0) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to send&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> pthread_exit(NULL);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">    fprintf(stderr, &quot;Usage: %s &lt;server_ip&gt; &lt;server_port&gt;\n&quot;, argv[0])</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> int sockfd, acceptfd;</span><br><span class="line"> struct sockaddr_in serveraddr, clientaddr;</span><br><span class="line"> socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line"> //第一步：创建套接字</span><br><span class="line"> if((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //将套接字设置为允许重复使用本机地址或者为设置为端口复用</span><br><span class="line"> int on = 1;</span><br><span class="line"> if(setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to setsockopt&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第二步：填充服务器网络信息结构体</span><br><span class="line"> serveraddr.sin_family = AF_INET;</span><br><span class="line"> serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line"> serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line"> //第三步：将套接字与服务器网络信息结构体绑定</span><br><span class="line"> if(bind(sockfd, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to bind&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //第四步：将套接字设置为被动监听状态</span><br><span class="line"> if(listen(sockfd, 5) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    ERR_LOG(&quot;fail to listen&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    //第五步：阻塞等待客户端的连接请求</span><br><span class="line">    if((acceptfd = accept(sockfd, (struct sockaddr *)&amp;clientaddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to accept&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    //打印客户端的信息</span><br><span class="line">    printf(&quot;%s ‐‐ %d\n&quot;, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));</span><br><span class="line"></span><br><span class="line">    //创建线程接收数据并处理数据</span><br><span class="line">    pthread_t thread;</span><br><span class="line">    if(pthread_create(&amp;thread, NULL, pthread_fun, &amp;acceptfd) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">        ERR_LOG(&quot;fail to pthread_create&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    pthread_detach(thread);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="11、网络通信过程"><a href="#11、网络通信过程" class="headerlink" title="11、网络通信过程"></a>11、网络通信过程</h1><h2 id="11-1、网络通信概述"><a href="#11-1、网络通信概述" class="headerlink" title="11-1、网络通信概述"></a>11-1、网络通信概述</h2><p>•网络通信过程分析软件<br>Packet Tracer 是由Cisco公司发布的一个辅助学习工具，提供了设计、配置、<br>排除网络故障网络模拟环境可以直接使用拖曳方法建立网络拓扑，<br>并可提供数据包在网络中行进的详细处理过程，<br>观察网络实时运行情况。  </p><h2 id="11-2、通信过程（PC-switch）"><a href="#11-2、通信过程（PC-switch）" class="headerlink" title="11-2、通信过程（PC+switch）"></a>11-2、通信过程（PC+switch）</h2><h3 id="11-2-1、-交换机介绍"><a href="#11-2-1、-交换机介绍" class="headerlink" title="11-2-1、 交换机介绍"></a>11-2-1、 交换机介绍</h3><pre><code>网络交换机（又称“网络交换器”），是一个扩大网络的器材，可以把更多的计算机等。网络设备连接到当前的网络中。具有性价比高、高度灵活、相对简单、易于实现等特点以太网技术已成为当今最重要的一种局域网组网技术，网络交换机也就成为了最普及的交换机。</code></pre><h3 id="2-2-交换机功能"><a href="#2-2-交换机功能" class="headerlink" title="2.2 交换机功能"></a>2.2 交换机功能</h3><pre><code>1、转发过滤：当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口）2、学习功能：以太网交换机了解每一端口相连设备的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中3、目前交换机还具备了一些新的功能，如对VLAN（虚拟局域网）的支持、对链路汇聚的支持，甚至有的还具有防火墙的功能</code></pre><h3 id="2-3-通信过程（PC-switch）"><a href="#2-3-通信过程（PC-switch）" class="headerlink" title="2.3 通信过程（PC+switch）"></a>2.3 通信过程（PC+switch）</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/pc+switch%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><pre><code>总结：如果PC不知目标IP所对应的MAC，那么可以看出，PC会先发送ARP广播，得到对方的MAC然后，再进行数据的传送，当switch第一次收到ARP广播数据，会把ARP广播数据包转发给所有端口（除来源端口）；如果以后还有PC询问此IP的MAC，那么只是向目标的端口进行转发数据每台PC都会有一个ARP缓存表，用来记录IP所对应的的MAC。 </code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/arp%E6%9F%A5%E7%9C%8Bip%E5%9C%B0%E5%9D%80%E5%8F%8A%E5%85%B6mac%E5%9C%B0%E5%9D%80.png"></p><pre><code>注意：arp表不是永久的，过一段时间之后就会将没有通信的主机的ip地址以及其mac地址从表中移除</code></pre><h2 id="11-3、通信过程（PC-switch-router）"><a href="#11-3、通信过程（PC-switch-router）" class="headerlink" title="11-3、通信过程（PC+switch+router）"></a>11-3、通信过程（PC+switch+router）</h2><h3 id="11-3-1、-路由器介绍"><a href="#11-3-1、-路由器介绍" class="headerlink" title="11-3-1、 路由器介绍"></a>11-3-1、 路由器介绍</h3><pre><code>路由器（Router）又称网关设备（Gateway）是用于连接多个逻辑上分开的网络所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成具有判断网络地址和选择IP路径的功能。路由器工作在网络层，可以实现不同网段的主机之间进行通信。</code></pre><h3 id="11-3-2、-通信过程（PC-switch-router）"><a href="#11-3-2、-通信过程（PC-switch-router）" class="headerlink" title="11-3-2、 通信过程（PC+switch+router）"></a>11-3-2、 通信过程（PC+switch+router）</h3><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/pc+switch+router.png"></p><pre><code>总结：不在同一网段的PC，需要设置默认网关才能把数据传送过去,通常情况下都会把路由器设为默认网关,当路由器收到一个其它网段的数据包时，会根据“路由表”来决定把此数据包发送到哪个端口；路由表的设定有静态和动态方法设置路由表就是设置下一跳，指定当前网段的主机与另一个网段主机通信是数据报应该交给那个路由器。</code></pre><h2 id="11-4、通信过程（浏览器跨网访问Web服务器）"><a href="#11-4、通信过程（浏览器跨网访问Web服务器）" class="headerlink" title="11-4、通信过程（浏览器跨网访问Web服务器）"></a>11-4、通信过程（浏览器跨网访问Web服务器）</h2><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E7%BD%91%E8%AE%BF%E9%97%AEweb%E6%9C%8D%E5%8A%A1%E5%99%A8.png"></p><pre><code>总结1、DNS服务器的作用是解析出IP2、DFGATEWAY指定发往其它网段的数据包转发的路径3、在路由器中路由表指定数据包的“下一跳”的地址4、公有IP、私有IP</code></pre><h1 id="12、原始套接字"><a href="#12、原始套接字" class="headerlink" title="12、原始套接字"></a>12、原始套接字</h1><h2 id="12-1、TCP、UDP开发回顾"><a href="#12-1、TCP、UDP开发回顾" class="headerlink" title="12-1、TCP、UDP开发回顾"></a>12-1、TCP、UDP开发回顾</h2><pre><code>数据报式套接字（SOCK_DGRAM）1、无连接的socket,针对无连接的 UDP 服务2、可通过邮件模型来进行对比</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E9%82%AE%E4%BB%B6%E6%A8%A1%E5%9E%8B.png"></p><pre><code>流式套接字（SOCK_STREAM）1、面向连接的socket,针对面向连接的 TCP 服务2、可通过电话模型来进行对比这两类套接字似乎涵盖了TCP/IP 应用的全部TCP与UDP各自有独立的port互不影响一个进程可同时拥有多个port不必关心tcp/ip协议实现的过程</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png"></p><h3 id="12-1-1、-UDP-编程回顾"><a href="#12-1-1、-UDP-编程回顾" class="headerlink" title="12-1-1、 UDP 编程回顾"></a>12-1-1、 UDP 编程回顾</h3><pre><code>client1、创建socket接口2、定义sockaddr_in变量，其中ip、port为目的主机的信息3、可发送0长度的数据包server1、bind本地主机的ip、port等信息2、接收到的数据包中包含来源主机的ip、port信息</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/udp%E7%BC%96%E6%88%90%E5%9B%9E%E9%A1%BE.png"></p><h3 id="12-1-2、-TCP编程回顾"><a href="#12-1-2、-TCP编程回顾" class="headerlink" title="12-1-2、 TCP编程回顾"></a>12-1-2、 TCP编程回顾</h3><pre><code>clientconnect来建立连接send、recv收发数据不可发送0长度的数据serverbind本地主机的ip、port等信息listen把主动套接字变为被动accept会有新的返回值多进程、线程完成并发</code></pre><p><img src="./../../../../img/4_%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/tcp%E7%BC%96%E7%A8%8B%E5%9B%9E%E9%A1%BE.png"></p><h2 id="12-2、原始套接字概述、创建"><a href="#12-2、原始套接字概述、创建" class="headerlink" title="12-2、原始套接字概述、创建"></a>12-2、原始套接字概述、创建</h2><pre><code>2.1 原始套接字概述原始套接字（SOCK_RAW）1、一种不同于SOCK_STREAM、SOCK_DGRAM的套接字，它实现于系统核心2、可以接收本机网卡上所有的数据帧（数据包）,对于监听网络流量和分析网络数据很有作用3、开发人员可发送自己组装的数据包到网络上4、广泛应用于高级网络编程5、网络专家、黑客通常会用此来编写奇特的网络程序</code></pre><p><code>流式套接字只能收发</code><br><code>TCP协议的数据</code><br><code>数据报套接字只能收发</code><br><code>UDP协议的数据</code><br><code>原始套接字可以收发</code><br><code>1、内核没有处理的数据包，因此要访问其他协议</code><br><code>2、发送的数据需要使用，原始套接字(SOCK_RAW)</code></p><h1 id="重要补充"><a href="#重要补充" class="headerlink" title="重要补充"></a>重要补充</h1><p>udp在通讯结束后也需要用close关闭描述符。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg</title>
      <link href="/posts/2ffce39e.html"/>
      <url>/posts/2ffce39e.html</url>
      
        <content type="html"><![CDATA[<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>ffplay -ar 8000 -ac 1 -f mulaw out.g711u<br>-ar 指定音频采样率<br>-ac 指定音频声道数<br>-f 指定音频格式，这里使用mulaw格式</p><p>将wav音频转换为mulaw格式(g711u)<br>ffmpeg -i input.wav -ar 8000 -ac 1 -acodec pcm_mulaw output.ulaw<br>-i 指定输入文件<br>-ar 指定音频采样率<br>-ac 指定音频声道数<br>-acodec 指定音频编码格式，这里使用pcm_mulaw</p><p>将mp3音频转换为wav格式，再转为mulaw格式才行，直接转有概率转的不对<br>ffmpeg -i song.mp3 -ar 8000 -ac 1 -ab 8 song.wav<br>-i 指定输入文件<br>-ar 指定音频采样率<br>-ac 指定音频声道数<br>-ab 指定音频码率</p><h1 id="PCM（脉冲编码调制）在FFmpeg中有以下常见类型："><a href="#PCM（脉冲编码调制）在FFmpeg中有以下常见类型：" class="headerlink" title="PCM（脉冲编码调制）在FFmpeg中有以下常见类型："></a>PCM（脉冲编码调制）在FFmpeg中有以下常见类型：</h1><p>pcm_s16le<br>16位有符号小端格式（Signed 16-bit Little Endian），常用于WAV文件的默认编码。</p><p>pcm_s16be<br>16位有符号大端格式（Signed 16-bit Big Endian），适用于特定硬件或协议需求。</p><p>pcm_u8<br>8位无符号格式（Unsigned 8-bit），数据范围0-255，音质较低但兼容老设备。</p><p>pcm_mulaw<br>G.711 μ-law编码，用于电话音频压缩，压缩比高但音质有限（如示例中的pcm_mulaw）。</p><p>pcm_alaw<br>G.711 A-law编码，与μ-law类似，适用于欧洲和中国的电话系统。</p><p>pcm_f32le&#x2F;pcm_f64le<br>32&#x2F;64位浮点格式（Float 32&#x2F;64-bit LE），用于高精度音频处理。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频协议 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中断</title>
      <link href="/posts/81483be3.html"/>
      <url>/posts/81483be3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux中中断"><a href="#Linux中中断" class="headerlink" title="Linux中中断"></a>Linux中中断</h1><p>在linux在中，嵌套中断被被禁止。<br>回顾：单片机中，嵌套中断是当前中断发生时，被优先级更高的中断打断，<br>优先执行级别更高的中断。</p><p>由于Linux的异步I&#x2F;O、进程调度等很多重要操作都依赖于中断，中断对于内核的运行非常重要，在屏蔽中断期间所有的中断都无法得到处理，因此长时间屏蔽中断是很危险的，这有可能造成数据丢失乃至系统崩溃等后果。这就要求在屏蔽了中断之后，当前的内核执行路径应当尽快地执行完临界区的代码。</p><p>向量表中保存了一系列的跳转指令，当系统发生异常时，由处理器负责将程序执行流转到向量表中的跳转指令，最常见的就是中断向量，应用工程师只需要使用固定的函数名编写中断处理程序，在中断发生时该中断处理程序就会被自动调用，这背后的实现就是中断向量表的功劳。</p><p>在 armv7 中，中断向量表可以设置在两个地址：0x00000000 和 0xffff0000，由协处理器 cp15 的 SCTLR 的 bit13 来控制，默认情况下，中断向量表的位置在 0x00000000，实际上，对于操作系统而言，比如 linux，会更倾向于将中断向量表放在 0xffff0000 处，因为 0x0 处在用户空间下，需要额外做一些限制，而 0xffff0000 处在内核空间，另一方面，0 地址通常是 NULL 指针访问的地址，这需要 MMU 做相应的访问限制规则，总之，将向量表放在高地址处会更方便。</p><p><img src="../../../../../img/7_linux%E5%BC%80%E5%8F%91/linux%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E5%9C%B0%E5%9D%80.png"><br>当对应的 exception event 发生时，系统会自动地修改 CPSR 状态寄存器，并跳转到上表中的地址执行指令，而软件上要做的，就是在该地址上放置对应的代码，除了 FIQ 之外，其它模式对应的都是一条跳转指令，如果存放多于 4 字节的指令，将会覆盖调用后续的异常向量，因为 FIQ 是最后一条异常向量，根据其特殊性，FIQ 的处理指令可以直接放置在以 oxffff001c 处，当然，具体怎么做由软件的实现来决定。</p><p>比如，在 U-boot 中，armv7 对应的 vector.S 中(启动代码)可以看到这样的代码(uboot中向量表配置在0地址处)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    b   reset</span><br><span class="line">    ldr pc, _undefined_instruction</span><br><span class="line">    ldr pc, _software_interrupt</span><br><span class="line">    ldr pc, _prefetch_abort</span><br><span class="line">    ldr pc, _data_abort</span><br><span class="line">    ldr pc, _not_used</span><br><span class="line">    ldr pc, _irq</span><br><span class="line">    ldr pc, _fiq</span><br></pre></td></tr></table></figure><p>因为在链接脚本中定义了 ENTRY(_start)，所以程序的第一条指令就是 b reset，尽管后续的指令得不到执行，但是它们在编译链接之后就被放置在以 0x4 开始的地址处，每一条指令占4字节，从指令内容可以看出这些指令都是跳转指令。</p><p>在汇编中标号表示标号之后的第一条指令的地址，比如，当发生 irq 中断时，处理器会强制跳转执行 ldr pc, _irq 这条指令，它的内容是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_irq:           .word irq   //./word为定义变量</span><br><span class="line"></span><br><span class="line">irq:</span><br><span class="line">    get_irq_stack</span><br><span class="line">    irq_save_user_regs      //保存断点</span><br><span class="line">    bl  do_irq</span><br><span class="line">    irq_restore_user_regs  //恢复断点</span><br></pre></td></tr></table></figure><h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><h2 id="1-1、异常和中断"><a href="#1-1、异常和中断" class="headerlink" title="1-1、异常和中断"></a>1-1、异常和中断</h2><p>在Linux中，异常（Exception）和中断（Interrupt）是两个不同但又相关的概念，它们的主要区别如下：</p><ul><li><p><strong>产生原因</strong></p><ul><li><p><strong>异常</strong>：通常是由程序自身的错误或特殊情况导致的，例如除以零、访问非法内存地址、断点指令等。这些情况是在程序执行过程中由内部因素引发的。</p></li><li><p><strong>中断</strong>：一般是由外部硬件设备发出的信号引起的，比如键盘输入、鼠标点击、定时器超时、网络数据包到达等。它是由外部事件触发的，与当前正在执行的程序没有直接关系。</p></li></ul></li><li><p><strong>处理时机</strong></p><ul><li><p><strong>异常</strong>：通常在指令执行过程中被检测到，一旦发生异常，CPU会立即停止当前程序的执行，转而执行相应的异常处理程序。</p></li><li><p><strong>中断</strong>：CPU在执行完当前指令后，会检查是否有中断请求到来。如果有中断请求，CPU会暂停当前程序的执行，保存现场，并跳转到相应的中断处理程序。</p></li></ul></li><li><p><strong>优先级</strong></p><ul><li><p><strong>异常</strong>：异常通常具有较高的优先级，因为它们往往表示程序出现了严重的错误或特殊情况，需要立即处理。例如，除数为零的异常必须在当前指令执行完毕后马上处理，否则程序将无法继续正确执行。</p></li><li><p><strong>中断</strong>：中断的优先级相对较低，且可以根据不同的设备或事件设置不同的优先级。例如，系统时钟中断可能具有较高的优先级，以确保系统的时间管理准确无误；而一些次要设备的中断，如打印机中断，优先级则相对较低。</p></li></ul></li><li><p><strong>处理方式</strong></p><ul><li><p><strong>异常</strong>：异常处理程序通常由操作系统或编程语言的运行时环境提供，用于处理特定类型的异常。例如，在C语言中，当出现除以零的异常时，程序会调用相应的信号处理函数来处理该异常。</p></li><li><p><strong>中断</strong>：中断处理程序是由设备驱动程序或操作系统内核提供的，用于处理特定设备的中断请求。例如，当键盘按下一个按键时，键盘驱动程序中的中断处理程序会被调用，以读取按键信息并将其传递给相应的应用程序。</p></li></ul></li><li><p><strong>对程序的影响</strong></p><ul><li><p><strong>异常</strong>：异常通常会导致当前程序的执行流程被改变，可能会使程序终止、进行错误处理或者尝试恢复执行。例如，当程序访问非法内存地址时，操作系统可能会终止该程序，并报告错误信息。</p></li><li><p><strong>中断</strong>：中断一般不会改变程序的执行流程，只是在中断处理程序执行完毕后，CPU会返回到被中断的程序继续执行。当然，在某些情况下，中断处理程序可能会对程序的执行产生间接影响，比如更新一些共享资源的状态等。</p></li></ul></li></ul><h2 id="1-2、中断处理函数"><a href="#1-2、中断处理函数" class="headerlink" title="1-2、中断处理函数"></a>1-2、中断处理函数</h2><p>在Linux系统中，当中断发生时，中断处理程序的调用过程如下：</p><ol><li><p><strong>中断信号产生</strong>：外部硬件设备（如键盘、鼠标、定时器等）通过中断控制器向CPU发送中断信号，告知有事件发生需要处理。</p></li><li><p><strong>CPU响应中断</strong>：CPU在执行完当前指令后，会检测到中断信号。如果当前中断的优先级高于正在执行的程序或任务的优先级，并且CPU处于允许中断的状态，CPU就会暂停当前程序的执行，并保存当前的程序状态，包括程序计数器（PC）、寄存器等信息，以便在中断处理完成后能够恢复到原来的执行状态。</p></li><li><p><strong>查找中断向量表</strong>：CPU根据中断信号的类型，在中断向量表中查找对应的中断处理程序的入口地址。中断向量表是一个存储中断处理程序入口地址的表格，通常位于内存的特定区域。每个中断类型都有一个唯一的编号，通过这个编号可以在中断向量表中找到相应的中断处理程序的地址。</p></li><li><p><strong>调用中断处理程序</strong>：找到中断处理程序的入口地址后，CPU将控制权转移到该地址，开始执行中断处理程序。中断处理程序通常是一段汇编语言或C语言编写的代码，用于处理特定类型的中断事件。例如，对于键盘中断，中断处理程序可能会读取键盘缓冲区中的数据，并将其传递给相应的应用程序。</p></li><li><p><strong>中断处理程序执行</strong>：中断处理程序在执行过程中，会根据具体的中断事件进行相应的处理。这可能包括读取或写入硬件寄存器、更新系统状态、通知相关进程或线程等操作。为了避免中断处理时间过长影响系统的响应性能，中断处理程序通常会尽量简短，只完成必要的处理工作。如果有更复杂的任务需要处理，中断处理程序可能会将任务交给其他线程或进程去完成，以尽快释放CPU资源。</p></li><li><p><strong>中断处理完成</strong>：当中断处理程序执行完毕后，它会恢复之前保存的CPU寄存器等状态信息，并将控制权返回给被中断的程序。CPU继续执行被中断的程序，就像没有发生过中断一样。</p></li></ol><p>整个过程是由硬件和软件共同协作完成的，它使得Linux系统能够及时响应外部设备的事件，保证系统的稳定性和实时性。<br>中断函数就是一个普普通通的函数.</p><h2 id="1-3、中断的上半步和下半步"><a href="#1-3、中断的上半步和下半步" class="headerlink" title="1-3、中断的上半步和下半步"></a>1-3、中断的上半步和下半步</h2><h3 id="上半部"><a href="#上半部" class="headerlink" title="上半部"></a>上半部</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p><strong>响应及时</strong>：当中断信号到来时，上半部会立即执行。这是为了能第一时间对中断做出反应，保证系统可以迅速感知并处理外部设备的请求，满足硬件实时性要求。例如，当网卡接收到一个数据包时，上半部需要马上对其进行初步处理，避免数据包丢失。</p></li><li><p><strong>执行时间短</strong>：为了尽量减少对其他任务的影响，上半部代码会设计得较为精简，仅处理那些必须立刻完成的关键操作。因为在执行上半部时，通常会屏蔽部分甚至全部中断，若执行时间过长，可能导致其他重要中断无法及时响应，影响系统的整体性能。</p></li><li><p><strong>运行在中断上下文</strong>：上半部运行在中断上下文环境中，这意味着它不能进行睡眠操作（如调用<code>sleep()</code>函数）。因为中断上下文没有自己的进程描述符，睡眠后无法被唤醒，会导致系统崩溃。</p></li><li><p><strong>高优先级</strong>：上半部在执行期间具有较高的优先级，会暂时屏蔽部分或全部其他中断，以保证关键的中断处理流程不被打断，确保硬件操作的完整性和准确性。</p></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><p><strong>处理紧急硬件操作</strong>：上半部负责对硬件进行直接的控制和操作，如读取或写入硬件寄存器。例如，在键盘中断发生时，上半部会读取键盘扫描码，将其从键盘控制器的寄存器中取出，为后续处理做准备。</p></li><li><p><strong>初步数据处理</strong>：对中断产生的初始数据进行简单处理和保存，确保数据的完整性和及时性。例如，在定时器中断中，上半部可以记录中断发生的时间戳，方便后续进行时间统计和调度。</p></li><li><p><strong>通知硬件中断已接收</strong>：及时告知硬件设备，其发出的中断已被系统接收，使硬件能够继续进行后续操作。例如，在磁盘控制器完成一次数据传输后发出中断，上半部处理时会向磁盘控制器发送确认信号，允许磁盘继续进行下一次传输。</p></li></ul><h3 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h3><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><p><strong>可延迟执行</strong>：下半部的执行并不要求与中断发生的时刻紧密相连，它可以在系统相对空闲时执行。这使得系统能够合理安排资源，优先处理紧急任务，提高整体性能。</p></li><li><p><strong>执行时间较长</strong>：由于不需要像上半部那样追求极致的速度，下半部可以处理一些较为复杂和耗时的任务。例如，对网络数据包进行详细的解析和处理，或者更新系统的一些统计信息。</p></li><li><p><strong>运行在软中断或内核线程上下文</strong>：下半部可以运行在软中断上下文或者内核线程上下文中，在这些上下文中可以进行适当的睡眠操作，以便等待某些资源或事件的发生。</p></li><li><p><strong>可被中断</strong>：下半部在执行过程中不会像上半部那样屏蔽大部分中断，它可以被其他中断打断，这使得系统能够及时响应新的紧急事件。</p></li></ul><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li><p><strong>处理非紧急任务</strong>：将那些不影响硬件正常运行的任务推迟到下半部处理，避免上半部负担过重。例如，在网卡接收到数据包后，上半部完成初步接收，下半部可以进行协议解析、数据缓存和转发等操作。</p></li><li><p><strong>提高系统并发能力</strong>：下半部可以在系统有空闲资源时并行执行，多个下半部任务可以在不同的CPU核心上同时运行，从而提高系统的并发处理能力。</p></li><li><p><strong>平衡系统负载</strong>：通过将中断处理的一部分工作推迟到下半部，使得系统在处理中断时能够更加灵活地分配资源，避免因集中处理所有中断任务而导致系统负载过高。例如，在高流量网络环境下，下半部可以将数据包处理任务分散到不同的时间段执行，减轻系统瞬间压力。</p></li></ul><h2 id="1-4、中断处理函数的注册"><a href="#1-4、中断处理函数的注册" class="headerlink" title="1-4、中断处理函数的注册"></a>1-4、中断处理函数的注册</h2><p>在 Linux 中，中断处理程序的注册过程主要涉及内核提供的相关接口函数，下面为你详细介绍注册步骤和代码示例：</p><h3 id="注册步骤"><a href="#注册步骤" class="headerlink" title="注册步骤"></a>注册步骤</h3><h4 id="1-分配中断号"><a href="#1-分配中断号" class="headerlink" title="1. 分配中断号"></a>1. 分配中断号</h4><p>中断号用于标识不同的硬件中断源，系统中每个外部设备都有一个对应的中断号。你可以通过查阅硬件文档或者内核源代码来确定具体设备的中断号。</p><h4 id="2-编写中断处理函数"><a href="#2-编写中断处理函数" class="headerlink" title="2. 编写中断处理函数"></a>2. 编写中断处理函数</h4><p>中断处理函数是实际处理中断事件的代码逻辑，它需要遵循特定的函数原型。其一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>irq</code> 是中断号，<code>dev_id</code> 是设备标识符，返回值 <code>irqreturn_t</code> 表示中断处理的结果。</p><h4 id="3-注册中断处理函数"><a href="#3-注册中断处理函数" class="headerlink" title="3. 注册中断处理函数"></a>3. 注册中断处理函数</h4><p>使用内核提供的 <code>request_irq</code> 函数来注册中断处理函数。该函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure><p>参数解释如下：</p><ul><li><code>irq</code>：要注册的中断号。</li><li><code>handler</code>：中断处理函数指针。</li><li><code>flags</code>：中断处理的标志，例如 <code>IRQF_SHARED</code> 表示允许多个设备共享同一个中断号。</li><li><code>name</code>：中断处理程序的名称，通常用于在 <code>/proc/interrupts</code> 中显示。</li><li><code>dev</code>：设备标识符，用于在共享中断时区分不同的设备。</li></ul><h4 id="4-卸载中断处理函数"><a href="#4-卸载中断处理函数" class="headerlink" title="4. 卸载中断处理函数"></a>4. 卸载中断处理函数</h4><p>当不再需要使用某个中断处理程序时，需要使用 <code>free_irq</code> 函数来卸载它。该函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><p>参数 <code>irq</code> 是要卸载的中断号，<code>dev_id</code> 是设备标识符。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个简单的中断处理程序注册和卸载的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_IRQ_NUMBER 12  <span class="comment">// 假设使用中断号 12</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt %d occurred!\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">// 注册中断处理函数</span></span><br><span class="line">    ret = request_irq(MY_IRQ_NUMBER, my_irq_handler, IRQF_SHARED, <span class="string">&quot;my_irq_handler&quot;</span>, &amp;my_irq_handler);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register interrupt %d\n&quot;</span>, MY_IRQ_NUMBER);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt %d registered successfully\n&quot;</span>, MY_IRQ_NUMBER);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 卸载中断处理函数</span></span><br><span class="line">    free_irq(MY_IRQ_NUMBER, &amp;my_irq_handler);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt %d unregistered\n&quot;</span>, MY_IRQ_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple interrupt handler example&quot;</span>);      </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li>**中断处理函数 <code>my_irq_handler</code>**：当指定的中断发生时，该函数会被调用，并打印一条信息表示中断已发生。</li><li>**模块初始化函数 <code>my_module_init</code>**：在模块加载时，调用 <code>request_irq</code> 函数注册中断处理函数。如果注册失败，会打印错误信息并返回错误码。</li><li>**模块退出函数 <code>my_module_exit</code>**：在模块卸载时，调用 <code>free_irq</code> 函数卸载中断处理函数。</li></ol><p>将上述代码保存为 <code>.c</code> 文件，使用内核编译工具链进行编译，然后加载和卸载内核模块，就可以测试中断处理程序的注册和卸载功能。 </p><h3 id="对于中断号说明"><a href="#对于中断号说明" class="headerlink" title="对于中断号说明"></a>对于中断号说明</h3><p>对于硬件的中断来说，中断号一般是确定好的。而如果是软件模拟的中断，则需要自己定义中断号。</p><h2 id="1-5、中断的释放"><a href="#1-5、中断的释放" class="headerlink" title="1-5、中断的释放"></a>1-5、中断的释放</h2><p>在 Linux 系统里，中断释放通常指的是注销中断处理程序，从而停止对特定中断源的响应。下面为你详细介绍释放中断的相关步骤与方法。</p><h3 id="释放中断的步骤"><a href="#释放中断的步骤" class="headerlink" title="释放中断的步骤"></a>释放中断的步骤</h3><ol><li><p><strong>确定中断号</strong>：要明确你想要释放的中断对应的中断号。这个中断号一般在注册中断处理程序时就已经确定，并且不同的硬件设备可能对应着不同的中断号。</p></li><li><p><strong>调用 <code>free_irq</code> 函数</strong>：在 Linux 内核里，可使用 <code>free_irq</code> 函数来释放中断处理程序。该函数会停止对指定中断号的中断响应，并且释放相关的资源。</p></li></ol><h3 id="free-irq-函数介绍"><a href="#free-irq-函数介绍" class="headerlink" title="free_irq 函数介绍"></a><code>free_irq</code> 函数介绍</h3><p><code>free_irq</code> 函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数说明</strong>：<ul><li><code>irq</code>：这是要释放的中断号。</li><li><code>dev_id</code>：它是一个设备标识符，在注册中断处理程序时会用到。这个标识符用于区分不同的中断处理程序，确保在释放中断时能够准确找到对应的处理程序。</li></ul></li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是一个简单的示例，展示了如何注册和释放中断处理程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUMBER 12  <span class="comment">// 假设中断号为 12</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *my_dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理程序</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler called for IRQ %d\n&quot;</span>, irq);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    my_dev_id = (<span class="type">void</span> *)&amp;my_interrupt_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册中断处理程序</span></span><br><span class="line">    ret = request_irq(IRQ_NUMBER, my_interrupt_handler, IRQF_SHARED, <span class="string">&quot;my_interrupt&quot;</span>, my_dev_id);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ %d\n&quot;</span>, IRQ_NUMBER);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler registered for IRQ %d\n&quot;</span>, IRQ_NUMBER);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放中断处理程序</span></span><br><span class="line">    free_irq(IRQ_NUMBER, my_dev_id);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt handler unregistered for IRQ %d\n&quot;</span>, IRQ_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Your Name&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple interrupt handler module&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol><li><strong>注册中断处理程序</strong>：在 <code>my_module_init</code> 函数里，调用 <code>request_irq</code> 函数来注册中断处理程序。这里使用 <code>IRQF_SHARED</code> 标志，表示该中断处理程序可以和其他处理程序共享同一个中断号。</li><li><strong>释放中断处理程序</strong>：在 <code>my_module_exit</code> 函数中，调用 <code>free_irq</code> 函数来释放中断处理程序。传入的参数为之前注册时使用的中断号和设备标识符。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>中断共享情况</strong>：若中断是共享的（使用 <code>IRQF_SHARED</code> 标志注册），<code>free_irq</code> 函数只会移除当前设备的中断处理程序，只有当所有共享该中断号的设备都释放了中断处理程序后，中断才会被完全禁用。</li><li><strong>权限问题</strong>：通常只有内核模块或者具有足够权限的程序才能注册和释放中断处理程序。</li></ul><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>对于共享中断，<code>free_irq</code> 函数只会移除当前设备的中断处理程序，只有当所有共享该中断号的设备都释放了中断处理程序后，中断才会被完全禁用。</p><h3 id="中断的重入"><a href="#中断的重入" class="headerlink" title="中断的重入"></a>中断的重入</h3><p>当给定的中断处理程序被调用时，内核会检查该中断处理程序是否正在运行。如果正在运行，则内核会等待该处理程序完成，然后再次调用该处理程序。也就是说，中断发生时，相应的中断线会在所有的处理器上屏蔽，直到中断处理程序完成。<br>总结来说：同一个中断不会被同时调用以处理嵌套中断。</p><h2 id="1-6-中断共享"><a href="#1-6-中断共享" class="headerlink" title="1-6 中断共享"></a>1-6 中断共享</h2><p>在Linux中，共享中断处理是一种允许多个设备共享同一个中断线的机制。以下是对它的详细介绍：</p><h3 id="背景及原理"><a href="#背景及原理" class="headerlink" title="背景及原理"></a>背景及原理</h3><ul><li>在传统的中断处理机制下，每个设备都有自己独立的中断线，当设备数量增加时，中断线数量也随之增加，导致中断处理复杂性增加，资源利用率降低。为解决此问题，Linux引入共享中断概念。通过硬件支持，当共享同一中断线的多个设备中的一个产生中断请求时，系统能够识别出具体是哪个设备发生了中断，然后对相应设备进行处理，并通知其他设备继续等待。</li></ul><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>Linux操作系统采用中断链表的数据结构来实现共享中断机制。多个设备的中断处理函数链接在一起，共享同一个中断向量。每个设备的中断请求通过中断控制器传递给中断链表中的相应设备的中断处理函数。</li></ul><h3 id="相关函数及参数"><a href="#相关函数及参数" class="headerlink" title="相关函数及参数"></a>相关函数及参数</h3><ul><li>注册共享中断时，需要使用<code>request_irq()</code>函数，其参数<code>flags</code>必须设置<code>IRQF_SHARED</code>标志，用于表明这是一个共享中断。<code>dev_id</code>参数必须唯一，通常选择设备私有数据结构，因为它是唯一的，且中断处理程序可能会用到它，不能给共享的处理程序传递<code>NULL</code>值。</li></ul><h3 id="硬件和软件要求"><a href="#硬件和软件要求" class="headerlink" title="硬件和软件要求"></a>硬件和软件要求</h3><ul><li>硬件层面，需要芯片或者总线控制器提供相应的功能，支持中断的共享。软件层面，操作系统需要对设备进行正确的中断处理和识别。内核提供了相应的接口和机制来实现共享中断的功能，例如通过中断链表来管理共享同一中断线的多个设备的中断处理函数。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>减少中断线数量</strong>：当系统中的设备增加时，只需要增加中断控制器的数量，而不需要增加中断线的数量，降低了中断处理的复杂性。</li><li><strong>提高资源利用率</strong>：设备共享中断，每个设备都可以利用其他设备的中断线，避免了资源的浪费。</li><li><strong>提升系统可扩展性</strong>：当有新的设备加入系统时，只需添加相应的中断处理函数到中断链表中即可，无需重新分配中断向量，简化了系统的维护工作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>影响处理速度</strong>：当一个设备产生中断请求时，可能会影响其他设备的处理速度，从而影响系统的响应速度和性能。</li><li><strong>增加实施难度</strong>：共享中断需要复杂的硬件和软件支持，在实施和调试过程中需要一定的技术经验和知识。</li></ul><h2 id="1-7、-proc-interrupts"><a href="#1-7、-proc-interrupts" class="headerlink" title="1-7、&#x2F;proc&#x2F;interrupts"></a>1-7、&#x2F;proc&#x2F;interrupts</h2><p>在Linux中，<code>/proc</code>是一个虚拟文件系统，它提供了有关系统进程和内核的信息，<br>这些信息在系统运行时动态生成，存储在内存中，不占用物理存储空间。<br><code>/proc/interrupts</code>文件包含了系统中与硬件中断相关的统计信息。以下是对其内容的详细解释：</p><ul><li><p><strong>irq编号</strong>：文件的第一列是irq（Interrupt Request，中断请求）编号，每个硬件设备在请求CPU服务时都会使用一个特定的中断号。</p></li><li><p><strong>CPU列</strong>：从第二列开始，每一列对应一个CPU核心。这表示每个CPU核心上对应中断号的中断发生次数。例如，在多处理器系统中，你可以看到不同CPU核心处理中断的负载情况。</p></li><li><p><strong>中断类型和设备名称</strong>：最后一列包含了中断的类型以及产生中断的设备名称（如果已知）。<br>常见的中断类型有<code>xt - pic</code>（旧的AT计算机中断）、<br><code>io - apic - edge</code>（基于IO高级可编程中断控制器的边缘触发中断）、<br><code>io - apic - level</code>（基于IO高级可编程中断控制器的电平触发中断）等。<br>设备名称则有助于你确定是哪个硬件设备产生了相应的中断，如<code>timer</code>（定时器）、<code>keyboard</code>（键盘）、<code>eth0</code>（网络接口）等。</p></li></ul><p>下面是一个<code>/proc/interrupts</code>文件内容的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">           CPU0       CPU1</span><br><span class="line">  0:   1366814704        0  xt - pic  timer</span><br><span class="line">  1:     128        340  io - apic - edge  keyboard</span><br><span class="line">  2:       0        0  xt - pic  cascade</span><br><span class="line">  8:       0        1  io - apic - edge  rtc</span><br><span class="line"> 12:     5323       5793  io - apic - edge  ps/2 mouse</span><br><span class="line"> 13:       1        0  xt - pic  fpu</span><br><span class="line"> 16:   11184294    15940594  io - apic - level  intel etherexpress pro 10/100 ethernet</span><br><span class="line"> 20:    8450043    11120093  io - apic - level  megaraid</span><br><span class="line"> 30:     10432       10722  io - apic - level  aic 7 xxx</span><br><span class="line"> 31:        23        22  io - apic - level  aic 7 xxx</span><br><span class="line">NMI:       0</span><br><span class="line">ERR:       0</span><br></pre></td></tr></table></figure><p>通过查看<code>/proc/interrupts</code>文件，系统管理员和开发人员可以了解系统中各个硬件设备的中断负载情况，及时发现可能存在的性能问题，比如某个设备的中断次数异常增多，可能表示该设备出现了故障或者工作负荷过重。同时，也可以帮助开发人员进行系统调优和故障排查，找出系统中存在的瓶颈，进而优化系统性能并提高系统稳定性。</p><h2 id="1-8、中断的控制api"><a href="#1-8、中断的控制api" class="headerlink" title="1-8、中断的控制api"></a>1-8、中断的控制api</h2><p>在Linux内核中，操作中断主要涉及注册、注销和管理中断处理程序，以及控制中断的状态（启用&#x2F;禁用）。以下是内核提供的主要接口及其功能：</p><h3 id="1-中断处理程序注册与注销"><a href="#1-中断处理程序注册与注销" class="headerlink" title="1. 中断处理程序注册与注销"></a>1. 中断处理程序注册与注销</h3><h4 id="request-irq"><a href="#request-irq" class="headerlink" title="request_irq()"></a><strong>request_irq()</strong></h4><p>注册一个中断处理程序，使设备能够响应特定的中断号（IRQ）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, </span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong>：<ul><li><code>irq</code>：中断号（如<code>1</code>对应键盘中断）。</li><li><code>handler</code>：中断处理函数（回调函数）。</li><li><code>flags</code>：中断标志（如<code>IRQF_SHARED</code>表示共享中断）。</li><li><code>name</code>：设备名称（显示在<code>/proc/interrupts</code>中）。</li><li><code>dev_id</code>：设备标识符（用于共享中断时区分不同设备）。</li></ul></li><li><strong>返回值</strong>：0 表示成功，负值表示错误。</li></ul><h4 id="free-irq"><a href="#free-irq" class="headerlink" title="free_irq()"></a><strong>free_irq()</strong></h4><p>注销中断处理程序，释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><h3 id="2-中断处理函数类型"><a href="#2-中断处理函数类型" class="headerlink" title="2. 中断处理函数类型"></a>2. 中断处理函数类型</h3><h4 id="irq-handler-t"><a href="#irq-handler-t" class="headerlink" title="irq_handler_t"></a><strong>irq_handler_t</strong></h4><p>中断处理函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>返回值</strong>：<ul><li><code>IRQ_NONE</code>：未处理该中断。</li><li><code>IRQ_HANDLED</code>：已处理该中断。</li></ul></li></ul><h3 id="3-中断状态控制"><a href="#3-中断状态控制" class="headerlink" title="3. 中断状态控制"></a>3. 中断状态控制</h3><h4 id="禁用-启用本地CPU中断"><a href="#禁用-启用本地CPU中断" class="headerlink" title="禁用&#x2F;启用本地CPU中断"></a><strong>禁用&#x2F;启用本地CPU中断</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();  <span class="comment">// 禁用本地CPU中断</span></span><br><span class="line">local_irq_enable();   <span class="comment">// 启用本地CPU中断</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：仅影响当前CPU核心，且需成对使用，避免死锁。</li></ul><h4 id="保存并禁用中断状态"><a href="#保存并禁用中断状态" class="headerlink" title="保存并禁用中断状态"></a><strong>保存并禁用中断状态</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">local_irq_save(flags);  <span class="comment">// 保存当前中断状态并禁用中断</span></span><br><span class="line"><span class="comment">// ... 临界区代码 ...</span></span><br><span class="line">local_irq_restore(flags);  <span class="comment">// 恢复中断状态</span></span><br></pre></td></tr></table></figure><h4 id="禁用-启用特定中断线"><a href="#禁用-启用特定中断线" class="headerlink" title="禁用&#x2F;启用特定中断线"></a><strong>禁用&#x2F;启用特定中断线</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;    <span class="comment">// 禁用中断线（等待当前中断处理完成）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;  <span class="comment">// 立即禁用中断线</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;     <span class="comment">// 启用中断线</span></span><br></pre></td></tr></table></figure><h3 id="4-中断底半部（Bottom-Half）处理"><a href="#4-中断底半部（Bottom-Half）处理" class="headerlink" title="4. 中断底半部（Bottom Half）处理"></a>4. 中断底半部（Bottom Half）处理</h3><p>为避免中断处理程序执行时间过长，可将耗时操作延迟到”底半部”执行。</p><h4 id="软中断（Softirq）"><a href="#软中断（Softirq）" class="headerlink" title="软中断（Softirq）"></a><strong>软中断（Softirq）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open_softirq(NR_SOFTIRQS, my_softirq_handler);  <span class="comment">// 注册软中断</span></span><br><span class="line">raise_softirq(NR_SOFTIRQS);                     <span class="comment">// 触发软中断</span></span><br></pre></td></tr></table></figure><h4 id="任务队列（Tasklet）"><a href="#任务队列（Tasklet）" class="headerlink" title="任务队列（Tasklet）"></a><strong>任务队列（Tasklet）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(my_tasklet, tasklet_handler, data);  <span class="comment">// 定义任务队列</span></span><br><span class="line">tasklet_schedule(&amp;my_tasklet);                        <span class="comment">// 调度任务队列</span></span><br></pre></td></tr></table></figure><h4 id="工作队列（Workqueue）"><a href="#工作队列（Workqueue）" class="headerlink" title="工作队列（Workqueue）"></a><strong>工作队列（Workqueue）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_WORK(my_work, work_handler);  <span class="comment">// 定义工作队列</span></span><br><span class="line">schedule_work(&amp;my_work);              <span class="comment">// 调度工作队列</span></span><br></pre></td></tr></table></figure><h3 id="5-中断共享（Shared-IRQ）"><a href="#5-中断共享（Shared-IRQ）" class="headerlink" title="5. 中断共享（Shared IRQ）"></a>5. 中断共享（Shared IRQ）</h3><p>允许多个设备共享同一中断线。</p><ul><li><strong>注册共享中断</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_irq(irq, handler, IRQF_SHARED, <span class="string">&quot;shared_device&quot;</span>, dev_id);</span><br></pre></td></tr></table></figure></li><li><strong>要求</strong>：<ul><li>所有共享设备必须使用<code>IRQF_SHARED</code>标志。</li><li><code>dev_id</code>必须唯一（通常指向设备结构体）。</li><li>中断处理函数需通过硬件状态判断是否为自己的中断。</li></ul></li></ul><h3 id="6-中断控制器操作"><a href="#6-中断控制器操作" class="headerlink" title="6. 中断控制器操作"></a>6. 中断控制器操作</h3><h4 id="获取中断控制器描述符"><a href="#获取中断控制器描述符" class="headerlink" title="获取中断控制器描述符"></a><strong>获取中断控制器描述符</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> *<span class="title">chip</span> =</span> irq_get_chip(irq);</span><br></pre></td></tr></table></figure><h4 id="设置中断触发类型"><a href="#设置中断触发类型" class="headerlink" title="设置中断触发类型"></a><strong>设置中断触发类型</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irq_set_irq_type(irq, IRQ_TYPE_EDGE_RISING);  <span class="comment">// 边缘触发（上升沿）</span></span><br><span class="line">irq_set_irq_type(irq, IRQ_TYPE_LEVEL_LOW);    <span class="comment">// 电平触发（低电平）</span></span><br></pre></td></tr></table></figure><h3 id="7-中断亲和性（CPU绑定）"><a href="#7-中断亲和性（CPU绑定）" class="headerlink" title="7. 中断亲和性（CPU绑定）"></a><strong>7. 中断亲和性（CPU绑定）</strong></h3><p>将中断处理固定到特定CPU核心，提高性能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irq_set_affinity_hint(irq, cpumask_of(cpu_id));  <span class="comment">// 设置亲和性提示</span></span><br><span class="line">irq_set_affinity(irq, cpumask_of(cpu_id));        <span class="comment">// 强制绑定CPU</span></span><br></pre></td></tr></table></figure><h3 id="8-中断状态查询"><a href="#8-中断状态查询" class="headerlink" title="8. 中断状态查询"></a>8. 中断状态查询</h3><h4 id="检查中断是否启用"><a href="#检查中断是否启用" class="headerlink" title="检查中断是否启用"></a><strong>检查中断是否启用</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">irqs_disabled</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">// 返回非零值表示中断被禁用</span></span><br></pre></td></tr></table></figure><h4 id="获取中断统计信息"><a href="#获取中断统计信息" class="headerlink" title="获取中断统计信息"></a><strong>获取中断统计信息</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/proc/interrupts  <span class="comment">// 显示系统中断统计</span></span><br><span class="line">/proc/softirqs    <span class="comment">// 显示软中断统计</span></span><br></pre></td></tr></table></figure><h3 id="示例：注册中断处理程序"><a href="#示例：注册中断处理程序" class="headerlink" title="示例：注册中断处理程序"></a><strong>示例：注册中断处理程序</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_interrupt_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="comment">// 中断处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备初始化时注册中断</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_device_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    ret = request_irq(MY_DEVICE_IRQ, my_interrupt_handler, </span><br><span class="line">                     IRQF_SHARED, <span class="string">&quot;my_device&quot;</span>, &amp;my_device);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to register IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备卸载时注销中断</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_device_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    free_irq(MY_DEVICE_IRQ, &amp;my_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li><strong>中断处理程序应尽可能短</strong>，耗时操作移到底半部。</li><li><strong>共享中断</strong>需确保每个设备能正确识别自己的中断。</li><li><strong>禁用中断</strong>会影响系统响应性，应尽量减少禁用时间。</li><li><strong>中断上下文</strong>中不能使用睡眠函数（如<code>msleep()</code>）。</li></ol><p>这些接口是内核与硬件交互的基础，合理使用它们对驱动开发和系统性能至关重要。</p><h1 id="下半部-1"><a href="#下半部-1" class="headerlink" title="下半部"></a>下半部</h1><h2 id="1、中断底半部（下半部）"><a href="#1、中断底半部（下半部）" class="headerlink" title="1、中断底半部（下半部）"></a>1、中断底半部（下半部）</h2><p>在Linux内核中，中断处理分为<strong>上半部（Top Half）</strong> 和<strong>下半部（Bottom Half）</strong>。上半部处理紧急的硬件相关操作（如确认中断、读取数据），而下半部处理耗时操作（如数据处理、状态更新），以避免长时间占用CPU导致其他中断被延迟。以下是Linux内核提供的几种主要的下半部实现机制及其特点：</p><h3 id="1-软中断（Softirq）"><a href="#1-软中断（Softirq）" class="headerlink" title="1. 软中断（Softirq）"></a><strong>1. 软中断（Softirq）</strong></h3><ul><li><strong>特点</strong>：<ul><li>性能最高，由内核直接调度，运行在中断上下文。</li><li>可在多CPU上并行执行（同一类型或不同类型）。</li><li>禁止睡眠，处理函数必须快速完成。</li></ul></li><li><strong>适用场景</strong>：高频、耗时短、需并行的任务（如网络数据包处理）。</li><li><strong>注册与触发</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册软中断处理函数（在模块初始化时）</span></span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, my_softirq_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发软中断（通常在硬中断处理程序中）</span></span><br><span class="line">raise_softirq(NET_RX_SOFTIRQ);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-任务队列（Tasklet）"><a href="#2-任务队列（Tasklet）" class="headerlink" title="2. 任务队列（Tasklet）"></a><strong>2. 任务队列（Tasklet）</strong></h3><ul><li><strong>特点</strong>：<ul><li>基于软中断实现（使用<code>TASKLET_SOFTIRQ</code>），同一类型的任务队列串行执行。</li><li>不同类型的任务队列可在不同CPU并行，但同一类型不会并发。</li><li>禁止睡眠，比软中断更易用。</li></ul></li><li><strong>适用场景</strong>：耗时操作，但无需并行（如设备状态更新）。</li><li><strong>使用示例</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务队列处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态定义并初始化任务队列</span></span><br><span class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_handler, data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度任务队列（通常在硬中断处理程序中）</span></span><br><span class="line">tasklet_schedule(&amp;my_tasklet);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-工作队列（Workqueue）"><a href="#3-工作队列（Workqueue）" class="headerlink" title="3. 工作队列（Workqueue）"></a><strong>3. 工作队列（Workqueue）</strong></h3><ul><li><strong>特点</strong>：<ul><li>由内核线程（<code>kworker</code>）执行，运行在进程上下文。</li><li>允许睡眠（如访问文件系统、获取信号量）。</li><li>性能开销高于软中断和任务队列。</li></ul></li><li><strong>适用场景</strong>：需要睡眠的任务（如DMA完成后的IO操作）。</li><li><strong>使用示例</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义工作队列处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span> &#123;</span><br><span class="line">    <span class="comment">// 可睡眠的处理逻辑</span></span><br><span class="line">    msleep(<span class="number">10</span>); <span class="comment">// 示例：休眠10ms</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态定义工作队列</span></span><br><span class="line">DECLARE_WORK(my_work, my_work_handler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度工作队列</span></span><br><span class="line">schedule_work(&amp;my_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟执行（单位：jiffies）</span></span><br><span class="line">schedule_delayed_work(&amp;my_work, <span class="number">100</span>); <span class="comment">// 约100ms后执行</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-传统底半部（BH，Bottom-Half）"><a href="#4-传统底半部（BH，Bottom-Half）" class="headerlink" title="4. 传统底半部（BH，Bottom Half）"></a><strong>4. 传统底半部（BH，Bottom Half）</strong></h3><ul><li><strong>特点</strong>：<ul><li>早期Linux内核的实现，现已被软中断和任务队列替代。</li><li>所有BH串行执行，性能较差。</li></ul></li><li><strong>现状</strong>：仅保留兼容性支持，新代码不建议使用。</li></ul><h3 id="5-线程化中断（Threaded-IRQ）"><a href="#5-线程化中断（Threaded-IRQ）" class="headerlink" title="5. 线程化中断（Threaded IRQ）"></a><strong>5. 线程化中断（Threaded IRQ）</strong></h3><ul><li><strong>特点</strong>：<ul><li>中断处理程序分为两部分：<ul><li><strong>快速上半部</strong>：禁止中断，执行紧急操作。</li><li><strong>线程化下半部</strong>：由内核线程执行，允许睡眠。</li></ul></li><li>通过<code>request_threaded_irq()</code>注册。</li></ul></li><li><strong>适用场景</strong>：需要睡眠且对实时性要求较高的中断（如键盘、鼠标）。</li><li><strong>使用示例</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="comment">// 快速处理部分（禁止睡眠）</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_WAKE_THREAD; <span class="comment">// 唤醒线程化下半部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_irq_thread</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程化处理部分（可睡眠）</span></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册线程化中断</span></span><br><span class="line">request_threaded_irq(irq, my_irq_handler, my_irq_thread, </span><br><span class="line">                    flags, <span class="string">&quot;my_device&quot;</span>, dev_id);</span><br></pre></td></tr></table></figure></li></ul><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a><strong>选择建议</strong></h3><table><thead><tr><th><strong>机制</strong></th><th><strong>是否可并行</strong></th><th><strong>是否可睡眠</strong></th><th><strong>适用场景</strong></th><th><strong>性能开销</strong></th></tr></thead><tbody><tr><td><strong>软中断</strong></td><td>是</td><td>否</td><td>高频、耗时短、需并行的任务</td><td>最低</td></tr><tr><td><strong>任务队列</strong></td><td>同类型串行</td><td>否</td><td>耗时操作，无需并行</td><td>低</td></tr><tr><td><strong>工作队列</strong></td><td>是</td><td>是</td><td>需要睡眠的任务</td><td>高</td></tr><tr><td><strong>线程化中断</strong></td><td>否</td><td>是</td><td>需要睡眠且对实时性要求高的中断</td><td>较高</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>优先使用任务队列</strong>：简单易用，适合大多数场景。</li><li><strong>高频任务用软中断</strong>：如网络栈、定时器处理。</li><li><strong>需要睡眠用工作队列</strong>：如文件IO、复杂计算。</li><li><strong>对实时性敏感用线程化中断</strong>：如人机交互设备。</li></ul><p>合理选择下半部机制能显著提升系统性能和响应性。</p><h2 id="2、软中断"><a href="#2、软中断" class="headerlink" title="2、软中断"></a>2、软中断</h2><p>在Linux内核中，<strong>软中断（Softirq）</strong> 是一种用于实现中断底半部（Bottom Half）处理的机制，其目的是将耗时的中断处理任务从硬中断上下文（关闭中断的临界区）中分离出来，在更安全的环境下异步执行，从而提高系统响应性。</p><h3 id="软中断的特点"><a href="#软中断的特点" class="headerlink" title="软中断的特点"></a><strong>软中断的特点</strong></h3><ol><li><strong>异步执行</strong>：软中断在中断处理程序返回后由内核在特定时机触发执行。</li><li><strong>执行时机</strong>：<ul><li>硬中断返回时（<code>irq_exit()</code>）。</li><li>内核线程<code>ksoftirqd</code>周期性触发（处理积压的软中断）。</li></ul></li><li><strong>禁止睡眠</strong>：软中断上下文不能休眠，必须快速执行。</li><li><strong>可在多CPU并行</strong>：同类型的软中断在不同CPU上可并行执行（需注意同步）。</li></ol><h3 id="软中断的注册与使用"><a href="#软中断的注册与使用" class="headerlink" title="软中断的注册与使用"></a><strong>软中断的注册与使用</strong></h3><h4 id="1-预定义的软中断类型"><a href="#1-预定义的软中断类型" class="headerlink" title="1. 预定义的软中断类型"></a><strong>1. 预定义的软中断类型</strong></h4><p>Linux内核预定义了一些常用的软中断类型（定义在<code>include/linux/interrupt.h</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    HI_SOFTIRQ=<span class="number">0</span>,     <span class="comment">// 高优先级软中断</span></span><br><span class="line">    TIMER_SOFTIRQ,    <span class="comment">// 定时器软中断</span></span><br><span class="line">    NET_TX_SOFTIRQ,   <span class="comment">// 网络发送软中断</span></span><br><span class="line">    NET_RX_SOFTIRQ,   <span class="comment">// 网络接收软中断</span></span><br><span class="line">    BLOCK_SOFTIRQ,    <span class="comment">// 块设备软中断</span></span><br><span class="line">    IRQ_POLL_SOFTIRQ, <span class="comment">// IRQ轮询软中断</span></span><br><span class="line">    TASKLET_SOFTIRQ,  <span class="comment">// 任务队列软中断</span></span><br><span class="line">    SCHED_SOFTIRQ,    <span class="comment">// 调度器软中断</span></span><br><span class="line">    HRTIMER_SOFTIRQ,  <span class="comment">// 高精度定时器软中断</span></span><br><span class="line">    RCU_SOFTIRQ,      <span class="comment">// RCU锁软中断</span></span><br><span class="line">    NR_SOFTIRQS       <span class="comment">// 软中断总数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-注册软中断处理函数"><a href="#2-注册软中断处理函数" class="headerlink" title="2. 注册软中断处理函数"></a><strong>2. 注册软中断处理函数</strong></h4><p>在模块初始化时，使用<code>open_softirq()</code>注册软中断处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span> &#123;</span><br><span class="line">    <span class="comment">// 软中断处理逻辑（禁止睡眠）</span></span><br><span class="line">    <span class="comment">// 例如：处理网络数据包、更新统计信息等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册软中断处理函数（以NET_RX_SOFTIRQ为例）</span></span><br><span class="line">    open_softirq(NET_RX_SOFTIRQ, my_softirq_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br></pre></td></tr></table></figure><h4 id="3-触发软中断"><a href="#3-触发软中断" class="headerlink" title="3. 触发软中断"></a><strong>3. 触发软中断</strong></h4><p>在硬中断处理程序或其他代码中，使用<code>raise_softirq()</code>触发软中断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="comment">// 硬中断快速处理部分</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发软中断，将耗时操作交给底半部处理</span></span><br><span class="line">    raise_softirq(NET_RX_SOFTIRQ);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="软中断与其他底半部机制的对比"><a href="#软中断与其他底半部机制的对比" class="headerlink" title="软中断与其他底半部机制的对比"></a><strong>软中断与其他底半部机制的对比</strong></h3><table><thead><tr><th><strong>机制</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>软中断</strong></td><td>性能最高，可并行执行，禁止睡眠</td><td>高频、耗时短、需并行的任务</td></tr><tr><td><strong>任务队列</strong></td><td>基于软中断实现，同一类型串行执行</td><td>耗时操作，无需并行</td></tr><tr><td><strong>工作队列</strong></td><td>由内核线程执行，可睡眠</td><td>需要睡眠的任务（如访问文件系统）</td></tr></tbody></table><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li><strong>软中断优先级</strong>：软中断执行时允许响应硬中断，但禁止其他软中断（同类型或不同类型）。</li><li><strong>同步问题</strong>：若软中断处理函数访问共享资源，需使用原子操作或自旋锁（<code>spin_lock_irqsave()</code>）。</li><li><strong>避免长时间执行</strong>：软中断长时间运行会导致<code>ksoftirqd</code>线程占用CPU，影响系统响应。</li><li><strong>动态创建软中断</strong>：内核不推荐动态创建新的软中断类型（预定义类型已足够），通常使用任务队列或工作队列。</li></ol><h3 id="调试与监控"><a href="#调试与监控" class="headerlink" title="调试与监控"></a><strong>调试与监控</strong></h3><ul><li><strong>查看软中断统计</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/softirqs</span><br></pre></td></tr></table></figure></li><li><strong>性能分析工具</strong>：<ul><li><code>perf</code>：分析软中断耗时。</li><li><code>top</code>&#x2F;<code>htop</code>：监控<code>ksoftirqd</code>线程CPU使用率。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>软中断是Linux内核中高效的底半部处理机制，适用于对性能要求极高且无需睡眠的场景。通常情况下，驱动开发者更常使用任务队列（<code>tasklet</code>）或工作队列（<code>workqueue</code>），因为它们更易用且安全。只有在需要极致性能时才考虑直接使用软中断。</p><h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>在Linux内核中，<strong>Tasklet</strong> 是一种基于软中断实现的下半部（Bottom Half）机制，用于处理不需要立即执行的耗时任务。它比软中断更易用，且同一类型的tasklet不会并发执行，适合大多数驱动开发场景。以下是tasklet的详细使用方法：</p><h3 id="1-Tasklet的特点"><a href="#1-Tasklet的特点" class="headerlink" title="1. Tasklet的特点"></a><strong>1. Tasklet的特点</strong></h3><ul><li><strong>基于软中断</strong>：使用<code>TASKLET_SOFTIRQ</code>类型的软中断实现。</li><li><strong>串行执行</strong>：同一类型的tasklet在多CPU上不会并行（自动同步）。</li><li><strong>禁止睡眠</strong>：运行在中断上下文，不能使用可能引起睡眠的函数。</li><li><strong>执行时机</strong>：硬中断返回时或<code>ksoftirqd</code>内核线程触发。</li></ul><h3 id="2-定义Tasklet处理函数"><a href="#2-定义Tasklet处理函数" class="headerlink" title="2. 定义Tasklet处理函数"></a><strong>2. 定义Tasklet处理函数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数原型：void func(unsigned long data)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑（禁止睡眠）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> my_device *)data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 例如：处理设备数据、更新状态</span></span><br><span class="line">    process_device_data(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-初始化Tasklet"><a href="#3-初始化Tasklet" class="headerlink" title="3. 初始化Tasklet"></a><strong>3. 初始化Tasklet</strong></h3><p>有两种方式初始化tasklet：</p><h4 id="静态初始化（推荐）"><a href="#静态初始化（推荐）" class="headerlink" title="静态初始化（推荐）"></a><strong>静态初始化（推荐）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并初始化tasklet（使用DECLARE_TASKLET）</span></span><br><span class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_handler, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;my_device);</span><br></pre></td></tr></table></figure><ul><li>参数1：tasklet名称（<code>my_tasklet</code>）。</li><li>参数2：处理函数（<code>my_tasklet_handler</code>）。</li><li>参数3：传递给处理函数的数据（需转换为<code>unsigned long</code>）。</li></ul><h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a><strong>动态初始化</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时初始化（如模块加载时）</span></span><br><span class="line">tasklet_init(&amp;my_tasklet, my_tasklet_handler, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;my_device);</span><br></pre></td></tr></table></figure><h3 id="4-调度Tasklet执行"><a href="#4-调度Tasklet执行" class="headerlink" title="4. 调度Tasklet执行"></a><strong>4. 调度Tasklet执行</strong></h3><p>在硬中断处理程序或其他代码中调度tasklet：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="comment">// 快速处理硬中断（如读取数据寄存器）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调度tasklet执行下半部处理</span></span><br><span class="line">    tasklet_schedule(&amp;my_tasklet);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-控制Tasklet执行"><a href="#5-控制Tasklet执行" class="headerlink" title="5. 控制Tasklet执行"></a><strong>5. 控制Tasklet执行</strong></h3><h4 id="延迟调度"><a href="#延迟调度" class="headerlink" title="延迟调度"></a><strong>延迟调度</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新调度已在队列中的tasklet（安全）</span></span><br><span class="line">tasklet_hi_schedule(&amp;my_tasklet);  <span class="comment">// 高优先级版本</span></span><br></pre></td></tr></table></figure><h4 id="禁用-启用Tasklet"><a href="#禁用-启用Tasklet" class="headerlink" title="禁用&#x2F;启用Tasklet"></a><strong>禁用&#x2F;启用Tasklet</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临时禁用tasklet（禁止执行，但不取消已调度的）</span></span><br><span class="line">tasklet_disable(&amp;my_tasklet);</span><br><span class="line"><span class="comment">// ... 临界区代码 ...</span></span><br><span class="line">tasklet_enable(&amp;my_tasklet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用并等待tasklet完成（若正在执行则等待结束）</span></span><br><span class="line">tasklet_disable_nosync(&amp;my_tasklet);  <span class="comment">// 不等待</span></span><br><span class="line">tasklet_kill(&amp;my_tasklet);            <span class="comment">// 取消调度并等待完成</span></span><br></pre></td></tr></table></figure><h3 id="6-示例：完整Tasklet使用流程"><a href="#6-示例：完整Tasklet使用流程" class="headerlink" title="6. 示例：完整Tasklet使用流程"></a><strong>6. 示例：完整Tasklet使用流程</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="comment">// 其他设备信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tasklet处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> my_device *)data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟耗时操作（禁止睡眠）</span></span><br><span class="line">    dev-&gt;data++;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Tasklet executed. Data: %d\n&quot;</span>, dev-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态定义tasklet</span></span><br><span class="line">DECLARE_TASKLET(my_tasklet, my_tasklet_handler, (<span class="type">unsigned</span> <span class="type">long</span>)&amp;dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">my_irq_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">    <span class="comment">// 快速处理硬中断</span></span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Interrupt received\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调度tasklet执行下半部</span></span><br><span class="line">    tasklet_schedule(&amp;my_tasklet);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">my_module_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册中断处理函数（假设IRQ为123）</span></span><br><span class="line">    <span class="type">int</span> ret = request_irq(<span class="number">123</span>, my_irq_handler, </span><br><span class="line">                         IRQF_SHARED, <span class="string">&quot;my_device&quot;</span>, &amp;dev);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;Failed to request IRQ\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module initialized\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块退出</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">my_module_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 取消tasklet调度并等待完成</span></span><br><span class="line">    tasklet_kill(&amp;my_tasklet);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放中断</span></span><br><span class="line">    free_irq(<span class="number">123</span>, &amp;dev);</span><br><span class="line">    </span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Module exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(my_module_init);</span><br><span class="line">module_exit(my_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a><strong>7. 注意事项</strong></h3><ol><li><strong>禁止睡眠</strong>：tasklet运行在中断上下文，不能使用<code>msleep()</code>、<code>mutex_lock()</code>等可能引起睡眠的函数。</li><li><strong>共享资源保护</strong>：若tasklet访问共享数据，需使用原子操作或自旋锁（如<code>spin_lock_irqsave()</code>）。</li><li><strong>避免递归调度</strong>：不要在tasklet处理函数中调用<code>tasklet_schedule()</code>，可能导致死循环。</li><li><strong>优先级</strong>：<code>tasklet_schedule()</code>是普通优先级，<code>tasklet_hi_schedule()</code>是高优先级（更快执行）。</li></ol><h3 id="8-调试与监控"><a href="#8-调试与监控" class="headerlink" title="8. 调试与监控"></a><strong>8. 调试与监控</strong></h3><ul><li><p><strong>查看软中断统计</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/softirqs</span><br></pre></td></tr></table></figure><p>观察<code>TASKLET</code>行的计数是否增加。</p></li><li><p><strong>性能分析</strong>：<br>使用<code>perf</code>工具分析tasklet耗时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf record -g -a <span class="built_in">sleep</span> 10  <span class="comment"># 记录10秒</span></span><br><span class="line">perf report                 <span class="comment"># 查看报告</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Tasklet是Linux内核中最简单、最常用的下半部机制，适合大多数无需睡眠的异步处理场景。通过合理使用tasklet，可以显著提升系统响应性和稳定性。</p><h2 id="ksoftirqd机制"><a href="#ksoftirqd机制" class="headerlink" title="ksoftirqd机制"></a>ksoftirqd机制</h2><p><code>ksoftirqd</code>是Linux内核中的一个重要内核线程，用于处理软中断。以下是关于它的详细介绍：</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><strong>处理软中断</strong>：负责执行系统中累积的软中断任务。软中断是一种在中断处理程序中延迟执行的机制，用于将一些非紧急但又需要在中断上下文完成的工作推迟到更合适的时机执行，以避免影响硬中断的处理速度。<code>ksoftirqd</code>线程会不断检查是否有软中断需要处理，并在有任务时执行相应的软中断处理函数。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li><strong>触发时机</strong>：当系统中有软中断被触发时（例如通过<code>raise_softirq</code>函数），并不立即执行软中断处理程序，而是将软中断标记为 pending 状态。在硬中断处理完成后，会检查是否有 pending 的软中断，如果有，则会唤醒<code>ksoftirqd</code>线程来处理这些软中断。</li><li><strong>执行频率</strong>：<code>ksoftirqd</code>线程会在系统空闲时被调度执行，它会循环执行，不断检查是否有软中断任务需要处理。如果没有软中断任务，它会进入睡眠状态，以节省CPU资源；当有软中断任务时，它会被唤醒并执行相应的处理函数。</li></ul><h3 id="与其他机制的关系"><a href="#与其他机制的关系" class="headerlink" title="与其他机制的关系"></a>与其他机制的关系</h3><ul><li><strong>与硬中断的关系</strong>：硬中断用于处理紧急的外部事件，如硬件设备的中断请求。软中断则是在硬中断处理的基础上，将一些可以延迟处理的任务放到软中断中执行，以提高系统的响应速度和整体性能。<code>ksoftirqd</code>作为软中断的执行者，与硬中断处理程序协同工作，共同完成系统对各种外部事件的处理。</li><li><strong>与Tasklet的关系</strong>：Tasklet是基于软中断实现的一种下半部机制，它是软中断的一种具体应用形式。<code>ksoftirqd</code>在处理软中断时，也会处理与Tasklet相关的软中断任务。Tasklet通过<code>tasklet_schedule</code>函数将任务添加到软中断队列中，然后由<code>ksoftirqd</code>线程在合适的时机执行。</li></ul><h3 id="查看与监控"><a href="#查看与监控" class="headerlink" title="查看与监控"></a>查看与监控</h3><ul><li><strong>查看线程状态</strong>：可以通过<code>ps -ef | grep ksoftirqd</code>命令查看<code>ksoftirqd</code>线程的状态，包括其进程ID、运行状态、所属用户等信息。</li><li><strong>监控软中断负载</strong>：通过<code>cat /proc/softirqs</code>命令可以查看系统中软中断的统计信息，包括各种类型软中断的触发次数等。这有助于了解系统中软中断的负载情况，以及<code>ksoftirqd</code>线程的工作负担。如果发现某些软中断的计数增长过快，可能意味着系统中存在频繁触发软中断的情况，需要进一步分析原因，可能是某些设备驱动程序或内核模块存在问题，导致软中断被过度使用。</li></ul><h3 id="配置与优化"><a href="#配置与优化" class="headerlink" title="配置与优化"></a>配置与优化</h3><ul><li><strong>内核参数调整</strong>：一些内核参数可以影响<code>ksoftirqd</code>的行为和性能。例如，<code>/proc/sys/kernel/softirq_maxcpus</code>参数可以限制软中断在多CPU系统中的分布范围，通过调整该参数，可以根据系统的硬件配置和工作负载特点，优化软中断在不同CPU核心上的分配，以提高系统的整体性能。</li><li><strong>根据负载调整策略</strong>：根据系统的实际负载情况，可以采取不同的优化策略。如果系统中软中断负载较高，可以考虑优化相关的设备驱动程序或内核模块，减少不必要的软中断触发；或者调整系统的资源分配，例如增加CPU核心、优化内存分配等，以提高系统处理软中断的能力。同时，也可以通过调整<code>ksoftirqd</code>的调度优先级等方式，使其能够更及时地处理软中断任务，但需要注意不要对其他重要任务的调度产生负面影响。</li></ul><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>在Linux内核中，<strong>工作队列（Workqueue）</strong> 是一种用于实现中断下半部（Bottom Half）处理的机制，它允许内核代码在进程上下文执行耗时操作，并且支持睡眠。与软中断和Tasklet不同，工作队列由内核线程执行，因此更适合处理需要较长时间或可能睡眠的任务。</p><h3 id="工作队列的特点"><a href="#工作队列的特点" class="headerlink" title="工作队列的特点"></a><strong>工作队列的特点</strong></h3><ol><li><strong>进程上下文执行</strong>：工作队列在专门的内核线程（<code>kworker</code>）中执行，属于进程上下文，因此可以使用可能引起睡眠的函数（如<code>kmalloc(GFP_KERNEL)</code>、信号量、<code>msleep()</code>等）。</li><li><strong>异步执行</strong>：任务通过<code>schedule_work()</code>调度后，会在后续某个时间点由内核线程执行，不阻塞当前代码路径。</li><li><strong>支持延迟执行</strong>：可以通过<code>schedule_delayed_work()</code>指定任务延迟执行的时间。</li><li><strong>可配置性</strong>：支持自定义工作队列和内核线程，以满足不同场景的需求。</li></ol><h3 id="工作队列的基本概念"><a href="#工作队列的基本概念" class="headerlink" title="工作队列的基本概念"></a><strong>工作队列的基本概念</strong></h3><ul><li><strong>工作项（Work Item）</strong>：表示一个需要执行的任务，由<code>struct work_struct</code>结构体表示。</li><li><strong>工作队列（Workqueue）</strong>：管理多个工作项的队列，每个工作队列对应一个或多个内核线程。</li><li><strong>内核工作线程（kworker）</strong>：负责执行工作队列中的任务，默认情况下每个CPU核心有一个<code>kworker</code>线程。</li></ul><h3 id="工作队列的使用方法"><a href="#工作队列的使用方法" class="headerlink" title="工作队列的使用方法"></a><strong>工作队列的使用方法</strong></h3><h4 id="1-定义工作队列处理函数"><a href="#1-定义工作队列处理函数" class="headerlink" title="1. 定义工作队列处理函数"></a><strong>1. 定义工作队列处理函数</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数原型：void func(struct work_struct *work)</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_work_handler</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取包含work_struct的父结构体（如果有）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_device</span> *<span class="title">dev</span> =</span> container_of(work, <span class="keyword">struct</span> my_device, work);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理逻辑（可睡眠）</span></span><br><span class="line">    msleep(<span class="number">10</span>); <span class="comment">// 示例：休眠10ms</span></span><br><span class="line">    process_device_data(dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-初始化工作项"><a href="#2-初始化工作项" class="headerlink" title="2. 初始化工作项"></a><strong>2. 初始化工作项</strong></h4><p>有两种方式初始化工作项：</p><h5 id="静态初始化（推荐）-1"><a href="#静态初始化（推荐）-1" class="headerlink" title="静态初始化（推荐）"></a><strong>静态初始化（推荐）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并初始化工作项（使用DECLARE_WORK）</span></span><br><span class="line">DECLARE_WORK(my_work, my_work_handler);</span><br></pre></td></tr></table></figure><h5 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a><strong>动态初始化</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">my_work</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时初始化（如模块加载时）</span></span><br><span class="line">INIT_WORK(&amp;my_work, my_work_handler);</span><br></pre></td></tr></table></figure><h4 id="3-调度工作项执行"><a href="#3-调度工作项执行" class="headerlink" title="3. 调度工作项执行"></a><strong>3. 调度工作项执行</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即执行</span></span><br><span class="line">schedule_work(&amp;my_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟执行（单位：jiffies）</span></span><br><span class="line">schedule_delayed_work(&amp;my_work, msecs_to_jiffies(<span class="number">100</span>)); <span class="comment">// 100ms后执行</span></span><br></pre></td></tr></table></figure><h4 id="4-取消工作项"><a href="#4-取消工作项" class="headerlink" title="4. 取消工作项"></a><strong>4. 取消工作项</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消未执行的工作项（若已执行则等待完成）</span></span><br><span class="line">cancel_work_sync(&amp;my_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消延迟工作项</span></span><br><span class="line">cancel_delayed_work_sync(&amp;my_work);</span><br></pre></td></tr></table></figure><h3 id="自定义工作队列"><a href="#自定义工作队列" class="headerlink" title="自定义工作队列"></a><strong>自定义工作队列</strong></h3><p>默认情况下，工作队列使用内核全局工作队列（<code>system_wq</code>）。若需要专用的内核线程，可以创建自定义工作队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建自定义工作队列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">my_wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化（在模块加载时）</span></span><br><span class="line">my_wq = alloc_workqueue(<span class="string">&quot;my_wq&quot;</span>, WQ_UNBOUND, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!my_wq) &#123;</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义工作队列调度工作项</span></span><br><span class="line">queue_work(my_wq, &amp;my_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放工作队列（在模块卸载时）</span></span><br><span class="line">destroy_workqueue(my_wq);</span><br></pre></td></tr></table></figure><h3 id="工作队列-vs-其他下半部机制"><a href="#工作队列-vs-其他下半部机制" class="headerlink" title="工作队列 vs 其他下半部机制"></a><strong>工作队列 vs 其他下半部机制</strong></h3><table><thead><tr><th><strong>机制</strong></th><th><strong>执行上下文</strong></th><th><strong>是否可睡眠</strong></th><th><strong>是否并行</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>软中断</strong></td><td>中断上下文</td><td>否</td><td>可在多CPU并行</td><td>高频、耗时短、需并行的任务</td></tr><tr><td><strong>Tasklet</strong></td><td>中断上下文</td><td>否</td><td>同类型串行，不同并行</td><td>耗时操作，无需并行</td></tr><tr><td><strong>工作队列</strong></td><td>进程上下文</td><td>是</td><td>是</td><td>需要睡眠的任务（如文件IO）</td></tr><tr><td><strong>线程化中断</strong></td><td>进程上下文</td><td>是</td><td>否</td><td>需要睡眠且对实时性要求高的中断</td></tr></tbody></table><h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li><strong>避免死锁</strong>：若工作队列处理函数获取了锁，需确保不会与其他代码路径产生死锁。</li><li><strong>资源管理</strong>：自定义工作队列使用完毕后需调用<code>destroy_workqueue()</code>释放资源。</li><li><strong>延迟精度</strong>：<code>schedule_delayed_work()</code>的延迟时间受内核调度影响，精度约为10ms级别。</li><li><strong>性能开销</strong>：工作队列的调度开销高于软中断和Tasklet，因此对于高频、短耗时的任务，建议使用Tasklet。</li></ol><h3 id="调试与监控-1"><a href="#调试与监控-1" class="headerlink" title="调试与监控"></a><strong>调试与监控</strong></h3><ul><li><p><strong>查看内核线程</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep kworker</span><br></pre></td></tr></table></figure><p>例如，<code>kworker/0:1H</code>表示CPU0的高优先级工作线程。</p></li><li><p><strong>监控工作队列负载</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/schedstat</span><br></pre></td></tr></table></figure><p>查看<code>kworker</code>线程的调度统计信息。</p></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>工作队列是Linux内核中处理需要睡眠或长时间运行任务的首选机制，它提供了简单易用的接口，同时保证了系统的稳定性。在驱动开发中，若下半部处理需要访问文件系统、等待IO完成或进行复杂计算，工作队列是最适合的选择。</p><h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><p>老的BH接口，任务队列目前仍然存在，但已经不建议使用。</p><h2 id="下半部机制选择"><a href="#下半部机制选择" class="headerlink" title="下半部机制选择"></a>下半部机制选择</h2><p>目前就三种选择：软中断，tasklet，工作队列。<br>有休眠等情况， 只能选择工作队列。其他情况优先tasklet，然后才是软中断。</p><h2 id="禁止下半部"><a href="#禁止下半部" class="headerlink" title="禁止下半部"></a>禁止下半部</h2><p>单纯的禁止下半部不可以，为了保证数据安全，一般是得到锁禁止。<br>在Linux内核中，禁止下半部（Bottom Half）是指临时阻止软中断、Tasklet或工作队列的执行。这通常用于需要完全排除下半部干扰的临界区，例如修改软中断状态或操作共享数据结构时。以下是禁止下半部的主要方法及其适用场景：</p><h3 id="1-禁止软中断和Tasklet"><a href="#1-禁止软中断和Tasklet" class="headerlink" title="1. 禁止软中断和Tasklet"></a><strong>1. 禁止软中断和Tasklet</strong></h3><h4 id="local-bh-disable-local-bh-enable"><a href="#local-bh-disable-local-bh-enable" class="headerlink" title="local_bh_disable() &#x2F; local_bh_enable()"></a><strong>local_bh_disable() &#x2F; local_bh_enable()</strong></h4><ul><li><strong>功能</strong>：禁止当前CPU上的软中断和Tasklet执行，但不影响工作队列。</li><li><strong>作用范围</strong>：仅针对当前CPU，不会影响其他CPU核心。</li><li><strong>使用场景</strong>：当需要保护临界区不被软中断或Tasklet打断时使用。</li><li><strong>注意事项</strong>：必须成对使用，且不能嵌套调用（会导致引用计数错误）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bottom_half.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">local_bh_disable();  <span class="comment">// 禁止软中断和Tasklet</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">local_bh_enable();   <span class="comment">// 恢复软中断和Tasklet</span></span><br></pre></td></tr></table></figure><h3 id="2-禁止工作队列"><a href="#2-禁止工作队列" class="headerlink" title="2. 禁止工作队列"></a><strong>2. 禁止工作队列</strong></h3><p>工作队列由内核线程执行，无法直接禁止。但可以通过以下方式控制：</p><h4 id="取消-暂停工作项"><a href="#取消-暂停工作项" class="headerlink" title="取消&#x2F;暂停工作项"></a><strong>取消&#x2F;暂停工作项</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消未执行的工作项（已执行的会等待完成）</span></span><br><span class="line">cancel_work_sync(&amp;my_work);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消延迟工作项</span></span><br><span class="line">cancel_delayed_work_sync(&amp;my_delayed_work);</span><br></pre></td></tr></table></figure><h4 id="自定义工作队列的暂停-恢复"><a href="#自定义工作队列的暂停-恢复" class="headerlink" title="自定义工作队列的暂停&#x2F;恢复"></a><strong>自定义工作队列的暂停&#x2F;恢复</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停自定义工作队列</span></span><br><span class="line">freeze_workqueue(my_wq);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复自定义工作队列</span></span><br><span class="line">thaw_workqueue(my_wq);</span><br></pre></td></tr></table></figure><h3 id="3-同时禁止硬中断和下半部"><a href="#3-同时禁止硬中断和下半部" class="headerlink" title="3. 同时禁止硬中断和下半部"></a><strong>3. 同时禁止硬中断和下半部</strong></h3><h4 id="local-irq-save-local-irq-restore"><a href="#local-irq-save-local-irq-restore" class="headerlink" title="local_irq_save() &#x2F; local_irq_restore()"></a><strong>local_irq_save() &#x2F; local_irq_restore()</strong></h4><ul><li><strong>功能</strong>：保存当前中断状态，禁用硬中断和下半部。</li><li><strong>作用范围</strong>：仅针对当前CPU。</li><li><strong>使用场景</strong>：极端临界区，需要完全禁止中断和下半部。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">local_irq_save(flags);  <span class="comment">// 禁用硬中断和下半部</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">local_irq_restore(flags);  <span class="comment">// 恢复中断状态</span></span><br></pre></td></tr></table></figure><h3 id="4-禁止下半部的高级方法"><a href="#4-禁止下半部的高级方法" class="headerlink" title="4. 禁止下半部的高级方法"></a><strong>4. 禁止下半部的高级方法</strong></h3><h4 id="raw-local-bh-disable-raw-local-bh-enable"><a href="#raw-local-bh-disable-raw-local-bh-enable" class="headerlink" title="raw_local_bh_disable() &#x2F; raw_local_bh_enable()"></a><strong>raw_local_bh_disable() &#x2F; raw_local_bh_enable()</strong></h4><ul><li><strong>功能</strong>：与<code>local_bh_disable()</code>类似，但不进行中断状态检查，适用于中断已被禁用的场景。</li><li><strong>注意事项</strong>：需自行确保中断状态，否则可能导致死锁。</li></ul><h4 id="irq-work"><a href="#irq-work" class="headerlink" title="irq_work"></a><strong>irq_work</strong></h4><ul><li><strong>功能</strong>：一种特殊的下半部机制，可以通过<code>irq_work_queue()</code>调度，但只能在特定上下文使用。</li></ul><h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a><strong>使用建议</strong></h3><ol><li><strong>最小化禁用时间</strong>：长时间禁止下半部会导致系统响应性下降，甚至引发软锁死。</li><li><strong>避免嵌套禁用</strong>：多次调用<code>local_bh_disable()</code>会增加引用计数，必须对应次数的<code>local_bh_enable()</code>才能恢复。</li><li><strong>优先使用更细粒度的锁</strong>：例如自旋锁（<code>spin_lock_bh()</code>），它仅在持有锁期间禁止下半部，而非整个临界区。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用自旋锁保护共享资源，同时禁止下半部</span></span><br><span class="line">spin_lock_bh(&amp;my_lock);</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">spin_unlock_bh(&amp;my_lock);</span><br></pre></td></tr></table></figure><h3 id="调试与监控-2"><a href="#调试与监控-2" class="headerlink" title="调试与监控"></a><strong>调试与监控</strong></h3><ul><li><p><strong>查看下半部状态</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/softirqs  <span class="comment"># 查看软中断计数</span></span><br><span class="line">ps -ef | grep kworker  <span class="comment"># 查看工作队列线程</span></span><br></pre></td></tr></table></figure></li><li><p><strong>检测下半部长时间禁用</strong>：<br>内核可能会通过<code>softlockup</code>机制检测并报告长时间（通常&gt;20秒）禁用中断或下半部的情况。</p></li></ul><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>禁止下半部是一种强力但危险的操作，应谨慎使用。通常情况下，优先使用锁机制（如自旋锁、互斥锁）保护共享资源，而非直接禁止下半部。只有在确实需要完全排除下半部干扰的极少数场景下，才考虑使用<code>local_bh_disable()</code>或<code>local_irq_save()</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>arm汇编与C内联汇编</title>
      <link href="/posts/cf1cdeca.html"/>
      <url>/posts/cf1cdeca.html</url>
      
        <content type="html"><![CDATA[<p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/arm%E6%B1%87%E7%BC%96%E4%B8%8EC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/%E5%B0%81%E9%9D%A2.png"></p><h1 id="0、常用指令"><a href="#0、常用指令" class="headerlink" title="0、常用指令"></a>0、常用指令</h1><h2 id="0-1、GNU汇编语法："><a href="#0-1、GNU汇编语法：" class="headerlink" title="0-1、GNU汇编语法："></a>0-1、GNU汇编语法：</h2><p>label:instruction @comment<br>label:标号，表示地址位置，有的指令前面有标号，通过标号来定位指令位置。<br>也可以用来表示数据地址,任何以:开头的标号都是数据地址。<br>instruction:指令，表示一条指令。也可以是伪指令。<br>@comment:注释，表示对指令的说明。</p><p>用户可以使用.section指令来自定义一个段，汇编系统自定义了一些段名字。<br>.text:定义一个代码段。<br>.data:定义一个初始化的数据段。<br>.bss:定义一个未初始化的数据段。<br>.redata:定义一个只读的只读数据段。</p><p>程序默认入口__start,也可以使用链接脚本中ENTRY指令指定程序入口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.global __start</span><br><span class="line">__start:</span><br><span class="line">    b main</span><br></pre></td></tr></table></figure><p>.global:全局指令，表示定义一个全局标号。相当于C语言中的extern，全局变量<br>.byte:定义一个字节，相当于C语言中的char。<br>.short:定义一个字，相当于C语言中的short。<br>.long:定义一个双字，相当于C语言中的int。<br>.equ:定义一个字节，.equ num,0x12 。相当于C语言中的num&#x3D;0x12。<br>.align:对齐指令，表示对齐。<br>.end:表示源文件结束。</p><p>GNU汇编函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数名:</span><br><span class="line">    函数体</span><br><span class="line">    返回语句</span><br></pre></td></tr></table></figure><h2 id="0-2、移动指令"><a href="#0-2、移动指令" class="headerlink" title="0-2、移动指令"></a>0-2、移动指令</h2><p>处理器做的最多的事情就是在处理器内部来回传数据</p><ul><li>将数据从一个寄存器传送到另一个寄存器</li><li>将数据从一个存储器传到另一个特殊的存储器，如cpsr寄存器。spsr寄存器。</li><li>将立即数立刻加载到寄存器</li></ul><h3 id="0-2-1、MOV指令"><a href="#0-2-1、MOV指令" class="headerlink" title="0-2-1、MOV指令"></a>0-2-1、MOV指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0, R1 @将R0寄存器的内容赋值给R1寄存器。</span><br><span class="line">MOV R0, #12 @将立即数12赋值给R0寄存器。</span><br></pre></td></tr></table></figure><h3 id="0-2-2、MRS指令"><a href="#0-2-2、MRS指令" class="headerlink" title="0-2-2、MRS指令"></a>0-2-2、MRS指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRS R0, CPSR @将cpsr寄存器的内容赋值给R0寄存器。R0=cpsr寄存器的内容。</span><br></pre></td></tr></table></figure><h3 id="0-2-3、MSR指令"><a href="#0-2-3、MSR指令" class="headerlink" title="0-2-3、MSR指令"></a>0-2-3、MSR指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSR CPSR_c, R0 @将R0寄存器的内容赋值给cpsr寄存器的内容。</span><br></pre></td></tr></table></figure><h2 id="0-3、压栈、弹栈"><a href="#0-3、压栈、弹栈" class="headerlink" title="0-3、压栈、弹栈"></a>0-3、压栈、弹栈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH &#123;R0, R1&#125; @将R0和R1寄存器的内容压入栈中。</span><br><span class="line">PUSH &#123;R0&#125; @将R0寄存器的内容压入栈中。</span><br><span class="line">POP &#123;R2, R3&#125; @将栈中的内容赋值给R2和R3寄存器。</span><br><span class="line">POP &#123;R2&#125; @将栈中的内容赋值给R2寄存器。</span><br></pre></td></tr></table></figure><h2 id="0-4、存储器访问指令"><a href="#0-4、存储器访问指令" class="headerlink" title="0-4、存储器访问指令"></a>0-4、存储器访问指令</h2><p>对寄存器、存储器存取数据，无法直接用mov等指令来操作，需要采用特殊的指令来操作。<br>方法：将值写入通用寄存器Rx（x&#x3D;0~12）中。然后借助指令，将寄存器写入存储器中。</p><h3 id="0-3-1、LDR指令"><a href="#0-3-1、LDR指令" class="headerlink" title="0-3-1、LDR指令"></a>0-3-1、LDR指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, =0x12345678 @将存储器地址0x12345678加载到R0寄存器。</span><br><span class="line">LDR R1, [R0] @将存储器地址[R0]的内容赋值给R1寄存器。</span><br></pre></td></tr></table></figure><p>和MOV有区别</p><h3 id="0-3-2、STR指令"><a href="#0-3-2、STR指令" class="headerlink" title="0-3-2、STR指令"></a>0-3-2、STR指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LDR R0,=0x12345678 @将R0寄存器的内容赋值给存储器地址0x12345678。</span><br><span class="line">LDR R1,=0x11111111 [R0] @将R0寄存器的内容赋值给存储器地址0x12345678。</span><br><span class="line">STR R1, [R0] @将R1寄存器的内容赋值给存储器地址[R0]。</span><br></pre></td></tr></table></figure><h2 id="0-5、跳转指令"><a href="#0-5、跳转指令" class="headerlink" title="0-5、跳转指令"></a>0-5、跳转指令</h2><p>跳转指令：</p><ul><li>b:跳转到标号处执行。</li><li>bl:跳转到标号处执行，并保存当前程序地址。</li><li>bx:跳转到寄存器中存储的地址处执行。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b label @跳转到标号处执行。</span><br><span class="line">bl label @跳转到标号处执行，并保存当前程序地址。</span><br><span class="line">bx R0 @跳转到寄存器中存储的地址处执行。</span><br></pre></td></tr></table></figure>例程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.global __start</span><br><span class="line">__start:</span><br><span class="line">    ldr r0, =0x12345678  @ 将立即数 0x12345678 装载到 R0</span><br><span class="line">    ldr r1, =0x20000000  @ 将立即数 0x20000000 装载到 R1</span><br><span class="line">    str r0, [r1, #0x10]  @ 将 R0 的内容存储到 R1 + 0x10 的地址处</span><br><span class="line">    b .                  @ 无限循环，防止程序退出</span><br></pre></td></tr></table></figure></li></ul><h2 id="0-6、算数运算"><a href="#0-6、算数运算" class="headerlink" title="0-6、算数运算"></a>0-6、算数运算</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/arm%E6%B1%87%E7%BC%96%E4%B8%8EC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/0%E3%80%81%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4.png"></p><h2 id="0-7、逻辑运算"><a href="#0-7、逻辑运算" class="headerlink" title="0-7、逻辑运算"></a>0-7、逻辑运算</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/arm%E6%B1%87%E7%BC%96%E4%B8%8EC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/0%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4.png"></p><h1 id="1、arm到底是干啥的？"><a href="#1、arm到底是干啥的？" class="headerlink" title="1、arm到底是干啥的？"></a>1、arm到底是干啥的？</h1><p>任何一款ARM芯片都由两大部分组成：ARM内核，外设。</p><ul><li><p>ARM内核<br>ARM内核：包括了寄存器组、指令集、总线、存储器映射规则、中断逻辑和调试组件等。<br>内核是由ARM公司设计并以销售方式授权给个芯片厂商使用的（ARM公司本身不做芯片）。<br>比如为高速度设计的Cortex A8、A9都是ARMv7a 架构;<br>Cortex M3、M4是ARMv7m架构;前者是处理器（就是内核），后者是指令集的架构（也简称架构）。<br>外设部分包括计时器、A&#x2F;D转换器、存储器、i2c、UART、SPI、ROM…等等，<br>则完全由各芯片厂商自己设计并与ARM内核衔接配套。<br>不同的芯片厂商就有不同的外设，因此构成了数量和规格庞大的ARM芯片产业。        </p></li><li><p>ARM指令集架构<br>指令集的设计是处理器结构中最重要的一个部分，用ARM的术语称之为ISA（Instruction Set Architecture）。指令集可以说是cpu设计的灵魂，是打开CPU这个潘多拉魔盒的咒语，要想使用cpu，<br>我们只能通过这些指令来操作cpu。对于32位的cpu，这些指令就是一个个32位的01的序列，<br>不同的值就代表了不同的机器指令，cpu的硬件能完美的解析并执行这些指令，比如寻址、运算、异常处理等等。<br>当我们用手机玩着王者荣耀的时候，要知道我们的每发的一招，其实最终都是被翻译成了一系列机器指令。<br>从1985年ARMv1架构诞生起，到2011年，ARM架构已经发展到了第八代ARMv8。<br>Cortex-A32&#x2F;35&#x2F;53&#x2F;57&#x2F;72&#x2F;73&#x2F;77&#x2F;78采用的都是ARMv8架构，<br>这是ARM公司的首款支持64位指令集的处理器架构。</p></li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/arm%E6%B1%87%E7%BC%96%E4%B8%8EC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/1%E3%80%81arm%E6%9E%B6%E6%9E%84%E5%8F%98%E5%8C%96.png"></p><p>ARM11就是ARMv6，之后都是ARMv7版本。从ARMV7开始，命名方式就有所改变。<br>新的处理器家族，改以Cortex命名，并分为三个系列，分别是Cortex-A，Cortex-R，Cortex-M。<br>很巧合，又是这三个字母A、R、M。</p><ul><li><p>Cortex-A系列（A：Application）<br>针对日益增长的消费娱乐和无线产品设计，用于具有高计算要求、<br>运行丰富操作系统及提供交互媒体和图形体验的应用领域，<br>如智能手机、平板电脑、汽车娱乐系统、数字电视，智能本、<br>电子阅读器、家用网络、家用网关和其他各种产品。</p></li><li><p>Cortex-R系列 （R：Real-time）<br>针对需要运行实时操作的系统应用，面向如汽车制动系统、动力传动解决方案、<br>大容量存储控制器等深层嵌入式实时应用。</p></li><li><p>Cortex-M系列（M：Microcontroller）该系列面向微控制器领域，<br>主要针对成本和功耗敏感的应用，如智能测量、人机接口设备、汽车和工业控制系统、<br>家用电器、消费性产品和医疗器械等。</p></li><li><p>Cortex-SC系列（SC：SecurCore）其实，除了上述三大系列之外，<br>还有一个主打安全的Cortex-SC系列（SC：SecurCore），主要用于政府安全芯片。</p></li></ul><h2 id="1-1、什么是soc"><a href="#1-1、什么是soc" class="headerlink" title="1-1、什么是soc"></a>1-1、什么是soc</h2><p>SoC的全称叫做：System-on-a-Chip，中文的的意思就是“把系统都做在一个芯片上”。<br>SoC上集成了很多手机上最关键的部件，<br>比如CPU、GPU、内存、也就说虽然它在主板上的存在是一个芯片，但是它里边可是由很多部件封装组成的。<br>比如通常我们所说的高通801，麒麟950，三星的exynos 4412，A6等等。<br>都只是系统部件打包封装（SoC）后的总称。然而各家的打包封装的内容则不尽相同，原因也不尽相同。</p><p>经典的ARM系统级芯片或所谓的Soc包含许多组件，其中只有一些直接源自ARM。<br>首先，核心本身通常深度嵌入在设备内部，在设备范畴内通常不直接可见，<br>而调试端口通常是唯一和核心本身相连的外露部分，有一些粘合逻辑，如时钟和复位集成电路。<br>由于 ARM 核心只有两个中断输入，最常见的外设就是某种中断控制器，在外设内部，<br>各组件通过芯片上互联总线架构相互连接，对于极大多数基于ARM的设备而言，这就是标准的 AMBA 互联。<br>AMBA 指定了两个总线，称为AXI的高性能系统总线，和称为APB的低功耗外设总线，<br>APB通常用于连接所有外设，AXI则用于存储器和其他发高速设备，<br>大多数设备都有一定数量的芯片上存储以及连接外设存储器设备的接口，<br>但是注意，与设备的外部连接并不是AMBA总线，这仅在设备内部使用，并不外露。</p><h2 id="1-2、ARM授权"><a href="#1-2、ARM授权" class="headerlink" title="1-2、ARM授权"></a>1-2、ARM授权</h2><ul><li><p>如何来理解ARM授权呢？<br>就比如我们制造汽车，ARM公司相当于拥有最先进的的’发动机’设计方案，<br>但是他不’生产发动机’，而是把设计方案授权给各大’汽车厂商’生产，<br>赚来的钱继续研发更先进的‘发动机’。</p></li><li><p>ARM授权分为ARM架构授权、IP核授权、使用层级授权。<br>一个公司若想使用ARM的内核来做自己的处理器，比如ST、苹果、三星、TI、高通、华为等等，<br>必须向ARM公司购买其架构下的不同层级授权，根据使用需要购买相应的层级授权。<br>架构的授权方式有三种：架构层级授权、内核层级授权(ip核授权)、使用层级授权。</p></li><li><p>1.架构层级授权，是指可以对ARM架构进行大幅度改造，甚至可以对ARM指令集进行扩展或缩减，<br>苹果就是一个很好的例子，在使用ARMv7-A架构基础上，扩展出了自己的苹果swift架构；</p></li><li><p>2.内核层级授权，是指可以以一个内核为基础然后在加上自己的外设，比如USART、GPIO、SPI、ADC等等，<br>最后形成了自己的MCU，这种公司很多，比如三星、TI;</p></li><li><p>3.使用层级授权，要想使用一款处理器，得到使用层级的授权是最基本的，<br>这就意味着你只能拿别人提供的定义好的ip来嵌入在你的设计中，不能更改人家的ip，<br>也不能借助人家的ip创造自己的基于该ip的封装产品。因此，如果华为分别拿到架构授权和ip核授权，<br>那么意味着它可以在ARM指令集基础上根据需要创建出自己的内核架构，<br>并可添加各种片内外设比如通信接口、显示器控制接口、GPIO等等，从而生产出自己的“处理器芯片”。<br>其实就像我写了一篇文章，我告诉甲，你可以拿去修改后使用，便是架构层级授权，我告诉乙，<br>你可以在你的文章中引用我的文章，便是内核级授权，我告诉丙，你只能对我的文章进行转发，<br>不能更改，不能添油加醋，便是使用层级授权。</p></li><li><p>总结：ARM公司的名字，叫ARM：Advanced RISC Machines；<br>1、ARM前身Acorn公司设计的第一款微处理器，叫ARM：Acorn RISC Machine；<br>2、ARM处理器名字：以前叫ARM9、ARM11,<br>3、新的命名规则改以Cortex命名，分别是Cortex-A，Cortex-R，Cortex-M；<br>4、这三个字母A、R、M合到一起又是ARM。ARM指令集，就是ARM架构，比如ARMv8，<br>5、每个处理器都需要依赖一定的ARM架构来设计；<br>6、SOC：各大厂商买来ARM的授权，得到ARM处理器的源代码，而后自己搞一些外围设备的IP（或者买或者自己设计），组成一个SOC，比如三星的Exynos 4412，华为的麒麟990。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux内核代码规范</title>
      <link href="/posts/66378cb.html"/>
      <url>/posts/66378cb.html</url>
      
        <content type="html"><![CDATA[<p>缩进：</p><p>使用 8 个空格的制表符进行缩进。<br>函数参数和长表达式在续行时也使用 8 个空格的缩进。<br>行长度：</p><p>每行最大长度为 80 个字符。<br>大括号：</p><p>大括号前换行，符合 Linux 风格。<br>空格：</p><p>赋值操作符前后留空格。<br>控制语句（如 if, for, while）前留空格。<br>行尾注释前留两个空格。<br>其他：</p><p>不允许短的 if 语句、循环语句、函数和代码块写在一行。<br>字符串字面量允许换行。<br>指针对齐方式为右对齐。<br>以下是调整后的 .clang-format 文件，确保更符合 Linux 内核的代码规范：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">BasedOnStyle: LLVM</span><br><span class="line">IndentWidth: 8          # 通用缩进宽度为8个空格</span><br><span class="line">UseTab: Never           # 不使用制表符，只使用空格</span><br><span class="line">TabWidth: 8             # 制表符宽度为8个空格</span><br><span class="line">ColumnLimit: 0</span><br><span class="line">BreakBeforeBraces: Linux</span><br><span class="line">AllowShortIfStatementsOnASingleLine: false</span><br><span class="line">AllowShortLoopsOnASingleLine: false</span><br><span class="line">AllowShortFunctionsOnASingleLine: None</span><br><span class="line">AllowShortBlocksOnASingleLine: false</span><br><span class="line">SpacesBeforeTrailingComments: 2</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: Yes</span><br><span class="line">BinPackParameters: false</span><br><span class="line">BinPackArguments: false</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignConsecutiveMacros: false</span><br><span class="line">AlignConsecutiveBitFields: false</span><br><span class="line">AlignConsecutiveAssignments: false</span><br><span class="line">AlignConsecutiveDeclarations: false</span><br><span class="line">AlignEscapedNewlines: Left</span><br><span class="line">AlignOperands: false</span><br><span class="line">AlignTrailingComments: false</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: false</span><br><span class="line">AllowAllArgumentsOnNextLine: false</span><br><span class="line">BreakBeforeBinaryOperators: NonAssignment</span><br><span class="line">BreakBeforeTernaryOperators: true</span><br><span class="line">BreakStringLiterals: true</span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: false</span><br><span class="line">ConstructorInitializerIndentWidth: 0</span><br><span class="line">ContinuationIndentWidth: 8</span><br><span class="line">DerivePointerBinding: false</span><br><span class="line">FixNamespaceComments: false</span><br><span class="line">IncludeBlocks: Preserve</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">IndentPPDirectives: None</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: false</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: None</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">ReflowComments: false</span><br><span class="line">SortIncludes: false</span><br><span class="line">SortUsingDeclarations: false</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceAfterTemplateKeyword: false</span><br><span class="line">SpaceBeforeCpp11BracedList: false</span><br><span class="line">SpaceBeforeInheritanceColon: false</span><br><span class="line">SpaceBeforeRangeBasedForLoopColon: false</span><br><span class="line">Standard: Cpp11</span><br><span class="line">UseCRLF: false</span><br><span class="line"></span><br><span class="line">Language:        Cpp</span><br><span class="line">AccessModifierOffset: -4  # 将访问控制符向左缩进8个空格</span><br><span class="line">IndentAccessModifiers: true  # 对访问控制符进行缩进</span><br></pre></td></tr></table></figure><p>关键点解释<br>IndentWidth: 8: 使用 8 个空格的缩进。<br>UseTab: Always: 使用制表符而不是空格进行缩进。<br>TabWidth: 8: 制表符宽度为 8 个空格。<br>ColumnLimit: 80: 每行最大长度为 80 个字符。<br>BreakBeforeBraces: Linux: 在大括号前换行，符合 Linux 风格。<br>AllowShortIfStatementsOnASingleLine: false: 不允许短的 if 语句写在一行。<br>AllowShortLoopsOnASingleLine: false: 不允许短的循环语句写在一行。<br>AllowShortFunctionsOnASingleLine: None: 不允许短的函数写在一行。<br>AllowShortBlocksOnASingleLine: false: 不允许短的代码块写在一行。<br>SpacesBeforeTrailingComments: 2: 行尾注释前留两个空格。<br>SpaceBeforeAssignmentOperators: true: 赋值操作符前后留空格。<br>SpaceBeforeParens: ControlStatements: 控制语句（如 if, for, while）前留空格。<br>SpaceInEmptyParentheses: false: 空括号内不留空格。<br>AlwaysBreakTemplateDeclarations: Yes: 模板声明总是换行。<br>BinPackParameters: false: 参数列表不紧凑排列。<br>BinPackArguments: false: 函数调用参数不紧凑排列。<br>AlignAfterOpenBracket: Align: 开括号后不对齐。<br>AlignConsecutiveMacros: false: 连续的宏定义不对齐。<br>AlignConsecutiveBitFields: false: 连续的位字段不对齐。<br>AlignConsecutiveAssignments: false: 连续的赋值语句不对齐。<br>AlignConsecutiveDeclarations: false: 连续的声明不对齐。<br>AlignEscapedNewlines: Left: 转义的换行符左对齐。<br>AlignOperands: false: 操作数不对齐。<br>AlignTrailingComments: false: 行尾注释不对齐。<br>AllowAllParametersOfDeclarationOnNextLine: false: 函数声明的参数不允许全部放在下一行。<br>AllowAllArgumentsOnNextLine: false: 函数调用的参数不允许全部放在下一行。<br>AllowParameterAlignment: false: 参数不允许对齐。<br>BreakBeforeBinaryOperators: NonAssignment: 二元操作符前换行，但赋值操作符除外。<br>BreakBeforeTernaryOperators: true: 三元操作符前换行。<br>BreakStringLiterals: true: 字符串字面量允许换行。<br>ConstructorInitializerAllOnOneLineOrOnePerLine: false: 构造函数初始化列表不允许全部放在一行。<br>ConstructorInitializerIndentWidth: 0: 构造函数初始化列表不额外缩进。<br>ContinuationIndentWidth: 8: 续行缩进宽度为 8 个空格。<br>DerivePointerBinding: false: 不推导指针绑定。<br>FixNamespaceComments: false: 不修复命名空间注释。<br>IncludeBlocks: Preserve: 保留 include 块的顺序。<br>IndentCaseLabels: false: case 标签不缩进。<br>IndentPPDirectives: AfterHash: 预处理器指令的缩进在 # 后。<br>IndentWidth: 8: 缩进宽度为 8 个空格。<br>KeepEmptyLinesAtTheStartOfBlocks: false: 不保留块开头的空行。<br>MaxEmptyLinesToKeep: 1: 最多保留 1 行空行。<br>NamespaceIndentation: None: 命名空间不缩进。<br>PenaltyBreakBeforeFirstCallParameter: 19: 在函数调用的第一个参数前换行的惩罚分数。<br>PenaltyBreakComment: 300: 注释前换行的惩罚分数。<br>PenaltyBreakString: 1000: 字符串字面量前换行的惩罚分数。<br>PenaltyExcessCharacter: 1000000: 超出列限制的惩罚分数。<br>PenaltyReturnTypeOnItsOwnLine: 60: 返回类型单独一行的惩罚分数。<br>PointerAlignment: Left: 指针对齐方式为左对齐。<br>ReflowComments: false: 不重排注释。<br>SortIncludes: false: 不排序 include 语句。<br>SortUsingDeclarations: false: 不排序 using 声明。<br>SpaceAfterCStyleCast: false: C 风格的强制类型转换后不留空格。<br>SpaceAfterTemplateKeyword: false: 模板关键字后不留空格。<br>SpaceBeforeCpp11BracedList: false: C++11 花括号列表前不留空格。<br>SpaceBeforeInheritanceColon: false: 继承冒号前不留空格。<br>SpaceBeforeRangeBasedForLoopColon: false: 范围 for 循环冒号前不留空格。<br>Standard: Cpp11: 使用 C++11 标准。<br>UseCRLF: false: 不使用 CRLF 行结束符。</p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/posts/4b0178e0.html"/>
      <url>/posts/4b0178e0.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>数据的物理结构<br>数据存储在存储器当中，而存储器相当于内存而言，而光盘，软盘，硬盘等外部存储器的数据组织通常用文件结构来描述。</p></li><li><p>数据存储的形式有两种：顺序式和链式。、</p></li><li><p>算法的五个特征：输入，输出，有穷性，确定性和可行性。   </p><table><thead><tr><th align="center">特征</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">输入</td><td align="center">0个或者多个</td></tr><tr><td align="center">输出</td><td align="center">一个或者多个输出</td></tr><tr><td align="center">有穷性</td><td align="center">不会无限循环</td></tr><tr><td align="center">确定性</td><td align="center">确定性不会有其他含义</td></tr><tr><td align="center">可行性</td><td align="center">每一步都是可行的</td></tr></tbody></table></li><li><p>算法的设计要求<br>1、没有语法错误。<br>2、算法程序对于合法输入能够产生满足要求的输出。<br>3、算法程序对于非法输入能产生满足规格的说明。<br>4、算法对于故意刁难的测试输入都有满足要求的输出结果。</p></li></ul><p>可读性<br>   需要便于后续的修改阅读  </p><p>健壮性<br>  输入不合理时，算法能够有相应的处理，而不是产生异常、崩溃或者莫名奇妙的结果。<br>   时间效率高和存储量</p><h1 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h1><p>关键在于认识： 时间&#x3D;执行次数<br>T(n)&#x3D;O(f(n));<br>这样就可以用O来记时间复杂度<br>一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。<br>常见的时间复杂度O(1),O(n),O(n^2),O(log(n)),O(nlog(n)),O(n^3),O(2^n),O(n!),O(n^n)</p><h1 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h1><p>关键在于认识： 空间&#x3D;占用内存<br>一般不关注。</p><h1 id="3、线性表"><a href="#3、线性表" class="headerlink" title="3、线性表"></a>3、线性表</h1><p>判断方法：如果存在多个元素，且每个元素都有唯一的一个前驱和后继，则该数据结构为线性表。头无前驱，尾无后继。<br>对数据的操作：增删改查。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value = <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span> ( x );</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里函数修改了元素值，却没有带回来原因是：传递时，test函数里的x是从main中的x复制过来的，所以修改了x的值，但test函数里的x并没有改变。</p><p>如果想将参数的结果带回来，需要传入参数的应用“&amp;”。<br>团队中，自己定义的数据结构如果要让人很方便的使用，自己就必须进行函数封装，方便调用。避免出错。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-1%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8.png"></p><h2 id="3-1、顺序表"><a href="#3-1、顺序表" class="headerlink" title="3.1、顺序表"></a>3.1、顺序表</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-1-1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-1-1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8.png"></p><p>顺序表的实现 – 静态分配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10 <span class="comment">// 定义最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    elemtype data[maxsize]; <span class="comment">// 定义表类型数组</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 表当前的长度</span></span><br><span class="line">&#125;SqList; <span class="comment">//顺序表的定义类型 （静态分配的方式）</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxsize 10 <span class="comment">// 定义最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> data[maxsize]; <span class="comment">// 定义表类型数组</span></span><br><span class="line"> <span class="type">int</span> length; <span class="comment">// 表当前的长度   </span></span><br><span class="line">&#125;sqlist; <span class="comment">//顺序表的定义类型 （静态分配的方式）</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initlist</span><span class="params">(sqlist &amp;L)</span> <span class="comment">// 初始化顺序表</span></span><br><span class="line">&#123;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">// 初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getelem</span><span class="params">(sqlist &amp;L, <span class="type">int</span> i)</span> <span class="comment">// 获取元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>&gt; || i&gt;L.length)</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sqlist L; <span class="comment">// 定义顺序表</span></span><br><span class="line">    Initlist(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    尝试打印“违规”操作，</span></span><br><span class="line"><span class="comment">    必须使用L.length进行限制</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; maxsize; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;%d lendth : %d\n&quot;, L.data[i], L.length);</span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//正确方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxsize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = getelem(L,i);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-1-1%E3%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%86%85%E5%AD%98%E6%83%85%E5%86%B5.png"></p><p>这种分配方式的缺点是：大小无法更改。</p><p>就只能采用动态分配的方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 5 <span class="comment">// 定义初始容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    elemtype *data; <span class="comment">// 定义表类型数组</span></span><br><span class="line">    <span class="type">int</span> MaxSize; <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 表当前的长度</span></span><br><span class="line">&#125;SqList; <span class="comment">//顺序表的定义类型 （动态分配的方式）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用c实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize  100 <span class="comment">// 初始化数组大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *data; <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> maxsize; <span class="comment">// 数组的最大容量</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 数组的当前长度</span></span><br><span class="line">&#125;sqlist;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initlist</span> <span class="params">(sqlist &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// malloc 函数申请一片连续的存储空间</span></span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(Initsize * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.maxsize = Initsize;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Increasize</span> <span class="params">(sqlist &amp;L, <span class="type">int</span> inc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *newdata; <span class="comment">// 新分配的数组</span></span><br><span class="line">    <span class="keyword">if</span>(inc &lt;= <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    newdata = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.maxsize + inc) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        newdata[ i ] = L.data[ i ];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data+=inc;</span><br><span class="line">    <span class="built_in">free</span>(L.data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sqlist L;</span><br><span class="line">    Initlist (L) </span><br><span class="line">    <span class="comment">//...........往顺序表种随便插入几个元素</span></span><br><span class="line">    Increasize (L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用c++实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> maxsize;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;sqlist ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">initlist</span><span class="params">(sqlist &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.data = <span class="keyword">new</span> <span class="type">int</span>[InitSize];</span><br><span class="line">    <span class="keyword">if</span>(L.data == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.maxsize = InitSize;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addlist</span> <span class="params">( sqlist &amp;L , <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( L.length &gt;= L.maxsize )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* newdata = <span class="keyword">new</span> <span class="type">int</span>[ L.maxsize + x ];</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; L.length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            newdata[ i ] = L.data[ i ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] L.data;</span><br><span class="line">        L.data = newdata;</span><br><span class="line">        L.maxsize += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adddate</span> <span class="params">( sqlist&amp; L , <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= L.maxsize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[L.length] = i;</span><br><span class="line">    L.length++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getelement</span> <span class="params">( sqlist&amp; L , <span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &lt; <span class="number">1</span> || i &gt; L.length )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqlist L;</span><br><span class="line">    <span class="built_in">initlist</span> ( L );</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">adddate</span> ( L , i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">addlist</span> ( L , <span class="number">1</span> ); <span class="comment">//表增加一个空位</span></span><br><span class="line">    <span class="built_in">adddate</span> ( L , <span class="number">10</span> );</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; L.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        k = <span class="built_in">getelement</span> ( L , i + <span class="number">1</span> );</span><br><span class="line">        cout &lt;&lt; k  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表释放删除</span></span><br><span class="line">    <span class="comment">//·····</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>顺序表的特点<br>1、随机访问，时间复杂度为O(1),即通过下标直接访问，效率高。<br>2、存储密度高，每个节点只存储数据元素。<br>3、扩展容量不方便（采用动态分配方式实现，时间复杂度较高）。<br>4、插入、删除操作不方便，需要移动大量的元素。</li></ul><h1 id="3-1-2、顺序表的插入"><a href="#3-1-2、顺序表的插入" class="headerlink" title="3-1-2、顺序表的插入"></a>3-1-2、顺序表的插入</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-1-1%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%8F%92%E5%85%A5%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><ul><li>顺序表的插入：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10 <span class="comment">// 定义顺序表的最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    elemtype data[Maxsize]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 表当前的长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initlist</span><span class="params">(SqList &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    sql.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == Maxsize) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 顺序表已满，不能插入</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 位置参数错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; --j)</span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    Initlist(L);</span><br><span class="line">    <span class="comment">//...............往顺序表种随便插入几个元素</span></span><br><span class="line">    <span class="type">bool</span> ret = ListInsert(L, <span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 在第一个元素之前插入一个值为10的元素</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>顺序表要求插入的时候不能跳跃。</p><ul><li>时间复杂度情况<br>最好情况： 插入位置在表尾，时间复杂度为O(1)</li></ul><p>最坏情况： 插入位置在表头，时间复杂度为O(n)</p><p>平均情况： 插入位置在表中间，时间复杂度为O(n)</p><ul><li>顺序表的删除<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 顺序表为空，不能删除</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 位置参数错误</span></span><br><span class="line">    e = L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; ++j) <span class="comment">// 删除元素后，将后面的元素全部前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    L.length--; <span class="comment">// 删除一个元素，表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SqList L;</span><br><span class="line">    Initlist(L);</span><br><span class="line">    <span class="comment">//...............往顺序表种随便插入几个元素</span></span><br><span class="line">    <span class="type">int</span> e=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ListDelete(L, <span class="number">1</span>, e) == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除的元素为：&quot;</span>&lt;&lt;e;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">函数的传参，需要确定是否需要将参数返回。</span><br><span class="line">不传函数地址或这不取地址，择会重新在内存中复制一份数据。</span><br><span class="line">取地址决定着数据是复制一份还是延用一份。</span><br><span class="line">![](./../../../img/<span class="number">0</span>_通用技术/数据结构/<span class="number">3</span>、线性表/<span class="number">3</span><span class="number">-1</span><span class="number">-1</span>、删除的情况下时间复杂度.png)</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span><span class="number">-1</span><span class="number">-3</span>、顺序表的查找</span><br><span class="line">* 顺序表的按位查找</span><br><span class="line">getElem(SqList L, <span class="type">int</span> i) <span class="comment">// 按位查找操作。获取表L中第i个元素的值。</span></span><br><span class="line"></span><br><span class="line">静态：</span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10 <span class="comment">// 定义顺序表的最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elemtype data[Maxsize]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 表当前的长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">Elemtype <span class="title function_">getElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span> <span class="comment">// 按位查找操作。获取表L中第i个元素的值。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>动态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">// 定义顺序表的最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elemtype *data; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> maxsize; <span class="comment">// 顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 表当前的长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">Elemtype <span class="title function_">getElem</span><span class="params">(SqList L, <span class="type">int</span> i)</span> <span class="comment">// 按位查找操作。获取表L中第i个元素的值。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 位置参数错误，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//return *(L.data + i - 1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于malloc得到的内存空间。可以采用数组的方式来进行访问。访问方法和访问普通数组一样。<br>时间复杂度为O(1)。顺序表随机存取。</p><ul><li>顺序表按照值查找：<br>LocateElem(SqList L, Elemtype e) &#x2F;&#x2F; 按值查找操作。获取表L中第1个值为e的元素位置。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">// 定义顺序表的最大容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elemtype *data; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> maxsize; <span class="comment">// 顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 表当前的长度</span></span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L, Elemtype e)</span> <span class="comment">// 按值查找操作。获取表L中第1个值为e的元素位置。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i)</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">         <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回该元素在顺序表中的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>基本数据类型：int float double char 都可以用&#x3D;&#x3D;进行比较。</li></ul><p>时间复杂度：<br>最坏情况：O(n)<br>最好情况：O(1)<br>平均情况：O(n)</p><h1 id="3-2、链表"><a href="#3-2、链表" class="headerlink" title="3-2、链表"></a>3-2、链表</h1><h2 id="3-2-1、单链表的定义"><a href="#3-2-1、单链表的定义" class="headerlink" title="3-2-1、单链表的定义"></a>3-2-1、单链表的定义</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><p>顺序表采用顺序储存，单链表采用链式储存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="comment">//节点</span></span><br><span class="line">    Elemtype data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;  Node,*LinkList;</span><br><span class="line"></span><br><span class="line">Node * <span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    Node *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回第i个节点</span></span><br><span class="line">&#125;</span><br><span class="line">Node *Linklist; <span class="comment">// 定义链表,强调链表</span></span><br><span class="line">Linklist p; <span class="comment">// 定义p，强调节点</span></span><br></pre></td></tr></table></figure><ul><li>强调这是一个单链表 Linklist</li><li>强调这是一个节点 Node *</li></ul><p>不带头节点的单链表初始化方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> <span class="comment">//取地址是因为需要返回一个链表</span></span><br><span class="line">&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList L ;</span><br><span class="line">    InitList(L); <span class="comment">// 初始化链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (L == <span class="literal">NULL</span>); <span class="comment">// 链表为空，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-1%E3%80%81%E4%B8%8D%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p><p>带头节点的单链表初始化方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span> <span class="comment">//取地址是因为需要返回一个链表</span></span><br><span class="line">&#123;</span><br><span class="line">    L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 初始化头节点</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    InitList(L); <span class="comment">// 初始化链表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListEmpty</span><span class="params">(LinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (L-&gt;next == <span class="literal">NULL</span>); <span class="comment">// 链表为空，返回true</span></span><br><span class="line">    <span class="comment">// 链表为空，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-1%E3%80%81%E9%93%BE%E8%A1%A8%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E5%92%8C%E4%B8%8D%E5%B8%A6%E5%A4%B4%E5%AF%B9%E6%AF%94.png"><br>链表不带头节点，操作比较麻烦。</p><h2 id="3-2-2、单链表的插入和删除"><a href="#3-2-2、单链表的插入和删除" class="headerlink" title="3-2-2、单链表的插入和删除"></a>3-2-2、单链表的插入和删除</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E9%93%BE%E8%A1%A8%E7%AE%80%E5%8C%96%E5%9B%BE.png"></p><ul><li>带头节点（按位序插入）</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5.png"></p><ul><li><p>不带头节点（按位序插入）<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E4%B8%8D%E5%B8%A6%E5%A4%B4%E8%8A%82%E7%82%B9%E6%8C%89%E4%BD%8D%E5%BA%8F%E6%8F%92%E5%85%A5.png"></p></li><li><p>指定的结点后插入操作</p></li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E7%9A%84%E5%90%8E%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.png"></p><p>与后面插入操作相比</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E5%90%8E%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C2.png"></p><ul><li>指定节点的前插操作 - 1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertElem</span><span class="params">(LinkList L, Node *p,ElemTyep e)</span> <span class="comment">//前插操作：在节点p的前面插入值为e的节点 ，L位表头指针</span></span><br><span class="line">然后遍历插入。</span><br><span class="line">时间复杂度：<span class="title function_">O</span><span class="params">(<span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>指定节点的前插操作 - 2 (节点没办法跑路。但是数据可以跑路)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(Lnode *p, Elemtype e)</span> <span class="comment">// 前插操作：在节点p的前面插入值为e的节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 生成新节点</span></span><br><span class="line">    <span class="keyword">if</span> (!s) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内存分配失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-next = p-&gt;next; <span class="comment">// 插入节点</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 将新节点连接到p的后面</span></span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">// 讲p的数据赋值给s</span></span><br><span class="line">    p-&gt;data = e; <span class="comment">// 将p的数据赋值给e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E7%9A%84%E5%89%8D%E6%8F%92%E6%93%8D%E4%BD%9C(%E5%B0%86%E6%95%B0%E6%8D%AE%E5%B8%A6%E8%B7%91).png"></p><p>时间复杂度：O(1)</p><p>直接传节点方式–原理和带跑数据一样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(Lnode *p, Node *s)</span> <span class="comment">// 前插操作：在节点p的前面插入值为e的节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">// 插入节点</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 将新节点连接到p的后面</span></span><br><span class="line">    Elemtype temp = s-&gt;data; <span class="comment">// 保存数据</span></span><br><span class="line">    s-&gt;data = p-&gt;data; <span class="comment">// 将p的数据赋值给s</span></span><br><span class="line">    p-&gt;data = temp; <span class="comment">// 将s的数据赋值给p</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>按位序删除（带头节点）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node, *LinkList;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i,Elemtype &amp;e)</span> <span class="comment">// 按位序删除操作,</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &lt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node *p ;<span class="comment">// 定义p，指向链表的第i-1个结点</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//当前p的位序</span></span><br><span class="line">    p = L; <span class="comment">// 指向头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p! = <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>) <span class="comment">// 找到第i-1个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">// 指针后移</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p ==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//第i-1个结点为尾节点，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">   Node *q = p-&gt;next; <span class="comment">// 定义q，指向第i个结点</span></span><br><span class="line">   e = q-&gt;data; <span class="comment">// 将第i个结点的数据赋值给e</span></span><br><span class="line">   p-&gt;next = q-&gt;next; <span class="comment">// 删除第i个结点</span></span><br><span class="line">   <span class="built_in">free</span>(q); <span class="comment">// 释放第i个结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 删除成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个办法，和带着数据跑插入一样<br>这次是往要删除的后一个节点的数据赋值到前一个节点，然后删除后一个节点，这样数据就跑到前一个节点了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(node *p)</span> <span class="comment">// 按位序删除操作,</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>) <span class="comment">//第i-1个结点为尾节点,只能从表头开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node *q = p-&gt;next; <span class="comment">// 定义q，指向第i个结点</span></span><br><span class="line">    p-&gt;data = q-&gt;data; <span class="comment">// 将第i个结点的数据赋值给e</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// 删除第i个结点</span></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放第i个结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 删除成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%8F%92%E5%85%A5%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h2 id="3-2-3、单链表的查找"><a href="#3-2-3、单链表的查找" class="headerlink" title="3-2-3、单链表的查找"></a>3-2-3、单链表的查找</h2><ul><li>1、按位查找<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// 按位查找操作,返回第i个结点的数据（带头节点）</span></span><br><span class="line">Node *<span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> <span class="comment">// 按位序查找操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 参数错误，返回NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node *p; <span class="comment">//指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>; <span class="comment">//当前p指向第几个节点</span></span><br><span class="line">    p=L; <span class="comment">// 指向头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i) <span class="comment">// 找到第i个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">// 指针后移</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回第i个结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>平均时间复杂度：O(n)</li></ul><p>2、按值查找</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 按值查找操作,返回值为e的结点（带头节点）</span></span><br><span class="line">Node *<span class="title function_">LocateElem</span><span class="params">(LinkList L, Elemtype e)</span> <span class="comment">// 按值查找操作</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *p; <span class="comment">// 定义指针p，指向当前扫描到的节点</span></span><br><span class="line">    p=L-&gt;next; <span class="comment">// 指向头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) <span class="comment">// 链表不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">// 指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回值为e的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2-4、单链表的建立"><a href="#3-2-4、单链表的建立" class="headerlink" title="3-2-4、单链表的建立"></a>3-2-4、单链表的建立</h2><h3 id="3-2-4-1、尾插法"><a href="#3-2-4-1、尾插法" class="headerlink" title="3-2-4-1、尾插法"></a>3-2-4-1、尾插法</h3><ul><li>方法：创立一个头节点。设置一个指针，永远指向尾节点。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertNewElem</span><span class="params">(Node *p, Elemtype e)</span> <span class="comment">// 尾插操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 参数错误，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node *s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 生成新节点</span></span><br><span class="line">    s-&gt;data = e; <span class="comment">// 将e赋值给新节点</span></span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">// 将新节点连接到p的后面</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 将新节点连接到p的后面</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>尾插法建立单链表：<br>初始化链表<br>设置变量Length记录链表长度<br>while 循环{<br>  每次取一个数据e<br>  LIstInsert(L, Length++, e);插入尾部<br>  length++<br>}</li></ul><h3 id="3-2-4-2、头插法"><a href="#3-2-4-2、头插法" class="headerlink" title="3-2-4-2、头插法"></a>3-2-4-2、头插法</h3><p>方法：对头节点进行后插操作。(元素逆序)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">Linklist <span class="title function_">List_Headinsert</span><span class="params">(LinkList &amp;L)</span> <span class="comment">//逆向建立单链表</span></span><br><span class="line">&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 生成头节点</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头节点无前驱</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) != EOF) <span class="comment">// 输入数据</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 生成新节点</span></span><br><span class="line">        s-&gt;data = x; <span class="comment">// 将x赋值给新节点</span></span><br><span class="line">        s-&gt;next = L-&gt;next; <span class="comment">// 将新节点连接到L的后面</span></span><br><span class="line">        L-&gt;next = s; <span class="comment">// 将新节点连接到L的后面</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L; <span class="comment">// 返回头节点</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-5、双链表"><a href="#3-2-5、双链表" class="headerlink" title="3-2-5、双链表"></a>3-2-5、双链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> &#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>, *<span class="title">next</span>;</span> <span class="comment">// 前驱和后继指针</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"><span class="comment">//注意 DNode *L和DLinkList L等价,只是强调的东西不同</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList_DL</span><span class="params">(DLinkList &amp;L)</span> <span class="comment">// 初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode)); <span class="comment">// 生成头节点</span></span><br><span class="line">    <span class="keyword">if</span>(!L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内存分配失败，返回false</span></span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>; <span class="comment">// 头节点永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头节点后暂时没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 初始化成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断双连边表是否为空（带头节点）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty_DL</span><span class="params">(DLinkList L)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 链表为空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 链表为空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 链表不为空，返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DLinkList L; <span class="comment">//不带星强调链表,带星强调节点</span></span><br><span class="line">    InitList_DL(L); <span class="comment">//初始化链表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-5%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png"></p><h3 id="3-2-5-1、双链表的插入"><a href="#3-2-5-1、双链表的插入" class="headerlink" title="3-2-5-1、双链表的插入"></a>3-2-5-1、双链表的插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert_DL</span><span class="params">(DNode *p, DNode *s)</span> <span class="comment">// 在p节点后插入s节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)  <span class="comment">// 参数错误，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">// 将s节点连接到p的后面</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) <span class="comment">//p不为尾节点</span></span><br><span class="line">        p-&gt;next-&gt;prior = s; <span class="comment">//将s节点连接到p的后面</span></span><br><span class="line"></span><br><span class="line">    s-&gt;prior = p; <span class="comment">// 将p节点赋值给s的前驱</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 将p节点赋值给s的前驱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有点绕，看图理解</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-5-1%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5.png"></p><h3 id="3-2-5-2、双链表的删除"><a href="#3-2-5-2、双链表的删除" class="headerlink" title="3-2-5-2、双链表的删除"></a>3-2-5-2、双链表的删除</h3><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8/3-2-5%E3%80%81%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Delete_DL</span><span class="params">(DNode *p)</span> <span class="comment">// 删除p节点后的q节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="comment">// 参数错误，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next; <span class="comment">// 定义指针q指向p的后继</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">NULL</span>) <span class="comment">// p为尾节点，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// 将q节点连接到p的后面</span></span><br><span class="line">    <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>) <span class="comment">// q不为尾节点</span></span><br><span class="line">        q-&gt;next-&gt;prior = p; <span class="comment">// 将p节点连接到q的后面</span></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 删除成功，返回true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>双链表销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyList_DL</span><span class="params">(DLinkList &amp;L)</span> <span class="comment">// 销毁操作</span></span><br><span class="line">&#123;</span><br><span class="line">    DNode *p, *q;</span><br><span class="line">    p = L-&gt;next; <span class="comment">// 定义指针p指向头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">// 链表不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        q = p-&gt;next; <span class="comment">// 定义指针q指向p的后继</span></span><br><span class="line">        <span class="built_in">free</span>(p); <span class="comment">// 释放节点</span></span><br><span class="line">        p = q; <span class="comment">// 指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 头节点后暂时没有节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3-2-5-3、双链表的遍历</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向后遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">// 链表不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next; <span class="comment">// 指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向前遍历</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>) <span class="comment">// 链表不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;prior; <span class="comment">// 指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向前遍历（跳过带头节点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>) <span class="comment">// 链表不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;prior; <span class="comment">// 指针后移; </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-6、循环链表"><a href="#3-2-6、循环链表" class="headerlink" title="3-2-6、循环链表"></a>3-2-6、循环链表</h2><p> 循环链表有两种，循环单链表和循环双链表。<br> 循环单链表常用操作<br>尾部节点的next指向头节点</p><ul><li>判断空 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty_CL</span><span class="params">(LinkList L)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L) <span class="comment">// 链表为空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 链表为空，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 链表不为空，返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>判断是不是表尾节点 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Last_CL</span><span class="params">(LinkList L, LinkList p)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == L) <span class="comment">// p是尾节点，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// p是尾节点，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// p不是尾节点，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>循环双链表操作</p><ul><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InitList_CL</span><span class="params">(LinkList &amp;L)</span> <span class="comment">// 初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    L = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 生成头节点</span></span><br><span class="line">    <span class="keyword">if</span>(!L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 内存分配失败，返回false</span></span><br><span class="line">    L-&gt;next = L; <span class="comment">// 尾节点指向自己</span></span><br><span class="line">    L-&gt;prior = L; <span class="comment">// 前驱节点指向自己</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 初始化成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty_CL</span><span class="params">(LinkList L)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == L) <span class="comment">// 链表为空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 链表为空，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 链表不为空，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert_CL</span><span class="params">(Dnode *p, Dnode *s)</span> <span class="comment">// 在p节点后插入s节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || s == <span class="literal">NULL</span>)  <span class="comment">// 参数错误，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">// 将s节点连接到p的后面</span></span><br><span class="line">    p-&gt;next-&gt;prior = s; <span class="comment">//将s节点连接到p的后面</span></span><br><span class="line">    s-&gt;prior = p; <span class="comment">// 将p节点赋值给s的前驱</span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 将p节点赋值给s的前驱</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Delete_CL</span><span class="params">(Dnode *p)</span> <span class="comment">// 删除p节点后的q节点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="comment">// 参数错误，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Dnode *q = p-&gt;next; <span class="comment">// 定义指针q指向p的后继</span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// 将q节点连接到p的后面</span></span><br><span class="line">    q-&gt;next-&gt;prior = p; <span class="comment">// 将p节点连接到q的后面</span></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 删除成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-2-7、静态链表"><a href="#3-2-7、静态链表" class="headerlink" title="3-2-7、静态链表"></a>3-2-7、静态链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 状态码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType; <span class="comment">// 存储元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态链表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="type">int</span> cur; <span class="comment">// 当前位置标志</span></span><br><span class="line">&#125;SLinkList[MAXSIZE];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、栈"><a href="#4、栈" class="headerlink" title="4、栈"></a>4、栈</h1><p>栈:只允许在一端进行插入和删除操作的线性表，后进先出LIFO(Last In First Out)<br>术语：栈顶top和栈底base，空栈：top &#x3D;&#x3D; base<br>基本操作：<br>1、初始化：分配栈空间<br>2、销毁：释放栈空间<br>3、入栈：将元素压入栈顶<br>4、出栈：将元素从栈顶弹出<br>5、读栈顶：读栈顶元素<br>6、判空：判断栈是否为空</p><h2 id="4-1、顺序栈"><a href="#4-1、顺序栈" class="headerlink" title="4-1、顺序栈"></a>4-1、顺序栈</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E6%A0%88/4-1-1%E3%80%81%E5%85%B1%E4%BA%AB%E6%A0%88.png"></p><p><code>代码中声明结构体，或者变量，就是开辟内存空间</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><ul><li><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack_Sq</span><span class="params">(SqStack &amp;S)</span> <span class="comment">// 初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>; <span class="comment">// 栈顶指针置-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty_Sq</span><span class="params">(SqStack S)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="comment">// 栈为空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 栈为空，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈不为空，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判满</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Full_Sq</span><span class="params">(SqStack S)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MAXSIZE - <span class="number">1</span>) <span class="comment">// 栈满，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 栈满，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈不满，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>入栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Push_Sq</span><span class="params">(SqStack &amp;S, SElemType e)</span> <span class="comment">// 入栈操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MAXSIZE - <span class="number">1</span>) <span class="comment">// 栈已满，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈已满，返回false</span></span><br><span class="line">    S.data[++S.top] = e; <span class="comment">// 栈顶指针后移，将元素压入栈顶</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 入栈成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>出栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Pop_Sq</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span> <span class="comment">// 出栈操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="comment">// 栈为空，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈为空，返回false</span></span><br><span class="line">    e = S.data[S.top--]; <span class="comment">// 栈顶指针前移，将元素弹出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 出栈成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读栈顶</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">GetTop_Sq</span><span class="params">(SqStack S, SElemType &amp;e)</span> <span class="comment">// 读栈顶操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="comment">// 栈为空，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 栈为空，返回false</span></span><br><span class="line">    e = S.data[S.top]; <span class="comment">// 将栈顶元素赋值给e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 读栈顶成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-1-1、共享栈"><a href="#4-1-1、共享栈" class="headerlink" title="4-1-1、共享栈"></a>4-1-1、共享栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> top0;</span><br><span class="line">    <span class="type">int</span> top1; <span class="comment">// 队头和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><ul><li>初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitStack_Sq</span><span class="params">(SqQueue &amp;Q)</span> <span class="comment">// 初始化操作</span></span><br><span class="line">&#123;</span><br><span class="line">    Q.top0 = <span class="number">-1</span>; </span><br><span class="line">    Q.top1 = MAXSIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>内存增长方向相反<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E6%A0%88/4-1-1%E3%80%81%E5%85%B1%E4%BA%AB%E6%A0%88.png"></li></ul><h2 id="4-2、链栈"><a href="#4-2、链栈" class="headerlink" title="4-2、链栈"></a>4-2、链栈</h2><p>使用链表的一段进行插入，或者删除操作，实现栈操作。</p><h1 id="5、队列"><a href="#5、队列" class="headerlink" title="5、队列"></a>5、队列</h1><h2 id="5-1、顺序队列"><a href="#5-1、顺序队列" class="headerlink" title="5-1、顺序队列"></a>5-1、顺序队列</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E9%98%9F%E5%88%97/5-1%E3%80%81%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>队列：只允许在一端进行插入，在另一端删除的线性表，先进先出FIFO(First In First Out)<br>术语：队头head和队尾tail，空队列：head &#x3D;&#x3D; tail<br>基本操作：<br>1、初始化：分配栈空间<br>2、销毁：释放栈空间<br>3、入队：将元素压入队尾<br>4、出队：将元素从队首弹出<br>5、读队首：读队首元素<br>6、判空：判断栈是否为空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队首指针</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><ul><li><p>判空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Empty_Sq</span><span class="params">(SqQueue Q)</span> <span class="comment">// 判断操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="comment">// 队为空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 队为空，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队不为空，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>入队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, SElemType e)</span> <span class="comment">// 入队操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front) <span class="comment">// 队已满，返回false，运用中，会浪费一个存储空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队已满，返回false</span></span><br><span class="line">    Q.data[Q.rear] = e; <span class="comment">// 将元素压入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE; <span class="comment">// 队尾指针后移,相当于一个循环队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 入队成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用取余运算，实现循环队列。逻辑上实现闭环</p></li><li><p>出队</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, SElemType &amp;e)</span> <span class="comment">// 出队操作</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="comment">// 队为空，返回false,和入队的条件不同，要注意区分</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队为空，返回false</span></span><br><span class="line">    e = Q.data[Q.front]; <span class="comment">// 将队首元素赋值给e</span></span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE; <span class="comment">// 队首指针后移,相当于一个循环队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 出队成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>另一种判断队空的方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队首指针</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="type">int</span> flag; <span class="comment">// 标志位,最后一次是入队还是出队</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="5-2、链队列"><a href="#5-2、链队列" class="headerlink" title="5-2、链队列"></a>5-2、链队列</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E3%80%81%E9%98%9F%E5%88%97/5-3%E3%80%81%E9%93%BE%E9%98%9F%E5%88%97%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>使用链表的一段进行插入，或者删除操作，实现栈操作。<br>回顾之前的链表，要标记一个链表，只需要保存链表的头指针就可以了。遍历，查询等，这个指针不要动。使用另一个指针，来遍历链表。</p><ul><li>带头结点<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">tyepdef <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QNode *front; <span class="comment">// 队首指针</span></span><br><span class="line">    QNode *rear; <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!Q-&gt;front) <span class="comment">// 分配失败，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 分配失败，返回false</span></span><br><span class="line">    Q-&gt;front-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 队空，队首指针指向NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 初始化成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判断空 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear) <span class="comment">// 队空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 队空，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队不空，返回false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 新元素入队 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q, SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="comment">// 分配失败，返回false</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 分配失败，返回false</span></span><br><span class="line">    s-&gt;data = e; <span class="comment">// 赋值</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 队尾指针指向NULL</span></span><br><span class="line">    Q-&gt;rear-&gt;next = s; <span class="comment">// 队尾指针指向新节点</span></span><br><span class="line">    Q-&gt;rear = s; <span class="comment">// 队尾指针指向新节点</span></span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 入队成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 带头节点的链队首元素出队 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q, SElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear) <span class="comment">// 只有一个元素，</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 头节点，返回false</span></span><br><span class="line">    QueuePtr *p = Q-&gt;front-&gt;next; <span class="comment">// 队首指针</span></span><br><span class="line">    e = p-&gt;data; <span class="comment">// 队首元素赋值给e</span></span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next; <span class="comment">// 队首指针指向下一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == p) <span class="comment">// 只有一个元素，队尾指针指向NULL</span></span><br><span class="line">        Q-&gt;rear = Q-&gt;front; <span class="comment">// 只有一个元素，队尾指针指向NULL</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 出队成功，返回true</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    InitQueue(&amp;Q); <span class="comment">// 初始化操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>不带头节点<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front = <span class="literal">NULL</span>; <span class="comment">// 队空，队首指针指向NULL</span></span><br><span class="line">    Q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">// 队尾指针指向NULL</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 判空*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>) <span class="comment">// 队空，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 队空，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队不空，返回false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入队  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q, QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="comment">// 分配失败，返回false</span></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 分配失败，返回false</span></span><br><span class="line">    s-&gt;data = e; <span class="comment">// 赋值</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 队尾指针指向NULL</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == <span class="literal">NULL</span>) <span class="comment">// 队空，队首指针指向新节点</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Q-&gt;front = s;</span><br><span class="line">        Q-&gt;rear = s; <span class="comment">// 队尾指针指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 队不空，队尾指针指向新节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear-&gt;next = s;</span><br><span class="line">        Q-&gt;rear = s; <span class="comment">// 队尾指针指向新节点</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 入队成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 出队操作 */</span></span><br><span class="line">bbool <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q, QElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == <span class="literal">NULL</span>) <span class="comment">// 队空，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 队空，返回false</span></span><br><span class="line">    QueuePtr p = Q-&gt;front; <span class="comment">// 队首指针</span></span><br><span class="line">    e = p-&gt;data; <span class="comment">// 队首元素赋值给e</span></span><br><span class="line">    Q-&gt;front = p-&gt;next; <span class="comment">// 队首指针指向下一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == p) <span class="comment">// 只有一个元素，队尾指针指向NULL</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear = <span class="literal">NULL</span>; <span class="comment">// 只有一个元素，队尾指针指向NULL</span></span><br><span class="line">        Q-&gt;front = <span class="literal">NULL</span>; <span class="comment">// 只有一个元素，队首指针指向NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">// 释放节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 出队成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-3、双端队列"><a href="#5-3、双端队列" class="headerlink" title="5-3、双端队列"></a>5-3、双端队列</h2><p>有多种形式，双端队列：只允许从两端插入、两端删除的线性表。<br>输入受限的双端队列：只允许一端插入，两端的删除操作。<br>输出受限的双端队列：只允许一端删除，两端的插入操作。</p><h1 id="6、栈在括号匹配中的应用"><a href="#6、栈在括号匹配中的应用" class="headerlink" title="6、栈在括号匹配中的应用"></a>6、栈在括号匹配中的应用</h1><p>IDE：可视化编程环境</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">bracketCheck</span><span class="params">(<span class="type">char</span> str[],<span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    SqStack S;</span><br><span class="line">    InitStack(&amp;S);<span class="comment">//初始化栈</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            Push(&amp;S,str[i]); <span class="comment">// 入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S.top == <span class="number">-1</span>) <span class="comment">// 栈空，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> topElem = pop(&amp;S); <span class="comment">// 获取栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span>) <span class="comment">// 栈顶元素不匹配，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span>) <span class="comment">// 栈顶元素不匹配，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span>) <span class="comment">// 栈顶元素不匹配，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.top != <span class="number">-1</span>) <span class="comment">// 栈不空，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 括号匹配，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、队列在括号匹配中的应用"><a href="#7、队列在括号匹配中的应用" class="headerlink" title="7、队列在括号匹配中的应用"></a>7、队列在括号匹配中的应用</h1><p>表达式：由操作数、运算符和界限符组成的序列。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E9%98%9F%E5%88%97%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/7%E3%80%81%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E3%80%81%E9%98%9F%E5%88%97%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/7%E3%80%81%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.png"></p><h1 id="8、栈在递归中的应用"><a href="#8、栈在递归中的应用" class="headerlink" title="8、栈在递归中的应用"></a>8、栈在递归中的应用</h1><p>函数调用的特点：最后调用的函数最先返回。也就符合栈的先进后出特点。<br>函数调用时，需要用栈来保存现场信息。</p><ul><li>调用返回地址</li><li>函数参数</li><li>局部变量</li></ul><h1 id="9、队列应用"><a href="#9、队列应用" class="headerlink" title="9、队列应用"></a>9、队列应用</h1><p>在操作系统中，进程调度算法：先来先服务、短作业优先、时间片轮转。<br>在树中，先序遍历、中序遍历、后序遍历。也是用队列来实现的。</p><h1 id="10、特殊矩阵的压缩存储"><a href="#10、特殊矩阵的压缩存储" class="headerlink" title="10、特殊矩阵的压缩存储"></a>10、特殊矩阵的压缩存储</h1><ul><li>一维数组存储结构：线性储存。</li><li>二维数组存储结构：行优先存储、列优先存储。都是线性。知道行号和列号，能直接得出地址。</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/10%E3%80%81%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><ul><li>矩阵：使用数组存储<br>特殊矩阵：<br>1、对称矩阵：对角线元素相同。<br>策略：只存储对角线元素+下三角元素。按行优先存储或者列优先存储。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/10%E3%80%81%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5.png"></li></ul><p>2、三角矩阵：上三角元素和下三角元素都为0。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/10%E3%80%81%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><p>3、对角矩阵：主对角线元素为1，其他元素为0。同样用一维数组存储。</p><p>4、稀疏矩阵：元素个数远小于n*m。两种方法存储：顺序存储三元组、链式存储十字链表。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10%E3%80%81%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/10%E3%80%81%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png"></p><h1 id="11、串"><a href="#11、串" class="headerlink" title="11、串"></a>11、串</h1><p>串：就是字符串，由0个或多个字符组成的有限序列。<br>串名：字符串的名称，是串的首地址。<br>串的长度：串中字符的个数。<br>空串：长度为0的串，空格也算字符。有空格不算空串。<br>子串：串中任意个连续的字符组成的串。<br>子串在主串中出现的位置：子串第一个字符在主串中的位置。<br>存储时以线性的方式存储。<br>主要操作：<br>假设有串T&#x3D;””,S&#x3D;”iphone 11 pro Max”,W &#x3D; “pro”<br>StrAssign(T,s)：将串s赋值给串T。<br>StrEmpty(T)：判断串T是否为空串。<br>StrLength(T)：求串T的长度。<br>StrCopy(T,S)：将串S复制给串T。<br>ClearSring(T)：清空串T。<br>DestoryString(T)：销毁串T。<br>Concat(T,S1,S2)：将串S1和S2连接起来，生成新串T。<br>SubString(&amp;Sub,S,i,j)：求子串Sub，其值等于主串S中从第i个字符开始的子串。<br>Indext(S,T)：返回串S中与串T相等的第一个子串的起始位置。否则返回0。<br>StrCompare(S,T)：比较串S和串T的大小关系，逐个字符比较，直到出现大小关系为止。以ASCCII码值大小比较。每个字符的ASCCII码值大小关系。</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><ul><li>英文和控制符：ASCCII码值。一个字符占1个字节。</li><li>中英文：Unicode码值。一个字符占3个字节。<br>基于同一种码值，不同编码方式，有uft-8、utf-16、utf-32。</li></ul><h2 id="11-1、串的存储结构"><a href="#11-1、串的存储结构" class="headerlink" title="11-1、串的存储结构"></a>11-1、串的存储结构</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-1%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%B2%E5%AD%98%E5%82%A8.png"><br>下面11-2采用第四种方法。</p><ul><li><p>顺序存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 串的长度</span></span><br><span class="line">&#125;SqString;</span><br></pre></td></tr></table></figure></li><li><p>顺序存储、堆区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 串的长度</span></span><br><span class="line">&#125;LinkNode, *LinkString;</span><br><span class="line"></span><br><span class="line">Hstring S;</span><br><span class="line">S.data = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * MAXSIZE); <span class="comment">// 分配空间</span></span><br><span class="line">S.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>链式存储</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tyoedef <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[i];<span class="comment">//每个节点存储i个字符，提高内存利用率。内存密度。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode, *LinkString;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-2、顺序串的功能实现"><a href="#11-2、顺序串的功能实现" class="headerlink" title="11-2、顺序串的功能实现"></a>11-2、顺序串的功能实现</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-2%E3%80%81%E9%A1%BA%E5%BA%8F%E4%B8%B2%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0.png"></p><ul><li>Substring(&amp;sub,S,i,j)：求子串Sub，其值等于主串S中从第i个字符开始,长度为j的子串。<br>假设S.ch &#x3D; “yanggguanchao”<br>S.length &#x3D; 14</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">// 串的长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> ch[MAXSIZE]; <span class="comment">// 存储空间</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">// 串的长度</span></span><br><span class="line">&#125;String;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Substring</span><span class="params">(String &amp;sub,String S,<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*这里的主串从1开始 , 0用来保存长度*/</span></span><br><span class="line">    <span class="keyword">if</span>(i+j - <span class="number">1</span> &gt; S.length) <span class="comment">// 越界，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= i+j; k++)</span><br><span class="line">        Sub.ch[k-i +<span class="number">1</span>] = S.ch[k]; </span><br><span class="line">    sub.length = j; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>比较串S和串T的大小关系,若S&gt;T，逐个字符比较，直到出现大小关系为止。以ASCCII码值大小比较。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">StrCompare</span><span class="params">(String S,String T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.length &amp;&amp; i &lt; T.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i]) <span class="comment">// 比较字符ASCCII码值大小</span></span><br><span class="line">            <span class="keyword">return</span> = S.ch[i] - T.ch[i]; <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length - T.length; <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找子串在主串中出现的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S,String T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = StringLength(S);</span><br><span class="line">    <span class="type">int</span> m = StringLength(T);</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n - m + <span class="number">1</span>)&#123;</span><br><span class="line">        Substring(Sub,S,i,m); </span><br><span class="line">        <span class="keyword">if</span>(StrCompare(Sub,T) != <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 返回位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//S中没有T串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-3、串的模式匹配"><a href="#11-3、串的模式匹配" class="headerlink" title="11-3、串的模式匹配"></a>11-3、串的模式匹配</h2><ul><li>朴素模式暴力匹配算法<br>子串：一定或者没有在主串中<br>模式串：找到的不一定是你想要的</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-3%E3%80%81%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.png"></p><p>上一节的子串匹配算法，在主串中找子串。即使一个朴素模式匹配算法。</p><p>通过数组下标，进行匹配。主串指针在头处，模式串指针<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-3%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S,String T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length - T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        ++j;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i=i-j+<span class="number">2</span>;<span class="comment">//这里字符位置是从1开始，所以要减2，串结构，下标0舍弃</span></span><br><span class="line">        j = <span class="number">1</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length; <span class="comment">// 返回位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// S中没有T串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-3%E3%80%81%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E5%9B%9E%E9%A1%BE.png"></p><h2 id="11-4、KMP算法"><a href="#11-4、KMP算法" class="headerlink" title="11-4、KMP算法"></a>11-4、KMP算法</h2><p>是对朴素模式匹配算法的改进。主串指针不返回，模式串指针返回<br>扫描过的位置放到数组中。当发生某一位不匹配，模式串指针返回该位置<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-4%E3%80%81kmp%E7%AE%97%E6%B3%95.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-4%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0.png"></p><ul><li>求next数组<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11%E3%80%81%E4%B8%B2/11-4%E3%80%81%E6%B1%82next%E6%95%B0%E7%BB%84.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求模式串T的next数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(String T,<span class="type">int</span> next[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="comment">//若pi = pj，则next[i+1] = next[j+1]</span></span><br><span class="line">            next[i] = j; <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(String S,String T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    get_next(T,next); <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j]; <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length)</span><br><span class="line">        <span class="keyword">return</span> i - T.length; <span class="comment">// 返回位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// S中没有T串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="12、树"><a href="#12、树" class="headerlink" title="12、树"></a>12、树</h1><p>根节点：开始节点。<br>叶子节点：没有子节点的节点。<br>边：连接节点。<br>分支节点：有子节点的节点。<br>空树：没有节点的树。</p><p>非空树：</p><ul><li>有节点的树。有且只有一个根节点。</li><li>没有后继的节点称之为“叶子节点”</li><li>有后继的节点称之为“分支节点”</li></ul><p>树：由n（n&gt;&#x3D;0）个节点组成的有限集合。n&#x3D;0时，称为空树。任意一个非空树m，有且仅有一个根节点。任何一个节点都有仅且只有一个父节点。</p><p>树形结构应用</p><ul><li>文件系统</li><li>国家省市县区镇村<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E8%8A%82%E7%82%B9%E3%80%81%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0.png"></li></ul><p>有序树：从逻辑上看，树中结点的各个子树从左到右是有次序的，不能互换。<br>无序树：从逻辑上看，树中结点的各个子树从左到右是无次序的，可以互换。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A3%AE%E6%9E%97.png"></p><h2 id="12-1、二叉树"><a href="#12-1、二叉树" class="headerlink" title="12-1、二叉树"></a>12-1、二叉树</h2><ul><li>定义<br>二叉树：每个节点最多有两个子树的树结构。</li><li>二叉树的性质<br> 1、 二叉树的深度为k，则最多有2^k-1个结点。<br> 2、左右树不能互换。有序树。</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BD%A2%E6%80%81.png"></p><p>几种特殊的二叉树：</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-1%E3%80%81%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-1%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91.png"><br>平衡二叉树：左右子树的高度差不超过1。效率很高</p><h2 id="12-2、二叉树的存储结构"><a href="#12-2、二叉树的存储结构" class="headerlink" title="12-2、二叉树的存储结构"></a>12-2、二叉树的存储结构</h2><p>顺序存储结构：用一维数组存储二叉树。（能快速访问，但是会浪费存储空间）<br>链式存储结构：用指针域存储二叉树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">/* 数据域 */</span></span><br><span class="line">    BiTNode *lchild, *rchild; <span class="comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建二叉树</span></span><br><span class="line">    BiTree root;</span><br><span class="line">    root = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)); <span class="comment">// 申请节点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化二叉树</span></span><br><span class="line">    root-&gt;data = <span class="number">1</span>;</span><br><span class="line">    root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建左子树</span></span><br><span class="line">    BiTNode *left = (BiTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)); <span class="comment">// 申请节点空间</span></span><br><span class="line">    left-&gt;data = <span class="number">2</span>;</span><br><span class="line">    left-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    left-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    root-&gt;lchild = left; <span class="comment">// 链接左子树</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在实际过程中，如果二叉树查找父节点很费时间，可以设置一个指针域，指向父节点。<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class"> ｛</span></span><br><span class="line"><span class="class">     <span class="title">ElemType</span> <span class="title">data</span>;</span></span><br><span class="line">     结构体指针 left;</span><br><span class="line">     结构体指针 right;</span><br><span class="line">     结构体指针 parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="12-3、二叉树的遍历"><a href="#12-3、二叉树的遍历" class="headerlink" title="12-3、二叉树的遍历"></a>12-3、二叉树的遍历</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.png"></p><p>先序遍历：<br>1、若二叉树为空，则返回空操作；<br>2、若二叉树非空：<br>（1）访问根节点；<br>（2）先序遍历左子树；<br>（3）先序遍历右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(T); <span class="comment">// 访问节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">// 遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">// 遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：<br>1、若二叉树为空，则返回空操作；<br>2、若二叉树非空：<br>（1）中序遍历左子树；<br>（2）访问根节点；<br>（3）中序遍历右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(T-&gt;lchild); <span class="comment">// 遍历左子树</span></span><br><span class="line">        visit(T); <span class="comment">// 访问节点</span></span><br><span class="line">        InOrder(T-&gt;rchild); <span class="comment">// 遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：<br> 1、若二叉树为空，则返回空操作；<br> 2、若二叉树非空：<br> （1）后序遍历左子树；<br> （2）后序遍历右子树；<br> （3）访问根节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">viod <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrder(T-&gt;lchild); <span class="comment">// 遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild); <span class="comment">// 遍历右子树</span></span><br><span class="line">        visit(T); <span class="comment">// 访问节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-4、二叉树的层序遍历"><a href="#12-4、二叉树的层序遍历" class="headerlink" title="12-4、二叉树的层序遍历"></a>12-4、二叉树的层序遍历</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><ul><li>算法描述<br>1、创建一个队列Q，并将根节点入队；<br>2、根节点入队后<br>3、若队列非空，则队头元素出队，访问该节点；并判断该节点的左右孩子是否为空，若非空，则将该节点入队；<br>4、循环3，直到队列为空。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue Q;<span class="comment">//创建队列</span></span><br><span class="line">    InitQueue(&amp;Q);<span class="comment">//初始化队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(&amp;Q, T); <span class="comment">//根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        DeQueue(&amp;Q, &amp;p); <span class="comment">//队头元素出队</span></span><br><span class="line">        visit(p); <span class="comment">//访问该节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="12-5、根据几种遍历序列重建二叉树"><a href="#12-5、根据几种遍历序列重建二叉树" class="headerlink" title="12-5、根据几种遍历序列重建二叉树"></a>12-5、根据几种遍历序列重建二叉树</h2><p>中序遍历序列和其他三种方式任意结合一种，都可以唯一确定一棵二叉树。<br>但是不用中序遍历，其他两种结合无法确定一棵二叉树。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-5%E3%80%81%E9%81%8D%E5%8E%86%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><h2 id="12-6、线索二叉树"><a href="#12-6、线索二叉树" class="headerlink" title="12-6、线索二叉树"></a>12-6、线索二叉树</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-6%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>普通二叉树找前驱后继比较麻烦。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-6%E3%80%81%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线索二叉树</span></span><br><span class="line">typede <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag, rtag; <span class="comment">// 左右标志</span></span><br><span class="line"></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-6%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-6%E3%80%81%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8.png"></p><h2 id="12-7、二叉树线索化，对visit函数进行实现"><a href="#12-7、二叉树线索化，对visit函数进行实现" class="headerlink" title="12-7、二叉树线索化，对visit函数进行实现"></a>12-7、二叉树线索化，对visit函数进行实现</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-7%EF%BC%8C%E7%BA%BF%E7%B4%A2%E5%8C%96%E8%A6%81%E5%AF%B9%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BF%9B%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E9%81%8D%E5%8E%86.png"><br>线索化先要对二叉树进行一次完整遍历。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-7%E3%80%81%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96.png"></p><p>中序线索化完整代码如下：</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-7%E3%80%81%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81.png"></p><p>先序线索化代码：<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-7%E3%80%81%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BB%A3%E7%A0%81.png"></p><p>后续线索化代码：<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-7%E3%80%81%E5%90%8E%E7%BB%AD%E7%BA%BF%E7%B4%A2%E5%8C%96.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-7%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h2 id="12-8、二叉树中序找后继和前驱"><a href="#12-8、二叉树中序找后继和前驱" class="headerlink" title="12-8、二叉树中序找后继和前驱"></a>12-8、二叉树中序找后继和前驱</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-8%E3%80%81%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%80%BB%E7%BB%93.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-8%E3%80%81%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%90%8E%E7%BB%A7.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-8%E3%80%81%E4%B8%AD%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%89%8D%E9%A9%B1.png"></p><h2 id="12-9、树的存储"><a href="#12-9、树的存储" class="headerlink" title="12-9、树的存储"></a>12-9、树的存储</h2><p><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>二叉树的顺序存储，使用数组存储，至于链式存储在上面已经讲过了。<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png"></p><p>其他树：<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png"><br>二叉树也可以以用这个方法存储。</p><p>孩子表示法：顺序+链式存储:<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png"></p><p>兄弟孩子表示法：链式存储:</p><p><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E5%85%84%E5%BC%9F%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95.png"><br>树和二叉树的转化：</p><p><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E5%8C%96.png"><br>森林转化成二叉树：</p><p><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-9%E3%80%81%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><h2 id="12-10、树的遍历"><a href="#12-10、树的遍历" class="headerlink" title="12-10、树的遍历"></a>12-10、树的遍历</h2><p>树的先根遍历，实现后达到树和二叉树的转化:<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-10%E3%80%81%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.png"></p><p>树的后续遍历，实现二叉树和树的转化:</p><p><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-10%E3%80%81%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><p>树的层序遍历：<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-10%E3%80%81%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.png"></p><h2 id="12-11、哈夫曼树"><a href="#12-11、哈夫曼树" class="headerlink" title="12-11、哈夫曼树"></a>12-11、哈夫曼树</h2><p>节点的权：节点上数据所表示的某种信息量。<br>节点的带权路径长度：从根节点到该节点的路径长度与该节点上数据的乘积。<br>哈夫曼树：带权路径长度最小的二叉树。也称为最优二叉树。<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-11%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png"></p><p>应用：哈夫曼编码。（可变长度编码）<br>一般的ascii码是定长编码，一个字节8位。<br>哈夫曼编码：将字符按照出现频率从高到低排序，然后两两合并，合并后字符频率和合并前字符频率之和就是合并后字符频率。<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-11%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png"><br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12%E3%80%81%E6%A0%91/12-11%E3%80%81%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%9B%9E%E9%A1%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通用技术-硬件基础</title>
      <link href="/posts/fd248405.html"/>
      <url>/posts/fd248405.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、元器件"><a href="#1、元器件" class="headerlink" title="1、元器件"></a>1、元器件</h1><h2 id="1-1、施密特触发器"><a href="#1-1、施密特触发器" class="headerlink" title="1-1、施密特触发器:"></a>1-1、施密特触发器:</h2><ul><li>迟滞特性：施密特触发器有两个不同的阈值电压，<br>一个用于从低电平转换到高电平（称为上阈值电压），<br>另一个用于从高电平转换到低电平（称为下阈值电压）。<br>这种迟滞特性使得施密特触发器对输入信号的噪声不敏感。</li><li>输入输出关系：当输入电压超过上阈值电压时，<br>输出会跳变到高电平；当输入电压低于下阈值电压时，<br>输出会跳变到低电平。</li><li>应用广泛：施密特触发器常用于信号整形、脉冲产生和噪声抑制等场合。<br>施密特触发器在数字电路和模拟电路中都有广泛应用，<br>特别是在需要对不稳定的输入信号进行处理的场景中。如将输入信号进行整形、转化为方波。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/1%E3%80%81%E5%85%83%E5%99%A8%E4%BB%B6/1-1%E3%80%81%E6%96%BD%E5%AF%86%E7%89%B9%E8%A7%A6%E5%8F%91%E5%99%A8%E7%94%B5%E5%8E%8B%E7%89%B9%E6%80%A7%E6%9B%B2%E7%BA%BF.png"></li></ul><h2 id="1-2、sd卡"><a href="#1-2、sd卡" class="headerlink" title="1-2、sd卡"></a>1-2、sd卡</h2><p>sd卡是一种广泛使用的存储设备，它基于闪存技术。也就是nand闪存。<br>主要外形有两种，一种是micro sd卡,也就是tf卡，一种是sd卡。<br>下面是两者的区别：<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/1%E3%80%81%E5%85%83%E5%99%A8%E4%BB%B6/1-2%E3%80%81sd%E5%8D%A1/1-2-1%E3%80%81tf%E5%8D%A1%E4%B8%8Esd%E5%8D%A1%E5%85%B3%E7%B3%BB.png"><br>卡上标签参数解读：c:写速度等级，u：读速度等级，v:视频的读写速度<br>sd卡和micro sd卡的区别：就是多了一根电源线，sd卡三根电源线，micro sd有两根。</p><h3 id="1-2-1、总线类型"><a href="#1-2-1、总线类型" class="headerlink" title="1-2-1、总线类型"></a>1-2-1、总线类型</h3><h3 id="扩展–扇区和簇的关系"><a href="#扩展–扇区和簇的关系" class="headerlink" title="扩展–扇区和簇的关系"></a>扩展–扇区和簇的关系</h3><p><strong>定义</strong></p><ul><li><p>扇区（Sector）<br>扇区是磁盘（包括 SD 卡等存储设备）物理结构中的最小可寻址存储单元，它是在磁盘格式化时就被划分好的。<br>从物理层面看，磁盘盘片被划分成许多同心圆的磁道，每个磁道又被等分为若干个扇区。<br>扇区就像是磁盘上一个个固定大小的 “小格子”，数据在磁盘上实际就是存储在这些扇区里。</p></li><li><p>簇（Cluster）<br>簇是文件系统中逻辑分配的最小单位，它由一个或多个连续的扇区组成。文件系统在管理磁盘空间和存储文件时，<br>并不直接操作扇区，而是以簇为单位进行数据的分配和管理。可以把簇看作是文件系统用来组织和管理扇区的一个 “逻辑包裹”。</p></li></ul><p><strong>大小</strong></p><ul><li><p>扇区<br>扇区的大小通常是固定的，传统磁盘和大多数 SD 卡的扇区大小为 512 字节。<br>不过，随着技术发展，现在一些大容量存储设备开始采用 4096 字节（4KB）的扇区大小，<br>这种被称为 “高级格式化” 或 “4K 扇区”。</p></li><li><p>簇<br>簇的大小不是固定的，它由文件系统和磁盘格式化时的设置决定。<br>簇的大小可以是扇区大小的整数倍，例如在 FAT32 文件系统中，<br>簇的大小可以是 4KB（相当于 8 个 512 字节的扇区）、8KB、16KB 等；在 NTFS 文件系统中，<br>簇的大小可以根据磁盘容量和用户设置进行调整，一般从 512 字节到 64KB 不等。<br>通常情况下，磁盘容量越大，簇的大小也会相应增大。</p></li></ul><p><strong>用途</strong></p><ul><li>扇区<br>扇区主要用于磁盘的物理存储和数据传输。磁盘驱动器在读写数据时，<br>是以扇区为单位进行操作的。当计算机向磁盘写入数据时，<br>数据会被分解成一个个扇区大小的数据块，然后依次写入到磁盘的相应扇区中；<br>读取数据时，也是按扇区从磁盘中读取数据。</li><li>簇<br>簇主要用于文件系统对磁盘空间的管理。文件系统在存储文件时，<br>会为文件分配一定数量的簇，这些簇可能在磁盘上是连续的，也可能是不连续的。<br>文件系统通过记录每个文件所占用的簇号来跟踪文件在磁盘上的存储位置。<br>例如，当你在计算机上创建一个新文件时，<br>文件系统会从可用的簇中为该文件分配足够的簇来存储文件内容。</li></ul><p><code>扇区是磁盘物理存储的最小单位，而簇是文件系统逻辑分配的最小单位， 一个簇包含一个或多个扇区。</code></p><h1 id="2、协议"><a href="#2、协议" class="headerlink" title="2、协议"></a>2、协议</h1><h2 id="2-1、串口"><a href="#2-1、串口" class="headerlink" title="2-1、串口"></a>2-1、串口</h2><p>串口通讯使用RX和TX交叉相连通讯，串口通讯是全双工通讯，可以同时接收和发送。同时需要接地，作为参考电压。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/2%E3%80%81%E5%8D%8F%E8%AE%AE/2-1%E3%80%81%E4%B8%B2%E5%8F%A3%E6%9D%BF%E5%AD%90%E8%BF%9E%E6%8E%A5%E5%9B%BE.png"><br>串口通讯采用TTL（transistor-transistor logic晶体管晶体管逻辑）逻辑。输出的高电平最小2.4V，低电平最大0.4V</p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/posts/8d4b7ae1.html"/>
      <url>/posts/8d4b7ae1.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、计算机发展"><a href="#1、计算机发展" class="headerlink" title="1、计算机发展"></a>1、计算机发展</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>计算机系统  &#x3D; 硬件 + 软件 </p><p>软件分为：</p><ul><li><p>系统软件： 用来管理整个计算机系统的软件（操作系统、标准程序库、数据库管理系统、网络软件（如tcp&#x2F;ip）、语言处理程序、服务程序（如：调试程序）等）</p></li><li><p>应用软件： 按任务需要编制的各种程序</p></li></ul><p>早期的计算机是使用手动接线来控制的计算，冯·诺依曼提出了 “存储程序”的概念，即指令以二进制代码的形式事先输入计算机的主存储器中，计算机执行指令的过程就是从主存储器中取出指令并执行的过程。 </p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95/1%E3%80%81%E6%97%A9%E6%9C%9F%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9C%BA.png"></p><p>冯·诺依曼计算机的结构特点<br>1、计算机由五大部件组成。<br>2、指令和数据以同等地位存于主存储器中，可按地址寻址。<br>3、指令和数据用二进制表示。<br>4、指令由操作码和地址码组成。<br>5、存储程序。<br>6、以运算器为中心。（输入&#x2F;输出设备与存储器之间的数据通过运算器进行传输）</p><p>上面经过优化，将存储器放到中心，得到现代的计算机结构。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95/1%E3%80%81%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.png"></p><h1 id="2、各个硬件的工作原理"><a href="#2、各个硬件的工作原理" class="headerlink" title="2、各个硬件的工作原理"></a>2、各个硬件的工作原理</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%E3%80%81%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2%E3%80%81%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>计算机中，cpu内部由主存储器，控制器，运算器构成</p><ul><li>主存储器：由存储体，MAR(Memory Address Register)(存储地址寄存器)和MDR(Memory Data Register)（存储数据寄存器）组成。<br>cpu对MAR进行寻址，将数据存入MDR中，或者读出数据。</li></ul><p>存储单元：每个存储单元存放一串二进制代码。<br>存储字：存储单元的容量，一般为8位或16位。<br>存储字长：存储单元中二进制代码的位数。<br>存储元：存储二进制的电子元件，每个存储元为1bit。</p><p>MAR：通过位数可以知道存储单元的个数，通过地址线可以知道每个存储元的编号。<br>MDR：通过位数可以知道储存单元的储存字长。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%E3%80%81%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2%E3%80%81%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8.png"><br>易混淆：<br>1个字节（1byte）&#x3D;8位（bit）<br>1B&#x3D;1个字节，1b&#x3D;8b</p><ul><li><p>运算器：用于实现算数运算（如加减乘除），逻辑运算（与或非）。由ACC（累加器，用于存放操作数，或者运算结果）、MQ(乘商寄存器，在乘、除运算时，用于存放操作数或运算结果)、X（通用的操作数寄存器，用于存放操作数）、ALU（算数逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算）。<br>ACC、MQ、X这三个主要是用来存放运算结果或数值的，ALU是用来实现算数运算和逻辑运算的。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%E3%80%81%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2%E3%80%81%E8%BF%90%E7%AE%97%E5%99%A8.png"></p></li><li><p>控制器：由CU（控制单元，分析指令，给出控制信号）、IR（指令寄存器，存放当前的执行指令）、PC（程序计数器，存放下一条指令的地址，有自动加1功能）</p></li></ul><p>完成一条指令：PC取指令，放到IR中分析指令，CU分析指令，给出控制信号。</p><ul><li>举例<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; b = <span class="number">20</span>; c = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d = a*b+c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>将上述的程序编译成二进制代码，存入主存储器中。</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%E3%80%81%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8C%87%E4%BB%A4.png"><br>下面是cpu运行的过程</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%E3%80%81%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8C%87%E4%BB%A4%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png"><br>上图中，这是执行主存地址0号地址的步骤，执行完0号地址的步骤后，PC自动加1，指向1号地址重复。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2%E3%80%81%E5%90%84%E4%B8%AA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png"><br>cpu区分指令和数据的依据：指令周期的不同阶段。</p><h1 id="3、计算机系统的层次结构"><a href="#3、计算机系统的层次结构" class="headerlink" title="3、计算机系统的层次结构"></a>3、计算机系统的层次结构</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%E3%80%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3%E3%80%81%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3%E3%80%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3%E3%80%81%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p><h1 id="4、计算机的性能指标"><a href="#4、计算机的性能指标" class="headerlink" title="4、计算机的性能指标"></a>4、计算机的性能指标</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/4%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.png"></p><h2 id="4-1、存储器的性能指标"><a href="#4-1、存储器的性能指标" class="headerlink" title="4.1、存储器的性能指标"></a>4.1、存储器的性能指标</h2><p>主存储器中，MAR的位数可以得到存储单元的位数。MDR的位数可以得到存储单元的容量。<br>总容量 &#x3D; 存储单元的个数 * 存储字节长 bit &#x3D; 存储单元个数X存储字长&#x2F;8 Byte<br>例如MAR &#x3D; 32位 。MDR &#x3D; 8位<br>总容量 &#x3D; 2^32 * 8 &#x3D; 4GB</p><p>2^10 &#x3D; k; 2^20 &#x3D; M; 2^30 &#x3D; G ; 2^40 &#x3D; T</p><h2 id="4-2、CPU的性能指标"><a href="#4-2、CPU的性能指标" class="headerlink" title="4-2、CPU的性能指标"></a>4-2、CPU的性能指标</h2><p>cpu主频：cpu工作的时钟频率。<br>cpu时钟周期：cpu工作一次的时间。主频的倒数。<br>CPI：指令周期数。（不同的指令，执行时间不同，甚至是相同的指令，执行时间也可能不同，或者如果负荷比较大，执行时间也可能不同）<br>执行一条指令的时间 &#x3D;CPI * cpu时钟周期<br>IPS：每秒执行多少指令。IPS&#x3D;主频&#x2F;CPI<br>FLOPD：每秒执行多少条浮点指令。</p><h2 id="4-3、系统的整体性能指标"><a href="#4-3、系统的整体性能指标" class="headerlink" title="4-3、系统的整体性能指标"></a>4-3、系统的整体性能指标</h2><p>数据通路带宽：数据总线一次所能并行传送的信息的位数<br>吞吐量：单位时间内处理请求的数量<br>响应时间：从发出请求到收到响应的时间</p><h1 id="5、进位计数制"><a href="#5、进位计数制" class="headerlink" title="5、进位计数制"></a>5、进位计数制</h1><p>比较简单，略过。<br>10进制小数化为二进制小数<br>如：0.3</p><ul><li>0.3 * 2 &#x3D; 0.6 &#x3D; 0 + 0.6</li><li>0.6 * 2 &#x3D; 1.2 &#x3D; 1 + 0.2</li><li>0.2 * 2 &#x3D; 0.4 &#x3D; 0 + 0.4</li><li>0.4 * 2 &#x3D; 0.8 &#x3D; 0 + 0.8</li><li>0.8 * 2 &#x3D; 1.6 &#x3D; 1 + 0.6</li><li>0.6 * 2 &#x3D; 1.2 &#x3D; 1 + 0.2</li><li>0.2 * 2 &#x3D; 0.4 &#x3D; 0 + 0.4</li></ul><p>0.010010B<br>发现10进制小数无法化为二进制小数。只能无限循环下去。</p><p>2^-1 &#x3D; 0.5<br>2^-2 &#x3D; 0.25</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%88%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h2 id="5-1、BCD码"><a href="#5-1、BCD码" class="headerlink" title="5-1、BCD码"></a>5-1、BCD码</h2><p>BCD码：二进制编码十进制数<br>主要有3类，8421码，余3码，2421码<br>8421码表示方法：比如985 &#x3D; 1001 1000 0101<br>其他类似<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5-1%E3%80%81BCD%E7%A0%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h2 id="5-2、无符号数表示运算"><a href="#5-2、无符号数表示运算" class="headerlink" title="5-2、无符号数表示运算"></a>5-2、无符号数表示运算</h2><p>机器字长决定了寄存器字长，决定了数据总线宽度。<br>无符号整数表示：假设机器字长为8，强行设置值为256，那么8为寄存器里值会都为0，有一个高位溢出了。<br>无符号整型减法则是：被减数不变，减数按位取反加1，得到减数补码。然后和被减数相加</p><h2 id="5-3、有符号数表示运算"><a href="#5-3、有符号数表示运算" class="headerlink" title="5-3、有符号数表示运算"></a>5-3、有符号数表示运算</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5-3%E3%80%81%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>原码：最高位为符号位，0表示正数，1表示负数。真值0有两种特形式，-0和+0。<br>原码表示缺点：符号位和数值部分不能一起运算。需要设计复杂的电路</p><p>所以就需要反码和补码。反码目的是为了得到补码，补码是为了方便计算。<br>正数原码到补码：原码到反码不变，反码到补码也不变<br>负数原码到补码：原码到反码符号位不变，数值位取反，反码到补码末位加1，注意负数补码转反码不可逆。计算机处理的方式。<br>对于人类来说。可以省略反码，源码到补码的互相转变是：如果是负数，从右往左找到第一个1，这个1左边所有的<code>数值位</code>全部按位取反，如果是正数，补码和原码相同。</p><p>最后补码参与加法运算，符号位要参与运算。最后在转为原码。<br>如果是减法，则减数全部取反，包括符号位，末位加一。(计算机做法)<br>对于人类：从右往左找到第一个1，这个1左边所有的全部按位取反，包括符号位。<br>最终减法转换位加法操作。</p><h2 id="5-4、移码"><a href="#5-4、移码" class="headerlink" title="5-4、移码"></a>5-4、移码</h2><p>移码：符号位取反，数值部分不变。得到从0开始的数。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5-4%E3%80%81%E7%A7%BB%E7%A0%81.png"></p><h2 id="5-5、定点数"><a href="#5-5、定点数" class="headerlink" title="5-5、定点数"></a>5-5、定点数</h2><p>定点整数：编码表示有源码、反码、补码和移码四种表示方法。<br>定点小数：编码表示有原码、反码、补码三种。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5-5%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0.png"></p><p>反码补码转换，和前面的内容一模一样</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5-5%E3%80%81%E5%8F%8D%E7%A0%81%E8%A1%A5%E7%A0%81%E8%BD%AC%E6%8D%A2.png"></p><ul><li>定点小数和定点整数在位数扩展时区别</li></ul><p>定点小数：x &#x3D; 1.110 扩展4位 1.1100</p><p>定点整数：x &#x3D; 1100 扩展4位 1.0001<br>定点整数扩展在符号位后面与数值中间，定点小数扩展在数值位后面。</p><h2 id="5-6、奇偶校验"><a href="#5-6、奇偶校验" class="headerlink" title="5-6、奇偶校验"></a>5-6、奇偶校验</h2><p>原理：在数据的首部或者尾部，加入一个校验位，使得数据中1的个数为奇数或者偶数。<br>假设采用奇数校验，则数据中1的个数为奇数，校验位为0。偶校验相反<br>如 1001101 加入校验位为偶数，则数据中1的个数为4个，为偶数。则数据最终为11001101。<br> 1000101加入校验位为奇数。则数据中1的个数为3个，为奇数。则数据最终为01000101。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5%E3%80%81%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0/5-6%E3%80%81%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C.png"></p><p>偶数个数据跳变无法检测出来。<br>硬件实现：通过异或运算实现。去异或每一位数据得到最终的值就是校验位。</p><h1 id="6、电路原理"><a href="#6、电路原理" class="headerlink" title="6、电路原理"></a>6、电路原理</h1><h2 id="6-1、加法器设计"><a href="#6-1、加法器设计" class="headerlink" title="6-1、加法器设计"></a>6-1、加法器设计</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-1%E3%80%81%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>运算器：由MQ，ACC，X，ALU，PSW组成。<br>算数逻辑单元（ALU）: 功能是实现算术运算和逻辑运算。加减乘除，与或非，移位等。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-1%E3%80%81%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83.png"></p><ul><li>逻辑运算<br>优先级 与 &gt; 或<br>A(C+D) &#x3D; AC + AD –分配律<br>ABC &#x3D; A(BC) –结合律<br>A + B + C &#x3D; A + (B+C) –交换律</li></ul><p>反演率–德摩根定律<br>!(A+B) &#x3D; !A*!B<br>!(A*B) &#x3D; !A+!B<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-1%E3%80%81%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8.png"></p><ul><li><p>串行加法器<br>由单个一位全加器串行组成，时间复杂度O(n)</p></li><li><p>并行加法器<br>由多个一位全加器串行，组成单个n位数，在进行相加，单个n位数相加（也称波形进位）</p></li></ul><h2 id="6-2、并位加法器"><a href="#6-2、并位加法器" class="headerlink" title="6-2、并位加法器"></a>6-2、并位加法器</h2><p>这部分心平气和跳过<br>略</p><h2 id="6-3、加法器"><a href="#6-3、加法器" class="headerlink" title="6-3、加法器"></a>6-3、加法器</h2><p>无符号数和有符号数都是用同一套电路实现。<br>区别在于出现溢出时情况不同</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-3%E3%80%81%E5%8A%A0%E6%B3%95%E5%99%A8.png"></p><h3 id="6-3-1、加法器溢出"><a href="#6-3-1、加法器溢出" class="headerlink" title="6-3-1、加法器溢出"></a>6-3-1、加法器溢出</h3><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-3-1%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>溢出判断：<br>只有正数和正数相加，才可能出现上溢。<br>只有负数和负数相加，才可能出现下溢出。</p><ul><li><p>方法一：采用一位符号位<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-3-1%E3%80%81%E7%AC%A6%E5%8F%B7%E4%BD%8D%E7%A1%AE%E5%AE%9A%E6%BA%A2%E5%87%BA.png"></p></li><li><p>方法二：</p></li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-3-1%E3%80%81%E7%A1%AE%E5%AE%9A%E6%BA%A2%E5%87%BA%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95.png"></p><ul><li>方法三：<br>扩展：模的概念：模运算，模m的意义是：如m&#x3D;4就是，加权值位4包括4后的位舍弃。</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-3-1%E3%80%81%E7%AC%A6%E5%8F%B7%E4%BD%8D%E7%A1%AE%E5%AE%9A%E6%BA%A2%E5%87%BA%E7%9A%84%E7%AC%AC%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95.png"></p><ul><li>解决溢出<br>采用符号扩展的方法</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-3-1%E3%80%81%E7%AC%A6%E5%8F%B7%E6%89%A9%E5%B1%95.png"></p><h2 id="6-4、标志位生成"><a href="#6-4、标志位生成" class="headerlink" title="6-4、标志位生成"></a>6-4、标志位生成</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-4%E3%80%81%E5%8A%A0%E6%B3%95%E5%99%A8.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-4%E3%80%81%E6%A0%87%E5%BF%97%E4%BD%8D.png"></p><h2 id="6-5、定点数移位运算"><a href="#6-5、定点数移位运算" class="headerlink" title="6-5、定点数移位运算"></a>6-5、定点数移位运算</h2><ul><li>算数移位<br>正数原码算术移位：符号位不变，数值部分左移或右移。溢出的舍弃。如果舍弃的为0，则丢失精度。舍弃的补上0。<br>正数补码算术移位：和正数原码相同。<br>正数反码算术移位：和正数原码相同。</li></ul><p>负数原码算术移位：符号位不变，数值部分左移或右移。溢出的舍弃。如果舍弃的不为0，则丢失精度。舍弃的补上0。<br>负数反码算术移位：符号位不变，数值部分左移或右移。溢出的舍弃。如果舍弃的为0，则丢失精度。和原码相反，舍弃的补上1。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-5%E3%80%81%E5%AE%9A%E7%82%B9%E6%95%B0%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97.png"></p><p>应用：计算机的乘除法运算是利用算数移位实现的。如20*7 &#x3D; 20 <em>（1+2+2</em>2）</p><ul><li>逻辑移位<br>逻辑移位：符号位不变，数值部分左移或右移。溢出的舍弃。如果舍弃的为0，则丢失精度。舍弃的补上0。可以把逻辑移位理解为<code>无符号数</code>的算数移位。</li></ul><p>应用：一般用于数值拼接。比如把两个8位的数值拼接为16位，左移8位。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-5%E3%80%81%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D%E7%9A%84%E8%BF%90%E7%94%A8.png"></p><ul><li>循环移位</li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-5%E3%80%81%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D.png"></p><p>可以用在大小端转换上。大端小端互转。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-5%E3%80%81%E7%A7%BB%E4%BD%8D%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h2 id="6-6、定点数的乘法运算"><a href="#6-6、定点数的乘法运算" class="headerlink" title="6-6、定点数的乘法运算"></a>6-6、定点数的乘法运算</h2><p>还是r进制思想。如下图：</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-6%E3%80%81%E6%89%8B%E7%AE%97%E4%BA%8C%E8%BF%9B%E5%88%B6.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-6%E3%80%81%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E7%BB%84%E6%88%90.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-6%E3%80%81%E5%8E%9F%E7%A0%81%E7%9A%84%E4%B8%80%E4%BD%8D%E4%B9%98%E6%B3%95.png"><br>原码的一位乘法：机器字长N+1，数值部分占N位，符号位通过<code>异或</code>确定。数值部分通过被乘数绝对值和乘数绝对值的N轮<code>加法</code>、<code>移位</code>完成，根据当前乘数中参与运算的位确定ACC寄存器加什的数值。若当前位为1，则（ACC）+[|X|]原;R若当前位为0，则（ACC）+0。每一轮ACC、MQ的内容统一逻辑右移。</p><h2 id="6-7、补码乘法"><a href="#6-7、补码乘法" class="headerlink" title="6-7、补码乘法"></a>6-7、补码乘法</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-7%E3%80%81%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E5%92%8C%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E5%81%9A%E5%AF%B9%E6%AF%94.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-7%E3%80%81%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-7%E3%80%81%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E6%89%8B%E7%AE%97%E6%A8%A1%E6%8B%9F.png"></p><h2 id="6-8、定点数的除法运算"><a href="#6-8、定点数的除法运算" class="headerlink" title="6-8、定点数的除法运算"></a>6-8、定点数的除法运算</h2><p>略–跳过</p><h2 id="6-9、补码除法运算"><a href="#6-9、补码除法运算" class="headerlink" title="6-9、补码除法运算"></a>6-9、补码除法运算</h2><p>略–跳过</p><h2 id="6-10、类型转化"><a href="#6-10、类型转化" class="headerlink" title="6-10、类型转化"></a>6-10、类型转化</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6%E3%80%81%E7%94%B5%E8%B7%AF%E5%8E%9F%E7%90%86/6-10%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96.png"></p><h1 id="7、数据的存储"><a href="#7、数据的存储" class="headerlink" title="7、数据的存储"></a>7、数据的存储</h1><p>大小端模式：大端模式，小端模式。<br>大端模式：便于人类阅读，小端模式：便于计算机处理。(比如在机器计算时，cpu时从低地址取数据，先读到的就是低字节，便于计算。)<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/7%E3%80%81%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8.png"></p><p>边界对齐问题：为了提高存储效率，通常会将数据按照边界对齐。结构体中常见<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/7%E3%80%81%E8%BE%B9%E7%95%8C%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98.png"></p><h1 id="8、浮点数"><a href="#8、浮点数" class="headerlink" title="8、浮点数"></a>8、浮点数</h1><p>也就是利用科学计数法的方法<br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA.png"><br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E5%B0%BE%E6%95%B0%E8%A7%84%E6%A0%BC%E5%8C%96.png"><br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0/8%E3%80%81%E8%A7%84%E6%A0%BC%E5%8C%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%89%B9%E7%82%B9.png"><br><img src="../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0/8%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h1 id="9、IEEE754"><a href="#9、IEEE754" class="headerlink" title="9、IEEE754"></a>9、IEEE754</h1><p>规定了浮点数的存储标准<br>移码：在补码的基础上将符号位取反。只能表示整数。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9%E3%80%81IEEE754/9%E3%80%81%E7%A7%BB%E7%A0%81.png"></p><p>移码的定义：真值+偏置值<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9%E3%80%81IEEE754/9%E3%80%81IEEE754.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/9%E3%80%81IEEE754/9%E3%80%8101%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86.png"></p><h1 id="10、浮点数的加减运算"><a href="#10、浮点数的加减运算" class="headerlink" title="10、浮点数的加减运算"></a>10、浮点数的加减运算</h1><p>对介，运算，规格化，先跳过</p><h1 id="11、存储系统基本概念"><a href="#11、存储系统基本概念" class="headerlink" title="11、存储系统基本概念"></a>11、存储系统基本概念</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/11%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11-1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E5%8C%96%E7%BB%93%E6%9E%84.png"></p><p>cache层一般软件不用管。由cpu内部缓存。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/11%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11-1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB-%E5%AD%98%E5%8F%96%E6%96%B9%E5%BC%8F.png"></p><ul><li>按照信息的可更改性，分为可读写和不可读写(只读)。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/11%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11-1%E3%80%81%E4%BF%A1%E6%81%AF%E7%9A%84%E5%8F%AF%E4%BF%9D%E5%AD%98%E6%80%A7.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/11%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11-1%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/11%E3%80%81%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/11-1%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/posts/e255a10a.html"/>
      <url>/posts/e255a10a.html</url>
      
        <content type="html"><![CDATA[<p>总览<br>计算机的硬件组成结构（1、早期冯诺依曼计算机、2、现代计算机的结构）</p><h1 id="1、计算机网络"><a href="#1、计算机网络" class="headerlink" title="1、计算机网络"></a>1、计算机网络</h1><h2 id="1-1、计算机网络概述"><a href="#1-1、计算机网络概述" class="headerlink" title="1.1、计算机网络概述"></a>1.1、计算机网络概述</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>计算机网络 ：由若干结点和连接这些结点的链路组成<br>互联网：isp：互联网服务提供商干的就是全世界的网络都连接起来，公众只需交网费就可以接入这个网络，必须使用tcp&#x2F;ip。Internet<br>互连网：由若干网络和连接这些网络的链路组成,可以使用其他协议。internet</p><p>集线器（hub）：允许将多台计算机连接起来，实现数据共享。但是，集线器存在数据传输效率低、容易发生数据碰撞的问题。（工作物理层）<br>多台设备同时发送时出现数据碰撞，导致数据丢失。</p><p>交换机：将数据包转发到目的主机，实现数据传输的高效。组建计算机网络。（ 数据链路层）<br>构建大的计算机网络就可以使用多台交换机。</p><p>路由器：可以将两个或者多个计算机网络连接起来，实现数据传输的高效，也称之为互连网。（ 网络层）</p><p>这里的路由器和家用路由器有区别：<br>家用路由器 &#x3D; 路由器+交换机+其他功能<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0.png"></p><h1 id="2、计算机网络组成"><a href="#2、计算机网络组成" class="headerlink" title="2、计算机网络组成"></a>2、计算机网络组成</h1><p>了解就可以：<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE1.png"></p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%84%E6%88%90/2%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8A%9F%E8%83%BD.png"></p><h1 id="3、电路交换，报文交换，分组交换"><a href="#3、电路交换，报文交换，分组交换" class="headerlink" title="3、电路交换，报文交换，分组交换"></a>3、电路交换，报文交换，分组交换</h1><p>电路交换：通信主端端之间建立电路，数据传输。通信时间内，通讯线路被占用。没有校验和纠错机制。<br>报文交换：通信主端端之间不需要先建立连接。先存储再转发。不长时间独占用物理通道。有检验和纠错机制。报文过大，会导致内存和时间开销消耗较大。长报文错误重传概率较大<br>分组交换：就是在报文交换的基础上，将数据进行分组传输，并且打上组好，这就是现代计算机网络的传输方式。吸收了报文交换的有点。缺点是报文的控制信息较多。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3%E3%80%81%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2/3%E3%80%81%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.png"></p><h1 id="3-1、三种交换的性能分析"><a href="#3-1、三种交换的性能分析" class="headerlink" title="3-1、三种交换的性能分析"></a>3-1、三种交换的性能分析</h1><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3%E3%80%81%E7%BD%91%E7%BB%9C%E4%BA%A4%E6%8D%A2/3-1%E3%80%81%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.png"></p><h1 id="4、计算机网络分类"><a href="#4、计算机网络分类" class="headerlink" title="4、计算机网络分类"></a>4、计算机网络分类</h1><p>在平常路由器中，wan口是广域网接口。lan口是局域网接口。平常的路由器实际是以太网交换机和路由器的组合。<br>个域网（wpan）:蓝牙，zigbee，等就是个域网</p><h1 id="5、计算机网络上的性能指标"><a href="#5、计算机网络上的性能指标" class="headerlink" title="5、计算机网络上的性能指标"></a>5、计算机网络上的性能指标</h1><p>速率：指连接到网络上节点在信道上的传输速率。也称数据率或者比特率、数据传输速率。<br>速率单位：bps（bit per second）(bit&#x2F;s)(b&#x2F;s)这几个等价、kbps、mbps、gbps。</p><ul><li><p>1B&#x3D;8b 两者不相同</p></li><li><p>在计算机组成中，k&#x3D; 2^10，M &#x3D; 2^20，G&#x3D;2^30，T&#x3D;2^40<br>带宽：最高传输速率，也称带宽。分为上行带宽和下行带宽。<br>调制解调器：俗称光猫，用于将光电信号转换为数字信号，用于局域网。</p></li><li><p>在通讯原理中，带宽指的是允许通过的信号频带范围。单位：Hz</p></li></ul><p>吞吐量：指单位时间内通过某个网络（或系统的）的数据量。受到网络和系统的限制，描述的是实际的数据量。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5%E3%80%81%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/5%E3%80%81%E5%B8%A6%E5%AE%BD.png"></p><p>总时延：发送时延（节点将数据发送到信道的时间）+ 传播时延（电磁波在信道中的传播时间） + 处理时延（被路由器处理所花费的时间–分析首部，查找转发储存） + 排队时延（数据排队进入、排队发出路由器的花费的时间）</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5%E3%80%81%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/5%E3%80%81%E6%97%B6%E5%BB%B6%E8%AE%A1%E7%AE%97.png"></p><p>时延带宽积：带宽*发送时延&#x3D;时延带宽积（与信道长度、电磁波传播速度有关）<br>时延带宽积的含义：一条链路中，已从发送端发出但是尚未到达接收端的最大比特数</p><p>往返时延RTT：表示发送方发送完数据，到发送方收到接收方收到数据的确认所经历的总时间。<br>游戏延迟就是这个参数。</p><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5%E3%80%81%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/5%E3%80%81%E5%BE%80%E8%BF%94%E6%97%B6%E5%BB%B6.png"></p><p>信道利用率：某个信道有百分之几的时间有数据通过。计算方法–有数据通过的时间除以有数据通过的时间和没有数据通过时间的总和。<br>利用率不能太高也不能太低，太高有堵塞，太低会浪费</p><h1 id="6、计算机网络的分层结构"><a href="#6、计算机网络的分层结构" class="headerlink" title="6、计算机网络的分层结构"></a>6、计算机网络的分层结构</h1><p>类似快递网络。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.png"></p><p>所有计算机网络都要实现五层结构（物理层，数据链路层，网络层，传输层，应用层）,路由器只用实现三层结构（物理层，数据链路层，网络层）。教学用<br>实际上现在用的互联网模型是四层tcp&#x2F;ip模型。由美国国防部提出，后来被全世界广泛使用。（网络接口层，网络层，传输层，应用层）<br>五层结构中，物理层不对数据进行处理。<br>数据链路层主要实现差错控制功能。<br>网络层实现的主要是路由功能。<br>每一层只关心自己的首部信息。<br>实体：在第n层的软件和硬件的集合称之为第n层实体。如果在不同的机器上，同一层次，叫做对等实体。<br>协议，是控制对能实体之间通信的规则的集合，是水平的。</p><p>接口：同一个节点内相邻两层的实体交换信息的逻辑接口，又称为服务访问点。<br>服务：服务是指下层为上层提供的功能，是垂直的。</p><p>例如应用层通过接口（函数调用），请求相邻下层的传输层服务。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%EF%BC%88%E5%9E%82%E7%9B%B4%E8%A7%86%E8%A7%92%EF%BC%89.png"></p><p>协议数据单元PDU：对等层次之间传送数据单位。第n层的PDU记为nPDU。<br>服务数据单元SDU：为完成上一层实体所要求的功能而传达的数据。第n层的SDU记为nSDU。<br>协议控制信息PCI：控制协议操作的信息。第n层的PCI记为nPci。<br>三者的关系为：nSDU + nPci &#x3D; nPDU &#x3D; (n-1)SDU</p><p>协议三要素：语法，语义，时序<br>语法：数据格式<br>语义：协议语义，协议功能，是否应答<br>时序：协议操作的时序，协议操作的顺序，协议操作的优先级，协议操作是否同步，如10秒未收到传输回应则失败。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h2 id="6-1、osi七层模型"><a href="#6-1、osi七层模型" class="headerlink" title="6-1、osi七层模型"></a>6-1、osi七层模型</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-1%E3%80%81osi%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-1%E3%80%81%E4%B8%83%E5%B1%82%E7%BB%93%E6%9E%84%E5%AF%B9%E5%BA%94.png"></p><ul><li><p>物理层：定义电路接口参数，传输信号的含义</p></li><li><p>数据链路层：最主要的任务是进行差错控制，检错，纠错，重传。<br>含有检验技术进行差错控制。（确保相邻两节点）以帧进行差错控制。<br>帧为单位进行处理。</p></li><li><p>网络层：路由选择，拥塞控制。分组转发。连接的建立和拆除。（以分组为单位进行差错控制）,可靠性传输。（这里每次进行一个传输都会有一个回答）分组段为单位做处理。</p></li><li><p>传输层：实现端口到端口的通讯。也就是进程到进程的通讯，这一层会将数据分给端口号所在的进程处理。拥有复用和分用功能。发送端几个高层复用一条低层链路，在接受端再进行分用。以报文段为单位进行控制。</p></li><li><p>会话层：建立，管理，终止会话。管理进程间会话。如断网续传。</p></li><li><p>表示层：对数据进行解释，加密，解密。如GBK编码和utf-8编码。</p></li><li><p>应用层：提供应用服务，如文件传输，电子邮件等。</p></li></ul><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-1%E3%80%81%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%95%E4%BD%8D.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-1%E3%80%81osi%E6%A8%A1%E5%9E%8B%E5%8F%82%E8%80%83%E5%9B%BE.png"></p><h2 id="6-2、tcp-ip模型"><a href="#6-2、tcp-ip模型" class="headerlink" title="6-2、tcp&#x2F;ip模型"></a>6-2、tcp&#x2F;ip模型</h2><p><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-2%E3%80%81tcpip%E6%A8%A1%E5%9E%8B.png"></p><p>网络接口层相比OSI的物理层和数据链路层，不做限制。只要能正常和网络层交互就可以，而osi模型种，物理层和数据链路层是做了严格限制的。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-2%E3%80%81tcpip%E6%A8%A1%E5%9E%8B%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png"><br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-2%E3%80%81tcpip%E6%A8%A1%E5%9E%8B%E5%92%8Cosi%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png"><br>会话层和表示层在tcp&#x2F;ip模型中不是必有的，交给应用层去做取舍。<br>在tcp&#x2F;ip模型中，网络层不再进行差错控制，而是交给传输层进行差错控制。流量管理，连接管理等都去掉了。<br>保留了tcp&#x2F;ip模型中的可靠传输，拥塞控制，路由选择，分组转发等。<br>原因是传输层正确可以保证网络层正确。<br><img src="./../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/6%E3%80%81%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/6-2%E3%80%81tcpip%E5%90%84%E5%B1%82%E5%8A%9F%E8%83%BD.png"></p><p>传输层可以向应用层提供UDP（无连接不可靠）和TCP（有链接可靠）服务。</p><h1 id="7、通信基础"><a href="#7、通信基础" class="headerlink" title="7、通信基础"></a>7、通信基础</h1><p>信源：产生信息，发送信息的设备。<br>信宿：接收信息，接受信息的设备。<br>信道：信源和信宿之间的传输通道，一条物理线路有两条信道。<br>信号：在信道中传输的电波。有数字信号和模拟信号。<br>码元：每一个信号对应一个码元。有四进制的，八进制的，十六进制的。对应功率会增加<br>速率：有两种 ：</p><ul><li>波特率：每秒传输的码元数。单位码元&#x2F;s，或者波特</li><li>比特率：每秒传输的二进制位数。单位b&#x2F;s，或者比特，bps</li></ul><p>若一个码元携带n比特信息量，波特率为M。则比特率为M*n。</p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu</title>
      <link href="/posts/7c4b9639.html"/>
      <url>/posts/7c4b9639.html</url>
      
        <content type="html"><![CDATA[<h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>linux目录从&#x2F;开始<br>&#x2F;bin 大部分系统的命令<br>&#x2F;boot 引导文件，启动相关的目录<br>&#x2F;dev 设备文件目录,Linux下一切设备皆文件<br>&#x2F;etc：系统配置文件<br>&#x2F;home 用户目录，一个用户对应一个文件夹<br>&#x2F;lib 库文件<br>&#x2F;lib64 64位库文件<br>&#x2F;libx32 32位库文件<br>&#x2F;lost+found 文件系统错误恢复文件<br>&#x2F;media 媒体文件目录<br>&#x2F;mnt 挂载目录<br>&#x2F;opt 第三方软件安装目录<br>&#x2F;proc 虚拟文件系统，存放进程和内核信息<br>&#x2F;root 超级用户目录<br>&#x2F;run 运行目录<br>&#x2F;sbin 超级用户可执行文件<br>&#x2F;srv 服务器数据目录<br>&#x2F;sys 虚拟文件系统，存放硬件信息<br>&#x2F;tmp 临时文件目录<br>&#x2F;usr 用户程序目录<br>&#x2F;var 变量文件目录</p><h1 id="1-、ubuntu-24-04"><a href="#1-、ubuntu-24-04" class="headerlink" title="1 、ubuntu 24.04"></a>1 、ubuntu 24.04</h1><h2 id="1-1、输入完密码或者安装完系统后黑屏"><a href="#1-1、输入完密码或者安装完系统后黑屏" class="headerlink" title="1-1、输入完密码或者安装完系统后黑屏"></a>1-1、输入完密码或者安装完系统后黑屏</h2><p>两步：vmware关闭3D加速、配置grub文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br><span class="line"></span><br><span class="line"> ---找到 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot; 一行</span><br><span class="line"> ---改为 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash nomodeset&quot;</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>解析：<br>GRUB_CMDLINE_LINUX_DEFAULT&#x3D;”quiet splash nomodeset” 这一行配置是在设置 GRUB（GNU GRand Unified Bootloader）引导程序的默认启动参数，<br>用于控制 Linux 内核的启动行为。<br>具体来说：</p><ul><li>quiet: 使系统在启动过程中减少输出信息，使启动过程更加安静，不显示详细的启动信息。</li><li>splash: 启用启动时的图形启动界面（splash screen），通常会显示一个漂亮的背景图片和启动进度条。</li><li>nomodeset: 防止内核在启动时尝试自动设置显卡模式，这对于一些可能引起显示问题的显卡来说很有用，特别是在一些集成显卡或较新硬件上。<br>这条配置通常出现在 &#x2F;etc&#x2F;default&#x2F;grub 文件中，并且在修改后需要运行 update-grub 命令来更新 GRUB 的配置文件，以使更改生效。这不属于编程语言层面的内容，而是操作系统级别的配置。</li></ul><h2 id="1-2、samba"><a href="#1-2、samba" class="headerlink" title="1-2、samba"></a>1-2、samba</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[shared]</span><br><span class="line">    comment = Shared Folder</span><br><span class="line">    path = /srv/samba/shared</span><br><span class="line">    browseable = yes</span><br><span class="line">    read only = no</span><br><span class="line">    guest ok = yes</span><br><span class="line">    create mask = 0644</span><br><span class="line">    directory mask = 0755</span><br><span class="line">    passwd level = 0 </span><br></pre></td></tr></table></figure><p>重点在于以下两个选项：</p><p>guest ok &#x3D; yes：允许以“访客”身份访问共享文件夹。这意味着不需要用户名和密码就可以访问共享资源。<br>read only &#x3D; no：允许用户写入共享文件夹。如果只需要读取访问，则可以设置为 yes。<br>passwd level &#x3D; 0：表示 Samba 不需要用户的密码与系统密码一致。<br>passwd level &#x3D; 0：表示 Samba 不需要用户的密码与系统密码一致。<br>还有不要有任何特定samba用户，若有就<code>sudo userdel -r &lt;username&gt;</code>删除掉。</p><h2 id="1-3、ubuntu报chown-无法访问-‘-var-lib-nfs’-没有那个文件或目录"><a href="#1-3、ubuntu报chown-无法访问-‘-var-lib-nfs’-没有那个文件或目录" class="headerlink" title="1-3、ubuntu报chown: 无法访问 ‘&#x2F;var&#x2F;lib&#x2F;nfs’: 没有那个文件或目录"></a>1-3、ubuntu报chown: 无法访问 ‘&#x2F;var&#x2F;lib&#x2F;nfs’: 没有那个文件或目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dpkg: 处理软件包 nfs-common (--configure)时出错：</span><br><span class="line"> 已安装 nfs-common 软件包 post-installation 脚本 子进程返回错误状态 1</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> nfs-common</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code </span><br></pre></td></tr></table></figure><p>报类似这个错误解决办法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1.重命名dpkg目录下的info目录</span></span><br><span class="line"> sudo mv /var/lib/dpkg/info /var/lib/dpkg/info_qingsword</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.创建一个新的info文件夹</span></span><br><span class="line"> sudo mkdir /var/lib/dpkg/info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3.执行更新操作</span></span><br><span class="line"> sudo apt-get update &amp;&amp; sudo apt-get -f install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4.将更新操作产生的文件，全部复制到重命名的info_qingsword文件夹下</span></span><br><span class="line"> sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_qingsword</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5.删除创建的info文件夹</span></span><br><span class="line"> sudo rm -rf /var/lib/dpkg/info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6.将重命名的info_qingsword文件夹重新重命名为info</span></span><br><span class="line"> sudo mv /var/lib/dpkg/info_qingsword /var/lib/dpkg/info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7.再次执行更新操作，问题解决</span></span><br><span class="line">  sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 常用技巧类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用代码库</title>
      <link href="/posts/456492a6.html"/>
      <url>/posts/456492a6.html</url>
      
        <content type="html"><![CDATA[<h1 id="调试篇"><a href="#调试篇" class="headerlink" title="调试篇"></a>调试篇</h1><h2 id="1、log彩色打印"><a href="#1、log彩色打印" class="headerlink" title="1、log彩色打印"></a>1、log彩色打印</h2><pre><code>命令我们常用的printf函数输出来的颜色是终端的配色。如果想要输出不同的颜色进行区分，就需要用到printf的控制命令：\033[m。控制命令以\033[开头，以m结尾，而中间则是属性码，属性代码之间使用;分隔，如\033[1;34;42m。而属性代码的含义见下面的表格</code></pre><p><img src="../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%93/%E5%B1%9E%E6%80%A7.png"><br><img src="../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%93/%E5%B1%9E%E6%80%A72.png"><br><img src="../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E5%BA%93/%E8%83%8C%E6%99%AF%E8%89%B2.png"></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_red</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1;31m%s\033[0m&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_green</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1;32m%s\033[0m&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_yellow</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1;33m%s\033[0m&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_blue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1;34m%s\033[0m&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_pink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1;35m%s\033[0m&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_cyan</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[0m\033[1;36m%s\033[0m&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    printf_red(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    printf_green(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    printf_yellow(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    printf_blue(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    printf_pink(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    printf_cyan(<span class="string">&quot;Hello World.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><h2 id="1、内存管理库-valgrind"><a href="#1、内存管理库-valgrind" class="headerlink" title="1、内存管理库 valgrind"></a>1、内存管理库 valgrind</h2><p>编译需要将修改configure： armv7*)改成 armv7*|arm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意指定编译器的浮点点类型</span><br><span class="line">export CXXFLAGS=&quot;-mfloat-abi=hard -mfpu=vfpv3-d16 -marm -march=armv7-a -mcpu=cortex-a7&quot;</span><br></pre></td></tr></table></figure><h2 id="2、文字编w码库：iconv"><a href="#2、文字编w码库：iconv" class="headerlink" title="2、文字编w码库：iconv"></a>2、文字编w码库：iconv</h2><h2 id="3、openssl-加密库"><a href="#3、openssl-加密库" class="headerlink" title="3、openssl 加密库"></a>3、openssl 加密库</h2><h2 id="4、zbar-条码扫描库"><a href="#4、zbar-条码扫描库" class="headerlink" title="4、zbar 条码扫描库"></a>4、zbar 条码扫描库</h2>]]></content>
      
      
      <categories>
          
          <category> 开发方法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技巧类</title>
      <link href="/posts/dcdad37e.html"/>
      <url>/posts/dcdad37e.html</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令类和shell技巧类"><a href="#linux命令类和shell技巧类" class="headerlink" title="linux命令类和shell技巧类"></a>linux命令类和shell技巧类</h1><h2 id="1、dd命令"><a href="#1、dd命令" class="headerlink" title="1、dd命令"></a>1、dd命令</h2><p>可以拷贝一切，内存，磁盘，当设备出现问题，可以通过dd命令将内存数据拷贝出，无敌。</p><h2 id="2、软连接"><a href="#2、软连接" class="headerlink" title="2、软连接"></a>2、软连接</h2><p>自己想要的软件直接到官网下载，或者交叉编译器可以直接使用此方法 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 【目标】  【链接到目标地址】</span><br></pre></td></tr></table></figure><p>都是绝对地址。</p><p>另一种是设置环境变量的方式，设置的地址在<code>/etc/profile</code></p><p>类似:<code>export PATH=$PATH:/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin</code>        </p><p><code>/usr/local/bin/</code>放置了一些软件的启动地址。<br>~&#x2F;bashrc放置的是用户的一些个性化设置，也可以将环境变量放到里面。            </p><p>bashrc的作用：1、可以在利用命名函数alias定制需要的指令；2、设定环境路径；3、提示符设置。</p><h2 id="3、vim中w-sudo-tee"><a href="#3、vim中w-sudo-tee" class="headerlink" title="3、vim中w ! sudo tee %"></a>3、vim中w ! sudo tee %</h2><p>%为当前文件，上面的作用主要是缺少sudo时，可以直接采用上面命令保存vim，避免尴尬。</p><h2 id="4、grep-nR可以查看引用的字符串"><a href="#4、grep-nR可以查看引用的字符串" class="headerlink" title="4、grep -nR可以查看引用的字符串"></a>4、grep -nR可以查看引用的字符串</h2><h2 id="5、find-name-“test”-可以查找文件"><a href="#5、find-name-“test”-可以查找文件" class="headerlink" title="5、find .&#x2F; -name “test” 可以查找文件"></a>5、find .&#x2F; -name “test” 可以查找文件</h2><h2 id="6、unzip解压乱码问题"><a href="#6、unzip解压乱码问题" class="headerlink" title="6、unzip解压乱码问题"></a>6、unzip解压乱码问题</h2><p>unzip有时候需要去指定编码 unzip -O GBK xxxxx.zip</p><h2 id="7、file-命令"><a href="#7、file-命令" class="headerlink" title="7、file 命令"></a>7、file 命令</h2><p>查看可执行程序是否有动态库依赖</p><h2 id="8、scp命令"><a href="#8、scp命令" class="headerlink" title="8、scp命令"></a>8、scp命令</h2><ul><li>使用git工具。模拟windos下的linux开发环境。常用的操作有scp操作将文件拷贝到开发版中。要求是开发板有ssh协议。</li></ul><h2 id="9、dig命令"><a href="#9、dig命令" class="headerlink" title="9、dig命令"></a>9、dig命令</h2><p>查询域名解析</p><h2 id="10、nm命令"><a href="#10、nm命令" class="headerlink" title="10、nm命令"></a>10、nm命令</h2><p>查看可执行程序是否有动态库依赖,可查询函数在是否被引用过。</p><h1 id="ubuntu设置"><a href="#ubuntu设置" class="headerlink" title="ubuntu设置"></a>ubuntu设置</h1><h2 id="1、tftp"><a href="#1、tftp" class="headerlink" title="1、tftp"></a>1、tftp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tftp-hpa tftpd-hpa</span><br><span class="line">sudo apt-get install xinetd</span><br></pre></td></tr></table></figure><p>创建配置文件：&#x2F;etc&#x2F;xinetd.d&#x2F;tftp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server tftp</span><br><span class="line">&#123;</span><br><span class="line">socket_type = dgram</span><br><span class="line">protocol = udp</span><br><span class="line">wait = yes</span><br><span class="line">user = root</span><br><span class="line">server = /usr/sbin/in.tftpd</span><br><span class="line">server_args = -s /home/ygc/Desktop/project/tftp</span><br><span class="line">disable = no</span><br><span class="line">per_source = 11</span><br><span class="line">cps = 100 2</span><br><span class="line">flags = IPv4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置&#x2F;etc&#x2F;default&#x2F;tftpd-hpa</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/default/tftpd-hpa</span></span><br><span class="line"></span><br><span class="line">TFTP_USERNAME=&quot;tftp&quot;</span><br><span class="line">TFTP_DIRECTORY=&quot;/home/ygc/Desktop/project/tftp&quot;</span><br><span class="line">TFTP_ADDRESS=&quot;:69&quot;</span><br><span class="line">TFTP_OPTIONS=&quot;-1 -c -s&quot;</span><br></pre></td></tr></table></figure><p>最后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start tftpd-hpa</span><br><span class="line">sudo systemctl enable tftpd-hpa</span><br><span class="line">sudo service tftpd-hpa restart</span><br></pre></td></tr></table></figure><h1 id="1、共享文件"><a href="#1、共享文件" class="headerlink" title="1、共享文件"></a>1、共享文件</h1><p>从ubuntu20.04开始，设置共享文件就很麻烦</p><p>第一步：<br>安装samba：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure><p>第二步;<br>创建一个共享文件夹<br>我以桌面Desktop为例子</p><p>第三步：<br>设置密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a ygc</span><br></pre></td></tr></table></figure><p><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/ubuntu%E8%AE%BE%E7%BD%AE.png"></p><p>第四步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Desktop]</span><br><span class="line">comment = my share dir</span><br><span class="line">path = /home/Desktop</span><br><span class="line">browseable = yes</span><br><span class="line">writable = yes</span><br></pre></td></tr></table></figure><h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><p>使用git工具。模拟windos下的linux开发环境。常用的操作有scp操作将文件拷贝到开发版中。要求是开发板有ssh协议。</p><h2 id="1、vscode阅读源码-ubuntu"><a href="#1、vscode阅读源码-ubuntu" class="headerlink" title="1、vscode阅读源码  ubuntu"></a>1、vscode阅读源码  ubuntu</h2><p>插件<br>1、c&#x2F;c++<br>2、gnu global<br>3、gtags<br>需要<a href="https://ftp.gnu.org/pub/gnu/global/%E6%88%96%E8%80%85wget">https://ftp.gnu.org/pub/gnu/global/或者wget</a> <a href="https://ftp.gnu.org/pub/gnu/global/global-6.6.6.tar.gz">https://ftp.gnu.org/pub/gnu/global/global-6.6.6.tar.gz</a>               </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hezz@ubu global-6.6 16:46]$ ./configure</span><br><span class="line">[hezz@ubu global-6.6 16:46]$ sudo make install</span><br><span class="line">[hezz@ubu global-6.6 16:46]$ make </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后global –version查看版本<br>gnu global扩展配置中<br>Auto Update配置为“Disable”<br>这是因为我们的工程文件太大，一般的文件大于50MB就要禁用此项功能。<br>completion配置为“Disable”<br>是为了启用VSCode自带的代码自动补全功能，因为不禁用global自动补全功能的话，有些变量输入时无法进行自动补全。<br>详细百度安装配置。    </p><h2 id="2、其他扩展插件"><a href="#2、其他扩展插件" class="headerlink" title="2、其他扩展插件"></a>2、其他扩展插件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1)、C/C++，这个肯定是必须的。</span><br><span class="line">2)、C/C++ Snippets，即 C/C++重用代码块。</span><br><span class="line">3)、C/C++ Advanced Lint,即 C/C++静态检测 。</span><br><span class="line">4)、Code Runner，即代码运行。</span><br><span class="line">5)、Include AutoComplete，即自动头文件包含。</span><br><span class="line">6)、Rainbow Brackets，彩虹花括号，有助于阅读代码。</span><br><span class="line">7)、One Dark Pro，VSCode 的主题。</span><br><span class="line">8)、GBKtoUTF8，将 GBK 转换为 UTF8。</span><br><span class="line">9)、ARM，即支持 ARM 汇编语法高亮显示。</span><br><span class="line">10)、Chinese(Simplified)，即中文环境。</span><br><span class="line">11)、vscode-icons，VSCode 图标插件，主要是资源管理器下各个文件夹的图标。</span><br><span class="line">12)、compareit，比较插件，可以用于比较两个文件的差异。</span><br><span class="line">13)、DeviceTree，设备树语法插件。</span><br><span class="line">14)、TabNine，一款 AI 自动补全插件，强烈推荐，谁用谁知道。</span><br><span class="line">15)、ssh扩展。</span><br><span class="line">16)、var-translate 中英文翻译</span><br><span class="line">17)、comment translate 翻译</span><br><span class="line">18&#125;、vim插件</span><br></pre></td></tr></table></figure><p>腾讯翻译api<br>SecretIdSecretKey<br>AKIDmkimx48AHao5S0UnxhaWOE2mZSI5z1BZNYbZTJ4rbCsWzJSSTSNC8yxvqcGtXN5d</p><h3 id="clangd插件"><a href="#clangd插件" class="headerlink" title="clangd插件"></a>clangd插件</h3><p>步骤：<br>1、下载clangd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clangd</span><br></pre></td></tr></table></figure><p>2、利用bear生成compile_commands.json</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bear -- make</span><br></pre></td></tr></table></figure><p>这里的bear只用去执行编译文件就可以</p><h2 id="3、使用vim开发"><a href="#3、使用vim开发" class="headerlink" title="3、使用vim开发"></a>3、使用vim开发</h2><p>第一步<br>    vim控制光标流畅运行<br>第二部<br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/vim%E5%BF%AB%E6%8D%B7%E9%94%AE.png"></p><p>第三步<br>快捷键<br> h j</p><p> 第四步<br> 删除 复制 粘贴 撤销快捷键</p><p> za zR zM zo za zf zd zj zk zz zb zt zc</p><p> 搜索 &#x2F;字符串  n&#x2F;N 上下移动</p><h2 id="4、vim的控制命令–s-–c-–d-–y"><a href="#4、vim的控制命令–s-–c-–d-–y" class="headerlink" title="4、vim的控制命令–s –c –d –y"></a>4、vim的控制命令–s –c –d –y</h2><p>操作<br>初始文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello world!&quot;</span><br></pre></td></tr></table></figure><p>将光标移动到双引号内，按<code>cs&quot;&#39;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;hello world!&#x27;</span><br></pre></td></tr></table></figure><p>接着将光标放入其中，按<code>cs&#39;&lt;q&gt;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;q&gt;hello world!&lt;/q&gt;</span><br></pre></td></tr></table></figure><p>移除它，<code>cst&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>光标移动到 hello上，按<code>ysiw]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hello] world!</span><br></pre></td></tr></table></figure><p>将整行外加括号同时括号内再加一个空格 <code>yss(</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [hello] world! )</span><br></pre></td></tr></table></figure><p>删除括号 <code>ds[ds)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><code>a</code>命令包括，<code>i</code>命令内部</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ca&#123;</span><br><span class="line"></span><br><span class="line">ci&#123;</span><br></pre></td></tr></table></figure><h2 id="4、cmake添加-g编译选项"><a href="#4、cmake添加-g编译选项" class="headerlink" title="4、cmake添加-g编译选项"></a>4、cmake添加-g编译选项</h2><p>有时候我们需要用gdb调试程序，需要为程序添加“-g”编译选项，那么cmake构建的项目该如何添加“-g”编译选项呢？此处收集了两种方式；</p><p>第一种</p><p>修改CMakelist.txt， 添加“add_definitions(“-Wall -g”)”行；</p><p>第二种</p><p> 执行cmake时，添加-DCMAKE_BUILD_TYPE&#x3D;Debug编译选项。</p><p>cmake -DCMAKE_BUILD_TYPE&#x3D;Debug ……</p><p>建议使用第二种，可以不用改变CMakelist.txt。</p><p>cmake编译生成的makefile如何打印详细信息呢？在执行make 时添加“VERBOSE&#x3D;1”，如果想加速编译速度，可以添加 -j 10 选项，后面的数字的最大值为本机的处理器核数。</p><h2 id="5、file命令"><a href="#5、file命令" class="headerlink" title="5、file命令"></a>5、file命令</h2><p>file命令可以查看文件的格式，属于什么架构等等信息</p><h2 id="6、服务器安装gitlab"><a href="#6、服务器安装gitlab" class="headerlink" title="6、服务器安装gitlab"></a>6、服务器安装gitlab</h2><ul><li>第一步 安装依赖<br>打开终端，运行如下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">sudo apt-get install curl openssh-server ca-certificates postfix</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-1.png"></p><p>接下来会遇到如下界面，Tab切换到“确定”按钮，然后回车。</p><p><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-2.png"><br>照样Tab切换到“确定”按钮，然后回车。<br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-3.png"></p><p>*第二步  安装Gitlab</p><p>先执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure><p><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-4.png"><br>前往Gitlab官网：<a href="https://packages.gitlab.com/gitlab/gitlab-ce%EF%BC%8C%E6%89%BE%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84gitlab-ce%E5%AE%89%E8%A3%85%E5%8C%85%EF%BC%8C%E6%B3%A8%E6%84%8F%E7%89%88%E6%9C%AC%E6%98%AFubuntu/focal%E3%80%82">https://packages.gitlab.com/gitlab/gitlab-ce，找到最新版本的gitlab-ce安装包，注意版本是ubuntu/focal。</a>           </p><p><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-5.png"><br>通过wget方式在线安装gitlab，复制wsgt下载命令。<br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-6.png"></p><p>安装命令：   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/focal/gitlab-ce_16.2.1-ce.0_amd64.deb/download.deb</span><br></pre></td></tr></table></figure><p>然后再解压：sudo dpkg -i gitlab-ce_16.2.1-ce.0_amd64.deb<br>运行完sudo dpkg后如果出现下面的界面就表示gitlab安装成功。<br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-7.png"></p><ul><li>最后一步 配置gitlab<br>运行sudo vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb来查看当前gitlab网页ip和端口号。<br>如果运行上述命令出现权限问题，运行下列命令即可：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 /var/log/gitlab</span><br></pre></td></tr></table></figure>然后再运行<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure>进入gitlab的配置文件修改界面，输入i进入编辑模式，然后找到external_url字段（在第32行），改成自己需要设置的IP和端口号，IP我设置为本机的ipv4地址。<br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-8.png"></li></ul><p>修改完毕以后按esc键退出编辑模式，然后输入:wq保存即可。接下来通过下列命令重启服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止gitlab服务</span> </span><br><span class="line">sudo gitlab-ctl stop ​</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动gitlab服务</span> </span><br><span class="line">sudo gitlab-ctl reconfigure ​</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启所有gitlab组件</span> </span><br><span class="line">sudo gitlab-ctl restart ​</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动所有gitlab组件</span> </span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用开机自启动</span></span><br><span class="line">sudo systemctl enable gitlab-runsvdir.service</span><br></pre></td></tr></table></figure><p>初始化管理员账户密码    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">切换路径</span></span><br><span class="line">cd /opt/gitlab/bin/ ​</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打开控制台</span></span><br><span class="line">sudo gitlab-rails console -e production ​</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查询用户账号信息并赋值给u</span></span><br><span class="line">u=User.where(id:1).first​</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置root的密码</span></span><br><span class="line">u.password=&#x27;wxy123456&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">确认密码</span></span><br><span class="line">u.password_confirmation=&#x27;wxy123456&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存信息(注意有个感叹号）</span></span><br><span class="line">u.save!</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><ul><li>最后登录验证<br>接下来就可以通过<a href="http://192.168.17.128:8077来登录gitlab了。登录的地址是你之前设置external_url字段的值。">http://192.168.17.128:8077来登录gitlab了。登录的地址是你之前设置external_url字段的值。</a><br>按下面的步骤将gitlab语言设置为中文：<br>注意点击Preferences<br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-9.png"><br><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/gitlab%E5%AE%89%E8%A3%85-10.png"><br>点击Save changes，刷新即可。</li></ul><p>在账户搜索阶段，搜索root可能会出错，如果出错看下面解决办法     </p><ul><li>对于账户来说<br>1.进入控制台：                                                      <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hostname ~]# gitlab-rails console production          </span><br><span class="line">或者：          </span><br><span class="line">[root@hostname ~]# gitlab-rails console                                 </span><br></pre></td></tr></table></figure>2.定位到需要修改的用户<br>方法一：</li></ul><p>通过用户名查找（推荐）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user=User.where(username:&#x27;root&#x27;).first</span><br></pre></td></tr></table></figure><p>另一种写法（只能定位到普通用户，很容易出错造成找不到用户，返回 &#x3D;&gt; nil，没有此用户的结果）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):002:0&gt; User.where(name:&#x27;doudou&#x27;).first</span><br></pre></td></tr></table></figure><p>方法二：</p><p>通过id查找（一般修改root使用，因为root id&#x3D;1）：         </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">irb(main):003:0&gt; user=User.where(id:1).first</span><br><span class="line"></span><br><span class="line">=&gt; #&lt;User id:1 @root&gt;</span><br></pre></td></tr></table></figure><p>方法三：        </p><p>通过邮箱查找：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">irb(main):004:0&gt; user=User.find_by(email:&#x27;123@qq.com&#x27;)</span><br><span class="line"></span><br><span class="line">=&gt; #&lt;User id:92 @doudou&gt;</span><br><span class="line">```shell</span><br><span class="line">3.重置密码：            </span><br><span class="line">一般数字密码就不用加引号：          </span><br></pre></td></tr></table></figure><p>irb(main):005:0&gt;user.password&#x3D;12345678</p><p>&#x3D;&gt; 12345678<br>有字符的密码一定要有引号（等号两边有空格）：</p><p>irb(main):006:0&gt;user.password &#x3D; ‘root@123’</p><p>&#x3D;&gt; “root@123”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4.确认新密码（可以省略）：      </span><br><span class="line">```shell</span><br><span class="line">irb(main):007:0&gt;user.password_confirmation = &#x27;root@123&#x27;</span><br><span class="line">=&gt; “root@123”</span><br></pre></td></tr></table></figure><p>5.保存新密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">irb(main):022:0&gt;user.save!</span><br><span class="line"></span><br><span class="line">Enqueued ActionMailer::DeliveryJob (Job ID: 04e11d87-7fc0-47a5-a792-aff11918335d) to Sidekiq(mailers) with arguments: “DeviseMailer”, “password_change”, “deliver_now”, #&lt;GlobalID:0x00007fe595b63078 @uri=#&lt;URI::GID gid://gitlab/User/10&gt;&gt;</span><br><span class="line">=&gt; true</span><br></pre></td></tr></table></figure><p>最后是true就保存可以了！！！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irb(main):023:0&gt;exit</span><br></pre></td></tr></table></figure><p>扩展：<br>用脚本实现非交互式重置密码：<br>1.脚本需要使用到expect和spawn，yum安装一些包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@hostname~]# </span><span class="language-bash">yum install -y tcl tclx tcl-devel expect</span>              </span><br><span class="line">[root@gmc-repository test]# vim gitlab.sh                </span><br></pre></td></tr></table></figure><h2 id="7、安装runner"><a href="#7、安装runner" class="headerlink" title="7、安装runner"></a>7、安装runner</h2><p>打开gitlab pages功能    </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Pages 服务地址</span></span><br><span class="line">pages_external_url &quot;http://git.liuweigl.cn&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 pages</span></span><br><span class="line">gitlab_pages[&#x27;enable&#x27;] = true</span><br></pre></td></tr></table></figure><p>重新配置完重启  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure><p>安装runner </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Debian/Ubuntu/Mint</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install gitlab-runner</span><br><span class="line">apt-cache madison gitlab-runner</span><br><span class="line">sudo apt-get install gitlab-runner</span><br><span class="line">sudo gitlab-runner run #启动Runner</span><br></pre></td></tr></table></figure><p>这部分在gitlab新建流水线的时候出现的token复制，按照上面提示的步骤       </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来会要求填入url和token:项目-设置-CI/CD-Runner展开复制url和token粘贴过来</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行器选择shell</span></span><br><span class="line">sudo gitlab-runner start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时gitlab-runner就配置完成了，代码库中有push就会触发持续集成</span></span><br></pre></td></tr></table></figure><p>配置文件选择在gitlab的流水线上下，不单独去写配置运行文件   </p><h2 id="8、运行脚本"><a href="#8、运行脚本" class="headerlink" title="8、运行脚本"></a>8、运行脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cache:</span><br><span class="line">  paths:</span><br><span class="line">    - node_modules/</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">    - hexo clean</span><br><span class="line"></span><br><span class="line">pages:</span><br><span class="line">  script:</span><br><span class="line">    - hexo generate</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - public</span><br><span class="line">  only:</span><br><span class="line">    - main</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="9、gitlab-runner一直处于pending状态原因分析"><a href="#9、gitlab-runner一直处于pending状态原因分析" class="headerlink" title="9、gitlab-runner一直处于pending状态原因分析"></a>9、gitlab-runner一直处于pending状态原因分析</h2><p>项目触发runner，一直处于pending<br>初步怀疑是runner卡住了，也有可能是因为服务器资源不足，在服务器上执行gitlab-ci-multi-runner list发现runer还在，<br>在执行gitlab-ci-multi-runner verify，发现runer还活着，但是就是一直不执行流程<br>有两个方法解决：<br>    1、执行gitlab-ci-multi-runner run（不推荐使用）<br>        他会去执行runner任务，但是每次都需要运行次命令才回去执行任务<br>    2、执行gitlab-ci-multi-runner restart<br>        重启runner，发现他会自动去执行触发runner的任务          </p><h2 id="10、vscode屏蔽不需要的文件"><a href="#10、vscode屏蔽不需要的文件" class="headerlink" title="10、vscode屏蔽不需要的文件"></a>10、vscode屏蔽不需要的文件</h2><p>点击设置齿轮，点击设置，又上角json。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;search.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>   <span class="comment">//搜索  true 屏蔽 false 不屏蔽</span></span><br><span class="line">        <span class="attr">&quot;**/node_modules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>       </span><br><span class="line">        <span class="attr">&quot;**/*.o&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.so&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="attr">&quot;**/bower_components&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">//默认配置</span></span><br><span class="line">        <span class="attr">&quot;/arch/avr32&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>         <span class="comment">//被禁止搜寻的文件/文件夹</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;files.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">//文件显示  true 屏蔽 false 不屏蔽</span></span><br><span class="line">        <span class="attr">&quot;**/.git&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.svn&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.hg&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.o&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/*.so&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  </span><br><span class="line">        <span class="attr">&quot;**/CVS&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;**/.DS_Store&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>  <span class="comment">//默认配置</span></span><br><span class="line">        <span class="attr">&quot;arch/avr32&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>   <span class="comment">//被禁止看见的文件/文件夹</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>下面为跳转相关--很重要</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>  <span class="comment">//包含的头件</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/ygc/Desktop/linux-gcc/atk-dlrv1126-toolchain-arm-buildroot-linux-gnueabihf-x86/bin/arm-linux-gnueabihf-c++&quot;</span><span class="punctuation">,</span>  <span class="comment">//编译器地址</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gnu++14&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux-gcc-x64&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="11、使用cpolar进行网络穿透"><a href="#11、使用cpolar进行网络穿透" class="headerlink" title="11、使用cpolar进行网络穿透"></a>11、使用cpolar进行网络穿透</h2><p>账号<a href="mailto:&#x38;&#54;&#x32;&#x34;&#53;&#x30;&#x37;&#51;&#52;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#x38;&#54;&#x32;&#x34;&#53;&#x30;&#x37;&#51;&#52;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a><br>密码qq862450734<br>在ubuntu上安装cpolar就行<br>登录网址 172.0.0.1:9200</p><p>gitlab<br>账号 root<br>密码 qq862450734<br>虚拟机地址：9999</p><h2 id="git工具"><a href="#git工具" class="headerlink" title="git工具"></a>git工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">git init   // 初始化一个仓库</span><br><span class="line">git clone  &lt;url&gt;  //从地址克隆一个项目</span><br><span class="line">git pull //命令尽量少用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log -a //查看所有的log</span><br><span class="line">git branch -a //查看所有的分支，包括远程分支</span><br><span class="line">git branch test //test为分支名字</span><br><span class="line">git git branch --set-upstream-to=main/分支 本地分支   //远程仓库分支和本地分支合并</span><br><span class="line"></span><br><span class="line">git checkout test //切换分支test</span><br><span class="line"></span><br><span class="line">git remote -v  //查看远程仓库地址</span><br><span class="line">git remote add 名称 url 添加远程仓库 </span><br><span class="line">git remote rm name  //删除远程仓库</span><br><span class="line">git remote rename old_name new_name   //修改仓库名</span><br><span class="line">git remote set-url --delete //删除地址</span><br><span class="line">git remote set-head origin -a        将 origin/HEAD 指向 远程仓库的 默认分支（-a 即 --auto）</span><br><span class="line">git remote set-head origin dev       将 origin/HEAD 指向 （origin/dev）  </span><br><span class="line">git remote set-head origin -d        删除 origin/HEAD</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git merge  name name1  //合并分支</span><br><span class="line">git stash  //添加到储藏区</span><br><span class="line">git stash pop //储藏区的内容恢复到当前区</span><br><span class="line"></span><br><span class="line">新建分支后</span><br><span class="line">git branch -u //进行远程分支关联</span><br><span class="line">git push 远程仓库 -d 远程分支  //删除远程分支</span><br><span class="line">git push //会直接推远程分支</span><br></pre></td></tr></table></figure><p>一般上传出问题，缺少关联，解决办法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote rm 关联</span><br><span class="line"></span><br><span class="line">git remote add 关联</span><br><span class="line"></span><br><span class="line">git remote set-head origin -a 自动关联</span><br></pre></td></tr></table></figure><p>远程版本先于本地版本，切换远程分支，查看更新log，然后拉远程代码和本地合并，解决完冲突在上传</p><p><img src="./../../../img/1_%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/%E6%8A%80%E5%B7%A7%E7%B1%BB/%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2.png"></p><h2 id="13、gdb调试"><a href="#13、gdb调试" class="headerlink" title="13、gdb调试"></a>13、gdb调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb ./a.out  //调试文件</span><br><span class="line">r //运行</span><br><span class="line">b main //打断点</span><br><span class="line">n //单步执行</span><br><span class="line">p i //打印变量i的值</span><br><span class="line">p &amp;i //打印变量i的地址</span><br><span class="line">p *p //打印指针的值</span><br><span class="line">q //退出</span><br><span class="line">gdb ./a.out core //调试core文件</span><br><span class="line">target remote localhost:1234 //连接调试</span><br><span class="line">gdbserver multi //启动gdbserver</span><br></pre></td></tr></table></figure><p>调试core，有的代码出现段错误后没有生成core文件，需要修改配置文件，执行<code>ulimit -c unlimited</code></p><p>调试进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb -p 1234</span><br><span class="line">1234为进程号</span><br></pre></td></tr></table></figure><p>调试线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info threads //查看线程</span><br><span class="line">thread id //切换线程</span><br><span class="line">set scheduler-locking off|on //关闭线程|开启线程</span><br><span class="line">thread apply id comand //对id线程执行command</span><br></pre></td></tr></table></figure><p>gdb设置日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set logging file /tmp/gdb.log</span><br><span class="line">set logging on</span><br><span class="line">set logging off</span><br></pre></td></tr></table></figure><p>gdb设置shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell cmd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发方法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>arm-A7中断</title>
      <link href="/posts/81483be3.html"/>
      <url>/posts/81483be3.html</url>
      
        <content type="html"><![CDATA[<p>有时候我们很多文件需要链接到指定的区域，或者叫做段里面，比如在 Linux 里面初始化函数就会放到 init 段里面。因此我们需要能够自定义一些段，这些段的起始地址我们可以自由指定，同样的我们也可以指定一个文件或者函数应该存放到哪个段里面去。</p><p>要完成这个功能我们就需要使用到链接脚本，看名字就知道链接脚本主要用于链接的，用于描述文件应该如何被链接在一起形成最终的可执行文件。其主要目的是描述输入文件中的段如何被映射到输出文件中，并且控制输出文件中的内存排布。比如我们编译生成的文件一般都包含 text 段、 data 段等等。</p><p>链接脚本的语法很简单，就是编写一系列的命令，这些命令组成了链接脚本，每个命令是一个带有参数的关键字或者一个对符号的赋值，可以使用分号分隔命令。像文件名之类的字符串可以直接键入，也可以使用通配符“*”。最简单的链接脚本可以只包含一个命令“SECTIONS”,我们可以在这一个“SECTIONS”里面来描述输出文件的内存布局。我们一般编译出来的代码都包含在 text、 data、 bss 和 rodata 这四个段内，假设现在的代码要被链接到 0X10000000 这个地址，数据要被链接到 0X30000000 这个地方，下面就是完成此功能的最简单的链接脚本：</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line"> . = 0X10000000;</span><br><span class="line"> .text : &#123;*(.text)&#125;</span><br><span class="line"> . = 0X30000000;</span><br><span class="line"> .data ALIGN(4) : &#123; *(.data) &#125;</span><br><span class="line"> .bss ALIGN(4) : &#123; *(.bss) &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第 1 行我们先写了一个关键字“SECTIONS”，后面跟了一个大括号，这个大括号和第 7 行的大括号是一对，这是必须的。看起来就跟 C 语言里面的函数一样。</p><p>第 2 行对一个特殊符号“.”进行赋值，“.”在链接脚本里面叫做定位计数器，默认的定位计数器为 0。我们要求代码链接到以 0X10000000 为起始地址的地方，因此这一行给“.”赋值0X10000000，表示以 0X10000000 开始，后面的文件或者段都会以 0X10000000 为起始地址开始链接。</p><p>第 3 行的“.text”是段名（代码段），后面的冒号是语法要求，冒号后面的大括号里面可以填上要链接到“.text”这个段里面的所有文件，“(.text)”中的“”是通配符，表示所有输入文件的.text段都放到“.text”中。</p><p>第 4 行，我们的要求是数据放到 0X30000000 开始的地方，所以我们需要重新设置定位计数器“.”，将其改为 0X30000000。如果不重新设置的话会怎么样？假设“.text”段大小为 0X10000，那么接下来的.data 段开始地址就是 0X10000000+0X10000&#x3D;0X10010000，这明显不符合我们的要求。所以我们必须调整定位计数器为 0X30000000。</p><p>第 5 行跟第 3 行一样，定义了一个名为“.data”的段（数据段），然后所有文件的“.data”段都放到这里面。但是这一行多了一个“ALIGN(4)”，这是什么意思呢？这是用来对“.data”这个段的起始地址做字节对齐的， ALIGN(4)表示 4 字节对齐。也就是说段“.data”的起始地址要能被 4 整除，一般常见的都是 ALIGN(4)或者 ALIGN(8)，也就是 4 字节或者 8 字节对齐。</p><p>第 6 行定义了一个“.bss”段（bss数据段x，表示定义了但是还没有初始化的数据段），所有文件中的“.bss”数据都会被放到这个里面，“.bss”数据就是那些定义了但是没有被初始化的变量。</p><p>“__bss_start”和“__bss_end”是符号，这两其实就是对这两个符号进行赋值，其值为定位符“.”，这两个符号用来保存.bss 段的起始地址和结束地址。</p><p>那个最先被执行，就把他链接到最前。</p><p>内存按存储的类型分以下几种;<br>1, .BSS段：BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。【包括未初始化的全局变量和局部静态变量，我们知道未初始化的全局变量和局部静态变量默认值都为0, 本来它们也可以被放在.data 段的， 但是因为它们都是 0, 所以为它们在.data 段分配空间并且存放数据 0 是没有必要的。 程序运行的时候它们的确是要占内存空间的， 并且可执行文件必须记录所冇未初始化的全局变量和局部静态变量的大小总和， 记为.Bss段。 所以.bss 段只是为未初始化的全局变量和局部静态变量预留位置而已， 它并没有内容， 所以它在文件中也不占据空间。】   </p><p>2, .data段：数据段（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。 【全局变量和局部变量数据经常放在数据段】</p><p>3, .text段：代码段（code segment&#x2F;text segment）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。【程序源代码编译后的机器指令经常放在代码段】</p><p>而在.bin文件中，包括Vectors段，ramcode段，SysApp段以及相对独立的功能段FeatureX</p><p>Vectors段即对应启动文件Cstartup.S，必须放置在bin文件0地址处。</p><p>ramcode段紧接着vectors段，对应程序中被标记为ramcode的函数。</p><p>SysApp段在Vectors段之后，其对应main.c以及一些程序逻辑代码等，包含对应的code，rodata，data(含retention和非retention)段。【retention内容为：在RAM中具有一段被保护的内存空间，此空间具有掉电保护机制，不会因为MCU掉电而擦除。】</p><p>FeatureX段为一个独立的功能段，包含对应的code，rodata，data等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__image_copy_start  uboot 拷贝的首地址</span><br><span class="line">__image_copy_end   uboot 拷贝的结束地址</span><br><span class="line">__rel_dyn_start  .rel.dyn 段起始地址</span><br><span class="line">__rel_dyn_end   .rel.dyn 段结束地址</span><br><span class="line">_image_binary_end   镜像结束地址</span><br><span class="line">__bss_start    .bss 段起始地址</span><br><span class="line">__bss_end    .bss 段结束地址</span><br></pre></td></tr></table></figure><p>修改了代码。会导致上面的值发生变化，除了首地址。</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uboot详解--初级</title>
      <link href="/posts/daa59fb4.html"/>
      <url>/posts/daa59fb4.html</url>
      
        <content type="html"><![CDATA[<p>从事嵌入式音视频AI开发中，需要多次使用uboot这个bootleader，<br>本文用来记述我工作学习中所学到的知识点和心得<br>本文主要是为了能够运行起uboot，裁减后面有时间再学习。<br>首先第一步，删除uboot目录下没有用的到的配置文件，太多了，不需要，架构和板子支持的没法动，删除就会出错。</p><h1 id="链接脚本详解"><a href="#链接脚本详解" class="headerlink" title="链接脚本详解"></a>链接脚本详解</h1><p>• 拿到半导体厂商给的uboot，进行第一次编译，编译后得到一个链接文件。从链接文件开始分析，链接的后缀为.lds<br>在使用imx6ull进行编译时，要把程序的起点链接到0x878000000     </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld  -Ttext 0X87800000  -o  ledc.elf   $^</span><br></pre></td></tr></table></figure><p>这样所有文件都会链接到这个地址区。</p><p>分析得到uboot程序启动入口为_start。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT( (&quot;elf32-littlearm&quot;, , &quot;elf32-littlearm&quot;, , &quot;elf32-littlearm&quot;) )</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure><p>•上面代码为链接文件的开头。<br>而在架构文件中–arch&#x2F;arm&#x2F;lib&#x2F;vectors.S中有这个_start的定义。<br>这里的_start里有大量的汇编命令，回顾之前的汇编编写从启动跳入c执行程序   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.global _start  /* 全局标号 */</span><br><span class="line"></span><br><span class="line">.global __bss_start</span><br><span class="line">_bss_start:</span><br><span class="line">.word __bss_start</span><br><span class="line"></span><br><span class="line">.global __bss_end</span><br><span class="line">_bss_end:</span><br><span class="line">.word __bss_end</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 描述：_start函数，程序从此函数开始执行，此函数主要功能是设置C</span><br><span class="line"> * 运行环境。</span><br><span class="line"> */</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">/* 进入SVC模式 */</span><br><span class="line">mrs r0, cpsr</span><br><span class="line">bic r0, r0, #0x1f /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 */</span><br><span class="line">orr r0, r0, #0x13 /* r0或上0x13,表示使用SVC模式*/</span><br><span class="line">msr cpsr, r0/* 将r0 的数据写入到cpsr_c中 */</span><br><span class="line"></span><br><span class="line">/* 清BSS段 */</span><br><span class="line">ldr r0, _bss_start</span><br><span class="line">ldr r1, _bss_end</span><br><span class="line">mov r2,  #0</span><br><span class="line">bss_loop:</span><br><span class="line">stmia r0!, &#123;r2&#125;/* 向r0的地址写入0,然后r0寄存器保存的地址值加1 */</span><br><span class="line">cmp r0, r1  /* 比较r0和r1，也就是__bss_start和__bss_end的值*/</span><br><span class="line">ble bss_loop/* 如果小于等于的话就跳转到bss_loop继续清bss段*/</span><br><span class="line">//cmp和ble一起用，相当于c语言的if</span><br><span class="line">/* 设置sp指针 */</span><br><span class="line">ldr sp,=0X80200000/* 设置栈指针 */</span><br><span class="line">b main/* 跳转到main函数  */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>BSS 段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域</p><p>BSS 段使用前需要清0，通过在这里提供 BSS 段的地址，方便链接时清0</p><p>•回归vectors.S  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *************************************************************************</span><br><span class="line"> *</span><br><span class="line"> * Vectors have their own section so linker script can map them easily</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">.section &quot;.vectors&quot;, &quot;ax&quot;  // ax这个代码放到了.vectors这个代码段中</span><br><span class="line">//“ax”表示该段--可执行并且可分配</span><br><span class="line">/*</span><br><span class="line"> *************************************************************************</span><br><span class="line"> *</span><br><span class="line"> * Exception vectors as described in ARM reference manuals</span><br><span class="line"> *</span><br><span class="line"> * Uses indirect branch to allow reaching handlers anywhere in memory.</span><br><span class="line"> *</span><br><span class="line"> *************************************************************************</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">.wordCONFIG_SYS_DV_NOR_BOOT_CFG</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">breset</span><br><span class="line">ldrpc, _undefined_instruction</span><br><span class="line">ldrpc, _software_interrupt</span><br><span class="line">ldrpc, _prefetch_abort</span><br><span class="line">ldrpc, _data_abort</span><br><span class="line">ldrpc, _not_used</span><br><span class="line">ldrpc, _irq</span><br><span class="line">ldrpc, _fiq</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中断单独做一篇分析  </p><p>•对以上的分析。<br>根据vectors存放的信息知道，他需要放在程序的最开始位置。<br>查看u-boot.map知道，他被放到了0x878000000的位置上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uboot编译后的链接文件</span><br><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = 0x00000000;</span><br><span class="line"> . = ALIGN(4);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面部分解析在uboot中链接文件分析中有解释。<br><img src="../../../img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/uboot%E8%AF%A6%E8%A7%A3/%E8%B7%B3%E8%BD%AC%E5%88%B0reset%E5%90%8E%E7%9B%AE%E5%BD%95.png"></p><p>目前先到这，后面吃透有点吃力，我在研究下<a href="https://zhuanlan.zhihu.com/p/195706497%E5%92%8C%E8%AF%BB%E4%B8%8Buboot%E6%BA%90%E7%A0%81">https://zhuanlan.zhihu.com/p/195706497和读下uboot源码</a></p><h1 id="1、uboot初次编译"><a href="#1、uboot初次编译" class="headerlink" title="1、uboot初次编译"></a>1、uboot初次编译</h1><h2 id="1-1、前提"><a href="#1-1、前提" class="headerlink" title="1-1、前提"></a>1-1、前提</h2><p>安装ncurses库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><h2 id="1-2、uboot命令"><a href="#1-2、uboot命令" class="headerlink" title="1-2、uboot命令"></a>1-2、uboot命令</h2><p>help &#x2F;&#x2F;bootz命令查看支持的命令</p><h2 id="1-3、移植"><a href="#1-3、移植" class="headerlink" title="1-3、移植"></a>1-3、移植</h2><p>简单来说，修改configs配置文件，修改include&#x2F;configs配置文件，对板级支持包进行修改（主要添加include&#x2F;configs配置文件位置），对架构内容修改（架构文件添加板级支持包位置）<br>这里的编译器无法支持&#x2F;&#x2F;注释功能，必须使用&#x2F;**&#x2F;   </p><p>使用grep -nR 去找我们include&#x2F;configs中添加的.h文件又没有引用<br><img src="../../../img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/uboot%E8%AF%A6%E8%A7%A3/%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E6%98%AF%E5%90%A6%E5%BC%95%E7%94%A8.png">  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS=&quot;IMX_CONFIG=board/freescale/mx6ull_wesker_evk/imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span><br><span class="line">CONFIG_ARM=y</span><br><span class="line">CONFIG_ARCH_MX6=y</span><br><span class="line">CONFIG_TARGET_MX6ULL_WESKER_EVK=y   //涉及能否正常编译 是一个编译的条件</span><br><span class="line">CONFIG_CMD_GPIO=y</span><br></pre></td></tr></table></figure><p>一般 uboot 中修改驱动基本都是在 xxx.h 和 xxx.c 这两个文件中进行的，xxx 为板子名称，<br>例如imx6ull的就是在include&#x2F;configs中和board&#x2F;freescale</p><h1 id="留一问"><a href="#留一问" class="headerlink" title="留一问"></a>留一问</h1><p>怎么通过源码修改默认环境变量</p><p>编译uboot生成的文件就在根目录下，和linux内核有点区别<br>linux编译的在arch&#x2F;arm&#x2F;boot下，设备树在arch&#x2F;arm&#x2F;boot&#x2F;dts下</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>驱动编写（linux）</title>
      <link href="/posts/9750cb91.html"/>
      <url>/posts/9750cb91.html</url>
      
        <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">查看设备节点</span><br><span class="line">驱动注册成功生成设备节点</span><br><span class="line">ls /dev/      查看加载的设备</span><br><span class="line">查看设备号</span><br><span class="line">主设备号    </span><br><span class="line">cat /proc/devices     </span><br><span class="line">包括字符设备和块设备</span><br><span class="line">MISC设备驱动次设备号</span><br><span class="line">cat /proc/misc</span><br><span class="line">主次设备号等信息</span><br><span class="line">ls /dev/dev_name -al</span><br><span class="line">查看类</span><br><span class="line">class_create函数创建成功后，使用命令ls /sys/class查看</span><br><span class="line"></span><br><span class="line">查看设备</span><br><span class="line">device_create函数创建成功后，使用命令ls /dev/查看</span><br><span class="line"></span><br><span class="line">查看已加载的模块</span><br><span class="line">lsmod</span><br><span class="line"></span><br><span class="line">设备树</span><br><span class="line">查看设备树节点</span><br><span class="line">ls /proc/device-tree</span><br><span class="line">查看设备树属性</span><br><span class="line">在设备树相应目录下，cat [Properties]</span><br><span class="line">查看内核打印信息</span><br><span class="line">dmesg</span><br><span class="line"></span><br><span class="line">查看设备树节点</span><br><span class="line">ls /proc/device-tree</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/425420889">https://zhuanlan.zhihu.com/p/425420889</a> 文章记录</p><h2 id="1、字符设备"><a href="#1、字符设备" class="headerlink" title="1、字符设备"></a>1、字符设备</h2><h2 id="1-1、加载驱动模块"><a href="#1-1、加载驱动模块" class="headerlink" title="1-1、加载驱动模块"></a>1-1、加载驱动模块</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">insmod drv.ko</span><br></pre></td></tr></table></figure><p>如果drv.ko设备存在了依赖关系，那么就必须先加载所依赖的模块，再加载drv.ko。<br>如果不想去关注依赖关系，可以采用modprobe进行驱动的加载。<br>驱动加载路径&#x2F;lib&#x2F;modules&#x2F;<kernel-version>目录中查找模块<code>默认下的情况</code></p><h2 id="1-2、卸载驱动"><a href="#1-2、卸载驱动" class="headerlink" title="1-2、卸载驱动"></a>1-2、卸载驱动</h2><p>可以采用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmmod drv.ko</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe -r drv.ko</span><br></pre></td></tr></table></figure><h2 id="1-3、工程创建"><a href="#1-3、工程创建" class="headerlink" title="1-3、工程创建"></a>1-3、工程创建</h2><p>打开 VSCode，按下“Crtl+Shift+P”打开 VSCode 的控制台，然后输入<br>“C&#x2F;C++: Edit configurations(JSON) ”，打开 C&#x2F;C++编辑配置文件</p><p>需要添加3个头文件的路径、Linux源码下的include、<br>arch&#x2F;arm&#x2F;include 和 arch&#x2F;arm&#x2F;include&#x2F;generated 这三个目录的路径</p><h1 id="2-、第一个驱动编写chardevbase"><a href="#2-、第一个驱动编写chardevbase" class="headerlink" title="2 、第一个驱动编写chardevbase"></a>2 、第一个驱动编写chardevbase</h1><ul><li>第一步：写驱动的入口<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(); //入口</span><br><span class="line">module_exit(); //出口</span><br></pre></td></tr></table></figure></li><li>第二步：注册入口函数<br> 注册函数怎么写？去kernel源码搜索module_init,看别人是怎么写的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake学习</title>
      <link href="/posts/72bbddf7.html"/>
      <url>/posts/72bbddf7.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/7_linux%E5%BC%80%E5%8F%91/cmake%E5%AD%A6%E4%B9%A0/cmake.png"><br>学习自<a href="https://subingwen.cn/cmake/CMake-primer/%E3%80%82">https://subingwen.cn/cmake/CMake-primer/。</a><br><a href="https://www.bilibili.com/video/BV14s4y1g7Zj/?p=3&spm_id_from=pageDriver&vd_source=a65f19543c0eb665983d7177bd50730e">https://www.bilibili.com/video/BV14s4y1g7Zj/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=a65f19543c0eb665983d7177bd50730e</a></p><p><code>！！！！！！编译过程中如果需要同时产出静态库和可执行程序或者动态库，一定要一步一步来，不要想着一次性调通，血泪</code></p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><h2 id="本次用c-简单测试"><a href="#本次用c-简单测试" class="headerlink" title="本次用c++简单测试"></a>本次用c++简单测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree结构</span><br><span class="line">.</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── head.h</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure><h2 id="1、add-cpp"><a href="#1、add-cpp" class="headerlink" title="1、add.cpp"></a>1、add.cpp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、sub-cpp"><a href="#2、sub-cpp" class="headerlink" title="2、sub.cpp"></a>2、sub.cpp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int subtract(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、mult-cpp"><a href="#3、mult-cpp" class="headerlink" title="3、mult.cpp"></a>3、mult.cpp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int multiply(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、div-cpp"><a href="#4、div-cpp" class="headerlink" title="4、div.cpp"></a>4、div.cpp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">double divide(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return (double)a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、head-h"><a href="#5、head-h" class="headerlink" title="5、head.h"></a>5、head.h</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _HEAD_H</span><br><span class="line">#define _HEAD_H</span><br><span class="line">// 加法</span><br><span class="line">int add(int a, int b);</span><br><span class="line">// 减法</span><br><span class="line">int subtract(int a, int b);</span><br><span class="line">// 乘法</span><br><span class="line">int multiply(int a, int b);</span><br><span class="line">// 除法</span><br><span class="line">double divide(int a, int b);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="6、main-cpp"><a href="#6、main-cpp" class="headerlink" title="6、main.cpp"></a>6、main.cpp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;head.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 20;</span><br><span class="line">    int b = 12;</span><br><span class="line">    printf(&quot;a = %d, b = %d\n&quot;, a, b);</span><br><span class="line">    printf(&quot;a + b = %d\n&quot;, add(a, b));</span><br><span class="line">    printf(&quot;a - b = %d\n&quot;, subtract(a, b));</span><br><span class="line">    printf(&quot;a * b = %d\n&quot;, multiply(a, b));</span><br><span class="line">    printf(&quot;a / b = %f\n&quot;, divide(a, b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)  </span><br><span class="line">#最低版本号的意思，可以不写</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project   ：定义工程名称，并可指定工程的版本、工程描述、</span><br><span class="line">web主页地址、支持的语言（默认情况支持所有语言），</span><br><span class="line">如果不需要这些都是可以忽略的，只需要指定出工程名字即可。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># PROJECT 指令的语法是：</span><br><span class="line">project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...]) 可直接指定名字就行，不管 其他</span><br><span class="line">project(&lt;PROJECT-NAME&gt;</span><br><span class="line">       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]</span><br><span class="line">       [DESCRIPTION &lt;project-description-string&gt;]</span><br><span class="line">       [HOMEPAGE_URL &lt;url-string&gt;]</span><br><span class="line">       [LANGUAGES &lt;language-name&gt;...])</span><br></pre></td></tr></table></figure><p>PROJECT-NAME，项目的名字。<br>VERSION <major>[.<minor>[.<patch>[.<tweak>项目的版本。<br>DESCRIPTION <project-description-string>项目的描述。<br>HOMEPAGE_URL <url-string>地址。可以是自己网站地址。<br>LANGUAGES <language-name>项目是用什么语言写的</p><p>add_executable：定义工程会生成一个可执行程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(可执行程序名 源文件名称)</span><br><span class="line">#第一个参数是要生成的参数 第二个是要编译的文件</span><br><span class="line">这里的可执行程序名和project中的项目名没有任何关系</span><br><span class="line"></span><br><span class="line">源文件名可以是一个也可以是多个，如有多个可用空格或;间隔</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 样式1</span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c)</span><br><span class="line"># 样式2</span><br><span class="line">add_executable(app add.c;div.c;main.c;mult.c;sub.c)</span><br></pre></td></tr></table></figure><p>cmake写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line"></span><br><span class="line">add_executable(app add.c div.c main.c mult.c sub.c )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指向cmake 命令时，单独创建个目录存放cmake文件</p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>通过add_executable设置的文件太多，可以通过设置变量的方法。<br>通过set（）设置，set设置的值是字符串类型。<br>set有多种用法</p><h2 id="1、取别名"><a href="#1、取别名" class="headerlink" title="1、取别名"></a>1、取别名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># SET 指令的语法是：</span><br><span class="line"># [] 中的参数为可选项, 如不需要可以不写</span><br><span class="line">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line">VAR：变量名</span><br><span class="line">VALUE：变量值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方式1: 各个源文件之间使用空格间隔</span><br><span class="line"># set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)</span><br><span class="line"></span><br><span class="line"># 方式2: 各个源文件之间使用分号 ; 间隔</span><br><span class="line">set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><p>取出值必须用${}</p><h2 id="2、指定c-编译标准"><a href="#2、指定c-编译标准" class="headerlink" title="2、指定c++编译标准"></a>2、指定c++编译标准</h2><p>C++标准对应有一宏叫做<code>DCMAKE_CXX_STANDARD</code>。在CMake中想要指定C++标准有两种方式：</p><h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#增加-std=c++11</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br><span class="line">#增加-std=c++14</span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line">#增加-std=c++17</span><br><span class="line">set(CMAKE_CXX_STANDARD 17)</span><br></pre></td></tr></table></figure><h3 id="第二种：-在执行-cmake-命令的时候指定出这个宏的值"><a href="#第二种：-在执行-cmake-命令的时候指定出这个宏的值" class="headerlink" title="第二种： 在执行 cmake 命令的时候指定出这个宏的值"></a>第二种： 在执行 cmake 命令的时候指定出这个宏的值</h3><p>#增加-std&#x3D;c++11<br>cmake CMakeLists.txt文件路径 -<code>DCMAKE_CXX_STANDARD</code>&#x3D;11<br>#增加-std&#x3D;c++14<br>cmake CMakeLists.txt文件路径 -<code>DCMAKE_CXX_STANDARD</code>&#x3D;14<br>#增加-std&#x3D;c++17<br>cmake CMakeLists.txt文件路径 -<code>DCMAKE_CXX_STANDARD</code>&#x3D;17</p><h3 id="3、指定输出的路径"><a href="#3、指定输出的路径" class="headerlink" title="3、指定输出的路径"></a>3、指定输出的路径</h3><p>在CMake中指定可执行程序输出的路径，也对应一个宏，叫做<code>EXECUTABLE_OUTPUT_PATH</code>，它的值还是通过set命令进行设置:</p><p><code>set(HOME /home/robin/Linux/Sort)</code><br><code>set(EXECUTABLE_OUTPUT_PATH $&#123;HOME&#125;/bin)</code><br>第一行：定义一个变量用于存储一个绝对路径<br>第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏<br>如果这个路径中的子目录不存在，会自动生成，无需自己手动创建<br>由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 .&#x2F;xxx&#x2F;xxx，那么这个路径中的 .&#x2F; 对应的就是 makefile 文件所在的那个目录。</p><p>练习</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )     //编译路经</span><br><span class="line">set(app app add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">add_executable($&#123;app&#125; )  //</span><br></pre></td></tr></table></figure><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件罗列出来，<br>这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用<code>aux_source_directory</code>命令或者<code>file</code>命令。</p><p>两种方式：</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>在 CMake 中使用<code>aux_source_directory </code>命令可以查找某个路径下的所有源文件，命令格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</span><br></pre></td></tr></table></figure><p>dir：要搜索的目录<br>variable：将从dir目录下搜索到的源文件列表存储到该变量中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">#搜索 src 目录下的源文件</span><br><span class="line">aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src SRC_LIST)</span><br><span class="line">add_executable(app  $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>如果一个项目里边的源文件很多，在编写CMakeLists.txt文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是<code>file</code>（当然，除了搜索以外通过 file 还可以做其他事情）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br></pre></td></tr></table></figure><p>GLOB: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。<br>GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">搜索当前目录的src目录下所有的源文件，并存储到变量中</span><br><span class="line">file(GLOB MAIN_SRC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line">file(GLOB MAIN_HEAD $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include/*.h)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。</p><p>关于要搜索的文件路径和类型可加双引号，也可不加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB MAIN_HEAD &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.h&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">第一种方式代码</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app app add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125; SRC )             #     //这个路径和cmake  ../ 路径一样的意思</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">add_executable($&#123;SRC&#125; )  #</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>PORJECT_SOURCE_DIR</code>这个路径和cmake  ..&#x2F; 路径一样的意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第二种</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">#aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">file(GLOB  SRC  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.c *.h )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">add_executable(app $&#123;SRC&#125; )  #</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是<code>include_directories</code>:<br><code>include_directories(headpath)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">└── src</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">#aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">file(GLOB  SRC  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.c *.h )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">file(GLOB  BL  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.c * ) </span><br><span class="line">set(app $&#123;SRC&#125; $&#123;BL&#125;)</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span><br><span class="line">add_executable(app $&#123;app&#125; )  #</span><br></pre></td></tr></table></figure><p>其中，第六行指定就是头文件的路径，PROJECT_SOURCE_DIR宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。</p><h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，<br>下面来讲解在cmake中生成这两类库文件的方法。</p><h2 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h2><p>在cmake中，如果要制作静态库，需要使用的命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(库名称 STATIC 源文件1 [源文件2] ...) </span><br></pre></td></tr></table></figure><p>在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include           # 头文件目录</span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          # 用于测试的源文件</span><br><span class="line">└── src               # 源文件目录</span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br></pre></td></tr></table></figure><p>根据上面的目录结构，可以这样编写CMakeLists.txt文件:</p><p>cmake_minimum_required(VERSION 3.0)<br>project(CALC)<br>include_directories(${PROJECT_SOURCE_DIR}&#x2F;include)<br>file(GLOB SRC_LIST “${CMAKE_CURRENT_SOURCE_DIR}&#x2F;src&#x2F;*.cpp”)<br>add_library(calc STATIC ${SRC_LIST})</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">#aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">file(GLOB  SRC  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.c *.h )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">#file(GLOB  BL  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.c * ) </span><br><span class="line">#set(app $&#123;SRC&#125; $&#123;BL&#125;)</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)  #添加头文件</span><br><span class="line">#add_executable(app $&#123;app&#125; )  #编译成可执行程序</span><br><span class="line"></span><br><span class="line">#add_library(mush SHARED  $&#123;SRC&#125; )   #制作成静态库</span><br><span class="line">add_library(mush STATIC  $&#123;SRC&#125; )  #制作成动态库</span><br><span class="line"></span><br><span class="line">set(LIBRARY_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01/lib) #LIBRARY_OUTPUT_PATH生成可执行文件的路径</span><br></pre></td></tr></table></figure><p>这样最终就会生成对应的静态库文件libcalc.a。</p><p><code>LIBRARY_OUTPUT_PATH</code>生成可执行库文件的路径</p><h2 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h2><p>在Linux中，动态库名字分为三部分：lib+库名字+.so，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</p><p>在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。</p><p>根据上面的目录结构，可以这样编写CMakeLists.txt文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(库名称 SHARED 源文件1 [源文件2] ...)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)</span><br><span class="line">add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样最终就会生成对应的动态库文件libcalc.so。</p><h2 id="指定输出的路径"><a href="#指定输出的路径" class="headerlink" title="指定输出的路径"></a>指定输出的路径</h2><h3 id="方式1-适用于动态库"><a href="#方式1-适用于动态库" class="headerlink" title="方式1 - 适用于动态库"></a>方式1 - 适用于动态库</h3><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)</span><br><span class="line"># 设置动态库生成路径</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line">add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于这种方式来说，其实就是通过set命令给EXECUTABLE_OUTPUT_PATH宏设置了一个路径，这个路径就是可执行文件生成的路径。</p><h3 id="方式2-都适用"><a href="#方式2-都适用" class="headerlink" title="方式2 - 都适用"></a>方式2 - 都适用</h3><p>由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用EXECUTABLE_OUTPUT_PATH宏了，而应该使用LIBRARY_OUTPUT_PATH，这个宏对应静态库文件和动态库文件都适用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">file(GLOB SRC_LIST &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;)</span><br><span class="line"># 设置动态库/静态库生成路径</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 生成动态库</span><br><span class="line">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"># 生成静态库</span><br><span class="line">add_library(calc STATIC $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h1><h2 id="包含库文件"><a href="#包含库文件" class="headerlink" title="包含库文件"></a>包含库文件</h2><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p><h3 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure><p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。<br>测试目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在cmake中，链接静态库的命令如下：<br><code>link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])</code><br>参数1：指定出要链接的静态库的名字<br>可以是全名 libxxx.a<br>也可以是掐头（lib）去尾（.a）之后的名字 xxx<br>参数2-N：要链接的其它静态库的名字<br>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><p><code>link_directories(&lt;lib path&gt;)</code><br>这样，修改之后的CMakeLists.txt文件内容如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALC)</span><br><span class="line"># 搜索指定目录下源文件</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp)</span><br><span class="line"># 包含头文件路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 包含静态库路径</span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 链接静态库</span><br><span class="line">link_libraries(calc)</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">实战</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">file(GLOB  SR  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib/*.a )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">#file(GLOB  BL  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.c  ) </span><br><span class="line">#set(app $&#123;SRC&#125; $&#123;BL&#125;)</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)  #添加头文件</span><br><span class="line">#add_executable(app $&#123;SRC&#125; )  #编译成可执行程序</span><br><span class="line">link_libraries($&#123;SR&#125;)     #需要链接的库</span><br><span class="line">link_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line">#add_library(mush SHARED  $&#123;BL&#125; )   #制作成静态库</span><br><span class="line">#add_library(mush STATIC  $&#123;SRC&#125; )  #制作成动态库</span><br><span class="line"></span><br><span class="line">#set(LIBRARY_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01/lib)  #LIBRARY_OUTPUT_PATH生成可执行库文件的路径</span><br></pre></td></tr></table></figure><h3 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h3><p>在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的。<br>在cmake中链接动态库的命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(</span><br><span class="line">    &lt;target&gt; </span><br><span class="line">    &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;... </span><br><span class="line">    [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure><p>target：指定要加载动态库的文件的名字</p><p>该文件可能是一个源文件<br>该文件可能是一个动态库文件<br>该文件可能是一个可执行文件</p><p>PRIVATE|PUBLIC|INTERFACE：动态库的访问权限，默认为PUBLIC<br>如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。<br>动态库的链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(A B C)</span><br><span class="line">target_link_libraries(D A)</span><br></pre></td></tr></table></figure><p>PUBLIC：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。<br>PRIVATE：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库<br>INTERFACE：在interface后面引入的库不会被链接到前面的target中，只会导出符号。</p><h4 id="链接系统动态库"><a href="#链接系统动态库" class="headerlink" title="链接系统动态库"></a>链接系统动态库</h4><p>动态库的链接和静态库是完全不同的：<br>静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。<br>动态库在生成可执行程序的链接阶段不会被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存，因此，在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line"># 添加并指定最终生成的可执行程序名</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line"># 指定可执行程序要链接的动态库名字</span><br><span class="line">target_link_libraries(app pthread)</span><br></pre></td></tr></table></figure><p>在target_link_libraries(app pthread)中：</p><p>app: 对应的是最终生成的可执行程序的名字<br>pthread：这是可执行程序要加载的动态库，这个库是系统提供的线程库，全名为libpthread.so，在指定的时候一般会掐头（lib）去尾（.so）。<br>动态库会被共享，共享一块内存，其他进程也会操作动态库的数据。</p><h3 id="链接第三方动态库"><a href="#链接第三方动态库" class="headerlink" title="链接第三方动态库"></a>链接第三方动态库</h3><p>现在，自己生成了一个动态库，对应的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h            # 动态库对应的头文件</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.so        # 自己制作的动态库文件</span><br><span class="line">└── main.cpp              # 测试用的源文件</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure><p>假设在测试文件main.cpp中既使用了自己制作的动态库libcalc.so又使用了系统提供的线程库，此时CMakeLists.txt文件可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line">target_link_libraries(app pthread calc)</span><br></pre></td></tr></table></figure><p>在第六行中，pthread、calc都是可执行程序app要链接的动态库的名字。当可执行程序app生成之后并执行该文件，会提示有如下错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./app </span><br><span class="line">./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>这是因为可执行程序启动之后，去加载calc这个动态库，但是不知道这个动态库被放到了什么位置解决动态库无法加载的问题，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">link_directories(path)</span><br></pre></td></tr></table></figure><p>所以修改之后的CMakeLists.txt文件应该是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">file(GLOB SRC_LIST $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line"># 指定源文件或者动态库对应的头文件路径</span><br><span class="line">include_directories($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 指定要链接的动态库的路径</span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 添加并生成一个可执行程序</span><br><span class="line">add_executable(app $&#123;SRC_LIST&#125;)</span><br><span class="line"># 指定要链接的动态库</span><br><span class="line">target_link_libraries(app pthread calc)</span><br></pre></td></tr></table></figure><p>通过link_directories指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。<br>温馨提示：使用 target_link_libraries 命令就可以链接动态库，也可以链接静态库文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">综合之前的</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">#file(GLOB  SR  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib/*.a )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">file(GLOB  BL  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib1/*.so ) </span><br><span class="line">#set(app $&#123;SRC&#125; $&#123;BL&#125;)</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)  #添加头文件</span><br><span class="line"></span><br><span class="line">add_executable(app $&#123;SRC&#125; )  #编译成可执行程序</span><br><span class="line">#link_libraries($&#123;SR&#125;)     #需要链接的库</span><br><span class="line">target_link_libraries(app $&#123;BL&#125;) #链接动态库      这个命令需要写到最后，涉及程序的允许顺序</span><br><span class="line">link_directories($&#123;SRC&#125;)</span><br><span class="line">#link_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line">#add_library(mush SHARED  $&#123;BL&#125; )   #制作成静态库</span><br><span class="line">#add_library(mush SHARED  $&#123;SRC&#125; )  #制作成动态库</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01)</span><br><span class="line">#set(LIBRARY_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01/lib1)  #LIBRARY_OUTPUT_PATH生成可执行库文件的路径</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01/lib1)  #LIBRARY_OUTPUT_PATH生成可执行动态库文件的路径</span><br></pre></td></tr></table></figure><h1 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h1><p> 日志<br> 在CMake中可以用用户显示一条消息，该命令的名字为<code>message</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] &quot;message to display&quot; ...)</span><br></pre></td></tr></table></figure><p>(无) ：重要消息<br>STATUS ：非重要消息<br>WARNING：CMake 警告, 会继续执行<br>AUTHOR_WARNING：CMake 警告 (dev), 会继续执行<br>SEND_ERROR：CMake 错误, 继续执行，但是会跳过生成的步骤<br>FATAL_ERROR：CMake 错误, 终止所有处理过程<br>CMake的命令行工具会在stdout上显示STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p><p>CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 输出一般日志信息</span><br><span class="line">message(STATUS &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)</span><br><span class="line"># 输出警告信息</span><br><span class="line">message(WARNING &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)</span><br><span class="line"># 输出错误信息</span><br><span class="line">message(FATAL_ERROR &quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;)</span><br></pre></td></tr></table></figure><h1 id="第八步"><a href="#第八步" class="headerlink" title="第八步"></a>第八步</h1><h2 id="变量操作"><a href="#变量操作" class="headerlink" title="变量操作"></a>变量操作</h2><h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p> 有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过file命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用set命令也可以使用list命令。</p><h4 id="使用set拼接"><a href="#使用set拼接" class="headerlink" title="使用set拼接"></a>使用set拼接</h4><p> 如果使用set进行字符串拼接，对应的命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(变量名1 $&#123;变量名1&#125; $&#123;变量名2&#125; ...)</span><br></pre></td></tr></table></figure><p>关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)</span><br><span class="line">file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)</span><br><span class="line"># 追加(拼接)</span><br><span class="line">set(SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure><h4 id="使用list拼接"><a href="#使用list拼接" class="headerlink" title="使用list拼接"></a>使用list拼接</h4><p>如果使用list进行字符串拼接，对应的命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(APPEND &lt;list&gt; [&lt;element&gt; ...])</span><br></pre></td></tr></table></figure><p>list命令的功能比set要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，APPEND表示进行数据追加，后边的参数和set就一样了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/src1/*.cpp)</span><br><span class="line">file(GLOB SRC_2 $&#123;PROJECT_SOURCE_DIR&#125;/src2/*.cpp)</span><br><span class="line"># 追加(拼接)</span><br><span class="line">list(APPEND SRC_1 $&#123;SRC_1&#125; $&#123;SRC_2&#125; $&#123;TEMP&#125;)</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure><p>在CMake中，使用set命令可以创建一个list。一个在list内部是一个由分号;分割的一组字符串。例如，set(var a b c d e)命令将会创建一个list:a;b;c;d;e，但是最终打印变量值的时候得到的是abcde。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set(tmp1 a;b;c;d;e)</span><br><span class="line">set(tmp2 a b c d e)</span><br><span class="line">message($&#123;tmp1&#125;)</span><br><span class="line">message($&#123;tmp2&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出的结果:</span><br><span class="line"></span><br><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure><h3 id="字符串移除"><a href="#字符串移除" class="headerlink" title="字符串移除"></a>字符串移除</h3><p>我们在通过file搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure><p>在当前这么目录有五个源文件，其中main.cpp是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要add.cpp、div.cp、mult.cpp、sub.cpp这四个源文件就可以了。此时，就需要将main.cpp从搜索到的数据中剔除出去，想要实现这个功能，也可以使用list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br></pre></td></tr></table></figure><p>通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了REMOVE_ITEM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line">set(TEMP &quot;hello,world&quot;)</span><br><span class="line">file(GLOB SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/*.cpp)</span><br><span class="line"># 移除前日志</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br><span class="line"># 移除 main.cpp</span><br><span class="line">list(REMOVE_ITEM SRC_1 $&#123;PROJECT_SOURCE_DIR&#125;/main.cpp)</span><br><span class="line"># 移除后日志</span><br><span class="line">message(STATUS &quot;message: $&#123;SRC_1&#125;&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看到，在第8行把将要移除的文件的名字指定给list就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。</span><br><span class="line"></span><br><span class="line">关于list命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;/src  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">#file(GLOB  SR  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib/*.a )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">file(GLOB  BL  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib1/*.so ) </span><br><span class="line">#set(app $&#123;SRC&#125; $&#123;BL&#125;)</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)  #添加头文件</span><br><span class="line"></span><br><span class="line">add_executable(app $&#123;SRC&#125; )  #编译成可执行程序</span><br><span class="line">#link_libraries($&#123;SR&#125;)     #需要链接的库</span><br><span class="line">#target_link_libraries(app $&#123;BL&#125;) #链接动态库      这个命令需要写到最后，涉及程序的允许顺序</span><br><span class="line">#link_directories($&#123;SRC&#125;)</span><br><span class="line">#link_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line">#add_library(mush SHARED  $&#123;BL&#125; )   #制作成静态库</span><br><span class="line">#add_library(mush SHARED  $&#123;SRC&#125; )  #制作成动态库</span><br><span class="line">message(&quot;$&#123;SRC&#125;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)</span><br><span class="line">list(APPEND SRC main.c) #字符串添加</span><br><span class="line">message($&#123;SRC&#125;)</span><br><span class="line">list(REMOVE_ITEM SRC main.c )   </span><br><span class="line">list(REMOVE_ITEM SRC $&#123;SRC&#125;/main.c )           #注意在删除时，在地层维护的字符串带分号</span><br><span class="line">message($&#123;SRC&#125;)                        #字符串可以带&quot;&quot;也可不带</span><br><span class="line">list(LENDTH SRC  )</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01)</span><br><span class="line">#set(LIBRARY_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01/lib1)  #LIBRARY_OUTPUT_PATH生成可执行库文件的路径</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01/lib1)  #LIBRARY_OUTPUT_PATH生成可执行动态库文件的路径</span><br></pre></td></tr></table></figure><h2 id="list其他操作"><a href="#list其他操作" class="headerlink" title="list其他操作"></a>list其他操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">获取 list 的长度。</span><br><span class="line"></span><br><span class="line">list(LENGTH &lt;list&gt; &lt;output variable&gt;)</span><br><span class="line">LENGTH：子命令LENGTH用于读取列表长度</span><br><span class="line">&lt;list&gt;：当前操作的列表</span><br><span class="line">&lt;output variable&gt;：新创建的变量，用于存储列表的长度。</span><br><span class="line">读取列表中指定索引的的元素，可以指定多个索引</span><br><span class="line"></span><br><span class="line">list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</span><br><span class="line">&lt;list&gt;：当前操作的列表</span><br><span class="line">&lt;element index&gt;：列表元素的索引</span><br><span class="line">从0开始编号，索引0的元素为列表中的第一个元素；</span><br><span class="line">索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素，以此类推</span><br><span class="line">当索引（不管是正还是负）超过列表的长度，运行会报错</span><br><span class="line">&lt;output variable&gt;：新创建的变量，存储指定索引元素的返回结果，也是一个列表。</span><br><span class="line">将列表中的元素用连接符（字符串）连接起来组成一个字符串</span><br><span class="line"></span><br><span class="line">list (JOIN &lt;list&gt; &lt;glue&gt; &lt;output variable&gt;)</span><br><span class="line">&lt;list&gt;：当前操作的列表</span><br><span class="line">&lt;glue&gt;：指定的连接符（字符串）</span><br><span class="line">&lt;output variable&gt;：新创建的变量，存储返回的字符串</span><br><span class="line">查找列表是否存在指定的元素，若果未找到，返回-1</span><br><span class="line"></span><br><span class="line">list(FIND &lt;list&gt; &lt;value&gt; &lt;output variable&gt;)</span><br><span class="line">&lt;list&gt;：当前操作的列表</span><br><span class="line">&lt;value&gt;：需要再列表中搜索的元素</span><br><span class="line">&lt;output variable&gt;：新创建的变量</span><br><span class="line">如果列表&lt;list&gt;中存在&lt;value&gt;，那么返回&lt;value&gt;在列表中的索引</span><br><span class="line">如果未找到则返回-1。</span><br><span class="line">将元素追加到列表中</span><br><span class="line"></span><br><span class="line">list (APPEND &lt;list&gt; [&lt;element&gt; ...])</span><br><span class="line">在list中指定的位置插入若干元素</span><br><span class="line"></span><br><span class="line">list(INSERT &lt;list&gt; &lt;element_index&gt; &lt;element&gt; [&lt;element&gt; ...])</span><br><span class="line">将元素插入到列表的0索引位置</span><br><span class="line"></span><br><span class="line">list (PREPEND &lt;list&gt; [&lt;element&gt; ...])</span><br><span class="line">将列表中最后元素移除</span><br><span class="line"></span><br><span class="line">list (POP_BACK &lt;list&gt; [&lt;out-var&gt;...])</span><br><span class="line">将列表中第一个元素移除</span><br><span class="line"></span><br><span class="line">list (POP_FRONT &lt;list&gt; [&lt;out-var&gt;...])</span><br><span class="line">将指定的元素从列表中移除</span><br><span class="line"></span><br><span class="line">list (REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</span><br><span class="line">将指定索引的元素从列表中移除</span><br><span class="line"></span><br><span class="line">list (REMOVE_AT &lt;list&gt; &lt;index&gt; [&lt;index&gt; ...])</span><br><span class="line">移除列表中的重复元素</span><br><span class="line"></span><br><span class="line">list (REMOVE_DUPLICATES &lt;list&gt;)</span><br><span class="line">列表翻转</span><br><span class="line"></span><br><span class="line">list(REVERSE &lt;list&gt;)</span><br><span class="line">列表排序</span><br><span class="line"></span><br><span class="line">list (SORT &lt;list&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])</span><br><span class="line">COMPARE：指定排序方法。有如下几种值可选：</span><br><span class="line">STRING:按照字母顺序进行排序，为默认的排序方法</span><br><span class="line">FILE_BASENAME：如果是一系列路径名，会使用basename进行排序</span><br><span class="line">NATURAL：使用自然数顺序排序</span><br><span class="line">CASE：指明是否大小写敏感。有如下几种值可选：</span><br><span class="line">SENSITIVE: 按照大小写敏感的方式进行排序，为默认值</span><br><span class="line">INSENSITIVE：按照大小写不敏感方式进行排序</span><br><span class="line">ORDER：指明排序的顺序。有如下几种值可选：</span><br><span class="line">ASCENDING:按照升序排列，为默认值</span><br><span class="line">DESCENDING：按照降序排列</span><br></pre></td></tr></table></figure><h1 id="第九步"><a href="#第九步" class="headerlink" title="第九步"></a>第九步</h1><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define NUMBER  3</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">    printf(&quot;我是一个程序猿, 我不会爬树...\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">    for(int i=0; i&lt;NUMBER; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;hello, GCC!!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序的第七行对DEBUG宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（上述代码中并没有定义这个宏）。</p><p>为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在gcc&#x2F;g++命令中去指定，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test.c -DDEBUG -o app</span><br></pre></td></tr></table></figure><p>在gcc&#x2F;g++命令中通过参数 -D指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为DEBUG。</p><p>在CMake中我们也可以做类似的事情，对应的命令叫做<code>add_definitions:</code></p><p>add_definitions(-D宏名称)<br>针对于上面的源文件编写一个CMakeLists.txt，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(TEST)</span><br><span class="line"># 自定义 DEBUG 宏</span><br><span class="line">add_definitions(-DDEBUG)</span><br><span class="line">add_executable(app ./test.c)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">综合所有</span><br><span class="line">cmake_minimum_required(VERSION 3.0.0)</span><br><span class="line"></span><br><span class="line">project (app)</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH /home/ygc/Desktop/stady_cmake/01 )  #   //编译路经</span><br><span class="line">#set(app  add.c div.c main.c mult.c sub.c)   //设置变量</span><br><span class="line">#set(CMAKE_CXX_STANDARD )</span><br><span class="line">aux_source_directory($&#123;PROJECT_SOURCE_DIR&#125;/src  SRC)             #     //PORJECT_SOURCE_DIR这个路径和执行cmake  ../ 路径一样的</span><br><span class="line">#file(GLOB  SR  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib/*.a )            #这个路径与CMakeLisits.txt 路径一致</span><br><span class="line">file(GLOB  BL  $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib1/*.so ) </span><br><span class="line">#set(app $&#123;SRC&#125; $&#123;BL&#125;)</span><br><span class="line">#假设有两个目录里有源文件，就是用搜索的方式，搜索到以后使用set进行合并</span><br><span class="line">include_directories($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)  #添加头文件</span><br><span class="line"></span><br><span class="line">add_executable(app $&#123;SRC&#125; )  #编译成可执行程序</span><br><span class="line">#link_libraries($&#123;SR&#125;)     #需要链接的库</span><br><span class="line">#target_link_libraries(app $&#123;BL&#125;) #链接动态库      这个命令需要写到最后，涉及程序的允许顺序</span><br><span class="line">#link_directories($&#123;SRC&#125;)</span><br><span class="line">#link_directories( $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line">#add_library(mush SHARED  $&#123;BL&#125; )   #制作成静态库</span><br><span class="line">#add_library(mush SHARED  $&#123;SRC&#125; )  #制作成动态库</span><br><span class="line">message(&quot;$&#123;SRC&#125;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;)</span><br><span class="line">list(APPEND SRC main.c) #字符串添加</span><br><span class="line">message($&#123;SRC&#125;)</span><br><span class="line">list(REMOVE_ITEM SRC main.c )   </span><br><span class="line">list(REMOVE_ITEM SRC $&#123;SRC&#125;/main.c )           #注意在删除时，在地层维护的字符串带分号</span><br><span class="line">message($&#123;SRC&#125;)                        #字符串可以带&quot;&quot;也可不带</span><br><span class="line">add_definitions(-DDEBUG)   #定义一个宏，起到一个开关的作用，很常用</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01)</span><br><span class="line">#set(LIBRARY_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01/lib1)  #LIBRARY_OUTPUT_PATH生成可执行库文件的路径</span><br><span class="line">#set(EXECUTABLE_OUTPUT_PATH  /home/ygc/Desktop/stady_cmake/01/lib1)  #LIBRARY_OUTPUT_PATH生成可执行动态库文件的路径</span><br></pre></td></tr></table></figure><p>通过这种方式，上述代码中的第八行日志就能够被输出出来了。</p><h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">宏                                                功能</span><br><span class="line">PROJECT_SOURCE_DIR使用cmake命令后紧跟的目录，一般是工程的根目录</span><br><span class="line">PROJECT_BINARY_DIR执行cmake命令的目录</span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR当前处理的CMakeLists.txt所在的路径</span><br><span class="line">CMAKE_CURRENT_BINARY_DIRtarget 编译目录</span><br><span class="line">EXECUTABLE_OUTPUT_PATH重新定义目标二进制可执行文件的存放位置</span><br><span class="line">LIBRARY_OUTPUT_PATH重新定义目标链接库文件的存放位置</span><br><span class="line">PROJECT_NAME返回通过PROJECT指令定义的项目名称</span><br><span class="line">CMAKE_BINARY_DIR项目实际构建路径，假设在build目录进行的构建，那么得到的就是这个目录的路径</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第十步"><a href="#第十步" class="headerlink" title="第十步"></a>第十步</h1><h2 id="嵌套的CMake"><a href="#嵌套的CMake" class="headerlink" title="嵌套的CMake"></a>嵌套的CMake</h2><p>如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个CMakeLists.txt，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个CMakeLists.txt文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。</p><p>先来看一下下面的这个的目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── calc</span><br><span class="line">│   ├── add.cpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── div.cpp</span><br><span class="line">│   ├── mult.cpp</span><br><span class="line">│   └── sub.cpp</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   ├── calc.h</span><br><span class="line">│   └── sort.h</span><br><span class="line">├── sort</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── insert.cpp</span><br><span class="line">│   └── select.cpp</span><br><span class="line">├── test1</span><br><span class="line">│   ├── calc.cpp</span><br><span class="line">│   └── CMakeLists.txt</span><br><span class="line">└── test2</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── sort.cpp</span><br><span class="line"></span><br><span class="line">6 directories, 15 files</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>include 目录：头文件目录<br>calc 目录：目录中的四个源文件对应的加、减、乘、除算法<br>对应的头文件是include中的calc.h<br>sort 目录 ：目录中的两个源文件对应的是插入排序和选择排序算法<br>对应的头文件是include中的sort.h<br>test1 目录：测试目录，对加、减、乘、除算法进行测试<br>test2 目录：测试目录，对排序算法进行测试<br>可以看到各个源文件目录所需要的CMakeLists.txt文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p> 节点关系<br> 众所周知，Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。因此，我们需要了解一些关于 CMakeLists.txt 文件变量作用域的一些信息：</p><p>根节点CMakeLists.txt中的变量全局有效<br>父节点CMakeLists.txt中的变量可以在子节点中使用<br>子节点CMakeLists.txt中的变量只能在当前节点中使用</p><p>添加子目录<br>接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake 命令：<br><code>dd_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code><br>source_dir：指定了CMakeLists.txt源文件和代码文件的位置，其实就是指定子目录<br>binary_dir：指定了输出文件的路径，一般不需要指定，忽略即可。<br>EXCLUDE_FROM_ALL：在子路径下的目标默认不会被包含到父路径的ALL目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。<br>通过这种方式CMakeLists.txt文件之间的父子关系就被构建出来了。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>在上面的目录中我们要做如下事情：</p><p>通过 test1 目录中的测试文件进行计算器相关的测试<br>通过 test2 目录中的测试文件进行排序相关的测试<br>现在相当于是要进行模块化测试，对于calc和sort目录中的源文件来说，可以将它们先编译成库文件（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。</p><p> 根目录<br> 根目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(test)</span><br><span class="line"># 定义变量</span><br><span class="line"># 静态库生成的路径</span><br><span class="line">set(LIB_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/lib)</span><br><span class="line"># 测试程序生成的路径</span><br><span class="line">set(EXEC_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/bin)</span><br><span class="line"># 头文件目录</span><br><span class="line">set(HEAD_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)</span><br><span class="line"># 静态库的名字</span><br><span class="line">set(CALC_LIB calc)</span><br><span class="line">set(SORT_LIB sort)</span><br><span class="line"># 可执行程序的名字</span><br><span class="line">set(APP_NAME_1 test1)</span><br><span class="line">set(APP_NAME_2 test2)</span><br><span class="line"># 添加子目录</span><br><span class="line">add_subdirectory(calc)</span><br><span class="line">add_subdirectory(sort)</span><br><span class="line">add_subdirectory(test1)</span><br><span class="line">add_subdirectory(test2)</span><br></pre></td></tr></table></figure><p>在根节点对应的文件中主要做了两件事情：定义全局变量和添加子目录。</p><p>定义的全局变量主要是给子节点使用，目的是为了提高子节点中的CMakeLists.txt文件的可读性和可维护性，避免冗余并降低出差的概率。<br>一共添加了四个子目录，每个子目录中都有一个CMakeLists.txt文件，这样它们的父子关系就被确定下来了。</p><p>calc 目录<br>calc 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALCLIB)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)</span><br><span class="line">add_library($&#123;CALC_LIB&#125; STATIC $&#123;SRC&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第3行aux_source_directory：搜索当前目录（calc目录）下的所有源文件<br>第4行include_directories：包含头文件路径，HEAD_PATH是在根节点文件中定义的<br>第5行set：设置库的生成的路径，LIB_PATH是在根节点文件中定义的<br>第6行add_library：生成静态库，静态库名字CALC_LIB是在根节点文件中定义的</p><p> sort 目录<br> sort 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(SORTLIB)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(LIBRARY_OUTPUT_PATH $&#123;LIB_PATH&#125;)</span><br><span class="line">add_library($&#123;SORT_LIB&#125; SHARED $&#123;SRC&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第6行add_library：生成动态库，动态库名字SORT_LIB是在根节点文件中定义的<br>这个文件中的内容和calc节点文件中的内容类似，只不过这次生成的是动态库。<br><code>在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。</code></p><p> test1 目录<br> test1 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(CALCTEST)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line"># include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">link_libraries($&#123;CALC_LIB&#125;)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)</span><br><span class="line">add_executable($&#123;APP_NAME_1&#125; $&#123;SRC&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第4行include_directories：指定头文件路径，HEAD_PATH变量是在根节点文件中定义的<br>第6行link_libraries：指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的<br>第7行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的<br>第8行add_executable：生成可执行程序，APP_NAME_1变量是在根节点文件中定义的<br><code>此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。</code></p><p>test2 目录<br>test2 目录中的 CMakeLists.txt文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(SORTTEST)</span><br><span class="line">aux_source_directory(./ SRC)</span><br><span class="line">include_directories($&#123;HEAD_PATH&#125;)</span><br><span class="line">set(EXECUTABLE_OUTPUT_PATH $&#123;EXEC_PATH&#125;)</span><br><span class="line"># link_directories($&#123;LIB_PATH&#125;)</span><br><span class="line">add_executable($&#123;APP_NAME_2&#125; $&#123;SRC&#125;)</span><br><span class="line">target_link_libraries($&#123;APP_NAME_2&#125; $&#123;SORT_LIB&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第四行include_directories：包含头文件路径，HEAD_PATH变量是在根节点文件中定义的<br>第五行set：指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的<br>第六行link_directories：指定可执行程序要链接的动态库的路径，LIB_PATH变量是在根节点文件中定义的<br>第七行add_executable：生成可执行程序，APP_NAME_2变量是在根节点文件中定义的<br>第八行target_link_libraries：指定可执行程序要链接的动态库的名字<br>在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。</p><p>构建项目<br>一切准备就绪之后，开始构建项目，进入到根节点目录的build 目录中，执行cmake 命令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cmake ..</span><br><span class="line">-- The C compiler identification is GNU 5.4.0</span><br><span class="line">-- The CXX compiler identification is GNU 5.4.0</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc</span><br><span class="line">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/robin/abc/cmake/calc/build</span><br></pre></td></tr></table></figure><p>可以看到在build目录中生成了一些文件和目录，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ tree build -L 1     </span><br><span class="line">build</span><br><span class="line">├── calc                  # 目录</span><br><span class="line">├── CMakeCache.txt        # 文件</span><br><span class="line">├── CMakeFiles            # 目录</span><br><span class="line">├── cmake_install.cmake   # 文件</span><br><span class="line">├── Makefile              # 文件</span><br><span class="line">├── sort                  # 目录</span><br><span class="line">├── test1                 # 目录</span><br><span class="line">└── test2                 # 目录</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在build 目录下执行make 命令:<br><img src="https://img-blog.csdnimg.cn/e862ad415ac94ef2885318bc8aa22f13.png"><br>通过上图可以得到如下信息：</p><p>在项目根目录的lib目录中生成了静态库libcalc.a<br>在项目根目录的lib目录中生成了动态库libsort.so<br>在项目根目录的bin目录中生成了可执行程序test1<br>在项目根目录的bin目录中生成了可执行程序test2<br>最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tree bin/ lib/</span><br><span class="line">bin/</span><br><span class="line">├── test1</span><br><span class="line">└── test2</span><br><span class="line">lib/</span><br><span class="line">├── libcalc.a</span><br><span class="line">└── libsort.so</span><br></pre></td></tr></table></figure><p>由此可见，真实不虚，至此，项目构建完毕。</p><p>写在最后：<br>在项目中，如果将程序中的某个模块制作成了动态库或者静态库并且在CMakeLists.txt 中指定了库的输出目录，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来。</p><h1 id="第十一步"><a href="#第十一步" class="headerlink" title="第十一步"></a>第十一步</h1><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>在 CMake 的 CMakeLists.txt 中也可以进行流程控制，也就是说可以像写 shell 脚本那样进行条件判断和循环。</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>条件判断取变量不需要${},直接变量名就可以<br>关于条件判断其语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;condition&gt;)</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line">elseif(&lt;condition&gt;) # 可选快, 可以重复</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line">else()              # 可选快</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>在进行条件判断的时候，如果有多个条件，那么可以写多个elseif，最后一个条件可以使用else，但是开始和结束是必须要成对出现的，分别为：if和endif。<br>基本表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;expression&gt;)</span><br></pre></td></tr></table></figure><p>如果是基本表达式，expression 有以下三种情况：常量、变量、字符串。</p><p>如果是1, ON, YES, TRUE, Y, 非零值，非空字符串时，条件判断返回True<br>如果是 0, OFF, NO, FALSE, N, IGNORE, NOTFOUND，空字符串时，条件判断返回False</p><h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(NOT &lt;condition&gt;)</span><br></pre></td></tr></table></figure><p>其实这就是一个取反操作，如果条件condition为True将返回False，如果条件condition为False将返回True。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;cond1&gt; AND &lt;cond2&gt;)</span><br></pre></td></tr></table></figure><p>如果cond1和cond2同时为True，返回True否则返回False。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;cond1&gt; OR &lt;cond2&gt;)</span><br></pre></td></tr></table></figure><p>如果cond1和cond2两个条件中至少有一个为True，返回True，如果两个条件都为False则返回False。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>基于数值的比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; LESS &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; GREATER &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; LESS_EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; GREATER_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure><p>LESS：如果左侧数值小于右侧，返回True<br>GREATER：如果左侧数值大于右侧，返回True<br>EQUAL：如果左侧数值等于右侧，返回True<br>LESS_EQUAL：如果左侧数值小于等于右侧，返回True<br>GREATER_EQUAL：如果左侧数值大于等于右侧，返回True</p><p>基于字符串的比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(&lt;variable|string&gt; STRLESS &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRGREATER &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRLESS_EQUAL &lt;variable|string&gt;)</span><br><span class="line">if(&lt;variable|string&gt; STRGREATER_EQUAL &lt;variable|string&gt;)</span><br></pre></td></tr></table></figure><p>STRLESS：如果左侧字符串小于右侧，返回True<br>STRGREATER：如果左侧字符串大于右侧，返回True<br>STREQUAL：如果左侧字符串等于右侧，返回True<br>STRLESS_EQUAL：如果左侧字符串小于等于右侧，返回True<br>STRGREATER_EQUAL：如果左侧字符串大于等于右侧，返回True</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>判断文件或者目录是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(EXISTS path-to-file-or-directory)</span><br><span class="line">如果文件或者目录存在返回True，否则返回False。</span><br></pre></td></tr></table></figure><p>判断是不是目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(IS_DIRECTORY path)</span><br><span class="line">此处目录的 path 必须是绝对路径</span><br><span class="line">如果目录存在返回True，目录不存在返回False。</span><br></pre></td></tr></table></figure><p>判断是不是软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(IS_SYMLINK file-name)</span><br><span class="line">此处的 file-name 对应的路径必须是绝对路径</span><br><span class="line">如果软链接存在返回True，软链接不存在返回False。</span><br><span class="line">软链接相当于 Windows 里的快捷方式</span><br></pre></td></tr></table></figure><p>判断是不是绝对路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(IS_ABSOLUTE path)</span><br><span class="line">关于绝对路径:</span><br><span class="line">如果是Linux，该路径需要从根目录开始描述</span><br><span class="line">如果是Windows，该路径需要从盘符开始描述</span><br><span class="line">如果是绝对路径返回True，如果不是绝对路径返回False</span><br></pre></td></tr></table></figure><h3 id="其他操作（不常用）"><a href="#其他操作（不常用）" class="headerlink" title="其他操作（不常用）"></a>其他操作（不常用）</h3><p>判断某个元素是否在列表中</p><p>if(&lt;variable|string&gt; IN_LIST <variable>)<br>CMake 版本要求：大于等于3.3<br>如果这个元素在列表中返回True，否则返回False。<br>比较两个路径是否相等</p><p>if(&lt;variable|string&gt; PATH_EQUAL &lt;variable|string&gt;)<br>CMake 版本要求：大于等于3.24<br>如果这个元素在列表中返回True，否则返回False。<br>关于路径的比较其实就是另个字符串的比较，如果路径格式书写没有问题也可以通过下面这种方式进行比较：</p><p>if(&lt;variable|string&gt; STREQUAL &lt;variable|string&gt;)<br>我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把&#x2F;a&#x2F;b&#x2F;c写成&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;&#x2F;c，此时通过STREQUAL对这两个字符串进行比较肯定是不相等的，但是通过PATH_EQUAL去比较两个路径，得到的结果确实相等的，可以看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.26)</span><br><span class="line">project(test)</span><br><span class="line"></span><br><span class="line">if(&quot;/home//robin///Linux&quot; PATH_EQUAL &quot;/home/robin/Linux&quot;)</span><br><span class="line">    message(&quot;路径相等&quot;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;路径不相等&quot;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">message(STATUS &quot;@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&quot;)</span><br><span class="line"></span><br><span class="line">if(&quot;/home//robin///Linux&quot; STREQUAL &quot;/home/robin/Linux&quot;)</span><br><span class="line">    message(&quot;路径相等&quot;)</span><br><span class="line">else()</span><br><span class="line">    message(&quot;路径不相等&quot;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>输出的日志信息如下:</p><p>路径相等<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>路径不相等<br>通过得到的结果我们可以得到一个结论：在进行路径比较的时候，如果使用 PATH_EQUAL 可以自动剔除路径中多余的分割线然后再进行路径的对比，使用 STREQUAL 则只能进行字符串比较。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>在 CMake 中循环有两种方式，分别是：foreach和while。<br>另外一种foreach不做介绍了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">while</span><br><span class="line">除了使用foreach也可以使用 while 进行循环，关于循环结束对应的条件判断的书写格式和if/elseif 是一样的。while的语法格式如下：</span><br><span class="line"></span><br><span class="line">while(&lt;condition&gt;)</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">endwhile()</span><br><span class="line">while循环比较简单，只需要指定出循环结束的条件即可：</span><br><span class="line"></span><br><span class="line">cmake_minimum_required(VERSION 3.5)</span><br><span class="line">project(test)</span><br><span class="line"># 创建一个列表 NAME</span><br><span class="line">set(NAME luffy sanji zoro nami robin)</span><br><span class="line"># 得到列表长度</span><br><span class="line">list(LENGTH NAME LEN)</span><br><span class="line"># 循环</span><br><span class="line">while($&#123;LEN&#125; GREATER  0)</span><br><span class="line">    message(STATUS &quot;names = $&#123;NAME&#125;&quot;)</span><br><span class="line">    # 弹出列表头部元素</span><br><span class="line">    list(POP_FRONT NAME)</span><br><span class="line">    # 更新列表长度</span><br><span class="line">    list(LENGTH NAME LEN)</span><br><span class="line">endwhile()</span><br><span class="line">输出的结果如下:</span><br><span class="line"></span><br><span class="line">$ cd build/</span><br><span class="line">$ cmake ..</span><br><span class="line">-- names = luffy;sanji;zoro;nami;robin</span><br><span class="line">-- names = sanji;zoro;nami;robin</span><br><span class="line">-- names = zoro;nami;robin</span><br><span class="line">-- names = nami;robin</span><br><span class="line">-- names = robin</span><br><span class="line">-- Configuring done (0.0s)</span><br><span class="line">-- Generating done (0.0s)</span><br><span class="line">-- Build files have been written to: /home/robin/abc/a/build</span><br><span class="line">可以看到当列表中的元素全部被弹出之后，列表的长度变成了0，此时while循环也就退出了。</span><br></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>添加选项 option(变量 “形容” OFF&#x2F;ONM)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.0)</span><br><span class="line">project(SORTTEST)</span><br><span class="line">option(ADD_TEST &quot;option for test&quot; OFF)</span><br><span class="line">if(ADD_TEST)</span><br><span class="line">    add_definitions(-DTEST)</span><br><span class="line">    message(&quot;----------&quot;)</span><br><span class="line">endif()</span><br><span class="line">add_executable(test main.cpp)</span><br></pre></td></tr></table></figure><p>以上来自于rk课程第二章第一节，。rkaiq这个宏来自于哪里</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>makefile语法</title>
      <link href="/posts/66ca84be.html"/>
      <url>/posts/66ca84be.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习环境搭建"><a href="#学习环境搭建" class="headerlink" title="学习环境搭建"></a>学习环境搭建</h1><h3 id="Linux（以Ubuntu为例）"><a href="#Linux（以Ubuntu为例）" class="headerlink" title="Linux（以Ubuntu为例）"></a>Linux（以Ubuntu为例）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++ make</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>学习与演示过程以Windows为主，Windows上装MinGW环境，MinGW官网： <a href="https://www.mingw-w64.org/">https://www.mingw-w64.org/</a><br>之前我们提过两个版本的环境，<strong>MingW-W64-builds</strong>和<strong>w64devkit</strong><br>推荐使用<strong>w64devkit</strong>套件，里面工具比较齐全，还提供模拟了许多Linux命令，用这个套件环境来学习可以保持在Linux与Windows上Makefile书写方式一致。<br>以下是w64devkit与其他包一些命令的区别</p><table><thead><tr><th align="center">w64devkit（模拟Linux）</th><th align="center">MingW-W64-builds或其他套件（Windows cmd命令）</th></tr></thead><tbody><tr><td align="center">make</td><td align="center">mingw32-make</td></tr><tr><td align="center">cc</td><td align="center">gcc</td></tr><tr><td align="center">rm</td><td align="center">del</td></tr><tr><td align="center">touch</td><td align="center"></td></tr><tr><td align="center">ls</td><td align="center">dir</td></tr><tr><td align="center">sh</td><td align="center"></td></tr><tr><td align="center">mv</td><td align="center"></td></tr><tr><td align="center">cp</td><td align="center">copy&#x2F;xcopy</td></tr><tr><td align="center">sed</td><td align="center"></td></tr></tbody></table><h3 id="学习材料"><a href="#学习材料" class="headerlink" title="学习材料"></a>学习材料</h3><p>make官方文档： <a href="https://www.gnu.org/software/make/manual/make.html">https://www.gnu.org/software/make/manual/make.html</a></p><p>2048: <a href="https://github.com/plibither8/2048.cpp">https://github.com/plibither8/2048.cpp</a></p><p>sudoku:  <a href="https://github.com/mayerui/sudoku">https://github.com/mayerui/sudoku</a></p><h1 id="Makefile基础知识"><a href="#Makefile基础知识" class="headerlink" title="Makefile基础知识"></a>Makefile基础知识</h1><h2 id="make使用流程"><a href="#make使用流程" class="headerlink" title="make使用流程"></a>make使用流程</h2><ol><li>准备好需要编译的源代码</li><li>编写Makefile文件</li><li>在命令行执行make命令</li></ol><h2 id="最简单的Makefile"><a href="#最简单的Makefile" class="headerlink" title="最简单的Makefile"></a>最简单的Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.cpp</span></span><br><span class="line">    g++ hello.cpp -o hello <span class="comment"># 开头必须为一个Tab，不能为空格</span></span><br></pre></td></tr></table></figure><p><strong>但通常需要将编译与链接分开写，分为如下两步</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.o</span></span><br><span class="line">    g++ hello.o -o hello</span><br><span class="line"><span class="section">hello.o: hello.cpp</span></span><br><span class="line">    g++ -c hello.cpp</span><br></pre></td></tr></table></figure><p><strong>规则</strong>(Rules)：一个Makefile文件由一条一条的规则构成，一条规则结构如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target … (目标): prerequisites …(依赖)</span><br><span class="line">        recipe(方法)</span><br><span class="line">        …</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><p>第二种写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target … (目标): prerequisites …(依赖); recipe(方法) ;…</span><br></pre></td></tr></table></figure><p>Make主要用于处理C和C++的编译工作，但不只能处理C和C++，所有编译器&#x2F;解释器能在命令行终端运行的编程语言都可以处理(例如Java、Python、 Golang….)。Make也不只能用来处理编程语言，所有基于一些文件(依赖)的改变去更新另一些文件(目标)的工作都可以做。</p><p><strong>Make编译与打包Java程序示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">snake.jar : C.class Main.class SnakeFrame.class SnakePanel.class</span><br><span class="line">    jar -cvfe snake.jar Main *.class</span><br><span class="line"></span><br><span class="line">C.class : C.java</span><br><span class="line">    javac C.java</span><br><span class="line"></span><br><span class="line">Main.class : Main.java</span><br><span class="line">    javac Main.java</span><br><span class="line"></span><br><span class="line">SnakeFrame.class : SnakeFrame.java</span><br><span class="line">    javac SnakeFrame.java</span><br><span class="line"></span><br><span class="line">SnakePanel.class : SnakePanel.java</span><br><span class="line">    javac SnakePanel.java</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.class *.jar</span><br></pre></td></tr></table></figure><h2 id="Makefile文件的命名与指定"><a href="#Makefile文件的命名与指定" class="headerlink" title="Makefile文件的命名与指定"></a>Makefile文件的命名与指定</h2><p>Make会自动查找makefile文件，查找顺序为GNUmakefile -&gt; makefile -&gt; Makefile</p><p><strong>GNUmakefile</strong>：不建议使用，因为只有GNU make会识别，其他版本的make（如BSD make, Windows nmake等）不会识别，如果只给GNU make使用的情况</p><p><strong>makefile</strong>：可以使用，GNU make和其他版本make识别</p><p><strong>Makefile</strong>：最常用，强烈建议使用</p><p>如果运行make的时候没有找到以上名字的文件，则会报错，这时候可以手动指定文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make -f mkfile  # make -f &lt;filename&gt;</span><br><span class="line">make --file=mkfile # make --file=&lt;filename&gt;</span><br></pre></td></tr></table></figure><blockquote><p>手动指定之后，make就会使用指定的文件，即使有Makefile或者makefile不会再自动使用</p></blockquote><h2 id="Makefile文件内容组成"><a href="#Makefile文件内容组成" class="headerlink" title="Makefile文件内容组成"></a>Makefile文件内容组成</h2><p>一个Makefile文件通常由五种类型的内容组成：显式规则、隐式规则、变量定义、指令和注释</p><p><strong>显式规则</strong>(<em>explicit rules</em>)：显式指明何时以及如何生成或更新目标文件，显式规则包括目标、依赖和更新方法三个部分</p><p><strong>隐式规则</strong>(<em>implicit rules</em>)：根据文件自动推导如何从依赖生成或更新目标文件。</p><p><strong>变量定义</strong>(<em>variable definitions</em>)：定议变量并指定值，值都是字符串，类似C语言中的宏定义(#define)，在使用时将值展开到引用位置</p><p><strong>指令</strong>(<em>directives</em>)：在make读取Makefile的过程中做一些特别的操作，包括：</p><ol><li><p>读取(包含)另一个makefile文件(类似C语言中的#include)</p></li><li><p>确定是否使用或略过makefile文件中的一部分内容(类似C语言中的#if)</p></li><li><p>定义多行变量</p></li></ol><p><strong>注释</strong>(<em>comments</em>)：一行当中 # 后面的内容都是注释，不会被make执行。make当中只有单行注释。如果需要用到#而不是注释，用\#。</p><h2 id="一个稍微复杂的Makefile"><a href="#一个稍微复杂的Makefile" class="headerlink" title="一个稍微复杂的Makefile"></a>一个稍微复杂的Makefile</h2><p><img src="./img/1.png"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">sudoku: block.o command.o input.o main.o scene.o test.o</span></span><br><span class="line">    g++ -o sudoku block.o command.o input.o main.o scene.o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">block.o: block.cpp common.h block.h color.h</span></span><br><span class="line">    g++ -c block.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">command.o: command.cpp scene.h common.h block.h command.h</span></span><br><span class="line">    g++ -c command.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">input.o: input.cpp common.h utility.inl</span></span><br><span class="line">    g++ -c input.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp scene.h common.h block.h command.h input.h</span></span><br><span class="line">    g++ -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">scene.o: scene.cpp common.h scene.h block.h command.h utility.inl</span></span><br><span class="line">    g++ -c scene.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">test.o: test.cpp test.h scene.h common.h block.h command.h</span></span><br><span class="line">    g++ -c test.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.cpp</span></span><br><span class="line">    g++ -c hello.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm block.o command.o input.o main.o scene.o test.o</span><br><span class="line">    rm sudoku.exe</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target … (目标): prerequisites …(依赖)</span><br><span class="line">        recipe(方法)</span><br><span class="line">        …</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li><p>Makefile中会有很多目标，但最终目标只有一个，其他所有内容都是为这个最终目标服务的，写Makefile的时候<strong>先写出最终目标，再依次解决总目标的依赖</strong></p></li><li><p>一般情况第一条规则中的目标会被确立为最终目标，第一条规则默认会被make执行</p></li><li><p>通常来说目标是一个文件，一条规则的目的就是生成或更新目标文件。</p></li><li><p>make会根据目标文件和依赖文件最后修改时间判断是否需要执行更新目标文件的方法。如果目标文件不存在或者目标文件最后修改时间早于其中一个依赖文件最后修改时间，则重新执行更新目标文件的方法。否则不会执行。</p></li><li><p>除了最终目标对应的更新方法默认会执行外，如果Makefile中一个目标不是其他目标的依赖，那么这个目标对应的规则不会自动执行。需要手动指定，方法为</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &lt;target&gt;  <span class="comment"># 如 make clean , make hello.o</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用.DEFAULT_GOAL来修改默认最终目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DEFAULT_GOAL = main</span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo all</span><br><span class="line"></span><br><span class="line"><span class="section">main:</span></span><br><span class="line">    @echo main</span><br></pre></td></tr></table></figure></li></ol><h2 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h2><p>如果一个标并不是一个文件，则这个目标就是伪目标。例如前面的clean目标。如果说在当前目录下有一个文件名称和这个目标名称冲突了，则这个目标就没法执行。这时候需要用到一个特殊的目标 .PHONY，将上面的clean目标改写如下 </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm block.o command.o input.o main.o scene.o test.o</span><br><span class="line">    rm sudoku.exe</span><br></pre></td></tr></table></figure><p>这样即使当前目录下存在与目标同名的文件，该目标也能正常执行。</p><p><strong>伪目标的其他应用方式</strong></p><p>如果一条规则的依赖文件没有改动，则不会执行对应的更新方法。如果需要每次不论有没有改动都执行某一目标的更新方法，可以把对应的目标添加到.PHONY的依赖中，例如下面这种方式，则每次执行make都会更新test.o，不管其依赖文件有没有改动</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test.o: test.cpp test.h</span></span><br><span class="line">        g++ -c test.cpp</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean test.o</span></span><br></pre></td></tr></table></figure><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="依赖类型"><a href="#依赖类型" class="headerlink" title="依赖类型"></a>依赖类型</h3><p><strong>普通依赖</strong></p><p>前面说过的这种形式都是普通依赖。直接列在目标后面。普通依赖有两个特点：</p><ol><li>如果这一依赖是由其他规则生成的文件，那么执行到这一目标前会先执行生成依赖的那一规则 </li><li>如果任何一个依赖文件修改时间比目标晚，那么就重新生成目标文件</li></ol><p><strong>order-only依赖</strong></p><p>依赖文件不存在时，会执行对应的方法生成，但依赖文件更新并不会导致目标文件的更新</p><p>如果目标文件已存在，order-only依赖中的文件即使修改时间比目标文件晚，目标文件也不会更新。</p><p>定义方法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targets : normal-prerequisites | order-only-prerequisites</span><br></pre></td></tr></table></figure><p>normal-prerequisites部分可以为空</p><h3 id="指定依赖搜索路径"><a href="#指定依赖搜索路径" class="headerlink" title="指定依赖搜索路径"></a>指定依赖搜索路径</h3><p>make默认在Makefile文件所在的目录下查找依赖文件，如果找不到，就会报错。这时候就需要手动指定搜索路径，用VPATH变量或vpath指令。</p><p><strong>VPATH用法如下：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VPATH = &lt;dir1&gt;:&lt;dir2&gt;:&lt;dir3&gt;...</span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line">VPATH = <span class="keyword">include</span>:src</span><br></pre></td></tr></table></figure><p>多个目录之间冒号隔开，这时make会在VPATH指定的这些目录里面查找依赖文件。</p><p><strong>vpath指令用法：</strong></p><p>vpath比VPATH使用更灵活，可以指定某个类型的文件在哪个目录搜索。</p><p>用法如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> &lt;pattern&gt; &lt;directories&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> %.h <span class="keyword">include</span>  <span class="comment"># .h文件在include目录下查找</span></span><br><span class="line"><span class="keyword">vpath</span> %.h <span class="keyword">include</span>:headers  <span class="comment"># .h文件在include或headers文件下查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> % src   <span class="comment"># 所有文件都在src下查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">vpath</span> hello.cpp src  <span class="comment"># hello.cpp文件在src查找</span></span><br></pre></td></tr></table></figure><h2 id="更新方法"><a href="#更新方法" class="headerlink" title="更新方法"></a>更新方法</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target … (目标): prerequisites …(依赖)</span><br><span class="line">        recipe(方法)</span><br><span class="line">        …</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><h4 id="关于执行终端"><a href="#关于执行终端" class="headerlink" title="关于执行终端"></a>关于执行终端</h4><p>更新方法实际上是一些Shell指令，通常以Tab开头，或直接放在目标-依赖列表后面，用分号隔开。这些指令都需要交给Shell执行，所以需要符合Shell语法。默认使用的Shell是sh，在Windows上如果没有安装sh.exe的话会自动查找使用cmd.exe之类的终端。这时有的指令写法，例如循环语句，与Linux不同，需要注意。</p><p>可以通过SHELL变量手动指定Shell</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL = C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe</span><br><span class="line">SHELL = cmd.exe</span><br></pre></td></tr></table></figure><p>默认的执行方式为一条指令重新调用一个Shell进程来执行。有时为了提高性能或其他原因，想让这个目标的所有指令都在同一进程中执行，可以在Makefile中添加 .ONESHELL</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.ONESHELL:</span></span><br></pre></td></tr></table></figure><p>这样所有指令都会在同一次Shell调用中执行</p><h4 id="Shell语句回显问题"><a href="#Shell语句回显问题" class="headerlink" title="Shell语句回显问题"></a>Shell语句回显问题</h4><p>通常make在执行一条Shell语句前都会先打印这条语句，如果不想打印可以在语句开头在@</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@echo hello</span><br><span class="line">@g++ -o hello hello.cpp</span><br></pre></td></tr></table></figure><p>也可以使用.SILENT来指定哪些目标的更新方法指令不用打印</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.SILENT: main all</span></span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果一条规则当中包含多条Shell指令，每条指令执行完之后make都会检查返回状态，如果返回状态是0，则执行成功，继续执行下一条指令，直到最后一条指令执行完成之后，一条规则也就结束了。</p><p>如果过程中发生了错误，即某一条指令的返回值不是0，那么make就会终止执行当前规则中剩下的Shell指令。</p><p>例如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm main.o hello.o</span><br><span class="line">    rm main.exe</span><br></pre></td></tr></table></figure><p>这时如果第一条rm main.o hello.o出错，第二条rm main.exe就不会执行。类似情况下，希望make忽视错误继续下一条指令。在指令开头<code>-</code>可以达到这种效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm main.o hello.o</span><br><span class="line">    -rm main.exe</span><br></pre></td></tr></table></figure><h2 id="变量应用"><a href="#变量应用" class="headerlink" title="变量应用"></a>变量应用</h2><p>Makefile中的变量有点类似C语言中的宏定义，即用一个名称表示一串文本。但与C语言宏定义不同的是，Makefile的变量值是可以改变的。变量定义之后可以在目标、依赖、方法等Makefile文件的任意地方进行引用。</p><blockquote><p>Makefile中的变量值只有一种类型： 字符串</p></blockquote><p><strong>变量可以用来表示什么</strong></p><ul><li><p>文件名序列</p></li><li><p>编译选项</p></li><li><p>需要运行的程序</p></li><li><p>需要进行操作的路径</p></li><li><p>……</p></li></ul><h3 id="变量定义与引用方式"><a href="#变量定义与引用方式" class="headerlink" title="变量定义与引用方式"></a>变量定义与引用方式</h3><p><strong>定义方式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &lt;变量名&gt; = &lt;变量值&gt;  &lt;变量名&gt; := &lt;变量值&gt;  &lt;变量名&gt; ::= &lt;变量值&gt;</span></span><br><span class="line">files = main.cpp hello.cpp</span><br><span class="line">objects := main.o hello.o</span><br><span class="line">var3 ::= main.o</span><br></pre></td></tr></table></figure><blockquote><p>变量名区分大小写，可以是任意字符串，不能含有”:”, “#”, “&#x3D;”</p></blockquote><p><strong>使用方式</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $(&lt;变量名&gt;) 或者 $&#123;&lt;变量名&gt;&#125;</span></span><br><span class="line">main.o : <span class="variable">$(files)</span> <span class="comment"># 或者 $&#123;files&#125;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p>如果变量名只有一个字符，使用时可以不用括号，如$a, $b， 但不建议这样用，不管是否只有一个字符都写成$(a), $(b)这种形式</p></blockquote><h3 id="Makefile读取过程"><a href="#Makefile读取过程" class="headerlink" title="Makefile读取过程"></a>Makefile读取过程</h3><p>GNU make分两个阶段来执行Makefile，第一阶段(读取阶段)：</p><ul><li><p>读取Makefile文件的所有内容</p></li><li><p>根据Makefile的内容在程序内建立起变量</p></li><li><p>在程序内构建起显式规则、隐式规则</p></li><li><p>建立目标和依赖之间的依赖图</p></li></ul><p>第二阶段(目标更新阶段)：</p><ul><li>用第一阶段构建起来的数据确定哪个目标需要更新然后执行对应的更新方法</li></ul><p>变量和函数的展开如果发生在第一阶段，就称作<strong>立即展开</strong>，否则称为<strong>延迟展开</strong>。立即展开的变量或函数在第一个阶段，也就是Makefile被读取解析的时候就进行展开。延迟展开的变量或函数将会到用到的时候才会进行展开，有以下两种情况：</p><ul><li><p>在一个立即展开的表达式中用到</p></li><li><p>在第二个阶段中用到</p></li></ul><p><strong>显式规则中，目标和依赖部分都是立即展开，在更新方法中延迟展开</strong></p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><h4 id="递归展开赋值（延迟展开）"><a href="#递归展开赋值（延迟展开）" class="headerlink" title="递归展开赋值（延迟展开）"></a>递归展开赋值（延迟展开）</h4><p>第一种方式就是直接使用<kbd>=</kbd>，这种方式如果赋值的时候右边是其他变量引用或者函数调用之类的，将不会做处理，直接保留原样，在使用到该变量的时候再来进行处理得到变量值（Makefile执行的第二个阶段再进行变量展开得到变量值）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bar2 = ThisIsBar2No.1</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">foo2 = <span class="variable">$(bar2)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(foo)</span>  <span class="comment"># Huh?</span></span><br><span class="line">    @echo <span class="variable">$(foo2)</span>  <span class="comment"># ThisIsBar2No.2</span></span><br><span class="line">    @echo <span class="variable">$(ugh)</span>   <span class="comment"># Huh?</span></span><br><span class="line"></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line">bar2 = ThisIsBar2No.2</span><br></pre></td></tr></table></figure><h4 id="简单赋值-立即展开"><a href="#简单赋值-立即展开" class="headerlink" title="简单赋值(立即展开)"></a>简单赋值(立即展开)</h4><p>简单赋值使用<kbd>:=</kbd>或<kbd>::=</kbd>，这种方式如果等号右边是其他变量或者引用的话，将会在赋值的时候就进行处理得到变量值。（Makefile执行第一阶段进行变量展开）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bar2 := ThisIsBar2No.1</span><br><span class="line">foo := <span class="variable">$(bar)</span></span><br><span class="line">foo2 := <span class="variable">$(bar2)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(foo)</span>    <span class="comment"># 空串，没有内容</span></span><br><span class="line">    @echo <span class="variable">$(foo2)</span>    <span class="comment"># ThisIsBar2No.1</span></span><br><span class="line">    @echo <span class="variable">$(ugh)</span>    <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">bar := <span class="variable">$(ugh)</span></span><br><span class="line">ugh := Huh?</span><br><span class="line">bar2 := ThisIsBar2No.2</span><br></pre></td></tr></table></figure><h4 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h4><p>条件赋值使用<kbd>?=</kbd>，如果变量已经定义过了（即已经有值了），那么就保持原来的值，如果变量还没赋值过，就把右边的值赋给变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var1 = 100</span><br><span class="line">var1 ?= 200</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(var1)</span> <span class="comment"># 100 注释var1 = 100之后为200</span></span><br></pre></td></tr></table></figure><p><strong>练习</strong>：试求a的值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = hello</span><br><span class="line">y = world</span><br><span class="line">a := <span class="variable">$(x)</span><span class="variable">$(y)</span></span><br><span class="line"></span><br><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line"></span><br><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($(<span class="variable">$(x)</span>))</span><br><span class="line"></span><br><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure><h4 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h4><p>使用<kbd>+=</kbd>在变量已有的基础上追加内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">files = main.cpp</span><br><span class="line">files += hello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(files)</span></span><br></pre></td></tr></table></figure><h4 id="Shell运行赋值"><a href="#Shell运行赋值" class="headerlink" title="Shell运行赋值"></a>Shell运行赋值</h4><p>使用<kbd>!=</kbd>，运行一个Shell指令后将返回值赋给一个变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc_version != gcc --version</span><br><span class="line">files != ls .</span><br></pre></td></tr></table></figure><blockquote><p>如果使用Windows需要注意，这种赋值方式只适用于与Linux相同的Shell指令，Windows独有的指令不能这样使用。</p></blockquote><h3 id="定义多行变量"><a href="#定义多行变量" class="headerlink" title="定义多行变量"></a>定义多行变量</h3><p>前面定义的变量都是单行的。</p><p>变量值有多行，多用于定义shell指令</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> &lt;varable_name&gt;  <span class="comment"># 默认为 = </span></span><br><span class="line"><span class="comment"># 变量内容</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> &lt;varable_name&gt; :=</span><br><span class="line"><span class="comment"># 变量内容</span></span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> &lt;varable_name&gt; +=</span><br><span class="line"><span class="comment"># 变量内容</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echosomething = @echo This is the first line</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> echosomething +=  </span><br><span class="line"></span><br><span class="line">@echo hello</span><br><span class="line">@echo world</span><br><span class="line">@echo 3</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="variable">$(echosomething)</span></span><br></pre></td></tr></table></figure><h3 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h3><p>如果想清除一个变量，用以下方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">undefine</span> &lt;变量名&gt;   如 <span class="keyword">undefine</span> files,  <span class="keyword">undefine</span> objs</span><br></pre></td></tr></table></figure><h3 id="环境变量的使用"><a href="#环境变量的使用" class="headerlink" title="环境变量的使用"></a>环境变量的使用</h3><p>系统中的环境变量可以直接在Makefile中直接使用，使用方法跟普通变量一样</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(USERNAME)</span></span><br><span class="line">    @echo <span class="variable">$(JAVA_HOME)</span></span><br><span class="line">    @echo <span class="variable">$(SystemRoot)</span></span><br></pre></td></tr></table></figure><h3 id="变量替换引用"><a href="#变量替换引用" class="headerlink" title="变量替换引用"></a>变量替换引用</h3><p>语法：__$(var:a&#x3D;b)__，意思是将变量var的值当中每一项结尾的a替换为b，直接上例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">files = main.cpp hello.cpp</span><br><span class="line">objs := $(files:.cpp=.o) <span class="comment"># main.o hello.o</span></span><br><span class="line"><span class="comment"># 另一种写法</span></span><br><span class="line">objs := $(files:%.cpp=%.o)</span><br></pre></td></tr></table></figure><h3 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h3><p>所有在Makefile中的变量，都可以在执行make时能过指定参数的方式进行覆盖。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OverridDemo := ThisIsInMakefile</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(OverridDemo)</span></span><br></pre></td></tr></table></figure><p>如果直接执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>则上面的输出内容为<em>ThisIsInMakefile</em>，但可以在执行make时指定参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make OverridDemo=ThisIsFromOutShell # 等号两边不能有空格</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果变量值中有空格，需要用引号</span></span><br><span class="line">make OverridDemo=“This Is From Out Shell”</span><br></pre></td></tr></table></figure><p>则输出OverridDemo的值是ThisIsFromOutShell或This Is From Out Shell。</p><p>用这样的命令参数会覆盖Makefile中对应变量的值，如果不想被覆盖，可以在变量前加上override指令，override具有较高优先级，不会被命令参数覆盖</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> OverridDemo := ThisIsInMakefile</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(OverridDemo)</span></span><br></pre></td></tr></table></figure><p>这样即使命令行指定参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make OverridDemo=ThisIsFromOutShell</span><br></pre></td></tr></table></figure><p>输出结果依然是ThisIsInMakefile</p><h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>**$@**：①本条规则的目标名；②如果目标是归档文件的成员，则为归档文件名；③在多目标的模式规则中, 为导致本条规则方法执行的那个目标名；</p><p>**$&lt;**：本条规则的第一个依赖名称</p><p>**$?**：依赖中修改时间晚于目标文件修改时间的所有文件名，以空格隔开</p><p><strong>$^</strong>：所有依赖文件名，文件名不会重复，不包含order-only依赖</p><p>**$+**：类似上一个， 表示所有依赖文件名，包括重复的文件名，不包含order-only依赖</p><p>**$|**：所有order-only依赖文件名</p><p>__$*__：(简单理解)目标文件名的主干部分(即不包括后缀名)</p><p>**$%**：如果目标不是归档文件，则为空；如果目标是归档文件成员，则为对应的成员文件名</p><p>以下变量对应上述变量，D为对应变量所在的目录，结尾不带&#x2F;，F为对应变量除去目录部分的文件名</p><p><strong>$(@D)</strong></p><p><strong>$(@F)</strong></p><p><strong>$(*D)</strong></p><p><strong>$(*F)</strong></p><p><strong>$(%D)</strong></p><p><strong>$(%F)</strong></p><p><strong>$(&lt;D)</strong></p><p><strong>$(&lt;F)</strong></p><p><strong>$(^D)</strong></p><p><strong>$(^F)</strong></p><p><strong>$(+D)</strong></p><p><strong>$(+F)</strong></p><p><strong>$(?D)</strong></p><p><strong>$(?F)</strong></p><h3 id="绑定目标的变量"><a href="#绑定目标的变量" class="headerlink" title="绑定目标的变量"></a>绑定目标的变量</h3><p>Makefile中的变量一般是全局变量。也就是说定义之后在Makefile的任意位置都可以使用。但也可以将变量指定在某个目标的范围内，这样这个变量就只能在这个目标对应的规则里面保用</p><p>语法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target … : variable-assignment</span><br><span class="line">target … : prerequisites</span><br><span class="line">    recipes</span><br><span class="line">    …</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var1 = Global Var</span><br><span class="line"></span><br><span class="line"><span class="section">first: all t2</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: var2 = Target All Var</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(var1)</span></span><br><span class="line">    @echo <span class="variable">$(var2)</span></span><br><span class="line"></span><br><span class="line"><span class="section">t2:</span></span><br><span class="line">    @echo <span class="variable">$(var1)</span></span><br><span class="line">    @echo <span class="variable">$(var2)</span></span><br></pre></td></tr></table></figure><p>这种定义变量的方式，目标也可以使用模式匹配，这样所有能匹配上的目标范围内都可以使用这些变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var1 = Global Var</span><br><span class="line"></span><br><span class="line"><span class="section">first: all.v t2.v t3</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.v: var2 = Target %.v Var</span></span><br><span class="line"><span class="section">all.v:</span></span><br><span class="line">    @echo <span class="variable">$@</span> -- <span class="variable">$(var1)</span></span><br><span class="line">    @echo <span class="variable">$@</span> -- <span class="variable">$(var2)</span></span><br><span class="line"></span><br><span class="line"><span class="section">t2.v:</span></span><br><span class="line">    @echo <span class="variable">$@</span> -- <span class="variable">$(var1)</span></span><br><span class="line">    @echo <span class="variable">$@</span> -- <span class="variable">$(var2)</span></span><br><span class="line"><span class="section">t3:</span></span><br><span class="line">    @echo <span class="variable">$@</span> -- <span class="variable">$(var1)</span></span><br><span class="line">    @echo <span class="variable">$@</span> -- <span class="variable">$(var2)</span></span><br></pre></td></tr></table></figure><h3 id="二次展开"><a href="#二次展开" class="headerlink" title="二次展开"></a>二次展开</h3><p>前面说过依赖中的变量都是在Makefile读取阶段立即展开的。如果想让依赖的的变量延迟展开，可以使用.SECONDEXPANSION:，添加之后，在依赖中使用变量时用<code>$$</code>，可以让变量在第二阶段进行二次展开，从而达到延迟展开的效果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VAR1 = main.cpp</span><br><span class="line"><span class="section">.SECONDEXPANSION:</span></span><br><span class="line"><span class="section">all: $<span class="variable">$(VAR1)</span></span></span><br><span class="line">    @echo <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">VAR1 = hello.cpp</span><br></pre></td></tr></table></figure><h1 id="自动推导与隐式规则"><a href="#自动推导与隐式规则" class="headerlink" title="自动推导与隐式规则"></a>自动推导与隐式规则</h1><p>Makefile中有一些生成目标文件的规则使用频率非常高，比如由.c或.cpp文件编译成.o文件，这样的规则在make中可以自动推导，所以可以不用明确写出来，这样的规则称为隐式规则。</p><h2 id="一些make预定义的规则"><a href="#一些make预定义的规则" class="headerlink" title="一些make预定义的规则"></a>一些make预定义的规则</h2><h3 id="C语言编译"><a href="#C语言编译" class="headerlink" title="C语言编译"></a>C语言编译</h3><p>从.c到.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -c</span><br></pre></td></tr></table></figure><h3 id="C-编译"><a href="#C-编译" class="headerlink" title="C++编译"></a>C++编译</h3><p>从.cc .cpp .C到.o</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CXXFLAGS)</span> -c</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>由.o文件链接到可执行文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> *.o <span class="variable">$(LOADLIBES)</span> <span class="variable">$(LDLIBS)</span></span><br></pre></td></tr></table></figure><h2 id="隐式规则中常用一些变量"><a href="#隐式规则中常用一些变量" class="headerlink" title="隐式规则中常用一些变量"></a>隐式规则中常用一些变量</h2><p>这些变量都有默认值，也可以自行修改</p><h3 id="CC"><a href="#CC" class="headerlink" title="CC"></a>CC</h3><p>编译C语言的程序，默认为 <code>cc</code></p><h3 id="CXX"><a href="#CXX" class="headerlink" title="CXX"></a>CXX</h3><p>编译C++的程序，默认为 <code>g++</code></p><h3 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h3><p>归档程序，默认为 <code>ar</code></p><h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><p>C语言预处理程序，默认为 <code>$(CC) -E</code></p><h3 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h3><p>删除文件的程序，默认为<code>rm -f</code></p><h3 id="CFLAGS"><a href="#CFLAGS" class="headerlink" title="CFLAGS"></a>CFLAGS</h3><p>传递给C编译器的一些选项，如-O2 -Iinclude</p><h3 id="CXXFLAGS"><a href="#CXXFLAGS" class="headerlink" title="CXXFLAGS"></a>CXXFLAGS</h3><p>传递给C++编译器的一些选项，如-std&#x3D;c++ 11 -fexec-charset&#x3D;GBK   </p><h3 id="CPPFLAGS"><a href="#CPPFLAGS" class="headerlink" title="CPPFLAGS"></a>CPPFLAGS</h3><p>C语言预处理的一些选项</p><h3 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h3><p>链接选项，如-L.</p><h3 id="LDLIBS"><a href="#LDLIBS" class="headerlink" title="LDLIBS"></a>LDLIBS</h3><p>链接需要用到的库，如-lkernel32 -luser32 -lgdi32</p><h1 id="多目标与多规则"><a href="#多目标与多规则" class="headerlink" title="多目标与多规则"></a>多目标与多规则</h1><p>显式规则中一条规则可以有多个目标，多个目标可以是相互独立的目标，也可以是组合目标，用写法来区分</p><h2 id="独立多目标"><a href="#独立多目标" class="headerlink" title="独立多目标"></a>独立多目标</h2><p>相互独立的多个目标与依赖之间直接用<code>:</code>，常用这种方式的有以下两种情况</p><ol><li><p>只需要写目标和依赖，不需要写方法的时候</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block.o input.o scene.o : common.h</span><br></pre></td></tr></table></figure><p>这种写法等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block.o : common.h</span><br><span class="line">input.o : common.h</span><br><span class="line">scene.o : common.h</span><br></pre></td></tr></table></figure></li><li><p>生成(更新)目标的方法写法一样的，只是依赖与目标不一样时。之前写的Makfile中，有如下代码：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">block.o: block.cpp common.h block.h color.h</span></span><br><span class="line">    g++ -c block.cpp</span><br><span class="line"><span class="section">command.o: command.cpp command.h scene.h</span></span><br><span class="line">    g++ -c command.cpp</span><br><span class="line"><span class="section">input.o: input.cpp common.h utility.inl</span></span><br><span class="line">    g++ -c input.cpp</span><br><span class="line"><span class="section">main.o: main.cpp scene.h input.h test.h</span></span><br><span class="line">    g++ -c main.cpp</span><br><span class="line"><span class="section">scene.o: scene.cpp common.h scene.h utility.inl</span></span><br><span class="line">    g++ -c scene.cpp</span><br><span class="line"><span class="section">test.o: test.cpp test.h</span></span><br><span class="line">    g++ -c test.cpp</span><br></pre></td></tr></table></figure><p>所有.o文件的生成都用的同一方法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>如果不考虑依赖源文件进行更新时，可以进行简写如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block.o command.o input.o main.o scene.o test.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c $(@:%.o=%.cpp)</span><br></pre></td></tr></table></figure><p>这种写法实际上等价于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">block.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$@</span>)</span></span><br><span class="line">command.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$@</span>)</span></span><br><span class="line">input.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$@</span>)</span></span><br><span class="line">main.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$@</span>)</span></span><br><span class="line">scene.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$@</span>)</span></span><br><span class="line">test.o : common.h block.h command.h ...</span><br><span class="line">    g++ -c <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$@</span>)</span></span><br></pre></td></tr></table></figure><p>其中，$@表示的是目标名称。subst是一个字符串替换函数，$(subst .o,.cpp,$@)表示将目标名称中的.o替换为.cpp。</p><p>这样的简写可以减少内容的书写量，但是不利于将每个目标与依赖分别对应。</p></li></ol><p>独立多目标虽然写在一起，但是每个目标都是单独调用一次方法来更新的。和分开写效果一样。</p><h2 id="组合多目标"><a href="#组合多目标" class="headerlink" title="组合多目标"></a>组合多目标</h2><p>多目标与依赖之前用<code>&amp;:</code>，这样的多个目标称为组合目标。与独立多目标的区别在于，独立多目标每个目标的更新需要单独调用一次更新方法。而组合多目标调用一次方法将更新所有目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block.o input.o scene.o &amp;: block.cpp input.cpp scene.cpp common.h</span><br><span class="line">    g++ -c block.cpp</span><br><span class="line">    g++ -c input.cpp</span><br><span class="line">    g++ -c scene.cpp</span><br></pre></td></tr></table></figure><p>所有目标的更新方法都写到其中，每次更新只会调用一次。</p><h2 id="同一目标多条规则"><a href="#同一目标多条规则" class="headerlink" title="同一目标多条规则"></a>同一目标多条规则</h2><p>同一目标可以对应多条规则。同一目标的所有规则中的依赖会被合并。但如果同一目标对应的多条规则都写了更新方法，则会使用最新的一条更新方法，并且会输出警告信息。</p><p>同一目标多规则通常用来给多个目标添加依赖而不用改动已写好的部分。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">input.o: input.cpp utility.inl</span></span><br><span class="line">    g++ -c input.cpp</span><br><span class="line"><span class="section">main.o: main.cpp scene.h input.h test.h</span></span><br><span class="line">    g++ -c main.cpp</span><br><span class="line"><span class="section">scene.o: scene.cpp scene.h utility.inl</span></span><br><span class="line">    g++ -c scene.cpp</span><br><span class="line"></span><br><span class="line">input.o main.o scene.o : common.h</span><br></pre></td></tr></table></figure><p>同时给三个目标添加了一个依赖common.h，但是不用修改上面已写好的部分。</p><h1 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h1><p>独立多目标可以简化Makefile的书写，但是不利于将各个目标的依赖分开，让目标文件根据各自的依赖进行更新。静态模式可以在一定程度上改进依赖分开问题。</p><p>静态模式就是用<code>%</code>进行文件匹配来推导出对应的依赖。</p><p><strong>语法</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets …: target-pattern(目标模式): prereq-patterns(依赖模式) …</span><br><span class="line">        recipe</span><br><span class="line">        …</span><br></pre></td></tr></table></figure><p>先看一个例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block.o : %.o : %.cpp %.h</span><br><span class="line">    g++ -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><p>block.o为目标，%.o为目标模式，%.cpp，%.h为依赖模式，对于这一条规则，%.o代表的是目标文件block.o，所以这里的%匹配的是block，因此，%.cpp表示block.cpp，%.h代表block.h，所以block.o : %.o : %.cpp %.h表示的意思同下面这种写法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">block.o : block.cpp block.h</span><br></pre></td></tr></table></figure><p>自动推导出block.o依赖block.cpp和block.h。</p><p>另外，$&lt;表示目标的第一个依赖，在这条规则中，$&lt;表示block.cpp</p><p>对应的Makefile可以做如下改进</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block.o command.o input.o scene.o test.o: %.o : %.cpp %.h</span><br><span class="line">    g++ -c <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">main.o: main.cpp scene.h input.h test.h</span></span><br><span class="line">    g++ -c main.cpp</span><br></pre></td></tr></table></figure><p>用这种方式可以在简写的同时一定程度上解决各个目标对应的依赖问题。</p><p>(不属于静态模式的内容，隐式规则的内容)利用模式匹配可以直接将所有.cpp到.o文件的编译简写为如下</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.cpp %.h</span><br><span class="line">    g++ -c <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure><h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>使用条件指令可以让make执行或略过Makefile文件中的一些部分。</p><p><strong>ifdef</strong>  判断一个变量是已否定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">OS = Linux</span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OS = Linux</span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifdef</span> Mac</span><br><span class="line">    OS= MacOS</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifdef</span> Win</span><br><span class="line">    OS = Windows</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifdef</span> Mac</span><br><span class="line">    OS= MacOS</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    OS = Linux</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><strong>ifndef</strong> 判断一个变量是否没被定义</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifndef</span> FLAGS</span><br><span class="line">    FLAGS = -finput-charset=utf-8</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p><strong>ifeq</strong> 判断两个值是否相等</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version = 3.0</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(version)</span>,1.0)            <span class="comment"># ifeq后一定要一个空格</span></span><br><span class="line">    msg := 版本太旧了，请更新版本</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">ifeq</span> (<span class="variable">$(version)</span>, 3.0)</span><br><span class="line">    msg := 版本太新了，也不行</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    msg := 版本可以用</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外的写法</span></span><br><span class="line">msg = Other</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;<span class="variable">$(OS)</span>&quot;</span> <span class="string">&quot;Windows_NT&quot;</span></span><br><span class="line">    msg = This is a Windows Platform</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> &#x27;<span class="variable">$(OS)</span>&#x27; &#x27;Windows_NT&#x27;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> &#x27;<span class="variable">$(OS)</span>&#x27; <span class="string">&quot;Windows_NT&quot;</span></span><br></pre></td></tr></table></figure><p><strong>ifneq</strong> 判断两个值是否不等</p><p>用法及参数同ifeq，只是判断结果相反</p><h1 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h1><p>C语言中，函数调用方法是function(arguments)；但在Makefile中调用函数的写法不同</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span> 或 $&#123;function arguments&#125;</span><br><span class="line"><span class="variable">$(function arg1,<span class="variable">$(arg2)</span>,arg3 ...)</span>  <span class="comment"># 参数之间不要有空格</span></span><br></pre></td></tr></table></figure><h2 id="字符替换与分析"><a href="#字符替换与分析" class="headerlink" title="字符替换与分析"></a>字符替换与分析</h2><h4 id="subst"><a href="#subst" class="headerlink" title="subst"></a><strong>subst</strong></h4><p>文本替换函数，返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> target,replacement,text)</span></span><br><span class="line">        --- 用relacement替换text中的target</span><br><span class="line">        --- target 需要替换的内容</span><br><span class="line">        --- replacement 替换为的内容</span><br><span class="line">        --- text 需要处理的内容，可以是任意字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objs = main.o hello.o</span><br><span class="line">srcs = <span class="variable">$(<span class="built_in">subst</span> .o,.cpp,<span class="variable">$(objs)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">subst</span> .cpp,.h,<span class="variable">$(srcs)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(srcs)</span></span><br><span class="line">    @echo <span class="variable">$(headers)</span></span><br></pre></td></tr></table></figure><p><strong>patsubst</strong></p><p>模式替换， 返回替换后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br><span class="line">        --- pattern 需要替换的模式</span><br><span class="line">        --- replacement 需要替换为</span><br><span class="line">        --- text 待处理内容，各项内容需要用空格隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objs = main.ohello.o</span><br><span class="line">srcs = <span class="variable">$(<span class="built_in">subst</span> %.o,%.cpp,<span class="variable">$(objs)</span>)</span></span><br><span class="line">headers = <span class="variable">$(<span class="built_in">subst</span> %.cpp,%.h,<span class="variable">$(srcs)</span>)</span>    </span><br></pre></td></tr></table></figure><h4 id="strip"><a href="#strip" class="headerlink" title="strip"></a><strong>strip</strong></h4><p>去除字符串头部和尾部的空格，中间如果连续有多个空格，则用一个空格替换，返回去除空格后的文本</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> string)</span></span><br><span class="line">        --- string 需要去除空格的字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = aa hello.cpp      main.cpp     test.cpp</span><br><span class="line">files := <span class="variable">$(<span class="built_in">subst</span> aa,        ,<span class="variable">$(files)</span>)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="findstring"><a href="#findstring" class="headerlink" title="findstring"></a>findstring</h4><p>查找字符串，如果找到了，则返回对应的字符串，如果没找到，则反回空串</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> find,string)</span></span><br><span class="line">        --- find 需要查找的字符串</span><br><span class="line">        --- string 用来查找的内容</span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp</span><br><span class="line">find = <span class="variable">$(<span class="built_in">findstring</span> hel,<span class="variable">$(files)</span>)</span></span><br><span class="line">find = <span class="variable">$(<span class="built_in">findstring</span> HEL,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>从文本中筛选出符合模式的内容并返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern…,text)</span></span><br><span class="line">        --- pattern 模式，可以有多个，用空格隔开</span><br><span class="line">        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理</span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">filter</span> %.o %.h,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="filter-out"><a href="#filter-out" class="headerlink" title="filter-out"></a>filter-out</h4><p>与filter相反，过滤掉符合模式的，返回剩下的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern…,text)</span></span><br><span class="line">        --- pattern 模式，可以有多个，用空格隔开</span><br><span class="line">        --- text 用来筛选的文本，多项内容需要用空格隔开，否则只会当一项来处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">filter</span>-out %.o %.cpp,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>将文本内的各项按字典顺序排列，并且移除重复项</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> list)</span></span><br><span class="line">        --- list 需要排序内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">sort</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="word"><a href="#word" class="headerlink" title="word"></a>word</h4><p>用于返回文本中第n个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> n,text)</span></span><br><span class="line">        --- n 第n个单词，从1开始，如果n大于总单词数，则返回空串</span><br><span class="line">        --- text 待处理文本</span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">word</span> 3,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="wordlist"><a href="#wordlist" class="headerlink" title="wordlist"></a>wordlist</h4><p>用于返回文本指定范围内的单词列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> start,end,text)</span></span><br><span class="line">        --- start 起始位置，如果大于单词总数，则返回空串</span><br><span class="line">        --- end 结束位置，如果大于单词总数，则返回起始位置之后全部，如果start &gt; end，什么都不返回</span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wordlist</span> 3,6,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="words"><a href="#words" class="headerlink" title="words"></a>words</h4><p>返回文本中单词数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(words text)</span></span><br><span class="line">        --- text 需要处理的文本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = hello.cpp main.cpp test.cpp main.o hello.o hello.h main.cpp hello.cpp</span><br><span class="line">nums = <span class="variable">$(words <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="firstword"><a href="#firstword" class="headerlink" title="firstword"></a>firstword</h4><p>返回第一个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> text)</span></span><br></pre></td></tr></table></figure><h4 id="lastword"><a href="#lastword" class="headerlink" title="lastword"></a>lastword</h4><p>返回最后一个单词</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">lastword</span> text)</span></span><br></pre></td></tr></table></figure><h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><h4 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h4><p>返回文件目录</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> files)</span></span><br><span class="line">        --- files 需要返回目录的文件名，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp</span><br><span class="line"></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="notdir"><a href="#notdir" class="headerlink" title="notdir"></a>notdir</h4><p>返回除目录部分的文件名</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> files)</span></span><br><span class="line">        --- files 需要返回文件列表，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="suffix"><a href="#suffix" class="headerlink" title="suffix"></a>suffix</h4><p>返回文件后缀名，如果没有后缀返回空</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> files)</span></span><br><span class="line">        --- files 需要返回后缀的文件名，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">suffix</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h4><p>返回文件名除后缀的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> files)</span></span><br><span class="line">        --- files 需要返回的文件名，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">basename</span> <span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="addsuffix"><a href="#addsuffix" class="headerlink" title="addsuffix"></a>addsuffix</h4><p>给文件名添加后缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> <span class="built_in">suffix</span>,files)</span></span><br><span class="line">        --- suffix 需要添加的后缀</span><br><span class="line">        --- files 需要添加后缀的文件名，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">addsuffix</span> .exe,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="addprefix"><a href="#addprefix" class="headerlink" title="addprefix"></a>addprefix</h4><p>给文件名添加前缀</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> prefix,files)</span></span><br><span class="line">        --- prefix 需要添加的前缀</span><br><span class="line">        --- files 需要添加前缀的文件名，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">addprefix</span> make/,<span class="variable">$(files)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>将两个列表中的内容一对一连接，如果两个列表内容数量不相等，则多出来的部分原样返回</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> list1,list2)</span></span><br><span class="line">        --- list1 第一个列表</span><br><span class="line">        --- list2 需要连接的第二个列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = hello main test</span><br><span class="line">f2 = .cpp .hpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">join</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><p>返回符合通配符的文件列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span></span><br><span class="line">        --- pattern 通配符</span><br><span class="line"></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> *)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">wildcard</span> src/*.cpp)</span></span><br></pre></td></tr></table></figure><h4 id="realpath"><a href="#realpath" class="headerlink" title="realpath"></a>realpath</h4><p>返回文件的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">realpath</span> files)</span></span><br><span class="line">        --- files 需要返回绝对路径的文件，可以有多个，用空格隔开</span><br><span class="line"></span><br><span class="line">f3 = <span class="variable">$(<span class="built_in">wildcard</span> src/*)</span></span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">realpath</span> <span class="variable">$(f3)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="abspath"><a href="#abspath" class="headerlink" title="abspath"></a>abspath</h4><p>返回绝对路径，用法同realpath，如果一个文件名不存在，realpath不会返回内容，abspath则会返回一个当前文件夹一下的绝对路径</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">abspath</span> files)</span></span><br></pre></td></tr></table></figure><h2 id="条件函数"><a href="#条件函数" class="headerlink" title="条件函数"></a>条件函数</h2><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>条伯判断，如果条件展开不是空串，则反回真的部分，否则返回假的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> condition,then-part[,else-part])</span></span><br><span class="line">        --- condition 条件部分</span><br><span class="line">        --- then-part 条件为真时执行的部分</span><br><span class="line">        --- else-part 条件为假时执行的部分，如果省略则为假时返回空串</span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(files)</span>,有文件,没有文件)</span></span><br></pre></td></tr></table></figure><h4 id="or"><a href="#or" class="headerlink" title="or"></a>or</h4><p>返回条件中第一个不为空的部分</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">or</span> condition1[,condition2[,condition3…]])</span></span><br><span class="line"></span><br><span class="line">f1 = </span><br><span class="line">f2 = </span><br><span class="line">f3 = hello.cpp</span><br><span class="line">f4 = main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">or</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>,<span class="variable">$(f3)</span>,<span class="variable">$(f4)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="and"><a href="#and" class="headerlink" title="and"></a>and</h4><p>如果条件中有一个为空串，则返回空，如果全都不为空，则返回最后一个条件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">and</span> condition1[,condition2[,condition3…]])</span></span><br><span class="line"></span><br><span class="line">f1 = 12</span><br><span class="line">f2 = 34</span><br><span class="line">f3 = hello.cpp</span><br><span class="line">f4 = main.cpp</span><br><span class="line">files2 = <span class="variable">$(<span class="built_in">and</span> <span class="variable">$(f1)</span>,<span class="variable">$(f2)</span>,<span class="variable">$(f3)</span>,<span class="variable">$(f4)</span>)</span></span><br></pre></td></tr></table></figure><h4 id="intcmp"><a href="#intcmp" class="headerlink" title="intcmp"></a>intcmp</h4><p>比较两个整数大小，并返回对应操作结果（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(intcmp lhs,rhs[,lt-part[,eq-part[,gt-part]]])</span> </span><br><span class="line">        --- lhs 第一个数</span><br><span class="line">        --- rhs 第二个数</span><br><span class="line">        --- lt-part  lhs &lt; rhs时执行</span><br><span class="line">        --- eq-part  lhs = rhs时执行</span><br><span class="line">        --- gt-part  lhs &gt; rhs时执行</span><br><span class="line">        --- 如果只提供前两个参数，则lhs == rhs时返回数值，否则返回空串</span><br><span class="line">            参数为lhs,rhs,lt-part时，当lhs &lt; rhs时返回lt-part结果，否则返回空</span><br><span class="line">            参数为lhs,rhs,lt-part,eq-part，lhs &lt; rhs返回lt-part结果，否则都返回eq-part结果</span><br><span class="line">            参数全时，lhs &lt; rhs返回lt-part，lhs == rhs返回eq-part, lhs &gt; rhs返回gt-part</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@echo <span class="variable">$(intcmp 2,2,-1,0,1)</span></span><br></pre></td></tr></table></figure><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>读写文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">file</span> op filename[,text])</span></span><br><span class="line">        --- op 操作</span><br><span class="line">                &gt; 覆盖</span><br><span class="line">                &gt;&gt; 追加</span><br><span class="line">                &lt; 读</span><br><span class="line">        --- filename 需要操作的文件名</span><br><span class="line">        --- text 写入的文本内容，读取是不需要这个参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">files = src/hello.cpp main.cpp hello.o hello.hpp hello</span><br><span class="line">write = <span class="variable">$(<span class="built_in">file</span> &gt; makewrite.txt,<span class="variable">$(files)</span>)</span></span><br><span class="line">read = <span class="variable">$(<span class="built_in">file</span> &lt; makewrite.txt)</span></span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>对一列用空格隔开的字符序列中每一项进行处理，并返回处理后的列表</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> each,list,process)</span></span><br><span class="line">        --- each list中的每一项</span><br><span class="line">        --- list 需要处理的字符串序列，用空格隔开</span><br><span class="line">        --- process 需要对每一项进行的处理</span><br><span class="line"></span><br><span class="line">list = 1 2 3 4 5</span><br><span class="line">result = <span class="variable">$(<span class="built_in">foreach</span> each,<span class="variable">$(list)</span>,$(<span class="built_in">addprefix</span> cpp,$(<span class="built_in">addsuffix</span> .cpp,<span class="variable">$(each)</span>)</span>))</span><br></pre></td></tr></table></figure><p>作用类似C&#x2F;C++中的循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> list[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> result[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> each;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    each = list[i];</span><br><span class="line">    result[i] = <span class="built_in">process</span>(each);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时result即为返回结果</span></span><br></pre></td></tr></table></figure><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>将一些复杂的表达式写成一个变量，用call可以像调用函数一样进行调用。类似于编程语言中的自定义函数。在函数中可以用$(n)来访问第n个参数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> funcname,param1,param2,…)</span></span><br><span class="line">        --- funcname 自定义函数（变量名）</span><br><span class="line">        --- 参数至少一个，可以有多个，用逗号隔开</span><br><span class="line"></span><br><span class="line">dirof =  <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(1)</span>)) <span class="variable">$(<span class="built_in">dir</span> $(<span class="built_in">realpath</span> $(2)</span>))</span><br><span class="line">result = <span class="variable">$(<span class="built_in">call</span> dirof,main.cpp,src/hello.cpp)</span></span><br></pre></td></tr></table></figure><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p>对于不是立即展开的变量，可以查看变量的原始定义；对于立即展开的变量，直接返回变量值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">value</span> variable)</span></span><br><span class="line"></span><br><span class="line">var = value function test</span><br><span class="line">var2 = <span class="variable">$(var)</span></span><br><span class="line">var3 := <span class="variable">$(var)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">value</span> var2)</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">value</span> var3)</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>查看一个变量定义来源</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> variable)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var2 = origin function </span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> var1)</span>    <span class="comment"># undefined 未定义</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> CC)</span>        <span class="comment"># default 默认变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> JAVA_HOME)</span> <span class="comment"># environment 环境变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> var2)</span>    <span class="comment"># file 在Makefile文件中定义的变量</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">origin</span> @)</span>        <span class="comment"># automatic 自动变量</span></span><br></pre></td></tr></table></figure><h2 id="flavor"><a href="#flavor" class="headerlink" title="flavor"></a>flavor</h2><p>查看一个变量的赋值方式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">flavor</span> variable)</span></span><br><span class="line"></span><br><span class="line">var2 = flavor function</span><br><span class="line">var3 := flavor funciton</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var1)</span>    <span class="comment"># undefined 未定义</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var2)</span>    <span class="comment"># recursive 递归展开赋值</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">flavor</span> var3)</span>    <span class="comment"># simple 简单赋值</span></span><br></pre></td></tr></table></figure><h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><p>可以将一段文本生成Makefile的内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">eval</span> text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> eval_target = </span><br><span class="line"><span class="section">eval:</span></span><br><span class="line">    @echo Target Eval Test</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">eval</span> <span class="variable">$(eval_target)</span>)</span></span><br></pre></td></tr></table></figure><p>以上，运行make时将会执行eval目标</p><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>用于执行Shell命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">files = <span class="variable">$(<span class="built_in">shell</span> ls *.cpp)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">shell</span> echo This is from <span class="built_in">shell</span> function)</span></span><br></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>将一个字符串序列中的项拆开放入多个变量中，并对各个变量进行操作（GNU make 4.4以上版本）</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(let var1 [var2 ...],[list],proc)</span></span><br><span class="line">        --- var 变量，可以有多个，用空格隔开</span><br><span class="line">        --- list 待处理字符串，各项之间空格隔开</span><br><span class="line">        --- proc 对变量进行的操作，结果为let的返回值</span><br><span class="line">            将list中的值依次一项一项放到var中，如果var的个数多于list项数，那多出来的var是空串。如果</span><br><span class="line">            var的个数小于list项数，则先依次把前而的项放入var中，剩下的list所有项都放入最后一个var中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list = a b c d</span><br><span class="line">letfirst = <span class="variable">$(let first second rest,<span class="variable">$(list)</span>,<span class="variable">$(first)</span>)</span></span><br><span class="line">letrest = <span class="variable">$(let first second rest,<span class="variable">$(list)</span>,<span class="variable">$(rest)</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合call可以对所有项进行递归处理</span></span><br><span class="line">reverse = <span class="variable">$(let first rest,$(1)</span>,<span class="variable">$(<span class="built_in">if</span> <span class="variable">$(rest)</span>,$(<span class="built_in">call</span> reverse,<span class="variable">$(rest)</span>)</span> )<span class="variable">$(first)</span>)</span><br><span class="line"><span class="section">all: ; @echo $(call reverse,d c b a)</span></span><br></pre></td></tr></table></figure><h2 id="信息提示函数"><a href="#信息提示函数" class="headerlink" title="信息提示函数"></a>信息提示函数</h2><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>提示错误信息并终止make执行</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> text)</span></span><br><span class="line">        --- text 提示信息</span><br><span class="line"></span><br><span class="line">EXIT_STATUS = -1</span><br><span class="line"><span class="keyword">ifneq</span> (0, <span class="variable">$(EXIT_STATUS)</span>)</span><br><span class="line">    <span class="variable">$(<span class="built_in">error</span> An <span class="built_in">error</span> occured! make stopped!)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h4 id="warning"><a href="#warning" class="headerlink" title="warning"></a>warning</h4><p>提示警告信息，make不会终止</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> text)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (0, <span class="variable">$(EXIT_STATUS)</span>)</span><br><span class="line">    <span class="variable">$(<span class="built_in">warning</span> This is a <span class="built_in">warning</span> message)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>输出一些信息</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(info text…)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(info 编译开始.......)</span></span><br><span class="line"><span class="variable">$(info 编译结束)</span></span><br></pre></td></tr></table></figure><h1 id="同一项目中有多个Makefile文件"><a href="#同一项目中有多个Makefile文件" class="headerlink" title="同一项目中有多个Makefile文件"></a>同一项目中有多个Makefile文件</h1><h2 id="包含其他makefile文件"><a href="#包含其他makefile文件" class="headerlink" title="包含其他makefile文件"></a>包含其他makefile文件</h2><p>使用<code>include</code>指令可以读入其他makefile文件的内容，效果就如同在include的位置用对应的文件内容替换一样。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> mkf1 mkf2 <span class="comment"># 可以引入多个文件，用空格隔开</span></span><br><span class="line"><span class="keyword">include</span> *.mk    <span class="comment"># 可以用通配符，表示引入所有以.mk结尾的文件</span></span><br></pre></td></tr></table></figure><p>如果找不到对应文件，则会报错，如果要忽略错误，可以在<code>include</code>前加<code>-</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> mkf1 mkf2</span><br></pre></td></tr></table></figure><h4 id="应用实例：自动生成依赖"><a href="#应用实例：自动生成依赖" class="headerlink" title="应用实例：自动生成依赖"></a>应用实例：自动生成依赖</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">objs = block.o command.o input.o main.o scene.o test.o</span><br><span class="line"></span><br><span class="line"><span class="section">sudoku: <span class="variable">$(objs)</span></span></span><br><span class="line">    g++ <span class="variable">$(objs)</span> -o sudoku</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> $(objs:%.o=%.d)</span><br><span class="line"></span><br><span class="line"><span class="section">%.d: %.cpp</span></span><br><span class="line">    @-rm <span class="variable">$@</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -MM  <span class="variable">$&lt;</span> &gt; <span class="variable">$@</span>.temp</span><br><span class="line">    @sed &#x27;s,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g&#x27; &lt; <span class="variable">$@</span>.temp &gt; <span class="variable">$@</span></span><br><span class="line">    @-rm <span class="variable">$@</span>.temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%.o : %.cpp</span><br><span class="line">    g++ -c <span class="variable">$&lt;</span></span><br><span class="line">    @echo <span class="variable">$^</span></span><br></pre></td></tr></table></figure><h2 id="嵌套make"><a href="#嵌套make" class="headerlink" title="嵌套make"></a>嵌套make</h2><p>如果将一个大项目分为许多小项目，则可以使用嵌套（递归）使用make。具体做法为，写一个总的Makefile，然后在每个子项目中都写一个Makefile，在总Makefile中进行调用。</p><p>例如，可以把sudoku项目中除main.cpp，test.cpp外的其他cpp存为一个子项目，编译为一个库文件，main.cpp test.cpp为另一个子项目，编译为.o然后链接库文件成可执行文件：</p><p>库文件Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS += -I../<span class="keyword">include</span> -fexec-charset=GBK -finput-charset=UTF-8</span><br><span class="line"></span><br><span class="line">cpps := <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">objs := $(cpps:%.cpp=%.o)</span><br><span class="line"></span><br><span class="line"><span class="section">libsudoku.a: <span class="variable">$(objs)</span></span></span><br><span class="line">    ar rcs <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objs)</span>: %.o : %.cpp %.h</span><br></pre></td></tr></table></figure><p>main.cpp test.cpp的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CXXFLAGS += -I../<span class="keyword">include</span> -fexec-charset=GBK -finput-charset=UTF-8</span><br><span class="line"><span class="keyword">vpath</span> %.h ../<span class="keyword">include</span></span><br><span class="line"><span class="keyword">vpath</span> %.a ../lib</span><br><span class="line"></span><br><span class="line"><span class="section">../sudoku: main.o test.o -lsudoku</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure><p>总的Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: subsrc</span></span><br><span class="line"></span><br><span class="line"><span class="section">subsrc: sublib</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C src</span><br><span class="line"></span><br><span class="line"><span class="section">sublib:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C lib</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm *.exe src/*.o lib/*.o lib/*.a </span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure><p>这一指令会自动进入subdir文件夹然后执行make。</p><p>可以通过<code>export</code>指令向子项目的make传递变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> var  <span class="comment"># 传递var</span></span><br><span class="line"><span class="keyword">export</span>         <span class="comment"># 传递所有变量</span></span><br><span class="line"><span class="keyword">unexport</span>    <span class="comment"># 取消传递</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell语法</title>
      <link href="/posts/4652f0c6.html"/>
      <url>/posts/4652f0c6.html</url>
      
        <content type="html"><![CDATA[<ul><li>shell函数例子     start()和stop()就是函数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Start logging</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">SYSLOGD_ARGS=-n</span><br><span class="line">KLOGD_ARGS=-n</span><br><span class="line">[ -r /etc/default/logging ] &amp;&amp; . /etc/default/logging</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">        printf &quot;Starting logging: &quot;</span><br><span class="line">        start-stop-daemon -b -S -q -m -p /var/run/syslogd.pid --exec /sbin/syslogd -- $SYSLOGD_ARGS</span><br><span class="line">        start-stop-daemon -b -S -q -m -p /var/run/klogd.pid --exec /sbin/klogd -- $KLOGD_ARGS</span><br><span class="line">        echo &quot;OK&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">        printf &quot;Stopping logging: &quot;</span><br><span class="line">        start-stop-daemon -K -q -p /var/run/syslogd.pid</span><br><span class="line">        start-stop-daemon -K -q -p /var/run/klogd.pid</span><br><span class="line">        echo &quot;OK&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in    #这里就是执行脚本的时候，后后面带的参数， 如果带了start参数就执行start函数  </span><br><span class="line">                               #$1就是取传入的第一个参数。$0是取脚本的名字（包括了路径）</span><br><span class="line">  start)</span><br><span class="line">        cat /etc/os-release</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">  restart|reload)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">  *)</span><br><span class="line">        echo &quot;Usage: $0 &#123;start|stop|restart&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>扩展<br>$PS1可以用来修改命令行的提示符。<br>$?可以用来获取一个函数的返回值，上一个命令的返回状态。</li></ul><h1 id="易错问题"><a href="#易错问题" class="headerlink" title="易错问题"></a>易错问题</h1><p> 判断，变量，各种语句之间尽量加上空格。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/posts/d04bd5bc.html"/>
      <url>/posts/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、操作系统概述"><a href="#1、操作系统概述" class="headerlink" title="1、操作系统概述"></a>1、操作系统概述</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>操作系统概念：操作系统是系统资源的管理者，是管理计算机硬件与软件资源的计算机程序。提供给用户和其他软件方便易用的接口和环境。最接近硬件的软件。</p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5.png"></p><p>例子<br>用qq和朋友视频聊天<br>step 1、在文件夹中找到qq安装位置（如d：&#x2F;qq） — 逐层打开文健夹<br>stpe 2、双击qq.exe  — 需要把程序相关数据放入内存<br>step 3、qq正常运行 —- 对应进程被处理机（cpu）处理<br>step 4、qq聊天  — 需要将摄像头分配给进程</p><p>补充：执行一个程序前，需要将该程序放入到内存中，才能被cpu处理</p><p>作为系统资源的管理者，主要提供以下功能： 1 、处理机管理 2、存储器管理 3、文健管理 4、设备管理<br>作为管理者向用户提供的接口：1、GUI图形管理界面 2、交互式命令接口 3、脱机批处理接口<br>作为管理者向应用软件提供接口： 1、系统调用接口<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5/1%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%91%E4%B8%8A%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1.png"></p><p>操作系统作为最接近硬件的层次对硬件机器进行了扩展：将cpu、硬盘、磁盘、内存等硬件资源进行协调配合。实现了很多复杂的功能。</p><h1 id="2、操作系统的特征"><a href="#2、操作系统的特征" class="headerlink" title="2、操作系统的特征"></a>2、操作系统的特征</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81.png"></p><ul><li>1、并发<br>微观上交替执行，宏观上同时运行。与并行区别是两个或者多个时间同一时间发生。容易混淆。</li></ul><p>重点：<br>单核cpu同一时刻，只能运行一个程序。各个程序只能并发的执行。<br>多核cpu同一时刻，可以运行多个程序。各个程序可以并发执行。</p><ul><li>2、共享<br>互斥共享方式：一个时间段内只允许一个进程访问该资源。<br>同时共享方式：允许同一个时间内多个进程同时对他进行访问。<br>所谓的同时共享往往是宏观上的，而微观上，有的进程可能是真的在进行同时共享，如扬声器被音乐和游戏同时占用。</li></ul><p>并发和共享互为存在条件。</p><ul><li><p>3、虚拟<br>虚拟技术：将一个物理实体，通过某种方式映射到多个逻辑实体上。<br>背景：gta5要4g内存，qq什么的要1g内存。电脑是4g内存，为什么还能够同时运行呢？<br>答：这就是虚拟储存器技术，实际的只有4g的内存。运用了虚拟技术中的“空分复用技术”<br>既然一个程序要分配cpu才能运行。那为什么单核cpu能够同时运行多个程序呢？<br>答：这是虚拟处理器技术，这就是虚拟技术中的“时间分片技术”。微观上处理机在各个微小时间内交替着为各个进程服务。</p></li><li><p>4、异步<br>异步是指进程以不阻碍其他进程的方式运行。由于资源有限，以不可预知的速度向前推进。</p></li></ul><h1 id="3、操作系统的发展与分类"><a href="#3、操作系统的发展与分类" class="headerlink" title="3、操作系统的发展与分类"></a>3、操作系统的发展与分类</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E7%B1%BB/3%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%88%86%E7%B1%BB.png"></p><h1 id="4、操作系统的运行机制"><a href="#4、操作系统的运行机制" class="headerlink" title="4、操作系统的运行机制"></a>4、操作系统的运行机制</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/4%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/4%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.png"><br>cpu有两种工作状态，用户态和内核态。<br>内核态只能运行内核代码，可以执行特权指令，用户态只能运行用户代码，只能执行非特权指令。</p><p>扩展：cpu中有一个寄存器叫做程序状态寄存器（psw）,其中有一个二进制位，1表示内核态，0表示用户态。</p><p>用户态、内核态的切换过程：<br>1、刚开机时，cpu处于内核态，此时运行的是操作系统代码。<br>2、开机完成后，cpu处于用户态，此时运行的是用户代码。<br>3、操作系统会在合适的时候让出cpu。让应用程序在cpu上运行。操作系统内核在让出cpu之前。会用一条特权指令把psw中的1变成0，进入用户态。<br>4、应用程序运行在用户态<br>5、此时，如果有人企图加入一条特权指令。破坏系统。<br>6、cpu接下来会发现要执行的指令是特权指令，此时又是在用户态<br>7、这个非法事件会引发一个中断信号—cpu检测到中断信号后，会立即变位内核态，并停止运行当前的应用程序。转而运行处理中断信号的内核程序<br>8、中断会使操作系统夺回cpu的控制权<br>9、操作系统会对引发的中断事件进行处理，处理完了再将cpu的使用权给应用程序</p><p>除了非法的使用特权指令之外，还有很多事件也会触发中断信号，但凡需要操作系统介入的地方，都会触发中断信号</p><h1 id="5、操作系统的中断和异常"><a href="#5、操作系统的中断和异常" class="headerlink" title="5、操作系统的中断和异常"></a>5、操作系统的中断和异常</h1><h2 id="5-1、中断的作用"><a href="#5-1、中断的作用" class="headerlink" title="5-1、中断的作用"></a>5-1、中断的作用</h2><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8/5-1%E3%80%81%E4%B8%AD%E6%96%AD%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>cpu上会运行两种程序，一种是操作系统内核程序，另一种是应用程序程序。<br>没有中断技术就没有并发，没有中断技术就没有系统。<br>中断是操作系统内核夺回cpu控制权的唯一途径。<br>内核态-&gt;用户态；执行一条特权指令–修改psw，让出cpu的控制权交给用户<br>用户态-&gt;内核态；由中断引发，硬件自动完成变态过程。</p><ul><li>中断的类型<br>内中断（异常）：由cpu执行指令引发的。<br>例子：1、试图在用户态下执行特权指令<br>2、执行除法指令发现除数为0<br>3、有时候想要执行一些内核服务，此时会执行一条特殊的指令，陷入内核，该指令会引发一个中断信号。</li></ul><p>外中断（中断）：由当前执行的指令无关，由外部设备引发的。<br>例子：1、时钟中断–时钟每走一次，就会引发一个中断信号，用来并行运行程序。<br>2、键盘中断–键盘每按下一个键，就会引发一个中断信号，用来并行运行程序。</p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8/5-1%E3%80%81%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB.png"></p><p>中断机制的基本原理</p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8/5-1%E3%80%81%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"></p><h2 id="5-2、系统调用"><a href="#5-2、系统调用" class="headerlink" title="5-2、系统调用"></a>5-2、系统调用</h2><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8/5-2%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>为什么要使用系统调用？<br>例程：假设打印店由两个人都点击了打印，两个进程没人管理，就会出现打印混乱。<br>而操作系统就是来管理这两个进程的。</p><p>系统调用分类(按功能)：设备管理、文件管理、进程管理、进程通讯、内存管理<br>扩展：可搜索linux系统调用有哪些</p><p>系统调用是怎么实现的，运行在用户态的程序在执行了某些系统调用的接口之后，会将后面携带的参数放到指定的寄存器中，最后指向一个陷入指令（psw），发生中断，陷入内核态。执行系统调用。通过第一个参数，就可以知道要进行那种类型的系统调用<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD%E6%96%AD%E5%BC%82%E5%B8%B8/5-2%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png"></p><h1 id="6、操作系统体系结构"><a href="#6、操作系统体系结构" class="headerlink" title="6、操作系统体系结构"></a>6、操作系统体系结构</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB/6%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"><br>原语：最小的不可再分的程序单元。是一种特殊的程序，处于系统的最底层，最接近硬件的部分，这种程序的运行具有原子性，不可被中断。运行时间较短，调用频繁。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8.png"><br>大内核：会对操作系统的性能产生影响。<br>注意：<br>操作系统内核运行在内核态，应用程序运行在用户态。</p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB/6%E3%80%81%E5%A4%A7%E5%86%85%E6%A0%B8%E5%92%8C%E5%BE%AE%E5%86%85%E6%A0%B8%E7%8A%B6%E6%80%81.png"></p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E4%BD%93%E7%B3%BB/6%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D.png"></p><h1 id="7、操作系统的引导boot"><a href="#7、操作系统的引导boot" class="headerlink" title="7、操作系统的引导boot"></a>7、操作系统的引导boot</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/7%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BCboot/7%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png"></p><h1 id="8、虚拟机"><a href="#8、虚拟机" class="headerlink" title="8、虚拟机"></a>8、虚拟机</h1><p>虚拟机就是让多个系统能够跑在同一个物理硬件上。需要硬件支持。<br>使用的是虚拟化的技术。需要虚拟机管理程序管理（vmm）,将硬件资源划给虚拟机。每个操作系统都有独立的资源。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA/8%E3%80%81%E4%B8%A4%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/8%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA/8%E3%80%81%E4%B8%A4%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AF%B9%E6%AF%94.png"></p><h1 id="9、操作系统进程"><a href="#9、操作系统进程" class="headerlink" title="9、操作系统进程"></a>9、操作系统进程</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90pcb.png"><br>在linux内核源码中，sched.h中定义了进程控制块的结构体:tast_struct</p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9%E3%80%81%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E6%88%90pcb.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"><br>上图中，值得注意的是，引入线程后，进程将不再是接受调度的基本单位。线程才是。</p><h2 id="9-1、进程的转换"><a href="#9-1、进程的转换" class="headerlink" title="9-1、进程的转换"></a>9-1、进程的转换</h2><p>进程创建的时，它的状态就是“创建态”，在这个阶段，操作系统会为它分配资源，初始化pcb。</p><p>当程序创建完成，会进入<code>就绪态</code>。但是这个时候没有空闲cpu，所以不会运行。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%B0%B1%E7%BB%AA%E6%80%81.png"><br>当一个进程被调度到cpu上运行，此时会进入<code>运行态</code>。<br>如果这个进程要请求使用某个设备，而这个设备被其他进程占用了，此时这个进程会进入<code>阻塞态</code>。<br>当这个设备空闲下来，此时会进入<code>就绪态</code>。给进程分配这个设备。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%E6%80%81.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BD%AC%E5%8C%96.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%9E%E9%A1%BE.png"><br>操作系统对进程的组织有两种方式，一种是链接表，一种是索引表。<br>一般的操作系统使用的是链式表。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-1%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F.png"></p><h2 id="9-2、进程控制"><a href="#9-2、进程控制" class="headerlink" title="9-2、进程控制"></a>9-2、进程控制</h2><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%B1%82%E6%AC%A1.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E5%8E%9F%E8%AF%AD.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%8E%9F%E8%AF%AD.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E5%8E%9F%E8%AF%AD.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD.png"></p><p>处理机：运行指令的实体，可以是cpu也可以是其他硬件。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%9A%84.png"><br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-2%E3%80%81%E7%A8%8B%E5%BA%8F%E5%88%87%E6%8D%A2%E5%8E%9F%E8%AF%AD.png"></p><h2 id="9-3、进程通信"><a href="#9-3、进程通信" class="headerlink" title="9-3、进程通信"></a>9-3、进程通信</h2><p>进程通信需要操作系统的支持。<br>原因：进程是分配资源的基本单位，为了保证各个进程之间不会互相影响。只能访问自己的内存空间和资源。</p><p>进程通信的方式：主要三种：管道、共享存储、消息通信</p><ul><li><p>共享存储：在内存中划出一块区域，多个进程都可以访问。如linux，使用int shm_open()创建共享内存。<br>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);将共享内存映射到自己的进程的地址空间。<br>这个时候，内存中会出现一个“段表项”，除开栈，堆外的新增区域。对这个内存区域访问需要加锁，防止冲突。<br>共享存贮有两种办法：<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-3%E3%80%81%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png"></p></li><li><p>消息通信：进程之间通过操作系统提供的消息传递机制来实现数据交换。有原语控制<br>消息主要由消息头和消息体组成。消息头中包含消息长度、进程id，消息体中包含消息内容。<br>消息传递两种方式：直接通信方式和间接通信方式。<br>直接通信方式：直接将消息发送给目标进程。指明id<br>间接通信方式：将消息发送到某个中间实体中，然后目标进程从这个中间实体中取出消息。<br>直接通信由内核控制的进程pcb中有一个消息队列。所有收到的消息都会放在这个队列中。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-3%E3%80%81%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E4%B8%AD%E7%9A%84%E7%9B%B4%E6%8E%A5%E9%80%9A%E4%BF%A1.png"></p></li></ul><p>间接通信方式：将消息发送到某个中间实体中，然后目标进程从这个中间实体中取出消息。就是会创建一个信箱。一个进程可以创建多个信箱。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-3%E3%80%81%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E4%B8%AD%E7%9A%84%E9%97%B4%E6%8E%A5%E6%96%B9%E5%BC%8F.png"></p><ul><li>管道通信：管道是是单向的，只能由一个进程向管道中写入数据，只能由管道中的另一个进程读取数据。就是一个循环队列。本质就是内存缓冲区。<br>和共享内存相比，区别是不能进行自由操作。是先写的先读。<br><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-3%E3%80%81%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png"></li></ul><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/9%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B/9-3%E3%80%81%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE.png"></p><h1 id="10、线程"><a href="#10、线程" class="headerlink" title="10、线程"></a>10、线程</h1><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10%E3%80%81%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%89%B9%E7%82%B9.png"></p><p>1、线程的管理由操作系统完成。<br>2、线程切换需要cpu变态切换。</p><p><img src="./../../../../img/0_%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10%E3%80%81%E7%BA%BF%E7%A8%8B/10%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E4%B8%8E%E6%8E%A7%E5%88%B6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 通用技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>kernel移植（linux5.1571移植）</title>
      <link href="/posts/ec914a40.html"/>
      <url>/posts/ec914a40.html</url>
      
        <content type="html"><![CDATA[<p>移植版本5.1571</p><h1 id="1、拿到源码编译测试"><a href="#1、拿到源码编译测试" class="headerlink" title="1、拿到源码编译测试"></a>1、拿到源码编译测试</h1><ul><li>1、下载源码</li><li>2、编译<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">path=&quot;/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin&quot;</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125;/arm-none-linux-gnueabihf- distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125;/arm-none-linux-gnueabihf- imx_v7_defconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125;/arm-none-linux-gnueabihf- menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125;/arm-none-linux-gnueabihf- all -j16</span><br></pre></td></tr></table></figure>测试编译。链接文件在arch&#x2F;arm&#x2F;kernel&#x2F;vmlinux.lds中。</li></ul><h1 id="2、添加开发版的默认配置"><a href="#2、添加开发版的默认配置" class="headerlink" title="2、添加开发版的默认配置"></a>2、添加开发版的默认配置</h1><h2 id="2-1、修改配置文件"><a href="#2-1、修改配置文件" class="headerlink" title="2.1、修改配置文件"></a>2.1、修改配置文件</h2><p>在arch&#x2F;arm&#x2F;crosstool&#x2F;目录下，找到文件：<br>imx_v7_defconfig，imx_v7_defconfig是这款芯片的配置文件。<br>改个名字，改成自己的名字，比如：imx_v7_naro_defconfig。</p><h2 id="2-2、添加自己板子的设备树"><a href="#2-2、添加自己板子的设备树" class="headerlink" title="2.2、添加自己板子的设备树"></a>2.2、添加自己板子的设备树</h2><p>编译linux的时候会编译出很多的设备树，在arch&#x2F;arm&#x2F;boot&#x2F;dts目录下。<br>查看makefile，找到：里面全部是参与编译的dts文件。<br>找到imx6ull-14x14-evk.dts，这个是官方给的设备树。<br>复制一份，改成自己的名字，比如：imx6ull-14x14-naro-evk.dts。<br>同时，在makefile中，将imx6ull-14x14-evk.dts改成自己的名字，比如：imx6ull-14x14-naro-evk.dts。或者加上一条也行。<br><img src="../../../../img/3_%E9%A9%B1%E5%8A%A8%E3%80%81bootleader%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/kernel%E7%A7%BB%E6%A4%8D/2%E3%80%81%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84makefile%E6%B7%BB%E5%8A%A0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>rootfs移植（rootfs移植）</title>
      <link href="/posts/cdd095c3.html"/>
      <url>/posts/cdd095c3.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、下载源码，官网下载"><a href="#1、下载源码，官网下载" class="headerlink" title="1、下载源码，官网下载"></a>1、下载源码，官网下载</h1><p>比较简单，略</p><h2 id="1-1、添加中文支持"><a href="#1-1、添加中文支持" class="headerlink" title="1-1、添加中文支持"></a>1-1、添加中文支持</h2><p>printable_string.c中<br>将下面删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &gt;= <span class="number">0x7f</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>往下找<br>下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span> || c &gt;= <span class="number">0x7f</span>)</span><br><span class="line">*d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">d++;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">*d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">d++;    </span><br></pre></td></tr></table></figure><p>unicode.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *d++ = (c &gt;= &#x27; &#x27; &amp;&amp; c &lt; 0x7f) ? c : &#x27;?&#x27;; */</span></span><br><span class="line">*d++ = (c &gt;= <span class="string">&#x27; &#x27;</span>) ? c : <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">src++;</span><br></pre></td></tr></table></figure><p>下面还有一个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* if (c &lt; &#x27; &#x27; || c &gt;= 0x7f) */</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">*d = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">d++;</span><br></pre></td></tr></table></figure><h1 id="2、编译源码"><a href="#2、编译源码" class="headerlink" title="2、编译源码"></a>2、编译源码</h1><p>makefie文件在源码目录下，修改makefie文件，指定交叉编译器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE ?= 指定编译器地址</span><br><span class="line">ARCH ?= arm</span><br></pre></td></tr></table></figure><p>或者脚本编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">path=&quot;/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin&quot;</span><br><span class="line">export &quot;CC=gcc CROSS_COMPILE=$&#123;path&#125;/arm-none-linux-gnueabihf-&quot;</span><br><span class="line">export </span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><h1 id="3、添加中文支持"><a href="#3、添加中文支持" class="headerlink" title="3、添加中文支持"></a>3、添加中文支持</h1><p>查看1.1：<br>&#x2F;libbb&#x2F;printable_string.c下<br>函数 printable_string<br>将关于0x7f的判断去掉<br>接着将ibbb&#x2F;unicode.c中<br>在unicode_conv_to_printable2函数中<br>将关于0x7f的判断去掉</p><h1 id="4、修改配置"><a href="#4、修改配置" class="headerlink" title="4、修改配置"></a>4、修改配置</h1><h2 id="4-1、先默认配置"><a href="#4-1、先默认配置" class="headerlink" title="4-1、先默认配置"></a>4-1、先默认配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure><h2 id="4-2、打开图形配置界面"><a href="#4-2、打开图形配置界面" class="headerlink" title="4-2、打开图形配置界面"></a>4-2、打开图形配置界面</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>4-3、选择编译的方式</p><ul><li><p>这里需要选择动态编译，选择静态编译的话DNS会出现问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Location:</span><br><span class="line">-&gt; Settings       </span><br><span class="line">    -&gt; Build static binary (no shared libs) 不要选</span><br></pre></td></tr></table></figure></li><li><p>允许使用vi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location :</span><br><span class="line">-&gt; Setting</span><br><span class="line">    -&gt; vi-style line editing commands</span><br></pre></td></tr></table></figure></li><li><p>简化驱动加载，这个要取消</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Location :</span><br><span class="line">-&gt; linux Module Utilities</span><br><span class="line">    -&gt;Simplified modules</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将mdev工具全部打开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Location :</span><br><span class="line">-&gt;Linux System Utilities</span><br><span class="line">    -&gt;mdev(16kb)</span><br><span class="line">    包括子项全部打开</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使能busybox的unicode编码以支持中文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Location :</span><br><span class="line">-&gt;Settings</span><br><span class="line">    -&gt;support unicode</span><br><span class="line">    -&gt;Check $LC_ALL,$LANG, $LC_CTYPE environment variables</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"></span><br><span class="line">make install CONFIG_PREFIX=/home/ygc/Desktop/project/nfs/rootfs</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>生成了rootfs下几个文件bin sbin usr linuxr,linux内核的lnit进程会去查找用户空间的init程序，找到以后会运行这用户空间init程序，从而切换到用户态，如果bootargs设置了init&#x3D;&#x2F;linuxrc，那么linuxrc就是可以作为用户空间的init程序，所以用户空间的init程序是busybox来生成的</p><h1 id="5、想rootfs下-lib目录库文件"><a href="#5、想rootfs下-lib目录库文件" class="headerlink" title="5、想rootfs下&#x2F;lib目录库文件"></a>5、想rootfs下&#x2F;lib目录库文件</h1><ul><li>1、创建&#x2F;lib目录和&#x2F;usr&#x2F;lib目录<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir lib</span><br></pre></td></tr></table></figure></li><li>2、将交叉编译器中的库文件都复制过来<br>进入编译工具工具链下的libc&#x2F;lib和lib目录下，将lib下的所有文件复制到rootfs&#x2F;lib目录下,如果有链接文件，要把被链接文件也复制过去。</li></ul><p>&#x2F;usr&#x2F;lib文件在工具链的libc&#x2F;usr&#x2F;lib目录下，复制到rootfs&#x2F;usr&#x2F;lib目录下。</p><h1 id="6、完成创建其他的文件"><a href="#6、完成创建其他的文件" class="headerlink" title="6、完成创建其他的文件"></a>6、完成创建其他的文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir dev proc mnt sys tmp root etc</span><br></pre></td></tr></table></figure><ul><li><p>在rootfs目录下创建etc&#x2F;init.d&#x2F;rcS文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH</span><br><span class="line">LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib</span><br><span class="line">export PATH LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure></li><li><p>创建&#x2F;etc&#x2F;fstab文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#&lt;file system&gt;   &lt;mount point&gt;     &lt;type&gt;       &lt;options&gt;       &lt;dump&gt;          &lt;pass&gt;</span><br><span class="line">proc            /proc              proc         defaults        0               0</span><br><span class="line">tmpfs           /tmp               tmpfs        defaults        0               0</span><br><span class="line">sysfs           /sys               sysfs        defaults        0               0</span><br></pre></td></tr></table></figure></li><li><p>创建&#x2F;etc&#x2F;inittab文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#etc/inittab</span><br><span class="line"></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line">::restart:/sbin/init</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure></li></ul><h1 id="7、设置环境变量，挂在根文件系统"><a href="#7、设置环境变量，挂在根文件系统" class="headerlink" title="7、设置环境变量，挂在根文件系统"></a>7、设置环境变量，挂在根文件系统</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.8.9:/home/ygc/Desktop/project/nfs/rootfs,proto=tcp rw ip=192.168.8.120:192.168.8.9:192.168.8.1:255.255.255.0::eth0:off&#x27;</span><br><span class="line"></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linuxCpp</title>
      <link href="/posts/6f1ca842.html"/>
      <url>/posts/6f1ca842.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、c-对c的扩展"><a href="#1、c-对c的扩展" class="headerlink" title="1、c++对c的扩展"></a>1、c++对c的扩展</h1><h2 id="1-1、冒号作用域"><a href="#1-1、冒号作用域" class="headerlink" title="1-1、冒号作用域"></a>1-1、冒号作用域</h2><pre><code>:: 运算符是一个作用域,::代表是全局作用域。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//输出局部变量a</span></span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl;<span class="comment">//输出全局变量a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">test01</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2、名字控制"><a href="#1-2、名字控制" class="headerlink" title="1-2、名字控制"></a>1-2、名字控制</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello namespace &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">( <span class="type">int</span> agr )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">obj</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::foo</span> <span class="params">( <span class="type">int</span> arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; arg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间是可以取别名的</span></span><br><span class="line"><span class="keyword">namespace</span> newA = A;</span><br><span class="line"><span class="keyword">namespace</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> C</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">namespace</span> D</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意: 如果命名空间没有名字 name这个命名空间内的所有成员都被编译器加上了static修饰,//只能被当前文件调用 这个属于内部链接属性</span></span><br><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::<span class="built_in">foo</span> ( <span class="number">222</span> );</span><br><span class="line">    newA::<span class="built_in">foo</span> ( <span class="number">333</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; C::a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; C::D::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; B::b &lt;&lt; endl;</span><br><span class="line">    A::<span class="built_in">fun</span> ( );</span><br><span class="line">    cout &lt;&lt; B::c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test03</span> ( );</span><br><span class="line">    <span class="built_in">test02</span> ( );</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3、全局变量检测增强"><a href="#1-3、全局变量检测增强" class="headerlink" title="1-3、全局变量检测增强"></a>1-3、全局变量检测增强</h2><p>c++的编译器对于全局变量的声明和定义有严格的区分,检测会增强              </p><p>c语言下的全局变量的声明和定义        </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//定义</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//声明</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//声明</span></span><br></pre></td></tr></table></figure><p>c++下全局变量声明和定义     </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a;<span class="comment">//定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a ; <span class="comment">//声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a; <span class="comment">//声明</span></span><br></pre></td></tr></table></figure><p>c+++ 定义为如下将报错    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><h2 id="1-4、更严格的类型转换检测"><a href="#1-4、更严格的类型转换检测" class="headerlink" title="1-4、更严格的类型转换检测"></a>1-4、更严格的类型转换检测</h2><p>比如malloc()申请的内存一定要做强转。     </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p =(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="1-5、struct类型增强"><a href="#1-5、struct类型增强" class="headerlink" title="1-5、struct类型增强"></a>1-5、struct类型增强</h2><p>在c++中使用结构体类型时，可以不写struct关键字，定义的时候要写。</p><h2 id="1-6、三目运算符有所不同"><a href="#1-6、三目运算符有所不同" class="headerlink" title="1-6、三目运算符有所不同"></a>1-6、三目运算符有所不同</h2><p>在c++中可以返回变量。而c++常量返回常量    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span> ( <span class="string">&quot;%d\n&quot;</span> , a &lt; b ? a : b );</span><br><span class="line">    <span class="comment">//在c语言中三目运算符返回的是表达式的值，是一个常量</span></span><br><span class="line">    <span class="comment">//( a &lt; b ? a : b) = 100; //c++可以正常编译。</span></span><br><span class="line">    *( a &lt; b ? &amp;a : &amp;b ) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-7、c-c-中const"><a href="#1-7、c-c-中const" class="headerlink" title="1-7、c&#x2F;c++中const"></a>1-7、c&#x2F;c++中const</h2><h3 id="1-7-1、const概述"><a href="#1-7-1、const概述" class="headerlink" title="1-7-1、const概述"></a>1-7-1、const概述</h3><p>const修饰的对象为一个常量。不能被改变。   </p><h3 id="1-7-2、c-c-中const的区别"><a href="#1-7-2、c-c-中const的区别" class="headerlink" title="1-7-2、c&#x2F;c++中const的区别"></a>1-7-2、c&#x2F;c++中const的区别</h3><h4 id="1-7-2-1、c语言中的const"><a href="#1-7-2-1、c语言中的const" class="headerlink" title="1-7-2-1、c语言中的const"></a>1-7-2-1、c语言中的const</h4><p>1 const修饰的局部变量,存在栈区,虽然不能通过const修饰的变量去修改栈区内容,但是可以<br>通过地址去修改const修饰的<br>2 const修饰的全局变量是保存在常量区,不能通过变量名去修改.也不能通过地址去修改<br>3 const修饰的全局变量,如果其他文件想使用,直接extern声明外部可用即可   </p><h4 id="1-7-2-2、c-中的const"><a href="#1-7-2-2、c-中的const" class="headerlink" title="1-7-2-2、c++中的const"></a>1-7-2-2、c++中的const</h4><p>1 const修饰的局部变量赋值常量时,局部变量保存在符号表中,修改不了,是一个常量<br>2  const修饰的全局变量保存在常量区,不能被修改<br>3 const修饰的全局变量默认是内部链接属性,加上extern修饰变成外部链接属性</p><h4 id="1-7-2-3、相同的点"><a href="#1-7-2-3、相同的点" class="headerlink" title="1-7-2-3、相同的点:"></a>1-7-2-3、相同的点:</h4><p>c和c++中的const修饰的全局变量都是保存在常量区,不能被修改            </p><h4 id="1-7-2-4、不同的点"><a href="#1-7-2-4、不同的点" class="headerlink" title="1-7-2-4、不同的点:"></a>1-7-2-4、不同的点:</h4><p>c语言中const修饰的局部变量赋值为常量时,,局部变量保存在栈区,可以被指针修<br>改<br>c++中,const修饰的局部变量赋值为常量时,局部变量保存符号表中,不能被修改<br>c语言中const修饰的全局变量默认是外部链接属性<br>c++语言中const修饰的全局变量默认是内部链接属性<br>c++中const修饰的变量,分配内存情况<br>const修饰的全局变量在常量区分配了内存<br>对const修饰的局部变量赋值为常量时,对其取地址,会在栈区分配临时的内存空间<br>const修饰的局部变量赋值为变量时,局部变量保存在栈区<br>const修饰的局部变量时一个自定义变量,也是在栈区分配内存<br>只有一种情况,const’修饰的局部变量被赋值为常量时,这个局部变量保存在符号表中    </p><h4 id="1-7-2-5、尽量以const替换define"><a href="#1-7-2-5、尽量以const替换define" class="headerlink" title="1-7-2-5、尽量以const替换define"></a>1-7-2-5、尽量以const替换define</h4><p>有两点原因:</p><ol><li>const修饰的全局变量或const修饰的局部变量赋值为常量,是有类型的,而define的<br>宏没有 类型</li><li>const修饰的全局变量或const修饰的局部变量赋值为常量有作用域的,而define的<br>宏没有作用域</li></ol><h3 id="1-7-2-6、引用的用法"><a href="#1-7-2-6、引用的用法" class="headerlink" title="1-7-2-6、引用的用法"></a>1-7-2-6、引用的用法</h3><p>注意事项：   </p><ul><li>1、应用一旦初始化，就不可以更改引用指向  </li><li>2、引用定义的时候必须要初始化  </li><li>3、原类型 &amp;别名 &#x3D; 旧名  引用的实质就职取别名</li><li>4、引用不能使用NULL</li><li>5、引用可以引用任意类型包括数组</li><li>6、&amp;在等号的左边是引用，在等号的右边是取地址</li><li>7、引用可以作为函数形参</li><li>8、不能返回局部变量的引用</li><li>9、引用的本质是一个指针常量</li><li>10、</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">引用的本质是一个指针常量</span><br><span class="line">type &amp;b = a;</span><br><span class="line"> 编译器底层这么实现的:</span><br><span class="line">type *<span class="type">const</span> b = &amp;a;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><ul><li>11、指针的引用<br>套用引用公式：type &amp;q&#x3D;p<br>假设：type为指针类型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">(<span class="type">int</span>* &amp;q)</span> <span class="comment">// int* &amp;q = p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="built_in">fun</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>12、常量引用<br>const type &amp;p&#x3D;q;<br>常量引用代表不能通过引用取修改引用标示的那块空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">10</span>;   </span><br><span class="line"> <span class="comment">// const 修饰的是引用&amp; 不能通过引用去修改引用的这块空间的内容</span></span><br><span class="line"> <span class="type">const</span> <span class="type">int</span> &amp;b= a;</span><br><span class="line"><span class="comment">//b=1000;//err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int b&amp; = 100;//不能应用常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = a;</span><br><span class="line"><span class="comment">//b=1000;//err</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-8、内联函数"><a href="#1-8、内联函数" class="headerlink" title="1-8、内联函数"></a>1-8、内联函数</h2><ul><li>1、为什么要有内联函数<br> 第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。<br> 第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作<br>类类的成员函数。<br>内联函数就是继承了宏函数的高效,并且不会出错,还可以当成类的成员函数用  </li><li>2、宏函数和内联函数的区别<br>宏函数的替换是发生在预处理阶段<br>内联函数的替换是发生在编译阶段<br>宏函数容易出错,内联函数不会<br>内联函数和宏函数一样,都省去了调用函数的开销</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define myadd(a,b) a+b</span><br><span class="line">inline int myadd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;J</span><br><span class="line">&#125;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    //int c= myadd (a,b)*5;//a+b*5 替换发生在预处理阶段</span><br><span class="line">    int c = myadd(a,b)*5;//(a+b)*5替换发生在编译阶段 也和宏函数一样不会有函数调用的开销</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在c++中，预定义宏的概念是用内联函数来实现的，而内联函数本身也是一个真正的函数。<br>内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏<br>一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。<br>在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数。但是必须注意必须<br>函数体和声明结合在一起，否则编译器将它作为普通函数来对待。<br><code>inline void func(int a);</code><br>以上写法没有任何效果，仅仅是声明函数，应该如下方式来做:<br><code>inline int func(int a)&#123;return ++;&#125; </code><br>注意: 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些事预<br>处理器无法完成的。<br>内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压<br>栈，跳转，返回的开销。我们可以理解为内联函数是以空间换时间。        </p><h3 id="1-8-1、类的成员函数默认编译器会将它做成内联函数"><a href="#1-8-1、类的成员函数默认编译器会将它做成内联函数" class="headerlink" title="1-8-1、类的成员函数默认编译器会将它做成内联函数"></a>1-8-1、类的成员函数默认编译器会将它做成内联函数</h3><p>任何在类内部定义的函数自动成为内联函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 class Person&#123;</span><br><span class="line">2 public:</span><br><span class="line">3 Person()&#123; cout &lt;&lt; &quot;构造函数!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">4 void PrintPerson()&#123; cout &lt;&lt; &quot;输出Person!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">5 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-8-2、内联函数和编译器"><a href="#1-8-2、内联函数和编译器" class="headerlink" title="1-8-2、内联函数和编译器"></a>1-8-2、内联函数和编译器</h4><p>内联函数并不是何时何地都有效，为了理解内联函数何时有效，应该要知道编译器碰到内联<br>函数会怎么处理？<br>对于任何类型的函数，编译器会将函数类型(包括函数名字，参数类型，返回值类型)放入到<br>符号表中。同样，当编译器看到内联函数，并且对内联函数体进行分析没有发现错误时，也<br>会将内联函数放入符号表。<br>当调用一个内联函数的时候，编译器首先确保传入参数类型是正确匹配的，或者如果类型不<br>正完全匹配，但是可以将其转换为正确类型，并且返回值在目标表达式里匹配正确类型，或<br>者可以转换为目标类型，内联函数就会直接替换函数调用，这就消除了函数调用的开销。假<br>如内联函数是成员函数，对象this指针也会被放入合适位置。<br>类型检查和类型转换、包括在合适位置放入对象this指针这些都是预处理器不能完成的。<br>但是c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译。<br><code>不能存在任何形式的循环语句</code><br> <code>不能存在过多的条件判断语句</code><br> <code>函数体不能过于庞大</code><br> <code>不能对函数进行取址操作</code><br> 内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为<br>内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</p><h2 id="1-9、函数的默认参数"><a href="#1-9、函数的默认参数" class="headerlink" title="1-9、函数的默认参数"></a>1-9、函数的默认参数</h2><p>c++中的函数,形参可以设置默认参数,设置时需要注意以下几点:    </p><ul><li>设置默认参数时,某个参数设置了默认参数,从这个参数开始,后面的每一个都要设置。        </li><li>函数的声明和定义处设置默认参数只能一处设置  </li><li>有实参传入则使用实参,实参没有传入使用默认参数       <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//void fun01(int a = 1, int b = 2);</span></span><br><span class="line"><span class="comment">//默认参数 在设置时 声明和定义只能一处设置默认参数</span></span><br><span class="line"><span class="comment">//设置默认参数时 有一个参数设置了默认参数,从这个参数往后的每一个参数都要设置默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun01</span><span class="params">(<span class="type">int</span> a=<span class="number">1</span>,<span class="type">int</span> b=<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">fun01</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">fun01</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">fun01</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">fun01</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">fun01</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="1-10、占位参数"><a href="#1-10、占位参数" class="headerlink" title="1-10、占位参数"></a>1-10、占位参数</h2><p>占位参数给函数形参设置的,调用时需要传参,也可以设置占位参数为默认参数;<br>占位参数在符号重载++时会用到        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>=<span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">fun</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">fun</span>(<span class="number">2</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="1-11、函数的重载"><a href="#1-11、函数的重载" class="headerlink" title="1-11、函数的重载"></a>1-11、函数的重载</h2><ul><li>1、函数的重载<br>在c++中函数的名字是刻印重名的,也就是可以有多个相同函数名的函数存在,<br>重载: 名字相同,意义不一样   </li><li>2、函数重载的条件<br>实现函数重载的条件：<br> 同一个作用域<br> 参数个数不同<br> 参数类型不同<br> 参数顺序不同<br> 函数的返回值不能成为函数重载的条件<br> 默认参数作为函数重载的条件可能发生二义性</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名一样 意义 不一样</span></span><br><span class="line"><span class="comment">//函数的重载发送必须在同一个作用域</span></span><br><span class="line"><span class="comment">//参数的个数不一样可以发送函数的重载</span></span><br><span class="line"><span class="comment">//参数 的类型不一样可以发生函数的重载</span></span><br><span class="line"><span class="comment">//参数的顺序不一样可以发生函数的重载</span></span><br><span class="line"><span class="comment">//返回值不能作为函数重载的条件</span></span><br><span class="line"><span class="comment">//默认参数作为函数重载的条件需要注意二义性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot; fun(double a, int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">( <span class="type">int</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot; void fun( int a, double b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot; void fun(double a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;void fun(int a) &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int fun(int a)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;void fun(int a) &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;void fun(int a,int b) &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//void fun(int a, int b=2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;void fun(int a,int b) &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">fun</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">fun</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">fun</span>(<span class="number">3.14</span>);</span><br><span class="line"> <span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">3.14</span>);</span><br><span class="line"> <span class="built_in">fun</span>(<span class="number">3.14</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译器为了实现函数重载，也是默认为我们做了一些幕后的工作，编译器用不同的参数类型<br>来修饰不同的函数名，比如void func(); 编译器可能会将函数名修饰成func，当编译器碰到<br>void func(int x),编译器可能将函数名修饰为funcint,当编译器碰到void func(int x,char c),编译器<br>可能会将函数名修饰为funcintchar我这里使用”可能”这个字眼是因为编译器如何修饰重载<br>的函数名称并没有一个统一的标准，所以不同的编译器可能会产生不同的内部名。<br>void func(){}<br>void func(int x){}<br>void func(int x,char y){}<br> 以上三个函数在linux下生成的编译之后的函数名为:<br>_Z4funcv &#x2F;&#x2F;v 代表void,无参数<br>_Z4funci &#x2F;&#x2F;i 代表参数为int类型<br>_Z4funcic &#x2F;&#x2F;i 代表第一个参数为int类型，第二个参数为char类型     </p><h2 id="1-12、extern-“c”浅析"><a href="#1-12、extern-“c”浅析" class="headerlink" title="1-12、extern “c”浅析"></a>1-12、extern “c”浅析</h2><p>c++编辑器编译.c的函数时,需要声明为 extern “C”<br>main.cpp            </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> cout &lt;&lt; <span class="title">myadd</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span> &lt;&lt; endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>test.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">myadd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">myadd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2、类和对象"><a href="#2、类和对象" class="headerlink" title="2、类和对象"></a>2、类和对象</h1><h2 id="2-1、c和c-中struct的区别"><a href="#2-1、c和c-中struct的区别" class="headerlink" title="2-1、c和c++中struct的区别"></a>2-1、c和c++中struct的区别</h2><ul><li>c语言中结构体中不能存放函数,也就是数据(属性)和行为(方<br>法)是分离的</li><li>c++中结构体中是可以存放函数的,也就是数据(属性)和行为<br>(方法)是封装在一起的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//c语言中 不能放函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_stu</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c++中 可以放函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_stu1</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print_stu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//学生的属性和数据</span></span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line"> <span class="type">int</span> id;</span><br><span class="line"> <span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line"> <span class="comment">//操作属性的叫做 方法或行为‐函数</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> cout &lt;&lt; age &lt;&lt; id &lt;&lt; name &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> student obj;</span><br><span class="line"> obj.age = <span class="number">10</span>;</span><br><span class="line"> obj.id = <span class="number">20</span>;</span><br><span class="line"> <span class="built_in">strcpy</span>(obj.name,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"> obj.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2、C语言中表示事物的方法存在的问题"><a href="#2-2、C语言中表示事物的方法存在的问题" class="headerlink" title="2-2、C语言中表示事物的方法存在的问题"></a>2-2、C语言中表示事物的方法存在的问题</h2><p>c语言中表示事物时,将属性和行为分离,有可能行为调用出错   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//表示人</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line"> <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person_eat</span><span class="params">(<span class="keyword">struct</span> Person *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s 在吃饭\n&quot;</span>,p‐&gt;name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//表示dog</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Dog_eat</span><span class="params">(<span class="keyword">struct</span> Dog *p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s 在吃粑粑\n&quot;</span>, p‐&gt;name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Person</span> p1;</span><br><span class="line">  p1.age = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(p1.name,<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">  <span class="built_in">Person_eat</span>(&amp;p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Dog</span> d1;</span><br><span class="line">  d1.age = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(d1.name,<span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">  <span class="built_in">Dog_eat</span>(&amp;d1);</span><br><span class="line">  <span class="built_in">Dog_eat</span>(&amp;p1);<span class="comment">//人 调用了狗的行为</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3、c-中对事物的封装-类"><a href="#2-3、c-中对事物的封装-类" class="headerlink" title="2-3、c++中对事物的封装-类"></a>2-3、c++中对事物的封装-类</h2><ul><li>c++将事物的属性和行为封装在一起</li><li>类和结构体的一个区别在于,类对成员可以进行访问的权限控<br>制,结构体不可以</li><li>类 &#x3D; 类型 (事物的行为和属性)   类实例化出来的变量叫对象</li><li>类中的函数 可以访问类里面的成员</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//c++中对事物的封装 将属性和行为封装在一起</span></span><br><span class="line"><span class="comment">//类 将事物抽象成属性和行为,并且封装在一起</span></span><br><span class="line"><span class="comment">//结构体中所有成员默认都是公有的 类中的所有成员默认是私有的,也可以修改成员的访问权限</span></span><br><span class="line"><span class="comment">// struct Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:<span class="comment">//公有的</span></span><br><span class="line">  <span class="comment">//类中的所有成员 访问的权限都是私有的 private</span></span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Person_eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s 吃饭\n&quot;</span>,name);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Dog</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Dog_eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s 吃粑粑\n&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//通过类 实例化出一个变量 这个变量叫对象</span></span><br><span class="line">  Person p1;</span><br><span class="line">  p1.age = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(p1.name, <span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">  p1.<span class="built_in">Person_eat</span>();</span><br><span class="line"></span><br><span class="line">  Dog d1;</span><br><span class="line">  d1.age == <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(d1.name,<span class="string">&quot;旺财&quot;</span>);</span><br><span class="line">  d1.<span class="built_in">Dog_eat</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、类中的成员权限"><a href="#2-4、类中的成员权限" class="headerlink" title="2-4、类中的成员权限"></a>2-4、类中的成员权限</h2><table><thead><tr><th align="center">访问属性</th><th align="center">属性</th><th align="center">对象内部</th><th align="left">对象外部</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">公有</td><td align="center">可访问</td><td align="left">可访问</td></tr><tr><td align="center">protected</td><td align="center">保护</td><td align="center">可访问</td><td align="left">不可访问</td></tr><tr><td align="center">privata</td><td align="center">私有</td><td align="center">可访问</td><td align="left">不可访问</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有的 类内类外都可访问</span></span><br><span class="line"> <span class="type">int</span> mTall; <span class="comment">//多高，可以让外人知道</span></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">// 保护的 类外不可访问 类内是可以访问的 子类可以访问</span></span><br><span class="line">  <span class="type">int</span> mMoney; <span class="comment">// 有多少钱,只能儿子孙子知道</span></span><br><span class="line"> <span class="keyword">private</span>: <span class="comment">//私有的 类外不可访问 类内是可以访问的 子类不可访问</span></span><br><span class="line">  <span class="type">int</span> mAge; <span class="comment">//年龄，不想让外人知道</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  cout &lt;&lt; mTall &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; mMoney &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; mAge &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  person p;</span><br><span class="line">  p.mTall = <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-5、尽量设置成员变量为私有权限"><a href="#2-5、尽量设置成员变量为私有权限" class="headerlink" title="2-5、尽量设置成员变量为私有权限"></a>2-5、尽量设置成员变量为私有权限</h2><p>设置成员变量为私有，有点：   </p><ul><li>对变量的设置时的控制</li><li>可以给变量设置只读权限</li><li>可以给变量设置只写权限</li><li>可以给变量设置可读可写权限</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccessLevels</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//对只读属性进行只读访问</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getReadOnly</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line"><span class="comment">//对读写属性进行读写访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setReadWrite</span><span class="params">(<span class="type">int</span> val)</span></span>&#123; readWrite = val; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getReadWrite</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line"><span class="comment">//对只写属性进行只写访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setWriteOnly</span><span class="params">(<span class="type">int</span> val)</span></span>&#123; writeOnly = val; &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> readOnly; <span class="comment">//对外只读访问</span></span><br><span class="line"> <span class="type">int</span> noAccess; <span class="comment">//外部不可访问</span></span><br><span class="line"> <span class="type">int</span> readWrite; <span class="comment">//读写访问</span></span><br><span class="line"> <span class="type">int</span> writeOnly; <span class="comment">//只写访问</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单示例<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">person_init</span> <span class="params">( <span class="type">int</span> age , <span class="type">char</span>* name )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">100</span> )</span><br><span class="line">            m_age = age;</span><br><span class="line">        <span class="built_in">strcpy</span> ( m_name , name );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_person</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_age</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_age</span> <span class="params">( <span class="type">int</span> age )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( age &gt;= <span class="number">0</span> &amp;&amp; age &lt;= <span class="number">100</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            m_age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get_name</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_name</span> <span class="params">( <span class="type">char</span>* name )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">strcpy</span> ( m_name , name );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">char</span> m_name[ <span class="number">128</span> ];</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.<span class="built_in">person_init</span> ( <span class="number">20</span> , <span class="string">&quot;lucy&quot;</span> );</span><br><span class="line">    p1.<span class="built_in">show_person</span> ( );</span><br><span class="line">    p1.<span class="built_in">set_age</span> ( <span class="number">30</span> );</span><br><span class="line">    p1.<span class="built_in">set_name</span> ( <span class="string">&quot;bob&quot;</span> );</span><br><span class="line">    p1.<span class="built_in">show_person</span> ( );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>判断两个立方体是否相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_L</span> <span class="params">( <span class="type">int</span> l )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        L = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_W</span> <span class="params">( <span class="type">int</span> w )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        W = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_H</span> <span class="params">( <span class="type">int</span> h )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_L</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_W</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_H</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求立方体的体积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_cube_V</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> L * W * H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求立方体面积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_cube_S</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * W * L + <span class="number">2</span> * W * H + <span class="number">2</span> * L * H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断两个立方体是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare_cube</span> <span class="params">( Cube&amp; c1 )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1.<span class="built_in">get_L</span> ( ) == L &amp;&amp; c1.<span class="built_in">get_W</span> ( ) == W &amp;&amp; c1.<span class="built_in">get_H</span> ( ) == H;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> L;</span><br><span class="line">    <span class="type">int</span> W;</span><br><span class="line">    <span class="type">int</span> H;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comapre_cube</span> <span class="params">( Cube&amp; c1 , Cube&amp; c2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c1.<span class="built_in">get_L</span> ( ) == c2.<span class="built_in">get_L</span> ( ) &amp;&amp; c1.<span class="built_in">get_W</span> ( ) == c2.<span class="built_in">get_W</span> ( ) &amp;&amp;</span><br><span class="line">        c1.<span class="built_in">get_H</span> ( ) == c2.<span class="built_in">get_H</span> ( );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cube c1;</span><br><span class="line">    c1.<span class="built_in">set_L</span> ( <span class="number">10</span> );</span><br><span class="line">    c1.<span class="built_in">set_W</span> ( <span class="number">20</span> );</span><br><span class="line">    c1.<span class="built_in">set_H</span> ( <span class="number">30</span> );</span><br><span class="line">    cout &lt;&lt; c1.<span class="built_in">get_cube_S</span> ( ) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c1.<span class="built_in">get_cube_V</span> ( ) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Cube c2;</span><br><span class="line">    c2.<span class="built_in">set_L</span> ( <span class="number">20</span> );</span><br><span class="line">    c2.<span class="built_in">set_W</span> ( <span class="number">20</span> );</span><br><span class="line">    c2.<span class="built_in">set_H</span> ( <span class="number">30</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( c1.<span class="built_in">compare_cube</span> ( c2 ) )</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;立方体相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;立方体不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">comapre_cube</span> ( c1 , c2 ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;立方体相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;立方体不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>点和圆关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span> <span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mX = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span> <span class="params">( <span class="type">int</span> y )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mY = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> mX;</span><br><span class="line">    <span class="type">int</span> mY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setP</span> <span class="params">( <span class="type">int</span> x , <span class="type">int</span> y )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mP.<span class="built_in">setX</span> ( x );</span><br><span class="line">        mP.<span class="built_in">setY</span> ( y );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setR</span> <span class="params">( <span class="type">int</span> r )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mR = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">getP</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getR</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断点和圆的关系</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">IsPointInCircle</span> <span class="params">( Point&amp; point )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> distance = ( point.<span class="built_in">getX</span> ( ) - mP.<span class="built_in">getX</span> ( ) ) * ( point.<span class="built_in">getX</span> ( ) - mP.<span class="built_in">getX</span> ( ) ) + ( point.<span class="built_in">getY</span> ( ) - mP.<span class="built_in">getY</span> ( ) ) * ( point.<span class="built_in">getY</span> ( ) - mP.<span class="built_in">getY</span> ( ) );</span><br><span class="line">        <span class="type">int</span> radius = mR * mR;</span><br><span class="line">        <span class="keyword">if</span> ( distance &lt; radius )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.<span class="built_in">getX</span> ( ) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; point.<span class="built_in">getY</span> ( ) &lt;&lt; <span class="string">&quot;)在圆内!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( distance &gt; radius )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.<span class="built_in">getX</span> ( ) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; point.<span class="built_in">getY</span> ( ) &lt;&lt; <span class="string">&quot;)在圆外!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Point(&quot;</span> &lt;&lt; point.<span class="built_in">getX</span> ( ) &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; point.<span class="built_in">getY</span> ( ) &lt;&lt; <span class="string">&quot;)在圆上!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Point mP; <span class="comment">//圆心</span></span><br><span class="line">    <span class="type">int</span> mR; <span class="comment">//半径</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实例化圆对象</span></span><br><span class="line">    Circle circle;</span><br><span class="line">    circle.<span class="built_in">setP</span> ( <span class="number">20</span> , <span class="number">20</span> );</span><br><span class="line">    circle.<span class="built_in">setR</span> ( <span class="number">5</span> );</span><br><span class="line">    <span class="comment">//实例化点对象</span></span><br><span class="line">    Point point;</span><br><span class="line">    point.<span class="built_in">setX</span> ( <span class="number">25</span> );</span><br><span class="line">    point.<span class="built_in">setY</span> ( <span class="number">20</span> );</span><br><span class="line"></span><br><span class="line">    circle.<span class="built_in">IsPointInCircle</span> ( point );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：类，相当于作用域<br>在 C++ 中，类确实可以被视为一种作用域。类作用域定义了类成员（包括数据成员和成员函数）的可见性和可访问性范围。以下是关于类作用域的一些关键点：</p><p>1、成员的可见性：</p><ul><li>类的成员默认是私有的（private），这意味着它们只能被类内的其他成员访问。</li><li>可以通过使用 public、protected 和 private 关键字来控制成员的访问级别。</li><li>类的公有成员（public）可以从类外部访问。</li><li>类的受保护成员（protected）可以从类外部的派生类访问。</li><li>类的私有成员（private）只能从类内部访问。</li></ul><p>2、成员的访问：</p><ul><li>非静态成员通常通过对象、对象指针或对象引用访问。</li><li>静态成员可以通过类名直接访问，也可以通过对象访问。</li><li>使用作用域解析运算符（::）来明确指定类名访问静态成员或类型别名等。</li></ul><p>3、命名冲突解决：</p><ul><li>类作用域帮助避免命名冲突，因为不同类中的成员可以有相同的名字，只要它们不互相干扰。</li></ul><p>4、封装：</p><ul><li>类作用域支持封装的概念，即隐藏实现细节并暴露有限的接口供外部使用。</li></ul><h1 id="3、-构造和析构"><a href="#3、-构造和析构" class="headerlink" title="3、 构造和析构"></a>3、 构造和析构</h1><h2 id="3-1-、构造和析构的概念"><a href="#3-1-、构造和析构的概念" class="headerlink" title="3-1 、构造和析构的概念"></a>3-1 、构造和析构的概念</h2><ul><li>创建对象时,对对象进行初始化的工作,就是构造</li><li>销毁对象时,对对象进行清理工作,就是析构</li><li>一般需要人为提供,如果不提供,那么编译器也会给提供,只是编</li><li>译器提供的构造和析构函数不会做任何操作</li><li>创建对象时和释放对象时,构造函数和析构函数自动会调用,不需要人为调用</li></ul><h2 id="3-2-构造函数和析构函数"><a href="#3-2-构造函数和析构函数" class="headerlink" title="3-2 构造函数和析构函数"></a>3-2 构造函数和析构函数</h2><p> 构造函数:          </p><ul><li>没有返回值</li><li>函数名和类名一致</li><li>有参数,参数可以有多个</li><li>可以发送函数的重载</li><li>创建对象时,会自定调用<br> 析构函数:</li><li>没有返回值</li><li>函数名: 类名前面加上~</li><li>没有参数</li><li>不能发送函数的重载</li><li>销毁对象之前,回被自动调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数 1 函数名和类名一致 没有返回值 不能写void 可以有参数 可以发生函数重载</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">int</span> age,string name)</span><br><span class="line">  &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;person的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  m_age = age;</span><br><span class="line">  m_name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数 函数名: 类名前面加上~ 没有返回值 不可以有参数 不能发生函数重载</span></span><br><span class="line">  ~<span class="built_in">Person</span>()</span><br><span class="line">  &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_age;</span><br><span class="line">  string m_name;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;lucy&quot;</span>)</span></span>; <span class="comment">//构造函数是在实例化对象时会创建,就是在内存开辟空间时会被调用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//销毁之前 自动调用析构函数</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-3、构造函数的分类"><a href="#3-3、构造函数的分类" class="headerlink" title="3-3、构造函数的分类"></a>3-3、构造函数的分类</h2><p>无参构造和有参构造<br>普通沟通和拷贝构造<br>拷贝构造函数的写法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名（const 类名 &amp;ob）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>如果自定义了一个构造函数,系统将不再提供默认的构造函数</li><li>如果自定义了一个拷贝构造,系统将不再提供默认的拷贝构造</li><li>默认的拷贝构造是简单的值拷贝</li><li>如果创建对象时,不能调用对应的构造函数,将不能创建出对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//有参和无参构造</span></span><br><span class="line">    <span class="built_in">Person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span> ( <span class="type">int</span> a , string n )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">        age = a;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造的调用时机 : 旧对象初始化新对象</span></span><br><span class="line">    <span class="comment">//如过自定义了一个拷贝构造,那么系统不再提供默认的拷贝构造</span></span><br><span class="line">    <span class="built_in">Person</span> ( <span class="type">const</span> Person&amp; p )<span class="comment">// Person p = p2</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝构造做了简单的值拷贝</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        name = p.name;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果人为提供了一个有参和有参构造,系统将不再提供默认的无参构造</span></span><br><span class="line">    Person p1;<span class="comment">//调用无参构造时 不能使用括号法</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span> <span class="params">( p2 )</span></span>;<span class="comment">//调用系统提供的默认拷贝构造</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//explicit 关键字 修饰构造函数  作用是不能通过隐式法调用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Person</span> <span class="params">( <span class="type">const</span> Person&amp; p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//匿名对象 没有名字 生命周期在当前行</span></span><br><span class="line">    <span class="built_in">Person</span> ( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> );<span class="comment">// 调用了有参构造创建了一个匿名对象</span></span><br><span class="line">    <span class="built_in">Person</span> ( );<span class="comment">//调用了无参构造创建了一个匿名对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span> <span class="params">( <span class="number">20</span> , <span class="string">&quot;heihei&quot;</span> )</span></span>;</span><br><span class="line">    <span class="comment">//Person (p1);//在定义时匿名对象不能使用括号法调用拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示法调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1 = <span class="built_in">Person</span> ( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> );<span class="comment">//显示法调用有参构造</span></span><br><span class="line">    Person p2 = <span class="built_in">Person</span> ( p1 );<span class="comment">//显示法调用拷贝构造</span></span><br><span class="line">    Person p3 = <span class="built_in">Person</span> ( );<span class="comment">//显示法调用无参构造</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式法调用构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1 = &#123; <span class="number">10</span>, <span class="string">&quot;lucy&quot;</span> &#125;;<span class="comment">// 隐式法调用有参构造</span></span><br><span class="line">    Person p2 = p1;<span class="comment">// 隐式法调用拷贝构造</span></span><br><span class="line">    <span class="comment">//Person p3 ;// 隐式法不能调用无参构造</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Complex</span> <span class="params">( <span class="type">double</span> real )</span> : _real ( real ) , _imag ( <span class="number">0</span> )</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125; <span class="comment">// 使用 explicit</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">( )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _real;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">( )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _imag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> _real;</span><br><span class="line">    <span class="type">double</span> _imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 下面的语句不会编译，因为构造函数被标记为 explicit</span></span><br><span class="line">    <span class="comment">// Complex c = 3.14; </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式调用构造函数</span></span><br><span class="line">    <span class="function">Complex <span class="title">c</span> <span class="params">( <span class="number">3.14</span> )</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段C++代码定义了一个名为Complex的类，用于表示复数。具体功能如下：</p><p>1、构造函数:<br><code>explicit Complex(double real) : _real(real), _imag(0)</code></p><ul><li>这个构造函数接收一个double类型的参数real，用来初始化复数的实部。</li><li>_real和_imag分别是存储复数实部和虚部的私有成员变量。</li><li>使用explicit关键字是为了避免无意间的类型转换。</li></ul><p>2、成员方法:<br><code>double real() const</code></p><ul><li>返回复数的实部。<br><code>double imag() const</code></li><li>返回复数的虚部。</li></ul><p>3、成员变量:</p><ul><li>_real: 存储复数的实部。</li><li>_imag: 存储复数的虚部。<br>综上所述，这个类可以创建复数对象并获取其实部和虚部。</li></ul><p>4、在这个上下文中，冒号 (:) 用于初始化列表 (Initializer List)。<br>在构造函数的定义中，explicit Complex(double real) : _real(real), _imag(0) 中的冒号后面跟着的是初始化列表。<br>这里的意思是：</p><ul><li>_real 成员变量被初始化为传入的 real 参数的值。</li><li>_imag 成员变量被初始化为 0。<br>这样做的好处是在构造函数执行之前就直接给成员变量赋值，而不是在构造函数体内通过赋值语句来设置它们的值。这种方式更加高效且安全</li></ul><p>5、在C++中，成员函数后面的const关键字表示该成员函数不会修改类的任何成员变量。具体来说：</p><ul><li>double real() const 和 double imag() const 中的 const 表示这两个成员函数是“常量成员函数”。</li><li>常量成员函数保证不会修改对象的状态，即不会修改类中的非静态数据成员。</li><li>这样的设计允许这些函数在一个常量对象上调用，或者在对象被声明为const的情况下调用。<br>简单来说，这里的const告诉编译器和程序员这两个函数是安全的，不会改变对象的状态。</li></ul><p>6、如果去掉explicit关键字，并使用Complex c &#x3D; 3.14;这样的语句，会发生以下情况：<br>隐式类型转换:</p><ul><li>不带explicit的单参数构造函数允许从double类型隐式转换到Complex类型。</li><li>在这种情况下，3.14会被隐式转换为Complex对象，其实部为3.14，虚部为0。</li></ul><p>对象创建:</p><ul><li><p>Complex c &#x3D; 3.14; 将创建一个Complex类型的对象c。</p></li><li><p>对象c的实部将被初始化为3.14，虚部默认为0。<br>总结：</p></li><li><p>如果不使用explicit，上述语句将成功编译，并创建一个实部为3.14、虚部为0的Complex对象c。</p></li></ul><p>7、如果保留explicit关键字，并使用Complex c &#x3D; 3.14;这样的语句，会发生以下情况：</p><p>显式构造函数:</p><ul><li>explicit关键字阻止了从double类型到Complex类型的隐式转换。</li><li>因此，Complex c &#x3D; 3.14;这样的语句会导致编译错误，因为不允许隐式转换。</li></ul><p>编译错误:</p><ul><li><p>编译器会报告一个错误，指出不能将double类型隐式转换为Complex类型。<br>总结：</p></li><li><p>如果保留explicit，上述语句会导致编译错误，因为不允许从double类型隐式转换到Complex类型。</p></li></ul><h2 id="3-4、拷贝构造函数的调用时机"><a href="#3-4、拷贝构造函数的调用时机" class="headerlink" title="3-4、拷贝构造函数的调用时机"></a>3-4、拷贝构造函数的调用时机</h2><p> 总结一种情况:  旧对象初始化新对象<br>分类:</p><ul><li>旧对象初始化新对象</li><li>形参是一个对象</li><li>返回局部对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no param contructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span> ( <span class="type">int</span> age )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;param constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span> ( <span class="type">const</span> Person&amp; person )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        mAge = person.mAge;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1. 旧对象初始化新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p</span> <span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span> <span class="params">( p )</span></span>;<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    Person p2 = <span class="built_in">Person</span> ( p );<span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    Person p3 = p; <span class="comment">// 相当于Person p2 = Person(p);调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 传递的参数是普通对象，函数参数也是普通对象，传递将会调用拷贝构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doBussiness</span> <span class="params">( Person p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;<span class="comment">//Person p = p</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span> <span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">    <span class="built_in">doBussiness</span> ( p );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 函数返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">MyBusiness</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span> <span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部p:&quot;</span> &lt;&lt; ( <span class="type">int</span>* )&amp;p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//vs release、qt下没有调用拷贝构造函数</span></span><br><span class="line">    <span class="comment">//vs debug下调用一次拷贝构造函数</span></span><br><span class="line">    Person p = <span class="built_in">MyBusiness</span> ( );</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部p:&quot;</span> &lt;&lt; ( <span class="type">int</span>* )&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test03</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-5、c-默认增加的函数"><a href="#3-5、c-默认增加的函数" class="headerlink" title="3.5、c++默认增加的函数"></a>3.5、c++默认增加的函数</h2><p>默认情况下，c++编译器至少为我们写的类增加3个函数<br>1．默认构造函数(无参，函数体为空)<br>2．默认析构函数(无参，函数体为空)<br>3．默认拷贝构造函数，对类中非静态成员属性简单值拷贝<br> 如果用户定义拷贝构造函数，c++不会再提供任何默认构造函数<br> 如果用户定义了普通构造(非拷贝)，c++不在提供默认无参构造，但是<br>会提供默认拷贝构造</p><h2 id="3-6、构造函数的深拷贝和浅拷贝"><a href="#3-6、构造函数的深拷贝和浅拷贝" class="headerlink" title="3-6、构造函数的深拷贝和浅拷贝"></a>3-6、构造函数的深拷贝和浅拷贝</h2><p>在C++中，深拷贝和浅拷贝指的是在对象复制过程中如何处理对象内部数据的不同方式，特别是当对象包含指向动态分配内存的指针时。</p><p>1、浅拷贝：</p><ul><li>浅拷贝指的是当复制一个对象时，仅仅是复制了对象的数据成员的值，对于对象中的指针成员，也只是进行了简单的地址复制。</li><li>如果对象中包含指向动态分配内存的指针，那么浅拷贝会导致两个对象都指向同一块内存区域。</li><li>这种情况下，当其中一个对象的生命周期结束或显式调用析构函数时，这块内存被释放，另一个对象的指针就变成了野指针，可能导致程序崩溃或未定义行为。</li></ul><p>2、深拷贝：</p><ul><li>深拷贝在复制对象时不仅复制对象的数据成员的值，还会为那些指向动态分配内存的指针成员重新分配新的内存，并且复制这些数据到新的内存位置。</li><li>这样，原始对象和复制的对象各自拥有自己的内存资源，修改一个对象的内容不会影响到另一个对象。</li><li>深拷贝确保了每个对象拥有独立的资源，避免了浅拷贝带来的问题。<br>为了实现深拷贝，通常需要自定义类的拷贝构造函数和赋值运算符重载，以确保在复制对象时能够正确地管理资源。例如，拷贝构造函数可能看起来像这样：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="comment">// 分配新的内存并复制数据</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">        *data = *(other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他成员函数...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>这里，MyClass 的拷贝构造函数为 data 分配了新的内存，并从 other 对象中复制了数据，这就是一个深拷贝的例子。如果只是简单地执行了 data &#x3D; other.data;，那就是浅拷贝。</li></ul><h2 id="3-7、多个对象构造和析构"><a href="#3-7、多个对象构造和析构" class="headerlink" title="3-7、多个对象构造和析构"></a>3-7、多个对象构造和析构</h2><h3 id="3-7-1、初始化列表"><a href="#3-7-1、初始化列表" class="headerlink" title="3-7-1、初始化列表"></a>3-7-1、初始化列表</h3><p>注意:</p><ul><li>初始化列表,先声明 在调用构造函数时定义并初始化 ,定义初<br>始化的顺序和声明的顺序一致</li><li>普通的构造函数,先定义,在赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//先定义了int m_a; int m_b;int m_c; 然后在分别赋值</span></span><br><span class="line">  <span class="comment">/*person(int a,int b,int c)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">  m_a = a;</span></span><br><span class="line"><span class="comment">  m_b = b;</span></span><br><span class="line"><span class="comment">  m_c = c;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">  <span class="comment">//先声明了int m_a; int m_b;int m_c 在根据声明的顺序进行定义初始化</span></span><br><span class="line">  <span class="comment">//调用构造函数是 定义并初始化,顺序和声明的顺序一致</span></span><br><span class="line">  <span class="built_in">person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b), <span class="built_in">m_c</span>(c) &#123;&#125;<span class="comment">//int m_a=a;int m_c=c;int m_b=b</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  cout &lt;&lt; m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> m_a;<span class="type">int</span> m_c;</span><br><span class="line">  <span class="type">int</span> m_b;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  p1.<span class="built_in">show</span>();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-7-2、类对象成为另一个类的成员"><a href="#3-7-2、类对象成为另一个类的成员" class="headerlink" title="3-7-2、类对象成为另一个类的成员"></a>3-7-2、类对象成为另一个类的成员</h3><ul><li>类中有多个对象时,构造的顺序是先构造里面的对象,在构造外<br>面的对象</li><li>类中有多个对象时,析构时顺序是先析构外面的对象,在析构里<br>面的对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span> ( string name )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pho_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Phone</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string pho_name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Game</span> ( string name )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Game的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">        game_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Game</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Game的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string game_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*Person(string per_name1,string pho_name,string g_name)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">    per_name = per_name1;</span></span><br><span class="line"><span class="comment">    phone.pho_name = pho_name;</span></span><br><span class="line"><span class="comment">    game.game_name = g_name;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="built_in">Person</span> ( string per_name1 , string pho_name , string g_name ) :<span class="built_in">per_name</span> ( per_name1 ) , <span class="built_in">phone</span> ( pho_name ) , <span class="built_in">game</span> ( g_name )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;person的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; per_name &lt;&lt; phone.pho_name &lt;&lt; <span class="string">&quot; 玩着&quot;</span> &lt;&lt; game.game_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string per_name;</span><br><span class="line">    Game game;</span><br><span class="line">    Phone phone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span> <span class="params">( <span class="string">&quot;bob&quot;</span> , <span class="string">&quot;诺基亚&quot;</span> , <span class="string">&quot;贪吃蛇&quot;</span> )</span></span>;</span><br><span class="line">    p1.<span class="built_in">show</span> ( );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-、explicit"><a href="#3-8-、explicit" class="headerlink" title="3-8 、explicit"></a>3-8 、explicit</h2><p>c++提供了关键字explicit，禁止通过构造函数进行的隐式转换。声明为<br>explicit的构造函数不能在隐式转换中使用。<br>[explicit注意]<br> explicit用于修饰构造函数,防止隐式转化。<br> 是针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值<br>的多参构造)而言。<code>之前有提到过</code></p><h2 id="3-9、动态对象创建"><a href="#3-9、动态对象创建" class="headerlink" title="3-9、动态对象创建"></a>3-9、动态对象创建</h2><h3 id="3-9-1、malloc和free动态申请对象和释放对象"><a href="#3-9-1、malloc和free动态申请对象和释放对象" class="headerlink" title="3-9-1、malloc和free动态申请对象和释放对象"></a>3-9-1、malloc和free动态申请对象和释放对象</h3><p>使用malloc和free函数去动态申请对象,和释放申请的对象,不会调用构<br>造函数和析构函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;person无参构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person* p = ( person* )<span class="built_in">malloc</span> ( <span class="built_in">sizeof</span> ( person ) );</span><br><span class="line">    <span class="built_in">free</span> ( p );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-2、-中动态申请对象和释放对象"><a href="#3-9-2、-中动态申请对象和释放对象" class="headerlink" title="3-9-2、++中动态申请对象和释放对象"></a>3-9-2、++中动态申请对象和释放对象</h3><p>类型 *p &#x3D; new  类型;<br>delete p;<br>申请数组:<br>类型 *p  &#x3D; new 类型[n];<br>delete []p;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无参构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//申请一块内存 sizeof(int)大小 并且对这块空间进行初始化</span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p;<span class="comment">//释放申请的空间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//申请一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person* p = <span class="keyword">new</span> person;<span class="comment">//sizeof(person)</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//new一个数组时,返回的是该数组的首元素的地址</span></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[ <span class="number">10</span> ];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[ i ] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p[ i ] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> [ ]p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test03</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-3、new和delete"><a href="#3-9-3、new和delete" class="headerlink" title="3-9-3、new和delete"></a>3-9-3、new和delete</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//new时调用有参构造</span></span><br><span class="line"> person *p = <span class="keyword">new</span> <span class="built_in">person</span>(<span class="number">10</span>);</span><br><span class="line"> <span class="keyword">delete</span> p;</span><br><span class="line"> person *p1 = <span class="keyword">new</span> person[<span class="number">10</span>];<span class="comment">//注意new对象的数组时不能调用有参构造 只能调用无参构造</span></span><br><span class="line"> <span class="keyword">delete</span> []p1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-9-4、delete-void-问题"><a href="#3-9-4、delete-void-问题" class="headerlink" title="3-9-4、delete void *问题"></a>3-9-4、delete void *问题</h3><p> void test05()<br> {<br>  void *p &#x3D; new person;<br>  delete p;&#x2F;&#x2F; p的类型是void *所有不会调用析构函数<br> }</p><h3 id="3-9-5、使用new和delete采用相同形式"><a href="#3-9-5、使用new和delete采用相同形式" class="headerlink" title="3-9-5、使用new和delete采用相同形式"></a>3-9-5、使用new和delete采用相同形式</h3><ul><li>new单一对象时,使用delete释放单一的对象</li><li>new一个数组时,使用delete []释放这个数组</li></ul><h2 id="3-10、静态成员"><a href="#3-10、静态成员" class="headerlink" title="3-10、静态成员"></a>3-10、静态成员</h2><p>在类定义中，它的成员（包括成员变量和成员函数），这些成员可以用<br>关键字static声明为静态的，称为静态成员。<br>不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所<br>有属于这个类的对象共享。</p><h3 id="3-10-1、静态成员变量"><a href="#3-10-1、静态成员变量" class="headerlink" title="3-10-1、静态成员变量"></a>3-10-1、静态成员变量</h3><ul><li>静态成员变量在内存中只有一份,多个对象共享一个静态变量</li><li>静态成员变量,必须类内声明,类外定义</li><li>静态成员变量可以通过类的作用域访问</li><li>静态成员变量可以通过类的对象访问</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="comment">//静态成员变量不能再类内初始化 类内只能声明,定义在全局 声明的作用只是限制静态成员变量作用域</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员变量 在编译阶段就分配内存 存在静态全局区</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::b = <span class="number">10</span>;<span class="comment">//类中成员变量的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person p1;</span><br><span class="line">    p1.b = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; p1.b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; person::b &lt;&lt; endl;<span class="comment">//通过类的作用域访问类的静态成员函数</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; person::a &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test02</span> ( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-10-2、静态成员函数"><a href="#3-10-2、静态成员函数" class="headerlink" title="3-10-2、静态成员函数"></a>3-10-2、静态成员函数</h3><ul><li>静态成员函数能访问静态成员变量不能访问普通的成员变量</li><li>可以通过类的作用域访问静态成员函数</li><li>可以通过对象访问静态成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="comment">//静态成员变量不能再类内初始化 类内只能声明,定义在全局 声明的作用只是限制静态成员变量作用域</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员变量 在编译阶段就分配内存 存在静态全局区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">static_show</span> <span class="params">( )</span><span class="comment">//静态成员函数 可以访问静态成员变量 不能访问普通的成员变量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::b = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person::<span class="built_in">static_show</span> ( );<span class="comment">//通过流类的作用域访问静态成员函数</span></span><br><span class="line">    person p1;</span><br><span class="line">    p1.<span class="built_in">static_show</span> ( );<span class="comment">//通过对象访问静态成员函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-10-3、const修饰的静态变量"><a href="#3-10-3、const修饰的静态变量" class="headerlink" title="3-10-3、const修饰的静态变量"></a>3-10-3、const修饰的静态变量</h3><ul><li>const修饰的静态成员变量保存在常量区,只读的,在内存中只有一份</li><li>const修饰的静态成员变量可以在类内定义且初始化</li><li>const修饰的静态成员变量可以通过类的作用域访问</li><li>const修饰的静态成员变量可以通过对象访问</li><li>静态成员函数可以访问const修饰的静态成员变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> num = <span class="number">10</span>;<span class="comment">//const修饰的全局变量保存在常量区 不可更改</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="comment">//静态成员变量不能再类内初始化 类内只能声明,定义在全局 声明的作用只是限制静态成员变量作用域</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员变量 在编译阶段就分配内存 存在静态全局区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> c = <span class="number">1000</span>;<span class="comment">//const修饰的静态成员变量 是保存在常量区 不可修改(只读) 在内存中只有一份</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::b = <span class="number">10</span>;<span class="comment">//类中成员变量的定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; person::c &lt;&lt; endl;</span><br><span class="line">    person p1;</span><br><span class="line">    cout &lt;&lt; p1.c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-10-4、单例模式"><a href="#3-10-4、单例模式" class="headerlink" title="3-10-4、单例模式"></a>3-10-4、单例模式</h3><p>单例模式: 一个类只能创建出一个对象<br>单例模式实现的步骤:</p><ul><li>将无参构造私有化</li><li>将拷贝构造私有化</li><li>定义一个静态的成员指针变量指向new出来的一个唯一对象</li><li>将静态的成员指针变量私有化,提供获得唯一对象的地址的静态接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Feifei</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">int</span> yanzhi;</span><br><span class="line">  <span class="function"><span class="type">static</span> Feifei * <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> single;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> Feifei *single;</span><br><span class="line">  <span class="built_in">Feifei</span>() <span class="comment">//无参构造私有化</span></span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="built_in">Feifei</span>(<span class="type">const</span> Feifei &amp;p)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"> Feifei * Feifei::single = <span class="keyword">new</span> Feifei;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  Feifei * p = Feifei::<span class="built_in">instance</span>();</span><br><span class="line">  p-&gt;age = <span class="number">10</span>;</span><br><span class="line">  p-&gt;yanzhi = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  Feifei * p1 = Feifei::<span class="built_in">instance</span>();</span><br><span class="line">  cout &lt;&lt; p1-&gt;age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p1-&gt;yanzhi &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//Feifei::single-&gt;age = 100;</span></span><br><span class="line">  <span class="comment">//Feifei::single-&gt;yanzhi = 100;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Feifei p1(*Feifei::single);//调用拷贝构造实例化出一个对象</span></span><br><span class="line">  <span class="comment">// Feifei::single = NULL;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//Feifei p1;//需要调用无参构造</span></span><br><span class="line">  <span class="comment">//Feifei p2;</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、类对象成员的初探"><a href="#4、类对象成员的初探" class="headerlink" title="4、类对象成员的初探"></a>4、类对象成员的初探</h1><h2 id="4-1、成员变量和函数的存储"><a href="#4-1、成员变量和函数的存储" class="headerlink" title="4-1、成员变量和函数的存储"></a>4-1、成员变量和函数的存储</h2><ul><li>类对象成员-普通成员变量占用对象空间大小</li><li>类对象成员-静态成员变量不占用对象空间大小</li><li>类对象成员-普通成员函数不占用对象空间大小</li><li>类对象成员-静态成员函数不占用对象空间大小</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;<span class="comment">//普通的成员变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b;<span class="comment">//静态成员不存在类实例化的对象中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span><span class="comment">//普通成员函数不存在类实例化的对象中</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show1</span> <span class="params">( )</span><span class="comment">//静态成员函数 不存在类实例化的对象中</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> person::b = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    person p;</span><br><span class="line">    p.<span class="built_in">show</span> ( );</span><br><span class="line">    <span class="comment">//空类的大小不是0 而是1</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span> ( person ) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-2、this指针的工作原理"><a href="#4-2、this指针的工作原理" class="headerlink" title="4-2、this指针的工作原理"></a>4-2、this指针的工作原理</h2><ul><li>类的成员函数默认编译器都加上了一个this指针,这个this指针<br>指向调用该成员函数的对象</li></ul><h2 id="4-3、this指针的用法"><a href="#4-3、this指针的用法" class="headerlink" title="4-3、this指针的用法"></a>4-3、this指针的用法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( <span class="type">int</span> age , string name )<span class="comment">// this</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt; name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">person <span class="title">person_add</span> <span class="params">( person&amp; p2 )</span><span class="comment">//this ‐‐‐‐‐‐&gt; p1</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">person <span class="title">p</span> <span class="params">( <span class="keyword">this</span>-&gt; age + p2.age , <span class="keyword">this</span>-&gt; name + p2.name )</span></span>;<span class="comment">//&quot;helloworld&quot;</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">person <span class="title">person_add</span> <span class="params">( person&amp; p1 , person&amp; p2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p</span> <span class="params">( p1.age + p2.age , p1.name + p2.name )</span></span>;<span class="comment">//&quot;helloworld&quot;</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;hello&quot;</span> )</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p2</span> <span class="params">( <span class="number">20</span> , <span class="string">&quot;world&quot;</span> )</span></span>;</span><br><span class="line">    <span class="comment">//p3 = p1 + p2 30,&quot;helloworld&quot;</span></span><br><span class="line">    <span class="comment">//person p3 = person_add(p1,p2);</span></span><br><span class="line">    <span class="comment">//p3.show();</span></span><br><span class="line">    person p3 = p1.<span class="built_in">person_add</span> ( p2 );</span><br><span class="line">    p3.<span class="built_in">show</span> ( );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">    p1.<span class="built_in">show</span> ( );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test02</span> ( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-4、cconst修饰的成员函数"><a href="#4-4、cconst修饰的成员函数" class="headerlink" title="4-4、cconst修饰的成员函数"></a>4-4、cconst修饰的成员函数</h2><ul><li>在函数后面加上const,这个是一个常函数</li><li>这个const修饰的是指针 const type * const  this,代表不能<br>通过this指针去修改this指针指向对象的内容</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常函数 不能通过this指针修改this指针指向的对象内容</span></span><br><span class="line"> <span class="comment">//常量指针常量</span></span><br><span class="line"> <span class="function">person <span class="title">person_add</span><span class="params">( person &amp;p2)</span><span class="type">const</span><span class="comment">//const person * const this ‐‐‐‐‐‐&gt; p</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="comment">//this‐&gt;age = 200;</span></span><br><span class="line"> <span class="function">person <span class="title">p</span><span class="params">(<span class="keyword">this</span>‐&gt;age+p2.age,<span class="keyword">this</span>‐&gt;name+p2.name)</span></span>;<span class="comment">//&quot;helloworld&quot;</span></span><br><span class="line"> <span class="keyword">return</span> p;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="5、有元"><a href="#5、有元" class="headerlink" title="5、有元"></a>5、有元</h1><p>类的主要特点之一是数据隐藏，即类的私有成员无法在类的外部(作用<br>域之外)访问。但是，有时候需要在类的外部访问类的私有成员，怎么<br>办？<br>解决方法是使用友元函数，友元函数是一种特权函数，c++允许这个特<br>权函数访问私有成员。这一点从现实生活中也可以很好的理解：<br>比如你的家，有客厅，有你的卧室，那么你的客厅是Public的，所有来<br>的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去，<br>但是呢，你也可以允许你的闺蜜好基友进去。<br>如果想要让全局函数或一个类的成员函数访问另一个类私有成<br>员,只需要声明友元即可</p><h2 id="5-1、-友元的语法"><a href="#5-1、-友元的语法" class="headerlink" title="5-1、 友元的语法"></a>5-1、 友元的语法</h2><h3 id="5-1-1、全局函数成为类的友元"><a href="#5-1-1、全局函数成为类的友元" class="headerlink" title="5-1-1、全局函数成为类的友元"></a>5-1-1、全局函数成为类的友元</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">print_Building</span> <span class="params">( Building&amp; b )</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span> ( string hall , string bedroom )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; bedroom = bedroom;</span><br><span class="line">        <span class="keyword">this</span>-&gt; hall = hall;</span><br><span class="line">    &#125;</span><br><span class="line">    string hall;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    string bedroom;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_Building</span> <span class="params">( Building&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; b.hall &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b.bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Building <span class="title">b1</span> <span class="params">( <span class="string">&quot;凌霄殿&quot;</span> , <span class="string">&quot;闺房&quot;</span> )</span></span>;</span><br><span class="line">    <span class="built_in">print_Building</span> ( b1 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2、类成为另一个类的友元-类的成员函数成为另一个类的友元"><a href="#5-2、类成为另一个类的友元-类的成员函数成为另一个类的友元" class="headerlink" title="5-2、类成为另一个类的友元,类的成员函数成为另一个类的友元"></a>5-2、类成为另一个类的友元,类的成员函数成为另一个类的友元</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goodgay</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goodgay</span> ( string hall , string bedroom );</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span> <span class="params">( )</span></span>;</span><br><span class="line">    Building* b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//friend void print_Building(Building &amp;b);</span></span><br><span class="line">    <span class="comment">//friend class Goodgay; //一个类成为另一个类的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Goodgay::visit</span> <span class="params">( )</span></span>;<span class="comment">//类的成员函数成为另一类的友元</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span> ( string hall , string bedroom )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; bedroom = bedroom;</span><br><span class="line">        <span class="keyword">this</span>-&gt; hall = hall;</span><br><span class="line">    &#125;</span><br><span class="line">    string hall;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    string bedroom;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Goodgay::<span class="built_in">Goodgay</span> ( string hall , string bedroom )</span><br><span class="line">&#123;</span><br><span class="line">    b = <span class="keyword">new</span> <span class="built_in">Building</span> ( hall , bedroom );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Goodgay::visit</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; b-&gt; hall &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b-&gt; bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Goodgay <span class="title">gd</span> <span class="params">( <span class="string">&quot;凌霄殿&quot;</span> , <span class="string">&quot;闺房&quot;</span> )</span></span>;</span><br><span class="line">    gd.<span class="built_in">visit</span> ( );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6、运算符重载"><a href="#6、运算符重载" class="headerlink" title="6、运算符重载"></a>6、运算符重载</h1><h2 id="6-1、-运算符重载的基本概念"><a href="#6-1、-运算符重载的基本概念" class="headerlink" title="6-1、 运算符重载的基本概念"></a>6-1、 运算符重载的基本概念</h2><p>运算符重载: 就是给运算符赋予一个新的意义<br>int  a &#x3D;1;<br>int   b&#x3D;2;’<br>int  c &#x3D; a +b;<br>person p1;<br>person p2;<br>person p3&#x3D; p1+p2;<br>运算符只能运算内置的数据类型,对于自定义的数据类型,不能运算,所以<br>我们可以重载运算符</p><h2 id="6-2、重载加号运算符"><a href="#6-2、重载加号运算符" class="headerlink" title="6-2、重载加号运算符"></a>6-2、重载加号运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( <span class="type">int</span> age )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    person <span class="keyword">operator</span>+( person&amp; p2 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">person <span class="title">p</span> <span class="params">( <span class="keyword">this</span>-&gt; age + p2.age )</span></span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person operator+(person &amp;p1, person &amp;p2)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"> <span class="comment">// person p(p1.age+p2.age);</span></span><br><span class="line"> <span class="comment">// return p;</span></span><br><span class="line"> <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span> <span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p2</span> <span class="params">( <span class="number">20</span> )</span></span>;</span><br><span class="line">    person p3 = p1 + p2;<span class="comment">// operator+(p1,p2) p1.operator+(p2)</span></span><br><span class="line">    cout &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3、重载左移运算符和算符重载碰上友元函数"><a href="#6-3、重载左移运算符和算符重载碰上友元函数" class="headerlink" title="6-3、重载左移运算符和算符重载碰上友元函数"></a>6-3、重载左移运算符和算符重载碰上友元函数</h2><p>友元相当于声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; cout , person&amp; p );</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( <span class="type">int</span> age )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span> -&gt;num = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; cout , person&amp; p )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; p.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.num;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span> <span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// operator&lt;&lt;(cout,p1) //cout.operator&lt;&lt;(p1)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-4、-可以重载的运算符"><a href="#6-4、-可以重载的运算符" class="headerlink" title="6-4、 可以重载的运算符"></a>6-4、 可以重载的运算符</h2><p><code>几几乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能使用C中当前没有意义的运算符(例如用**求幂)不能改变运算符优先级，不能改变运算符的参数个数。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清寓语意乎C中所有的运算符都可以重载，但运算符重载的使用时相当受限制的。特别是不能使用C中当前没有意义的运算符(例如用**求幂)不能改变运算符优先级，不能改变运算符的参数个数。这样的限制有意义，否则，所有这些行为产生的运算符只会混淆而不是澄清寓语意</code></p><h2 id="6-5、重载自加自减运算符"><a href="#6-5、重载自加自减运算符" class="headerlink" title="6-5、重载自加自减运算符"></a>6-5、重载自加自减运算符</h2><p>++a   ; 先自加 在使用<br>a++;&#x2F;&#x2F;先使用 在自加<br>前置加加返回的是引用<br>后置加加返回的是对象<br>前置加加调用TYPE&amp; operator++()函数<br>后再加加调用的是TYPE operator++(int)函数,也就是后置加<br>加多了一个占位参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Myint</span> ( <span class="type">int</span> num )<span class="comment">//this</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    Myint&amp; <span class="keyword">operator</span>++( )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;num = <span class="keyword">this</span>-&gt;num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Myint <span class="keyword">operator</span>++( <span class="type">int</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Myint tmp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//加加</span></span><br><span class="line">        <span class="keyword">this</span>-&gt; num = <span class="keyword">this</span>-&gt; num + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;( ostream&amp; cout ,<span class="type">const</span> Myint&amp; p )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; p.num;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Myint <span class="title">p1</span> <span class="params">( <span class="number">10</span> )</span></span>;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    ++p1;<span class="comment">//operator++(p1) p1.operator++()</span></span><br><span class="line">    cout &lt;&lt; ++p1 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; p1++ &lt;&lt; endl;//p1.operator++(int)</span></span><br><span class="line">    cout &lt;&lt; p1++ &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-6、智能指针"><a href="#6-6、智能指针" class="headerlink" title="6-6、智能指针"></a>6-6、智能指针</h2><p>我们经常new一个对象,忘记释放,所以我们使用智能指针来维护<br>智能指针实质是一个局部对象,这个局部对象维护了new出来的对象的<br>地址,在局部对象的析构函数中,会帮忙释放new出来的对象<br>对于智能指针我们重载了-&gt; 和* 让指针指针和普通指针一样使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( <span class="type">int</span> age )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Smartpointer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Smartpointer</span> ( person* p1 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt; p = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Smartpointer</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;释放了p&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    person* <span class="keyword">operator</span>-&gt; ( )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    person&amp; <span class="keyword">operator</span>*( )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    &#125;</span><br><span class="line">    person* p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部对象 在释放之前可以帮助释放 p,</span></span><br><span class="line">    <span class="comment">//person *p = new person(10);</span></span><br><span class="line">    <span class="function">Smartpointer <span class="title">sp</span> <span class="params">( <span class="keyword">new</span> person ( <span class="number">10</span> ) )</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; p‐&gt;age &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; sp-&gt; age &lt;&lt; endl;<span class="comment">//sp‐&gt; 返回的是p p sp.operator‐&gt;()</span></span><br><span class="line">    cout &lt;&lt; ( *sp ).age &lt;&lt; endl;<span class="comment">//sp.operator*()</span></span><br><span class="line">    <span class="comment">//忘记释放p指向申请的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-7、重载-号运算符"><a href="#6-7、重载-号运算符" class="headerlink" title="6-7、重载&#x3D;号运算符"></a>6-7、重载&#x3D;号运算符</h2><p>编译器默认给每一个类加上了4个函数</p><ul><li>默认无参构造</li><li>默认的拷贝构造</li><li>析构</li><li>operator&#x3D;()<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">person</span> ( <span class="type">int</span> age1 , <span class="type">char</span>* name1 )</span><br><span class="line">    &#123;</span><br><span class="line">        age = age1;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span> ( name1 ) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span> ( name , name1 );</span><br><span class="line">    &#125;</span><br><span class="line">    person&amp; <span class="keyword">operator</span>=( person&amp; p1 )<span class="comment">//this- ..&gt; p2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = p1.age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="type">char</span>[ <span class="built_in">strlen</span> ( p1.name ) + <span class="number">1</span> ];</span><br><span class="line">        <span class="built_in">strcpy</span> ( <span class="keyword">this</span>-&gt;name , p1.name );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">person</span> ( )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> [ ]name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;bob&quot;</span> )</span></span>;</span><br><span class="line">    person p2;</span><br><span class="line">    p2 = p1;<span class="comment">//p2.operator=(p1)</span></span><br><span class="line">    cout &lt;&lt; p2.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p2.name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="6-8、重载不等号"><a href="#6-8、重载不等号" class="headerlink" title="6-8、重载不等号"></a>6-8、重载不等号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">person</span> ( <span class="type">int</span> age , string name )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==( person&amp; p2 )<span class="comment">//this-&gt;&gt;&gt;p1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age == p2.age &amp;&amp; <span class="keyword">this</span>-&gt;name == p2.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=( person&amp; p2 )<span class="comment">//this-&gt;&gt;&gt;p1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age != p2.age || <span class="keyword">this</span>-&gt;name != p2.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p2</span> <span class="params">( <span class="number">20</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ( p1 == p2 )<span class="comment">//p1.operator==(p2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 == p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( p1 != p2 )<span class="comment">//p1.operator!=(p2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 != p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-9、函数对象"><a href="#6-9、函数对象" class="headerlink" title="6-9、函数对象"></a>6-9、函数对象</h2><p>一个类中重载了()的类,那么整个类定义处来的对象可以像函数一样使用,本质是调用了operator()整个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+ y;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="comment">//Myadd p;</span></span><br><span class="line">  <span class="comment">//cout &lt;&lt; p.add(3, 4) &lt;&lt; endl;</span></span><br><span class="line">  <span class="comment">// p() 可以像函数一样调用的对象 函数对象</span></span><br><span class="line">  <span class="comment">//cout &lt;&lt; p(3, 4) &lt;&lt; endl;//p.operator()(3,4)</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">Myadd</span> ()(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;<span class="comment">//匿名对象 Myadd ().operator()(3,4)</span></span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-10、不要重载-和"><a href="#6-10、不要重载-和" class="headerlink" title="6-10、不要重载&amp;&amp;和||"></a>6-10、不要重载&amp;&amp;和||</h3><p>不能重载operator&amp;&amp; 和 operator|| 的原因是，无法在这两种情况下<br>实现内置操作符的完整语义。说得更具体一些，内置版本版本特殊之处<br>在于：内置版本的&amp;&amp;和||首先计算左边的表达式，如果这完全能够决<br>定结果，就无需计算右边的表达式了‐‐而且能够保证不需要。我们都已<br>经习惯这种方便的特性了。<br>我们说操作符重载其实是另一种形式的函数调用而已，对于函数调用总<br>是在函数执行之前对所有参数进行求值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Complex</span>(<span class="type">int</span> flag)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;flag = flag;</span><br><span class="line">&#125;</span><br><span class="line">Complex&amp; <span class="keyword">operator</span>+=(Complex&amp; complex)&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;flag = <span class="keyword">this</span>-&gt;flag + complex.flag;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">bool</span> <span class="keyword">operator</span>&amp;&amp;(Complex&amp; complex)&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;flag &amp;&amp; complex.flag;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> flag;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function">Complex <span class="title">complex1</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">//flag 0</span></span><br><span class="line"> <span class="function">Complex <span class="title">complex2</span><span class="params">(<span class="number">1</span>)</span></span>;  <span class="comment">//flag 1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//原来情况，应该从左往右运算，左边为假，则退出运算，结果为假</span></span><br><span class="line"> <span class="comment">//这边却是，先运算（complex1+complex2），导致，complex1的flag变为complex1+complex2的值， complex1.a = 1</span></span><br><span class="line"> <span class="comment">// 1 &amp;&amp; 1</span></span><br><span class="line"> <span class="comment">//complex1.operator&amp;&amp;(complex1.operator+=(complex2))</span></span><br><span class="line"> <span class="keyword">if</span> (complex1 &amp;&amp; (complex1 += complex2))&#123;  </span><br><span class="line">         <span class="comment">//complex1.operator+=(complex2)</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;真!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;假!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-11、重载运算符建议"><a href="#6-11、重载运算符建议" class="headerlink" title="6-11、重载运算符建议"></a>6-11、重载运算符建议</h2><p>&#x3D;, [], () 和 ‐&gt; 操作符只能通过成员函数进行重载<br>  &lt;&lt; 和 &gt;&gt;只能通过全局函数配合友元函数进行重载<br>  不要重载 &amp;&amp; 和 || 操作符，因为无法实现短路规则</p><h2 id="6-12、封装string类"><a href="#6-12、封装string类" class="headerlink" title="6-12、封装string类"></a>6-12、封装string类</h2><p>略</p><h2 id="6-13、优先级"><a href="#6-13、优先级" class="headerlink" title="6-13、优先级"></a>6-13、优先级</h2><p>略</p><h1 id="7、继承"><a href="#7、继承" class="headerlink" title="7、继承"></a>7、继承</h1><h3 id="7-1、继承概念"><a href="#7-1、继承概念" class="headerlink" title="7-1、继承概念"></a>7-1、继承概念</h3><h3 id="7-1-1、为什么需要继承为什么需要继承"><a href="#7-1-1、为什么需要继承为什么需要继承" class="headerlink" title="7-1-1、为什么需要继承为什么需要继承"></a>7-1-1、为什么需要继承为什么需要继承</h3><p>全部都重新定义，代码重复比较严重</p><h3 id="7-1-2、继承的好处"><a href="#7-1-2、继承的好处" class="headerlink" title="7-1-2、继承的好处"></a>7-1-2、继承的好处</h3><p>c++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型<br>来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成<br>员。<br>一个B类继承于A类，或称从类A派生类B。这样的话，类A成为基类（父<br>类）， 类B成为派生类（子类）。<br>派生类中的成员，包含两大部分：<br>  一类是从基类继承过来的，一类是自己增加的成员。<br>  从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h3 id="7-2、继承方法"><a href="#7-2、继承方法" class="headerlink" title="7-2、继承方法"></a>7-2、继承方法</h3><p>派生类定义格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class 派生类名 :  继承方式 基类名&#123;</span><br><span class="line">      <span class="comment">//派生类新增的数据成员和成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种继承方式：<br>  public ： 公有继承<br>  private ： 私有继承<br>  protected ： 保护继承</p><h3 id="7-2-1、派生类访问权限控制"><a href="#7-2-1、派生类访问权限控制" class="headerlink" title="7-2-1、派生类访问权限控制"></a>7-2-1、派生类访问权限控制</h3><p><img src="./../../../../img/7_linux%E5%BC%80%E5%8F%91/cpp/linuxCpp/%E7%BB%A7%E6%89%BF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//公有的继承方式 基类中是什么控制权限,继承到子类中也是什么控制权限</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  public:</span></span><br><span class="line"><span class="comment">  int a;</span></span><br><span class="line"><span class="comment">  protected:</span></span><br><span class="line"><span class="comment">  int b;</span></span><br><span class="line"><span class="comment">  private:</span></span><br><span class="line"><span class="comment">  int c;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//子类的成员函数去访问父类的成员 子类不可以访父类的私有成员</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  //公有继承 将父类中的公有的权限变成保护的,其他不变</span></span><br><span class="line"><span class="comment">  protected:</span></span><br><span class="line"><span class="comment">  int a;</span></span><br><span class="line"><span class="comment">  protected:</span></span><br><span class="line"><span class="comment">  int b;</span></span><br><span class="line"><span class="comment">  private:</span></span><br><span class="line"><span class="comment">  int c;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//子类访问父类 不能访问父类的私有成员</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//私有继承 会将所有的权限都变成私有的</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  private:</span></span><br><span class="line"><span class="comment">  int a;</span></span><br><span class="line"><span class="comment">  private:</span></span><br><span class="line"><span class="comment">  int b;</span></span><br><span class="line"><span class="comment">  private:</span></span><br><span class="line"><span class="comment">  int c;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> d;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d &lt;&lt; endl;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A p;</span><br><span class="line">  <span class="comment">//p通过类外可以访问公有的权限</span></span><br><span class="line">  p.a = <span class="number">10</span>;</span><br><span class="line">  p.d = <span class="number">20</span>;</span><br><span class="line">  B p1;</span><br><span class="line">  <span class="comment">//p1.a = 100;</span></span><br><span class="line">  p1.d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  C p2;</span><br><span class="line">  <span class="comment">//p2.a = 100;</span></span><br><span class="line">  p2.d = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3、继承中的析构和构造"><a href="#7-3、继承中的析构和构造" class="headerlink" title="7-3、继承中的析构和构造"></a>7-3、继承中的析构和构造</h2><h3 id="7-3-1、继承中的对象模型"><a href="#7-3-1、继承中的对象模型" class="headerlink" title="7-3-1、继承中的对象模型"></a>7-3-1、继承中的对象模型</h3><p>在C++编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员而成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aclass</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> mA;</span><br><span class="line">  <span class="type">int</span> mB;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bclass</span> : <span class="keyword">public</span> Aclass</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> mC;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cclass</span> : <span class="keyword">public</span> Bclass</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> mD;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;A size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span> ( Aclass ) &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;B size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span> ( Bclass ) &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;C size:&quot;</span> &lt;&lt; <span class="built_in">sizeof</span> ( Cclass ) &lt;&lt; endl;<span class="comment">//16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> ( )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-2、对象构造和析构的调用原则"><a href="#7-3-2、对象构造和析构的调用原则" class="headerlink" title="7-3-2、对象构造和析构的调用原则"></a>7-3-2、对象构造和析构的调用原则</h3><p>继承中的构造和析构<br> 子类对象在创建时会首先调用父类的构造函数,父类构造函数执行完毕后，才会调用子类的构造函数<br> 当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数<br> 析构函数调用顺序和构造函数相反<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span> ( <span class="type">int</span> age , string name )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Base</span> ( )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  string name;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建子类对象时,必须先构建父类 需要调用父类的构造函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span> ( <span class="type">int</span> id , <span class="type">int</span> age , string name ) :<span class="built_in">Base</span> ( age , name )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Son</span> ( )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Son <span class="title">p</span> <span class="params">( <span class="number">10</span> , <span class="number">18</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="7-3-3、继承中同名成员的处理问题"><a href="#7-3-3、继承中同名成员的处理问题" class="headerlink" title="7-3-3、继承中同名成员的处理问题"></a>7-3-3、继承中同名成员的处理问题</h3><p> 如果子类和父类有同名的成员变量和成员函数,发送继承时,父类的成员变量和成员函数会被<br>隐藏</p><h3 id="7-3-4、非自动继承的函数"><a href="#7-3-4、非自动继承的函数" class="headerlink" title="7-3-4、非自动继承的函数"></a>7-3-4、非自动继承的函数</h3><p>发送继承时,子类不会继承父类的构造函数 ,析构函数和operator&#x3D;函数</p><h3 id="7-3-5、继承中的静态成员特性"><a href="#7-3-5、继承中的静态成员特性" class="headerlink" title="7-3-5、继承中的静态成员特性"></a>7-3-5、继承中的静态成员特性</h3><p>发送继承时,子类和父类有同名的静态成员函数或静态成员变量.父类中的静态成员函数或静<br>态成员变量会被隐藏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sNum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span> <span class="params">( <span class="type">int</span> param )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sNum + param;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> sNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::sNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> sNum; <span class="comment">//基类静态成员属性将被隐藏</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">//重定义一个函数，基类中重载的函数被隐藏</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getNum</span> <span class="params">( <span class="type">int</span> param1 , <span class="type">int</span> param2 )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sNum + param1 + param2;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">//改变基类函数的某个特征，返回值或者参数个数，将会隐藏基类重载的函数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">getNum</span> <span class="params">( <span class="type">int</span> param1 , <span class="type">int</span> param2 )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; sNum + param1 + param2 &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Derived::sNum = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Derived p1;</span><br><span class="line">  <span class="comment">//如果子类和父类有同名的静态成员变量,父类中的静态成员变量会被隐藏</span></span><br><span class="line">  cout &lt;&lt; p1.sNum &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//如果子类和父类有同名的静态成员函数,父类中的静态成员函数都会被隐藏</span></span><br><span class="line">  p1.<span class="built_in">getNum</span> ( <span class="number">1</span> , <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4、多继承"><a href="#7-4、多继承" class="headerlink" title="7-4、多继承"></a>7-4、多继承</h2><h3 id="7-4-1、多继承的概念"><a href="#7-4-1、多继承的概念" class="headerlink" title="7-4-1、多继承的概念"></a>7-4-1、多继承的概念</h3><p>一个类继承了多个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A , <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  C p;</span><br><span class="line">  p.A::a = <span class="number">10</span>;</span><br><span class="line">  p.B::a = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//p.b = 20;</span></span><br><span class="line">  p.c = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-4-2、菱形继承和虚继承"><a href="#7-4-2、菱形继承和虚继承" class="headerlink" title="7-4-2、菱形继承和虚继承"></a>7-4-2、菱形继承和虚继承</h3><p><img src="./../../../../img/7_linux%E5%BC%80%E5%8F%91/cpp/linuxCpp/%E5%A4%9A%E7%BB%A7%E6%89%BF.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">camel</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> camel_num;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shenshou</span> :<span class="keyword">public</span> sheep , <span class="keyword">public</span> camel</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  Shenshou p;</span><br><span class="line">  <span class="comment">//p.sheep::age = 100;</span></span><br><span class="line">  p.age = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-4-3、虚继承的实现原理"><a href="#7-4-3、虚继承的实现原理" class="headerlink" title="7-4-3、虚继承的实现原理"></a>7-4-3、虚继承的实现原理</h3><p><code>有点难理解</code><br>遇到再说</p><h1 id="8、多态"><a href="#8、多态" class="headerlink" title="8、多态"></a>8、多态</h1><h2 id="8-1、多态的概念"><a href="#8-1、多态的概念" class="headerlink" title="8-1、多态的概念"></a>8-1、多态的概念</h2><p>多态: 一种接口,多种形态<br>静态多态:  编译时,地址早绑定(静态联编)  foo(int)    foo()<br>动态多态:   运行时,才确定需要调用的地址(动态联编)</p><p>发送多态的四个条件:<br>父类中有虚函数<br>必须发送继承<br>子类必须重写虚函数(函数的返回值 函数名 参数一致 函数内容可以不一致)<br>父类的指针或引用指向子类的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span> <span class="params">( )</span> <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//重写虚函数 函数的返回值 参数 函数名一致</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果两个类发生了继承 父类和子类编译器会自动转换.不需要人为转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span> <span class="params">( Animal&amp; obj )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj.<span class="built_in">speak</span> ( );<span class="comment">//地址早绑定 ‐&gt; 加上函数前面加上virtual关键字 地址晚绑定</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Animal p1;</span><br><span class="line">  <span class="built_in">do_work</span> ( p1 );</span><br><span class="line"></span><br><span class="line">  Dog p2;</span><br><span class="line">  <span class="built_in">do_work</span> ( p2 );</span><br><span class="line"></span><br><span class="line">  Cat p3;</span><br><span class="line">  <span class="built_in">do_work</span> ( p3 );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-2、多态实现计算器的案例"><a href="#8-2、多态实现计算器的案例" class="headerlink" title="8-2、多态实现计算器的案例"></a>8-2、多态实现计算器的案例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//开发时 对源码的修改是关闭的 对扩展是开发的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mycalc</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,string cmd)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( cmd == <span class="string">&quot;+&quot;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  Mycalc p;</span><br><span class="line">  cout &lt;&lt; p.<span class="built_in">calc</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; p.<span class="built_in">calc</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*******************************************************************/</span></span><br><span class="line"> <span class="comment">//多态实现计算器案例</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Calc</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">mycalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Add</span> :<span class="keyword">public</span> Calc</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">mycalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Sub</span> :<span class="keyword">public</span> Calc</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">mycalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Mul</span> :<span class="keyword">public</span> Calc</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">mycalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">do_calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calc &amp;obj)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj.<span class="built_in">mycalc</span>(a, b);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  Add p;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">do_calc</span>(<span class="number">2</span>,<span class="number">3</span>,p) &lt;&lt;endl;</span><br><span class="line">  Sub p1;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">do_calc</span>(<span class="number">2</span>, <span class="number">3</span>, p1) &lt;&lt; endl;</span><br><span class="line">  Mul p2;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">do_calc</span>(<span class="number">2</span>, <span class="number">3</span>, p2) &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3、-c-如何实现动态绑定"><a href="#8-3、-c-如何实现动态绑定" class="headerlink" title="8-3、 c++如何实现动态绑定"></a>8-3、 c++如何实现动态绑定</h3><p>略</p><h3 id="8-4、纯虚函数和抽象类"><a href="#8-4、纯虚函数和抽象类" class="headerlink" title="8-4、纯虚函数和抽象类"></a>8-4、纯虚函数和抽象类</h3><p>纯虚函数: 将虚函数 等于0  实质是将虚函数 表的函数入口地址置为NULL<br>抽象类:一个类中如果有纯虚函数,那么这个类就是一个抽象类,抽象类不能实例化对象<br>继承抽象类的子类也是一个抽象类,如果子类重写了虚函数,那么子类就不是抽象类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多态实现计算器案例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">mycalc</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b )</span> </span>= <span class="number">0</span>;<span class="comment">//虚函数等于0 纯虚函数</span></span><br><span class="line">  <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">  return 0;</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mod</span> :<span class="keyword">public</span> Calc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//子类继承了抽象类,那么子类也是一个抽象类</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">mycalc</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  &#125;<span class="comment">//如果子类重写类虚函数 就不是抽象类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有纯虚函数的类 叫做抽象类 抽象类不能实例化对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//Calc p;</span></span><br><span class="line">  Mod p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5、纯虚函数和多继承"><a href="#8-5、纯虚函数和多继承" class="headerlink" title="8-5、纯虚函数和多继承"></a>8-5、纯虚函数和多继承</h3><p>多继承带来了一些争议，但是接口继承可以说一种毫无争议的运用了。<br>绝大数面向对象语言都不支持多继承，但是绝大数面向对象对象语言都支持接口的概念，<br>c++中没有接口的概念，但是可以通过纯虚函数实现接口。<br>接口类中只有函数原型定义，没有任何数据定义。<br>多重继承接口不会带来二义性和复杂性问题。接口类只是一个功能声明，并不是功能实现，<br>子类需要根据功能说明定义功能实现。<br><code>注意:除了析构函数外，其他声明都是纯虚函数。</code></p><h3 id="8-6、虚析构"><a href="#8-6、虚析构" class="headerlink" title="8-6、虚析构"></a>8-6、虚析构</h3><p>作用:在调用基类的析构函数之前,会先调用子类的析构函</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span> <span class="params">( )</span> <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span> ( )<span class="comment">//虚析构 作用 在调用基类的析构函数之前,会先调用子类的析构函数</span></span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//重写虚函数 函数的返回值 参数 函数名一直</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">speak</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Dog</span> ( )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;狗的析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_work</span> <span class="params">( Animal&amp; obj )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  obj.<span class="built_in">speak</span> ( );<span class="comment">//地址早绑定 -&gt; 加上函数前面加上virtual关键字 地址晚绑定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Animal* p = <span class="keyword">new</span> Dog;</span><br><span class="line">  p-&gt;<span class="built_in">speak</span> ( );</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-7、纯虚析构"><a href="#8-7、纯虚析构" class="headerlink" title="8-7、纯虚析构"></a>8-7、纯虚析构</h3><p>虚析构函数等于0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span> <span class="params">( )</span> <span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span> ( ) = <span class="number">0</span>;<span class="comment">//纯虚析构</span></span><br><span class="line">  <span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">   cout &lt;&lt; &quot;Animal的析构&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="8-8、重载-重定义-重写"><a href="#8-8、重载-重定义-重写" class="headerlink" title="8-8、重载 重定义 重写"></a>8-8、重载 重定义 重写</h3><p>重载:</p><ul><li>函数名相同</li><li>同一个作用域</li><li>参数的个数,顺序,类型不一致</li><li>const也可以成为重载的条件<br>重定义:</li><li>发生继承</li><li>子类和父类有同名的变量和函数,父类中同名的变量和函数会<br>被隐藏<br>重写:</li><li>父类中有虚函数</li><li>发生了继承</li><li>子类重写了虚函数  函数名 返回值 参数一致,函数体不一致</li></ul><h1 id="第九章-模板"><a href="#第九章-模板" class="headerlink" title="第九章 模板"></a>第九章 模板</h1><h2 id="9-1、模板的简单介绍"><a href="#9-1、模板的简单介绍" class="headerlink" title="9-1、模板的简单介绍"></a>9-1、模板的简单介绍</h2><p>函数模板: 形参的类型不具体指定,用通用类型代替,在调用时,编译器会<br>根据实参的类型推导出形参的类型(类型参数化)</p><h2 id="9-2、函数模板"><a href="#9-2、函数模板" class="headerlink" title="9-2、函数模板"></a>9-2、函数模板</h2><h3 id="9-2-1、什么是函数模板"><a href="#9-2-1、什么是函数模板" class="headerlink" title="9-2-1、什么是函数模板"></a>9-2-1、什么是函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( <span class="type">int</span>&amp; x , <span class="type">int</span>&amp; y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( <span class="type">char</span>&amp; x , <span class="type">char</span>&amp; y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> ( a , b );</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> ( a , b );</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板来实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//定义一个模板 模板的通用类型为T</span></span><br><span class="line"><span class="comment">//紧跟函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_temp</span> <span class="params">( T&amp; a , T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> d = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">swap_temp</span> ( a , b );<span class="comment">//自动推导</span></span><br><span class="line">  <span class="comment">//swap_temp(a,c); 自动类型推导的结果不一致</span></span><br><span class="line">  <span class="built_in">swap_temp</span> ( c , d );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="10-、模板"><a href="#10-、模板" class="headerlink" title="10 、模板"></a>10 、模板</h1><h2 id="10-1、模板的简单介绍"><a href="#10-1、模板的简单介绍" class="headerlink" title="10-1、模板的简单介绍"></a>10-1、模板的简单介绍</h2><p>函数模板: 形参的类型不具体指定,用通用类型代替,在调用时,编译器会根据实参的类型推导出形参的类型(类型参数化)</p><h2 id="10-2、函数模板"><a href="#10-2、函数模板" class="headerlink" title="10-2、函数模板"></a>10-2、函数模板</h2><h3 id="10-2-1、什么是函数模板"><a href="#10-2-1、什么是函数模板" class="headerlink" title="10-2-1、什么是函数模板"></a>10-2-1、什么是函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( <span class="type">int</span>&amp; x , <span class="type">int</span>&amp; y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span> <span class="params">( <span class="type">char</span>&amp; x , <span class="type">char</span>&amp; y )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> temp = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> ( a , b );</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">swap</span> ( a , b );</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数模板来实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//定义一个模板 模板的通用类型为T</span></span><br><span class="line"><span class="comment">//紧跟函数的定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_temp</span> <span class="params">( T&amp; a , T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">  <span class="type">int</span> d = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">swap_temp</span> ( a , b );<span class="comment">//自动推导</span></span><br><span class="line">  <span class="comment">// swap_temp(a,c); //自动类型推导的结果不一致</span></span><br><span class="line">  <span class="built_in">swap_temp</span> ( c , d );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-2-2、函数模板练习"><a href="#10-2-2、函数模板练习" class="headerlink" title="10-2-2、函数模板练习"></a>10-2-2、函数模板练习</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板 用于排序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">array_sort</span> <span class="params">( T* a , <span class="type">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a[ i ] &gt; a[ j ] )</span><br><span class="line">      &#123;</span><br><span class="line">        T temp = a[ i ];</span><br><span class="line">        a[ i ] = a[ j ];</span><br><span class="line">        a[ j ] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span> <span class="params">( T* p , <span class="type">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; p[ i ] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a[ <span class="number">10</span> ] = &#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">88</span>,<span class="number">17</span>,<span class="number">2</span>,<span class="number">69</span>,<span class="number">0</span> &#125;;</span><br><span class="line">  <span class="built_in">array_sort</span> ( a , <span class="built_in">sizeof</span> ( a ) / <span class="built_in">sizeof</span> ( a[ <span class="number">0</span> ] ) );</span><br><span class="line">  <span class="built_in">print_array</span> ( a , <span class="built_in">sizeof</span> ( a ) / <span class="built_in">sizeof</span> ( a[ <span class="number">0</span> ] ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> b[ <span class="number">5</span> ] = &#123; <span class="number">3.1</span> ,<span class="number">4.5</span> ,<span class="number">2.1</span> ,<span class="number">5.6</span> ,<span class="number">1.1</span> &#125;;</span><br><span class="line">  <span class="built_in">array_sort</span>&lt;<span class="type">double</span>&gt; ( b , <span class="built_in">sizeof</span> ( b ) / <span class="built_in">sizeof</span> ( b[ <span class="number">0</span> ] ) );</span><br><span class="line">  <span class="built_in">print_array</span>&lt;<span class="type">double</span>&gt; ( b , <span class="built_in">sizeof</span> ( b ) / <span class="built_in">sizeof</span> ( b[ <span class="number">0</span> ] ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-2-3、函数模板区别"><a href="#10-2-3、函数模板区别" class="headerlink" title="10-2-3、函数模板区别"></a>10-2-3、函数模板区别</h3><ul><li>函数模板不能自动进行类型转换</li><li>普通函数可以自动进行类型转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Myadd</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">Myadd</span> <span class="params">( T a , T b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;模板函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">Myadd</span> ( a , a );<span class="comment">//调用普通函数 不用推导</span></span><br><span class="line">  Myadd&lt;&gt; ( a , a );<span class="comment">//指定调用模板函数</span></span><br><span class="line">  <span class="built_in">Myadd</span>&lt;<span class="type">int</span>&gt; ( a , a );<span class="comment">//指定调用模板函数</span></span><br><span class="line">  <span class="built_in">Myadd</span> ( a , b );<span class="comment">//调用普通函数 因为普通的函数可以自动类型转换</span></span><br><span class="line">  <span class="built_in">Myadd</span>&lt;<span class="type">char</span> &gt; ( a , b );<span class="comment">//函数模板不会做自动类型转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-2-4、函数模板和普通函数在一起的调用规则"><a href="#10-2-4、函数模板和普通函数在一起的调用规则" class="headerlink" title="10-2-4、函数模板和普通函数在一起的调用规则"></a>10-2-4、函数模板和普通函数在一起的调用规则</h3><ul><li>c++编译器优先考虑普通函数</li><li>可以通过空模板实参列表的语法限定编译器只能通过模板匹配</li><li>函数模板可以像普通函数那样可以被重载</li><li>函数模板如果有更好的匹配,优先使用函数模板</li></ul><h3 id="10-2-5、编译过程和函数模板本质"><a href="#10-2-5、编译过程和函数模板本质" class="headerlink" title="10-2-5、编译过程和函数模板本质"></a>10-2-5、编译过程和函数模板本质</h3><p>就是进行二次编译<br>第一次对函数模板进行编译,第二次在调用处对函数模板展开,进行二次<br>编译</p><h3 id="10-2-6、模板具体化"><a href="#10-2-6、模板具体化" class="headerlink" title="10-2-6、模板具体化"></a>10-2-6、模板具体化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span> ( string name , <span class="type">int</span> age )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt; mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt; mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通交换函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span> <span class="params">( T&amp; a , T&amp; b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第三代具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="type">void</span>  <span class="built_in">mySwap</span>&lt;Person&gt; ( Person&amp; p1 , Person&amp; p2 )</span><br><span class="line">&#123;</span><br><span class="line">  string nameTemp;</span><br><span class="line">  <span class="type">int</span> ageTemp;</span><br><span class="line"></span><br><span class="line">  nameTemp = p1.mName;</span><br><span class="line">  p1.mName = p2.mName;</span><br><span class="line">  p2.mName = nameTemp;</span><br><span class="line"></span><br><span class="line">  ageTemp = p1.mAge;</span><br><span class="line">  p1.mAge = p2.mAge;</span><br><span class="line">  p2.mAge = ageTemp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">P1</span> <span class="params">( <span class="string">&quot;Tom&quot;</span> , <span class="number">10</span> )</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">P2</span> <span class="params">( <span class="string">&quot;Jerry&quot;</span> , <span class="number">20</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">mySwap</span> ( P1 , P2 );</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;P1 Name = &quot;</span> &lt;&lt; P1.mName &lt;&lt; <span class="string">&quot; P1 Age = &quot;</span> &lt;&lt; P1.mAge &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;P2 Name = &quot;</span> &lt;&lt; P2.mName &lt;&lt; <span class="string">&quot; P2 Age = &quot;</span> &lt;&lt; P2.mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-2-7、类模板"><a href="#10-2-7、类模板" class="headerlink" title="10-2-7、类模板"></a>10-2-7、类模板</h3><h4 id="10-2-7-1、类模板的实现"><a href="#10-2-7-1、类模板的实现" class="headerlink" title="10-2-7-1、类模板的实现"></a>10-2-7-1、类模板的实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span> ( T1 a , T2 b )</span><br><span class="line">  &#123;</span><br><span class="line">    age = a;</span><br><span class="line">    data = b;</span><br><span class="line">  &#125;</span><br><span class="line">  T1 age;</span><br><span class="line">  T2 data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//类模板不能自动类型推导</span></span><br><span class="line">  <span class="function">Animal&lt;<span class="type">int</span> , <span class="type">int</span>&gt; <span class="title">dog</span> <span class="params">( <span class="number">10</span> , <span class="number">10</span> )</span></span>;<span class="comment">//显示指定</span></span><br><span class="line">  <span class="function">Animal&lt;<span class="type">int</span> , string&gt; <span class="title">cat</span> <span class="params">( <span class="number">4</span> , <span class="string">&quot;lili&quot;</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-7-2、类模板作为函数参数"><a href="#10-2-7-2、类模板作为函数参数" class="headerlink" title="10-2-7-2、类模板作为函数参数"></a>10-2-7-2、类模板作为函数参数</h4><p>类模板作为函数的形参,该函数需要写成韩顺模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span> ( T1 a , T2 b )</span><br><span class="line">  &#123;</span><br><span class="line">    age = a;</span><br><span class="line">    data = b;</span><br><span class="line">  &#125;</span><br><span class="line">  T1 age;</span><br><span class="line">  T2 data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( Animal&lt;<span class="type">int</span> , <span class="type">int</span>&gt;&amp; p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( Animal&lt;T1 , T2&gt;&amp; p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show1</span> <span class="params">( T1&amp; p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.age &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-2-7-3、类模板遇到继承"><a href="#10-2-7-3、类模板遇到继承" class="headerlink" title="10-2-7-3、类模板遇到继承"></a>10-2-7-3、类模板遇到继承</h4><ul><li>类模板遇到继承  在继承时,继承的类必须是一个模板类&lt;&gt;</li><li>类模板遇到继承,可以将子类写成类模板</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span> ( T a )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt; a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son1</span> ( <span class="type">int</span> x1 , <span class="type">int</span> a ) :<span class="built_in">Base</span>&lt;<span class="type">int</span>&gt; ( a ) , <span class="built_in">x</span> ( x1 )</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son2</span> ( T1 x1 , T2 a ) :<span class="built_in">Base</span>&lt;T2&gt; ( a ) , <span class="built_in">x</span> ( x1 )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  T1 x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Son1 <span class="title">p</span> <span class="params">( <span class="number">10</span> , <span class="number">20</span> )</span></span>;</span><br><span class="line">  <span class="function">Son2&lt;<span class="type">int</span> , string&gt; <span class="title">p2</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-7-4、类模板的成员函数类内实现"><a href="#10-2-7-4、类模板的成员函数类内实现" class="headerlink" title="10-2-7-4、类模板的成员函数类内实现"></a>10-2-7-4、类模板的成员函数类内实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span> ( T1 a , T2 b )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt; a = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt; b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  T1 a;</span><br><span class="line">  T2 b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Person&lt;<span class="type">int</span> , string&gt; <span class="title">p</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;hello&quot;</span> )</span></span>;</span><br><span class="line">  p.<span class="built_in">show</span> ( );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-2-7-5、类模板的成员函数类外实现"><a href="#10-2-7-5、类模板的成员函数类外实现" class="headerlink" title="10-2-7-5、类模板的成员函数类外实现"></a>10-2-7-5、类模板的成员函数类外实现</h4><p>类模板的成员函数放在类外实现需要写成函数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span> ( T1 a , T2 b );</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span>;</span><br><span class="line">  T1 a;</span><br><span class="line">  T2 b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类模板的成员函数在类外实现 需要写成函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1 , T2&gt;::<span class="built_in">Person</span> ( T1 a , T2 b )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">  <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1 , T2&gt;::<span class="built_in">show</span> ( )</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Person&lt;<span class="type">int</span> , string&gt; <span class="title">p</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;hello&quot;</span> )</span></span>;</span><br><span class="line">  p.<span class="built_in">show</span> ( );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-7-6、类模板成员函数的创建时机"><a href="#10-2-7-6、类模板成员函数的创建时机" class="headerlink" title="10-2-7-6、类模板成员函数的创建时机"></a>10-2-7-6、类模板成员函数的创建时机</h4><p>类模板成员函数的创建时机是在调用时,没有调用,编译器不会创建这个函数,只有函数的声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showA</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;showA&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">showB</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;showB&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*   void foo1 ( )</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    obj.showA ( );</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">foo2</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    obj.<span class="built_in">showB</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  T obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  C&lt;B&gt; p;</span><br><span class="line">  <span class="comment">// p.foo1 ( );//调用foo1</span></span><br><span class="line">  p.<span class="built_in">foo2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-2-7-7、类模板的分文件问题"><a href="#10-2-7-7、类模板的分文件问题" class="headerlink" title="10-2-7-7、类模板的分文件问题"></a>10-2-7-7、类模板的分文件问题</h4><p>注意: 类模板的分文件,必须将函数的定义和类的声明写到一个文件<br>在person.h中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">person</span> ( T1 a , T2 b );</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span> <span class="params">( )</span></span>;</span><br><span class="line">  T1 a;</span><br><span class="line">  T2 b;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">person&lt;T1 , T2&gt;::<span class="built_in">person</span> ( T1 a , T2 b )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">  <span class="keyword">this</span>-&gt;b = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> person&lt;T1 , T2&gt;::<span class="built_in">show</span> ( )</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.cpp中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//调用构造函数和show函数需要创建,但是没有这两个函数的定义,不能创建</span></span><br><span class="line">  <span class="function">person&lt;<span class="type">int</span> , <span class="type">int</span>&gt; <span class="title">p</span> <span class="params">( <span class="number">10</span> , <span class="number">20</span> )</span></span>;<span class="comment">//</span></span><br><span class="line">  p.<span class="built_in">show</span> ( );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-2-7-8、类模板遇到友元"><a href="#10-2-7-8、类模板遇到友元" class="headerlink" title="10-2-7-8、类模板遇到友元"></a>10-2-7-8、类模板遇到友元</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span> <span class="params">( Person&lt;T1 , T2&gt;&amp; p )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板作为函数形参 函数需要学成 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span> <span class="params">( Person&lt;T1 , T2&gt;&amp; p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">void</span> showPerson1&lt;&gt; ( Person&lt;T1 , T2&gt;&amp; p );</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">void</span> showPerson&lt;&gt; ( Person&lt;T1 , T2&gt;&amp; p );</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">showPerson2</span> <span class="params">( Person&lt;T1 , T2&gt;&amp; p )</span><span class="comment">//定义一个全局函数并且声明为类的元</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span> ( T1 a , T2 b )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt; a = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt; b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  T1 a;</span><br><span class="line">  T2 b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span> , <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span> <span class="params">( Person&lt;T1 , T2&gt;&amp; p )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; p.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Person&lt;<span class="type">int</span> , string&gt; <span class="title">p</span> <span class="params">( <span class="number">10</span> , <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">  <span class="built_in">showPerson</span> ( p );</span><br><span class="line">  <span class="built_in">showPerson1</span> ( p );</span><br><span class="line">  <span class="built_in">showPerson2</span> ( p );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11、c-转换"><a href="#11、c-转换" class="headerlink" title="11、c++转换"></a>11、c++转换</h1><p>static_cast&lt;待转换的类型&gt;(待转换的数据)</p><ul><li>static_cast可以用来转换基本的内置数据类型 int char  double…</li><li>static_cast不能转换没有发生继承关系之间的类</li><li>static_cast可以用来转换发送继承关系之间的类,但是不保存安全性</li><li>不能用来转换指针<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//static_cast 用来转换内置的数据类型 和c语言的强制类型转换一样</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">double</span> c = <span class="number">3.14</span>;</span><br><span class="line">  a = <span class="built_in">static_cast</span>&lt; <span class="type">int</span> &gt;( b );</span><br><span class="line">  a = <span class="built_in">static_cast</span>&lt; <span class="type">int</span> &gt;( c );</span><br><span class="line">  c = <span class="built_in">static_cast</span>&lt; <span class="type">double</span> &gt;( a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A* p1 = <span class="keyword">new</span> A;</span><br><span class="line">  B* p2 = <span class="keyword">new</span> B;</span><br><span class="line">  <span class="comment">//static_cast不能转换没有发生继承关系之间的类</span></span><br><span class="line">  <span class="comment">//如果两个类之间发生了继承关系,可以类型转换 但是static_cast不会保证转换的安全</span></span><br><span class="line">  p1 = <span class="built_in">static_cast</span>&lt; A* &gt;( p2 );<span class="comment">//子转父 向上转换 是安全的</span></span><br><span class="line">  p2 = <span class="built_in">static_cast</span>&lt; B* &gt;( p1 );<span class="comment">//父转子 向下转换 是不安全的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">char</span>* p2 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//static_cast不能用来转指针</span></span><br><span class="line">  <span class="comment">//p1 = static_cast&lt;int *&gt;(p2);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="11-1、动态转换"><a href="#11-1、动态转换" class="headerlink" title="11-1、动态转换"></a>11-1、动态转换</h2><ul><li>不能用于转换基本的数据类型</li><li>可以用于转换发送继关系之间的类,保证转换是安全的 子转父是可以的</li><li>如果发生了多态,子转父和父转子总是安全的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//动态转换 dynamic_cast</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test04</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//动态转换不能转内置的基本数据类型</span></span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//a = dynamic_cast&lt;int&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A* p1 = <span class="keyword">new</span> A;</span><br><span class="line">  B* p2 = <span class="keyword">new</span> B;</span><br><span class="line">  <span class="comment">//dynamic_cast不能用于没有发生继承关系之间的类转换</span></span><br><span class="line">  <span class="comment">//dynamic_cast可以用于发生继承关系之间的类号转换</span></span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">dynamic_cast</span>&lt; A* &gt;( p2 );<span class="comment">//子转父 是安全的</span></span><br><span class="line">  <span class="comment">//p2 = dynamic_cast&lt;B*&gt;(p1);//父转子 不安全 不允许</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-2、常量转换"><a href="#11-2、常量转换" class="headerlink" title="11-2、常量转换"></a>11-2、常量转换</h2><p>const_cast 一般用来加const或去除const</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//const转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>* p1 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* p2 = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//int *p1 = static_cast&lt;int *&gt;(p2);</span></span><br><span class="line">  p1 = <span class="built_in">const_cast</span>&lt; <span class="type">int</span>* &gt;( p2 );</span><br><span class="line">  p2 = <span class="built_in">const_cast</span>&lt; <span class="type">const</span> <span class="type">int</span>* &gt;( p1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3、重新解释转换"><a href="#11-3、重新解释转换" class="headerlink" title="11-3、重新解释转换"></a>11-3、重新解释转换</h2><p>reinterpret_cast<br>一般用来转换指针 整数和指针之间都可以转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test07</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">char</span>* p2 = <span class="literal">NULL</span>;</span><br><span class="line">  p = <span class="built_in">reinterpret_cast</span>&lt; <span class="type">int</span>* &gt;( p2 );</span><br><span class="line">  p2 = <span class="built_in">reinterpret_cast</span>&lt; <span class="type">char</span>* &gt;( p );</span><br><span class="line">  <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">  c = <span class="built_in">reinterpret_cast</span>&lt; <span class="type">int</span> &gt;( p2 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-4、总结"><a href="#11-4、总结" class="headerlink" title="11-4、总结"></a>11-4、总结</h2><ul><li>static_cast 一般用来转换内置的基本数据类型</li><li>dynamic_cast 一般用来转发生继承关系之间的自定义的数据类型</li><li>const_cast  一般用来转换加const和去除const</li><li>reinterpret_cast   一般用来转指针</li></ul><h1 id="12、异常"><a href="#12、异常" class="headerlink" title="12、异常"></a>12、异常</h1><p>异常: 出错后,将出错问题返回给调用处<br>c语言的异常处理比较简单,容易出错,c++处理异常不容易出错</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mydive</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//errno = 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">mydive</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;除数为0&quot;</span> &lt;&lt; endl;<span class="comment">//perror(&quot;&quot;);</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>c语言一般方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义错误码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ERROR_NONE = <span class="number">0</span>,</span><br><span class="line">    ERROR_INVALID_INPUT,</span><br><span class="line">    ERROR_OUT_OF_MEMORY,</span><br><span class="line">    <span class="comment">// 可以添加更多错误码</span></span><br><span class="line">&#125; ErrorCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局错误码变量</span></span><br><span class="line">ErrorCode g_errorCode = ERROR_NONE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置错误码的宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_ERROR_CODE(code) do &#123; \</span></span><br><span class="line"><span class="meta">    g_errorCode = code;           \</span></span><br><span class="line"><span class="meta">    return;                       \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异常抛出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ThrowException</span><span class="params">(ErrorCode code)</span> &#123;</span><br><span class="line">    SET_ERROR_CODE(code);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟异常处理</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HandleException</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (g_errorCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> ERROR_INVALID_INPUT:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Invalid input detected.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ERROR_OUT_OF_MEMORY:</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Out of memory.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ExampleFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 某些条件 */</span>) &#123;</span><br><span class="line">        ThrowException(ERROR_INVALID_INPUT);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 正常执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    ExampleFunction();</span><br><span class="line">    HandleException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-1、c-处理异常"><a href="#12-1、c-处理异常" class="headerlink" title="12-1、c++处理异常"></a>12-1、c++处理异常</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mydive</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( b == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//处理异常 抛出异常 抛出一个类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//尝试捕获异常</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">mydive</span> ( <span class="number">2</span> , <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">char</span> )<span class="comment">//如果没有捕获的抛出的异常 程序会被终止</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;捕获了一个char类型的异常&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">char</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;捕获了一个char类型的异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-2、异常严格类型匹配"><a href="#12-2、异常严格类型匹配" class="headerlink" title="12-2、异常严格类型匹配"></a>12-2、异常严格类型匹配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mydive</span> <span class="params">( <span class="type">int</span> a , <span class="type">int</span> b )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( b == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">throw</span> str;<span class="comment">//处理异常 抛出异常 抛出一个类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//尝试捕获异常</span></span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">mydive</span> ( <span class="number">2</span> , <span class="number">0</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">char</span> )<span class="comment">//如果没有捕获的抛出的异常 程序会被终止</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;捕获了一个char类型的异常&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">int</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;捕获了一个int类型的异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">double</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;捕获了一个double类型的异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( ... )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;捕获了一个其他类型的异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">test01</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">char</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;捕获了一个char类型的异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="12-3、栈解旋"><a href="#12-3、栈解旋" class="headerlink" title="12-3、栈解旋"></a>12-3、栈解旋</h2><p>在try到throw之间定义的对象,在throw之后会被释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span> ( string name )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">this</span>-&gt; name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Person</span> ( )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span> <span class="params">( <span class="string">&quot;bob&quot;</span> )</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span> <span class="params">( <span class="string">&quot;peter&quot;</span> )</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;001&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span> <span class="params">( <span class="string">&quot;lucy&quot;</span> )</span></span>;</span><br><span class="line">    <span class="built_in">fun</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( <span class="type">int</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;002&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;捕获到异常&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-4、异常接口的声明"><a href="#12-4、异常接口的声明" class="headerlink" title="12-4、异常接口的声明"></a>12-4、异常接口的声明</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本例程用不了了，不符合c++的最新标准了。已经移除</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//可抛出所有类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只能抛出int char char*类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction02</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span> ,<span class="type">char</span>, <span class="type">char</span>*)</span></span>&#123;</span><br><span class="line">string exception = <span class="string">&quot;error!&quot;</span>;</span><br><span class="line"><span class="keyword">throw</span> exception;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//不能抛出任何类型异常</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">TestFunction03</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//  TestFunction01();</span></span><br><span class="line"> <span class="built_in">TestFunction02</span>();</span><br><span class="line"> <span class="comment">//TestFunction03();</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (...)&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;捕获异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>修改后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可抛出所有类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能抛出 int, char, char* 类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string exception = <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* c_exception = exception.<span class="built_in">c_str</span>(); <span class="comment">// 转换为 char* 类型</span></span><br><span class="line">    <span class="keyword">throw</span> c_exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能抛出任何类型异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFunction03</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不应该抛出任何异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TestFunction01();</span></span><br><span class="line">        <span class="built_in">TestFunction02</span>(); <span class="comment">// 测试 TestFunction02</span></span><br><span class="line">        <span class="comment">// TestFunction03(); // 测试 TestFunction03</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获整数异常: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获 C 风格字符串异常: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获其他类型异常!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-5、异常变量生命周期"><a href="#12-5、异常变量生命周期" class="headerlink" title="12-5、异常变量生命周期"></a>12-5、异常变量生命周期</h2><p>抛出的匿名对象的生命周期在catch里面</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myexception</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Myexception</span> ( )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Myexception</span> ( )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">error</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;my error&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Myexception p1;</span><br><span class="line">  <span class="comment">//throw Myexception();//如果抛出匿名对象 他的声明周期在catch里面</span></span><br><span class="line">  <span class="keyword">throw</span> p1;<span class="comment">//p1声明周期在throw之后</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fun</span> ( );</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( Myexception&amp; p )</span><br><span class="line">  &#123;</span><br><span class="line">    p.<span class="built_in">error</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6、异常的多态使用"><a href="#12-6、异常的多态使用" class="headerlink" title="12-6、异常的多态使用"></a>12-6、异常的多态使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myexception</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span> <span class="params">( )</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Out_of_range</span> :<span class="keyword">public</span> Myexception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">error</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Out_of_range&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad_cast</span> :<span class="keyword">public</span> Myexception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">error</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bad_cast&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Out_of_range</span>();</span><br><span class="line">  <span class="comment">// throw Bad_cast ( );</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fun</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( Myexception&amp; p )</span><br><span class="line">  &#123;</span><br><span class="line">    p.<span class="built_in">error</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base::display()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;  <span class="comment">// 虚析构函数，确保派生类对象正确释放</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived::display()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr;  <span class="comment">// 基类指针</span></span><br><span class="line"></span><br><span class="line">    Base baseObj;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line"></span><br><span class="line">    basePtr = &amp;baseObj;</span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>();  <span class="comment">// 输出 &quot;Base::display()&quot;</span></span><br><span class="line"></span><br><span class="line">    basePtr = &amp;derivedObj;</span><br><span class="line">    basePtr-&gt;<span class="built_in">display</span>();  <span class="comment">// 输出 &quot;Derived::display()&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-7、c-的异常库"><a href="#12-7、c-的异常库" class="headerlink" title="12-7、c++的异常库"></a>12-7、c++的异常库</h2><p>异常库使用<br>#define _CRT_SECURE_NO_WARNINGS<br>#include <iostream><br>#include &lt;string.h&gt;<br>#include <string><br>&#x2F;&#x2F;exception<br>#include <stdexcept><br>using namespace std;</p><p>void fun ( )<br>{<br>  &#x2F;**&#x2F;<br>  &#x2F;&#x2F; throw out_of_range(“越界”);<br>  throw invalid_argument ( “段错误” );<br>}<br>void test01 ( )<br>{<br>  try<br>  {<br>    fun ( );<br>  }<br>  catch ( exception&amp; p )<br>  {<br>    cout &lt;&lt; p.what ( ) &lt;&lt; endl;<br>  }<br>}<br>int main ( )<br>{<br>  test01 ( );<br>  return 0;<br>}</p><p>编写自己的异常类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//exception</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Longlongerror</span> :<span class="keyword">public</span> exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Longlongerror</span> ( string data )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt; data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Longlongerror</span> ( <span class="type">char</span>* data )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt; data = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span> <span class="params">( )</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">c_str</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  string data;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Longlongerror</span> ( <span class="string">&quot;长长的错误&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fun</span> ( );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> ( exception&amp; p )</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">what</span> ( ) &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span> ( );</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13、STL模板"><a href="#13、STL模板" class="headerlink" title="13、STL模板"></a>13、STL模板</h1><h2 id="13-1、容器map"><a href="#13-1、容器map" class="headerlink" title="13-1、容器map"></a>13-1、容器map</h2><p>由关键字和其对应的值构成的一个键值对，通过关键字来查找对应的值。<br><code>关键字别名：first。</code><br><code>值别名：second。</code><br>例子:<br>abacsdffjkalsjdfajsdjla<br>统计每个字母出现的次数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cnt;<span class="comment">//把各个字母出现的次数存入cnt中</span></span><br><span class="line">cnt.<span class="built_in">inser</span>(std::<span class="built_in">make_pair</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>));<span class="comment">//插入键值对</span></span><br><span class="line">cnt.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>));</span><br><span class="line">cnt[<span class="string">&#x27;a&#x27;</span>]++;<span class="comment">//a出现的次数加一</span></span><br><span class="line">cnt[<span class="string">&#x27;c&#x27;</span>]++; <span class="comment">//可以取代cnt.insert(std::make_pair(&#x27;c&#x27;, 1));</span></span><br></pre></td></tr></table></figure><p>插入元素有多种方式</p><ol><li>插入元素;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt;student;</span><br><span class="line"><span class="comment">//方式一：用inser函数插入pair</span></span><br><span class="line">student.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span> , string&gt;(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line"></span><br><span class="line">方式二：用insert函数插入value_type数据</span><br><span class="line">studen.<span class="built_in">insert</span>(map&lt;<span class="type">int</span> , string&gt;::<span class="built_in">value_type</span>(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;Bob&quot;</span>));</span><br><span class="line"></span><br><span class="line">方式三：用类似数组的方式插入数据</span><br><span class="line">student[<span class="number">3</span>] = <span class="string">&quot;Tom&quot;</span>;</span><br></pre></td></tr></table></figure>2、查找元素;<br>find()返回一个迭代器,指向查找的元素,如果没找到则返回map::end()位置（NULL）;<br>注意，值的别名是second。通过迭代器去访问。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iter = student.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(iter != student.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;找到&quot;</span> &lt;&lt;iter-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt;<span class="string">&quot;没找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意：如果关键字是整型，也可以通过student[1]读取关键字1对应的数据。</li></ol><p>几种引用情况：<br>第一种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">100</span>;</span><br><span class="line">mp1[<span class="number">10</span>] = <span class="number">3</span>;</span><br><span class="line">sum += mp1[<span class="number">10</span>];<span class="comment">//mp1中存在关键字10，他对应的数据是3，所以sum = 100 + 3 = 103</span></span><br></pre></td></tr></table></figure><p>第二种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">100</span>;</span><br><span class="line">sum += mp1[<span class="number">10</span>];<span class="comment">//mp1中不存在关键字10，所以sum = 100 + 0 = 100</span></span><br></pre></td></tr></table></figure><p>第三种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;</span><br><span class="line">mp1[<span class="number">10</span>] = <span class="number">3</span>;</span><br><span class="line">mp1[<span class="number">10</span>] ++ ;<span class="comment">//mp1中存在关键字10，他对应的数据是3，所以mp1[10] = 4</span></span><br></pre></td></tr></table></figure><p>第四种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp1;</span><br><span class="line">map[<span class="number">20</span>] ++ ;<span class="comment">//mp1中不存在关键字20，所以mp1[20] = 1</span></span><br><span class="line"><span class="comment">//也就是mp1会增加一个元素，关键字是20，值是1</span></span><br></pre></td></tr></table></figure><p>扩展：如果关键字是自己构造的类型，那么需要自己写比较函数。需要重载。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linuxC</title>
      <link href="/posts/69453faf.html"/>
      <url>/posts/69453faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-、系统调用和库函数"><a href="#1-、系统调用和库函数" class="headerlink" title="1 、系统调用和库函数"></a>1 、系统调用和库函数</h1><h2 id="1-1-、库函数由两类函数组成"><a href="#1-1-、库函数由两类函数组成" class="headerlink" title="1-1 、库函数由两类函数组成"></a>1-1 、库函数由两类函数组成</h2><ul><li><p>1、不需要调用系统调用,不需要切换到内核空间即可完成函数的全部功能，并且将结果反馈给应用程序，如strcpy、bzero等字符串操作函数。</p></li><li><p>2、需要调用系统调用,需要切换到内核空间,这类函数通过封装的系统调用去实现相应的功能,如printf、fread等</p></li></ul><pre><code>          </code></pre><h2 id="1-2、系统调用与库函数的关系"><a href="#1-2、系统调用与库函数的关系" class="headerlink" title="1-2、系统调用与库函数的关系"></a>1-2、系统调用与库函数的关系</h2><ul><li>并不是所有系统调用都被封装成为库函数，</li><li>系统提供的很多功能必须通过系统调用才能实现。</li><li>也就是大部分的库函数都是由系统调用封装而来。</li><li>只不过库函数拥有缓冲区，</li><li>减少了系统调用的次数</li></ul><h3 id="1-2-1、系统调用特点"><a href="#1-2-1、系统调用特点" class="headerlink" title="1-2-1、系统调用特点"></a>1-2-1、系统调用特点</h3><ul><li>系统调用是需要时间的，</li><li>频繁的系统调用会降低程序的运行效率。</li><li>当运行内核代码时，</li><li>cpu工作在内核态，</li><li>在系统调用发生前需要保存用户态的栈和内存环境，</li><li>然后转入内核态工作。</li><li>结束调用后又返回用户态。</li></ul><h3 id="1-2-2、库函数的好处"><a href="#1-2-2、库函数的好处" class="headerlink" title="1-2-2、库函数的好处"></a>1-2-2、库函数的好处</h3><ul><li>库函数访问文件的时候需要根据需要设置不同类型的缓存区，</li><li>从而减少了直接调用io系统调用</li><li>的次数，</li><li>提高了访问的效率。<br><img src="../../../../img/7_linux%E5%BC%80%E5%8F%91/c/1%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0.png"></li></ul><p>如：应用程序调用printf时，如下图<br><img src="../../../../img/7_linux%E5%BC%80%E5%8F%91/c/1-2-2%E3%80%81%E5%BA%93%E5%87%BD%E6%95%B0.png"></p><h1 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h1><p>当一个系统启动后，会先后创建3个文件描述符。0、1、2，也就是终端输出，终端输入，错误输出。</p><h2 id="1-1、进程的定义"><a href="#1-1、进程的定义" class="headerlink" title="1-1、进程的定义"></a>1-1、进程的定义</h2><ul><li>程序和进程的区别：<br>程序：是静态的，存放在磁盘上的可执行文件<br>进程：是动态的，是运行在内存中的程序的执行实例</li></ul><p>程序是一些指令的有序集合，而进程是执行程序的过程。进程的状态是变化的。<br>只要程序运行，此时就是进程，程序每运行一次，就会创建一个进程。</p><p>在linux系统中，进程是管理事务的基本单元。进程拥有自己独立的处理环境和系统资源<br> （处理器、存储器、io设备、数据、程序）。<br>##1-2、进程的状态及转换<br>进程可以划分为三中状态：</p><ul><li>就绪态：进程已经具备执行的一切条件，正在等待分配cpu的处理时间。</li><li>执行态：该进程正在占用cpu运行。</li><li>等待态：进程因不具备某些执行条件而暂时无法继续执行的状态。比如scanf输入，在没有输入时就是等待态。</li></ul><h2 id="1-3、进程的调度机制"><a href="#1-3、进程的调度机制" class="headerlink" title="1-3、进程的调度机制"></a>1-3、进程的调度机制</h2><p>时间片轮转：如单核cpu，同一时间段内只能运行一个进程，下一个时间段运行第二个进程。上下文切换：<br>就是比如上部分程序运行了，下部分程序还没有运行被切换到另一个进程中去了。<br><img src="https://img-blog.csdnimg.cn/89171d8fa7304322a662eac554d08124.png"></p><h2 id="1-4、进程控制块"><a href="#1-4、进程控制块" class="headerlink" title="1-4、进程控制块"></a>1-4、进程控制块</h2><p>进程控制块就是用于保存一个进程信息的结构体，又称之为PCB。进程控制块就是一个保存进程信息&#x3D;结构体，存放在task_struct结构体中。</p><p>PCB结构体中的部分数据<br>    调度数据<br>        进程的状态、标志、优先级、调度策略等。<br>    时间数据<br>        创建该进程的时间、<br>        在用户态的运行时间<br>        、在内核态的运行时间等。<br>    文件系统数据<br>        umask掩码、文件描述符表等。<br>        内存数据、进程上下文、进程标识（进程号）</p><h2 id="1-5、进程号"><a href="#1-5、进程号" class="headerlink" title="1-5、进程号"></a>1-5、进程号</h2><pre><code>    每一个进程都由一个进程号来标识，    类型为pid_t，凡时下划线为_t的数据类型都称为类整型。    进程号是唯一的，    但是在一个进程终止后可以重复使用。    进程号是由操作系统随机给程序分配的。    </code></pre><p><code>凡时下划线为_t的数据类型都称为类整型.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ead530fd35a45e786ec14387c221718.png"></p><pre><code>    PPID：当前进程的父进程的进程号    PID：当前进程的进程号    PGID：当前进程组所在的进程组ID，进程组是一个或者多个进程的集合，相互关联，        进程组可以接收同一个终端信号。    COMMAND：当前进程的名字        特殊的进程号：            在linux系统中进程号由0开始。            进程号0和1由进程创建。            进程号0通常称之为调度进程，交换进程。            进程号为1的进程通常是init进程。init是所有进程的祖先。            除了调度进程外，所有进程都由init进程直接或间接创建。        父子进程的关系就是由谁创建了谁的关系。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Linux操作系统提供了三个获得进程号的函数</span><br><span class="line">getpid()、getppid()、getpgid()。</span><br><span class="line"></span><br><span class="line">linux下提供三个获得进程号的函数 </span><br><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"> pid_t getpid(void);</span><br><span class="line"> 功能：获取当前进程的进程号</span><br><span class="line"> pid_t getppid(void);</span><br><span class="line"> 功能：获取当前进程的父进程的进程号</span><br><span class="line"> pid_t getpgid(pid_t pid);</span><br><span class="line"> 功能：获取当前进程所在进程组的id</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/******* 示例 *********/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">/********* 获取当前进程的进程号  **********/</span><br><span class="line">printf(&quot;pid = %d\n&quot;,getpid());</span><br><span class="line">/************ 获取当前进程的父进程id *************/</span><br><span class="line">printf(&quot;ppid = %d\n&quot;,getppid());</span><br><span class="line">/************ 获取当前进程所在组的id  *************/</span><br><span class="line">printf(&quot;pgid = %d\n&quot;,getpgid(getpid()));</span><br><span class="line">while(1)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6、进程的创建fork函数"><a href="#2-6、进程的创建fork函数" class="headerlink" title="2-6、进程的创建fork函数"></a>2-6、进程的创建fork函数</h2><pre><code>    创建进程的方法主要是调用一下两个函数：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork(void);</span><br><span class="line">功能：在已有的进程基础上有创建一个子进程</span><br><span class="line">参数：</span><br><span class="line">无</span><br><span class="line">返回值：</span><br><span class="line">成功：</span><br><span class="line">&gt;0 子进程的进程号，标识父进程的代码区</span><br><span class="line">0 子进程的代码区</span><br><span class="line"> 失败：</span><br><span class="line"> ‐1 返回给父进程，子进程不会创建</span><br></pre></td></tr></table></figure><pre><code>使用fork函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间地址空间:    包括进程上下文、    进程堆栈、    打开的文件描述符、    信号控制设定、    进程优先级、    进程组号等。    子进程所独有的只有它的进程号，计时器等。因此，使用fork函数的代价是很大的。fork函数执行完毕后父子进程的空间示意图：    使用fork函数后：</code></pre><p><img src="https://img-blog.csdnimg.cn/7f766c609fb54de3b78cf29a746de36e.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    /******  通过fork函数创建一个子进程 *******/</span><br><span class="line">     /***********     **************/</span><br><span class="line"> #if 0   </span><br><span class="line"> fork();</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line"> #endif</span><br><span class="line"> /****** 通过fork函数的返回值来确定父子进程的独立区代码 ********/</span><br><span class="line"> /********  父子进程是来回交替运行的，谁先允许，后允许，这个是不确定的   **************/</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;parent :pid = %d,ppid = %d\r\n&quot;,getpid(),getppid());    </span><br><span class="line">        printf(&quot;pid = %d\r\n&quot;,pid);</span><br><span class="line">        printf(&quot;this is parent\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;**********************************&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     while (1)</span><br><span class="line">     &#123;</span><br><span class="line">        printf(&quot;son :pid = %d,ppid = %d\r\n&quot;,getpid(),getppid());   </span><br><span class="line">        printf(&quot;this is child\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;**********************************&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int a = 1;</span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    /******  通过fork函数创建一个子进程 *******/</span><br><span class="line">     /***********     **************/</span><br><span class="line"> #if 0   </span><br><span class="line"> fork();</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line"> #endif</span><br><span class="line"> /****** 通过fork函数的返回值来确定父子进程的独立区代码 ********/</span><br><span class="line"> /********  父子进程是来回交替运行的，谁先允许，后允许，这个是不确定的   **************/</span><br><span class="line">    int b = 2;</span><br><span class="line">    static int c = 3;</span><br><span class="line">    /************** 同时，在fork之前的数据，子进程都会保留，后面无论父进程怎么变（</span><br><span class="line">      堆区栈区数据区），都不会影响子进程***************/</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        c++;</span><br><span class="line">        printf(&quot;this is parent a = %d ,b = %d ,c = %d\r\n&quot;, a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">     &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">     printf(&quot;this is son a = %d ,b = %d ,c = %d\r\n&quot;,a, b, c);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果</span><br><span class="line">ygc@ygc:~/network/07_fork2$ ./a.out </span><br><span class="line">this is parent a = 2 ,b = 3 ,c = 4</span><br><span class="line">this is son a = 1 ,b = 2 ,c = 3</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><pre><code>    从上面可以看出，子进程会在fork之前做数据的继承    而有内核空间，磁盘空间是进程所共有的，改变偏移量，    会将偏移指针保存在内核中，所以父进程改变的偏移量会继承到子进程中。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(&quot;file.txt&quot;,O_RDONLY)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open file.txt&quot;);</span><br><span class="line">        goto filed_open;</span><br><span class="line">    &#125; </span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;filed_fork&quot;);</span><br><span class="line">        goto filed_fork;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[32] = &quot; &quot;;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        printf(&quot;this is parent\r\n&quot;);</span><br><span class="line">        if(read(fd,buf,30) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;filed_read\r\n&quot;);</span><br><span class="line">            goto filed_read;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;buf = [%s]\r\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line"></span><br><span class="line">        printf(&quot;this is son\r\n&quot;);    </span><br><span class="line"></span><br><span class="line">         char buf[32] = &quot; &quot;;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        printf(&quot;this is parent\r\n&quot;);</span><br><span class="line">        if(read(fd,buf,30) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;filed_read\r\n&quot;);</span><br><span class="line">            goto filed_read;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;buf = [%s]\r\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line">    filed_read:</span><br><span class="line">    close(fd);</span><br><span class="line">    filed_fork:</span><br><span class="line">    filed_open:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-7、进程的挂起"><a href="#1-7、进程的挂起" class="headerlink" title="1-7、进程的挂起"></a>1-7、进程的挂起</h2><pre><code>    进程在一段时间内没有任何的动作，称为进程的挂起。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line">unsigned int sleep(unsigned int seconds);</span><br><span class="line"> 功能：进程在一定的时间内没有任何动作，称为进程的挂起（进程处于等待态）</span><br><span class="line">参数：</span><br><span class="line"> seconds：指定要挂起的秒数</span><br><span class="line"> 返回值：</span><br><span class="line"> 若进程挂起到sec指定的时间则返回0，若有信号中断则返回剩余秒数</span><br><span class="line"> 注意：</span><br><span class="line"> 进程挂起指定的秒数后程序并不会立即执行，系统只是将此进程切换到就绪态</span><br></pre></td></tr></table></figure><h2 id="1-8、进程的等待"><a href="#1-8、进程的等待" class="headerlink" title="1-8、进程的等待"></a>1-8、进程的等待</h2><pre><code>Linux进程有时候需要简单的进程之间的同步，如父进程等待子进程的结束。</code></pre><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/wait.h&gt;</span><br><span class="line"> pid_t wait(int *status);</span><br><span class="line"> 功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line"> 调用wait函数的进程会挂起，直到它的一个子进程退出或收到一个不能被忽视的信号时才</span><br><span class="line">被唤醒。</span><br><span class="line">若调用进程没有子进程或它的子进程已经结束，该函数立即返回。</span><br><span class="line">参数：</span><br><span class="line">status：函数返回时，参数status中包含子进程退出时的状态信息。</span><br><span class="line">子进程的退出信息在一个int中包含了多个字段，</span><br><span class="line"> 用宏定义可以取出其中的每个字段</span><br><span class="line"> 子进程可以通过exit或者_exit函数发送退出状态</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：子进程的进程号。</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>取出子进程的退出信息WIFEXITED(status)如果子进程是正常终止的，取出的字段值非零。WEXITSTATUS(status)返回子进程的退出状态，退出状态保存在status变量的8~16位。在用此宏前应先用宏WIFEXITED判断子进程是否正常退出，正常退出才可以使用此宏。注意：此status是个wait的参数指向的整型变量。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    pid=fork();</span><br><span class="line">    if(pid&lt;0)</span><br><span class="line">     &#123;</span><br><span class="line">    perror(&quot;fail to fork&quot;);</span><br><span class="line">    return ‐1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i=0;i&lt;5;i++)</span><br><span class="line">         &#123;</span><br><span class="line">          printf(&quot;this is son process\n&quot;);</span><br><span class="line">         sleep(1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         //使用exit退出当前进程并设置退出状态</span><br><span class="line">         exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">//使用wait在父进程中阻塞等待子进程的退出</span><br><span class="line"> //不接收子进程的退出状态</span><br><span class="line"> //wait(NULL);</span><br><span class="line"></span><br><span class="line"> //接收子进程的退出状态，子进程中必须使用exit或者_exit函数退出进程是发送退出状态</span><br><span class="line">    int status = 0;</span><br><span class="line">    wait(&amp;status);</span><br><span class="line"></span><br><span class="line">    if(WIFEXITED(status) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">     printf(&quot;The son process return status: %d\n&quot;, WEXITSTATUS(status));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;this is father process\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/wait.h&gt;</span><br><span class="line"> pid_t waitpid(pid_t pid, int *status,int options)</span><br><span class="line"> 功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源。</span><br><span class="line"> 参数：</span><br><span class="line"> pid：指定的进程或者进程组</span><br><span class="line"> pid&gt;0：等待进程ID等于pid的子进程。</span><br><span class="line"> pid=0：等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid</span><br><span class="line">不会等待它。</span><br><span class="line">pid=‐1：等待任一子进程，此时waitpid和wait作用一样。</span><br><span class="line"> pid&lt;‐1：等待指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值</span><br><span class="line"> status：保存子进程退出时的状态信息</span><br><span class="line"> options：选项</span><br><span class="line"> 0：同wait，阻塞父进程，等待子进程退出。</span><br><span class="line"> WNOHANG：没有任何已经结束的子进程，则立即返回。</span><br><span class="line"> WUNTRACED：如果子进程暂停了则此函数马上返回，并且不予以理会子进程的结束状态。</span><br><span class="line">（跟踪调试，很少用到）</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回状态改变了的子进程的进程号；如果设置了选项WNOHANG并且pid指定的进程存</span><br><span class="line">在则返回0。</span><br><span class="line"> 失败：返回‐1。当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进</span><br><span class="line">程，waitpid就会出错返回，这时errno被设置为ECHILD。</span><br><span class="line"></span><br><span class="line"> wait(status) &lt;==&gt; waitpid(‐1, status, 0)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">     pid=fork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        return ‐1;</span><br><span class="line">        &#125;</span><br><span class="line">     if(pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(i=0;i&lt;5;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;this is son process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">        exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">     else</span><br><span class="line">        &#123;</span><br><span class="line">        waitpid(pid, NULL, 0);</span><br><span class="line">        printf(&quot;this is father process\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">两个函数</span><br><span class="line">wait（）、waitpid（）</span><br><span class="line">如果父进程先结束，会打印终端提示符</span><br><span class="line">有返回值。</span><br><span class="line">子进程可以通过exit和_exit发送退出状态。</span><br><span class="line">也可以用宏来取出子进程的退出信息</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">如果子进程是正常终止的，取出的字段值非零。</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">返回子进程的退出状态，退出状态保存在status变量8~16位。在</span><br><span class="line">使用前先用宏判断WIFEXITED判断子进程是否正常退出，正常退</span><br><span class="line">出才能使用此宏</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><pre><code>两个函数都可以回收子进程的资源</code></pre><h4 id="特殊进程"><a href="#特殊进程" class="headerlink" title="特殊进程"></a>特殊进程</h4><pre><code>僵尸进程    子进程已经运行结束，    父进程没有wait或者waitpid。    进行子进程资源的回收，就称为僵尸进程。孤儿进程    父进程运行结束，但子进程未运行结束的进程。守护进程（精灵进程）    守护进程是个特殊的孤儿进程，这种进程脱离了终端，在后台运行。</code></pre><h2 id="1-9、进程的终止"><a href="#1-9、进程的终止" class="headerlink" title="1-9、进程的终止"></a>1-9、进程的终止</h2><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void _exit(int status);</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">一般失败退出设置为非0</span><br><span class="line">一般成功退出设置为0</span><br><span class="line">返回值：</span><br><span class="line">无</span><br></pre></td></tr></table></figure><h3 id="exit函数-1"><a href="#exit函数-1" class="headerlink" title="_exit函数"></a>_exit函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void exit(int status);</span><br><span class="line">功能：退出当前进程</span><br><span class="line">参数：</span><br><span class="line">status：退出状态，由父进程通过wait函数接收这个状态</span><br><span class="line">一般失败退出设置为非0</span><br><span class="line">一般成功退出设置为0</span><br><span class="line">返回值：</span><br><span class="line">无</span><br></pre></td></tr></table></figure><h3 id="exit和-exit函数的区别："><a href="#exit和-exit函数的区别：" class="headerlink" title="exit和_exit函数的区别："></a>exit和_exit函数的区别：</h3><pre><code>exit为库函数，而_exit为系统调用exit会刷新缓冲区，但是_exit不会刷新缓冲区一般会使用exit</code></pre><p><img src="https://img-blog.csdnimg.cn/a4d7e16325c34ebc9b04e7c95b59f99a.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void myfun()</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;nihao beijing&quot;);</span><br><span class="line"></span><br><span class="line">   //使用return</span><br><span class="line">   //return除了可以返回值以外，在主函数中使用可以退出进程，但是在子函数中使用只能退出当前函数</span><br><span class="line">   //return ;</span><br><span class="line"></span><br><span class="line">   //使用exit</span><br><span class="line">   //exit可以退出一个进程并且可以刷新缓冲区</span><br><span class="line">   //exit(0);</span><br><span class="line"></span><br><span class="line">   //使用_exit</span><br><span class="line">   //_exit可以退出一个进程，但是不会刷新缓冲区</span><br><span class="line">   _exit(0);</span><br><span class="line"></span><br><span class="line">   printf(&quot;welcome to 1000phone\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;hello world\n&quot;);</span><br><span class="line">   </span><br><span class="line">   myfun();</span><br><span class="line">   </span><br><span class="line">   printf(&quot;hello kitty\n&quot;);</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>return是退出函数，并不是退出进程</code><br><code>exit为退出当前的进程</code></p><pre><code>Linux下可以通过 ：void  exit(int value)void _exit(int value)区别在于：exit为库函数，exit为系统调用在文章《进程的退出及错误打印》中有具体用法。</code></pre><h2 id="1-10、进程退出清理"><a href="#1-10、进程退出清理" class="headerlink" title="1-10、进程退出清理"></a>1-10、进程退出清理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atexit(void (*function)(void));\</span><br><span class="line">功能：注册进程正常结束前调用的函数，进程退出执行注册函数</span><br><span class="line">参数：</span><br><span class="line">function：进程结束前，调用函数的入口地址。</span><br><span class="line">一个进程中可以多次调用atexit函数注册清理函数，</span><br><span class="line">正常结束前调用函数的顺序和注册时的顺序相反</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void clear_fun1(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;perform clear fun1 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_fun2(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;perform clear fun2 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear_fun3(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;perform clear fun3 \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //atexit函数在进程结束时才会去执行参数对应的回调函数</span><br><span class="line">    //atexit多次调用后，执行顺序与调用顺序相反</span><br><span class="line">atexit(clear_fun1);</span><br><span class="line">atexit(clear_fun2);</span><br><span class="line">atexit(clear_fun3);</span><br><span class="line">printf(&quot;process exit 3 sec later!!!\n&quot;);</span><br><span class="line">sleep(3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b68814f5f5eb4ec39f9080f0fb46e9ad.png"></p><h2 id="1-11、进程的创建—vfork"><a href="#1-11、进程的创建—vfork" class="headerlink" title="1-11、进程的创建—vfork"></a>1-11、进程的创建—vfork</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;unistd.h&gt;</span><br><span class="line"> pid_t vfork(void);</span><br><span class="line"> 功能：vfork函数和fork函数一样都是在已有的进程中创建一个新的进程，但它们创建的子</span><br><span class="line">进程是有区别的。</span><br><span class="line"> 参数：</span><br><span class="line"> 无</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功：子进程中返回0,父进程中返回子进程ID</span><br><span class="line"> 失败：‐1。</span><br></pre></td></tr></table></figure><p>fork和vfork函数的区别：<br>vfork保证子进程先运行，<br>在它调用exec或exit之后，<br>父进程才可能被调度运行。<br>vfork和fork一样都创建一个子进程，<br>但它并不将父进程的地址空间完全复制到子进程中，<br>因为子进程会立即调用exec(或exit)，<br>于是也就不访问该地址空间。<br>相反，<br>在子进程中调用exec或exit之前，<br>它在父进程的地址空间中运行，<br>在exec之后子进程会有自己的进程空间。</p><h3 id="1-11-1、子进程在父进程之前运行"><a href="#1-11-1、子进程在父进程之前运行" class="headerlink" title="1-11-1、子进程在父进程之前运行"></a>1-11-1、子进程在父进程之前运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    //使用vfork函数创建完子进程后</span><br><span class="line">    //子进程会先执行，直到子进程执行exit或者exec后，父进程才会执行</span><br><span class="line">     pid = vfork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">         &#123;</span><br><span class="line">         perror(&quot;fail to vfork&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">         &#125;</span><br><span class="line">     if(pid == 0) //子进程的代码区</span><br><span class="line">         &#123;</span><br><span class="line">         int i = 0;</span><br><span class="line">         for(i=0;i&lt;5;i++)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;this is son process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">         exit(0);</span><br><span class="line">         &#125;</span><br><span class="line">     else //父进程代码区</span><br><span class="line">         &#123;</span><br><span class="line">         while(1)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;this is father process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d67846d880bc49958dcdd70667455a9e.png"></p><h3 id="1-11-2、子进程和父进程共享同一块空间"><a href="#1-11-2、子进程和父进程共享同一块空间" class="headerlink" title="1-11-2、子进程和父进程共享同一块空间"></a>1-11-2、子进程和父进程共享同一块空间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int a = 10;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    int b = 9;</span><br><span class="line"></span><br><span class="line">     //使用vfork创建完子进程</span><br><span class="line">     //在子进程执行exit或者exec之前，父子进程共有同一块地址空间</span><br><span class="line">     pid = vfork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to vfork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">     if(pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        printf(&quot;in son process a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">        exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">     else</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;in father process a=%d, b=%d\n&quot;, a, b);</span><br><span class="line">         &#125;</span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0e1498bfe5ac4f01a31dab82088fb695.png"></p><h3 id="1-12、-进程的替换"><a href="#1-12、-进程的替换" class="headerlink" title="1-12、 进程的替换"></a>1-12、 进程的替换</h3><pre><code>进程的替换：exec函数族，是由六个exec函数组成的。1、exec函数族提供了六种在进程中启动另一个程序的方法。2、exec函数族可以根据指定的文件名或目录名找到可执行文件。3、调用exec函数的进程并不创建新的进程，故调用exec前后，进程的进程号并不会改变，其执行的程序完全由新的程序替换，而新程序则从其main函数开始执行。exec函数族取代调用进程的数据段、代码段和堆栈段。</code></pre><p><img src="https://img-blog.csdnimg.cn/973727ddf1a7421f986e2596b3f6a774.png"></p><pre><code>一个进程调用exec后，除了进程ID，进程还保留了下列特征不变：父进程号进程组号控制终端根目录当前工作目录进程信号屏蔽集未处理信号...</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">exec函数族</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int execl(const char *path, const char *arg, .../* (char *) NULL */);</span><br><span class="line">int execlp(const char *file, const char *arg, .../* (char *) NULL */);</span><br><span class="line">int execv(const char *path, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execle(const char *path, const char *arg, .../*, (char *) NULL*/, cha</span><br><span class="line">* const envp[] );</span><br><span class="line">int execvpe(const char *file, char *const argv[], char *const envp[]);</span><br><span class="line">功能：在一个进程里面执行另一个程序，主要用于执行命令</span><br><span class="line"> 参数：</span><br><span class="line"> path：命令或者程序的路径</span><br><span class="line"> l：如果是带l的函数，对应的命令或者程序是通过每一个参数进行传</span><br><span class="line"> 递的，最后一个为NULL表示结束</span><br><span class="line"> 例如：&quot;ls&quot;, &quot;‐l&quot;, NULL</span><br><span class="line"> v:如果是带v的函数，对应的命令或者程序是通过一个指针数组来传递的，</span><br><span class="line"> 指针数组的最后一个元素为NULL标识结束</span><br><span class="line"> char *str[] = &#123;&quot;ls&quot;, &quot;‐l&quot;, NULL&#125;;</span><br><span class="line"> p：如果是不带p的函数，第一个参数必须传当前命令或者程序的绝对路径，</span><br><span class="line"> 如果是带p的函数，第一个参数既可以是绝对路径，也可以是相对路径</span><br><span class="line"> 返回值：</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>案例：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">   &#123;</span><br><span class="line">   pid_t pid;</span><br><span class="line">    if((pid = fork()) &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">       perror(&quot;fail to fork&quot;);</span><br><span class="line">       exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    else if(pid &gt; 0) //父进程</span><br><span class="line">       &#123;</span><br><span class="line">       printf(&quot;This is parent process\n&quot;);</span><br><span class="line"></span><br><span class="line">       wait(NULL);</span><br><span class="line">       printf(&quot;The child process has quited\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">    else //子进程</span><br><span class="line">       &#123;</span><br><span class="line">       printf(&quot;This is child process\n&quot;);</span><br><span class="line"></span><br><span class="line">       //调用exec函数族中的函数，执行其他命令或者程序</span><br><span class="line">       //查看命令的路径：whereis 命令或者which 命令</span><br><span class="line"></span><br><span class="line">       //***************exec函数族调用shell命令******************</span><br><span class="line">       //不带p的函数，命令的路径一定要用绝对路径</span><br><span class="line">       #if 0</span><br><span class="line">       if(execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execl&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       //带p的函数，第一个参数既可以是相对路径，也可以是绝对路径</span><br><span class="line">       #if 0</span><br><span class="line">       if(execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execlp&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       //带v的函数需要使用指针数组来传递</span><br><span class="line">       #if 0</span><br><span class="line">       char *str[] = &#123;&quot;ls&quot;, &quot;-l&quot;, NULL&#125;;</span><br><span class="line">       if(execv(&quot;/bin/ls&quot;, str) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execv&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line">       //***************exec函数族调用可执行文件******************</span><br><span class="line">       #if 0</span><br><span class="line">       if(execlp(&quot;./hello&quot;, &quot;./hello&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execlp&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       #if 0</span><br><span class="line">       if(execl(&quot;./hello&quot;, &quot;./hello&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execl&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       //***************exec函数族调用shell脚本******************</span><br><span class="line">       #if 1</span><br><span class="line">       if(execlp(&quot;./myshell.sh&quot;, &quot;./myshell.sh&quot;, NULL) == -1)</span><br><span class="line">           &#123;</span><br><span class="line">           perror(&quot;fail to execl&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">           &#125;</span><br><span class="line">       #endif</span><br><span class="line">       //exec函数族取代调用进程的数据段、代码段和堆栈段</span><br><span class="line">       //所以当exec函数执行完毕后，当前进程就结束了，所以原本进程中的代码不会再执行</span><br><span class="line">       printf(&quot;hello world\n&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-13、system函数"><a href="#1-13、system函数" class="headerlink" title="1-13、system函数"></a>1-13、system函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int system(const char *command);</span><br><span class="line">功能：执行一个shell命令（shell命令、可执行文件、shell脚本）</span><br><span class="line">system会调用fork函数产生子进程，</span><br><span class="line">子进程调用exec启动/bin/sh ‐c string</span><br><span class="line">来执行参数string字符串所代表的命令，</span><br><span class="line">此命令执行完后返回原调用进程</span><br><span class="line">参数：</span><br><span class="line">command：要执行的命令的字符串</span><br><span class="line">返回值：</span><br><span class="line">如果command为NULL，则system()函数返回非0，一般为1。</span><br><span class="line">如果system()在调用/bin/sh时失败则返回127，其它失败原因返回‐1</span><br></pre></td></tr></table></figure><p><code> 此命令执行完后返回原调用进程</code><br><code>与exec区别</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用system执行shell命令</span><br><span class="line">system(&quot;clear&quot;);</span><br><span class="line">system(&quot;ls -l&quot;);</span><br><span class="line"></span><br><span class="line"> system(&quot;./hello&quot;);</span><br><span class="line"></span><br><span class="line"> system(&quot;./myshell.sh&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="2、进程之间的通信"><a href="#2、进程之间的通信" class="headerlink" title="2、进程之间的通信"></a>2、进程之间的通信</h1><pre><code>进程间通信(IPC:Inter Processes Communication)进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源（例如打开的文件描述符）。进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信。进程间通信功能：数据传输：一个进程需要将它的数据发送给另一个进程。资源共享：多个进程之间共享同样的资源。通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事件。进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程。希望能够拦截另一个进程的所有操作，并能够及时知道它的状态改变。Linux操作系统支持的主要进程间通信的通信机制</code></pre><p><img src="https://img-blog.csdnimg.cn/8adbe4a0ff9448c292b9ab5c01444216.png"></p><pre><code>进程间通信的实质：系统只要创建一个进程，就会给当前进程分配4G的虚拟内存（32位操作系统），虚拟内存不是常说的内存条的空间，内存条的空间称之为物理内存，虚拟内存和物理内存之间存在映射关系4G的虚拟内存分为3G的用户空间（0~3G）和1G（3~4G）的内核空间，用户空间是进程所私有的，每一个进程的用户空间只能自己访问和使用，我们之前说的栈区、堆区、数据区、代码区等都是用户空间的区域内核空间是所有进程所公有的，也就意味着绝大多数进程间通信方式，本质就是对内核空间的操作特殊的进程间通信方式：socket通信可以实现不同主机的进程间通信，其他六个只能在一台主机的多个进程间通信信号通信是唯一的一种异步通信机制共享内存是所有进程间通信方式中效率最高的，他是直接对物理内存进行操作。</code></pre><h2 id="2-1、信号"><a href="#2-1、信号" class="headerlink" title="2-1、信号"></a>2-1、信号</h2><h3 id="2-1-1、信号的概念："><a href="#2-1-1、信号的概念：" class="headerlink" title="2-1-1、信号的概念："></a>2-1-1、信号的概念：</h3><pre><code>信号是软件中断，    它是在软件层次上对中断机制的一种模拟。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。信号是一种异步通信方式。进程不必等待信号的到达，进程也不知道信号什么时候到达。信号可以直接进行用户空间进程和内核空间进程的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。每个信号的名字都以字符SIG开头。每个信号和一个数字编码相对应，在头文件signum.h中，这些信号都被定义为正整数。信号名定义路径：/usr/include/i386-linux-gnu/bits/signum.h （ubuntu12.04）/usr/include/x86_64-linux-gnu/bits/signum.h （ubuntu16.04）在Linux下，要想查看这些信号和编码的对应关系，可使用命令：kill ­l</code></pre><p><img src="https://img-blog.csdnimg.cn/e269e821a6e8410ab1acd346462fdd12.png"></p><pre><code>信号是由当前系统已经定义好的一些标识，每一个标识都会在特定的场合使用并且都会对进程有一定的影响，当信号产生时，会让当前信号做出相应的操作这些信号都是已经定义好的，我们不能自己再去创造，直接使用这些就可以。</code></pre><h3 id="2-1-2-产生信号的方式"><a href="#2-1-2-产生信号的方式" class="headerlink" title="2.1.2 产生信号的方式"></a>2.1.2 产生信号的方式</h3><pre><code>1、当用户按某些终端键时，将产生信号例如：终端上按“Ctrl+c”组合键通常产生中断信号SIGINT、终端上按&quot;Ctrl+\&quot;键通常产生中断信号SIGQUIT、终端上按&quot;Ctrl+z&quot;键通常产生中断信号SIGSTOP。2、硬件异常将产生信号除数为0，无效的内存访问等。这些情况通常由硬件检测到，并通知内核,然后内核产生适当的信号发送给相应的进程。3、软件异常将产生信号。当检测到某种软件条件已发生，并将其通知有关进程时，产生信号。4、调用kill函数将发送信号。注意：接收信号进程和发送信号进程的所有者必须相同，或发送信号进程的所有者必须是超级用户。5、运行kill命令将发送信号。此程序实际上是使用kill函数来发送信号。也常用此命令终止一个失控的后台进程。</code></pre><h3 id="2-1-3-信号的默认（缺省）处理方式"><a href="#2-1-3-信号的默认（缺省）处理方式" class="headerlink" title="2-1-3 信号的默认（缺省）处理方式"></a>2-1-3 信号的默认（缺省）处理方式</h3><pre><code>当进程中产生了一个信号，就会让当前进程做出一定的反应，默认处理进程的方式如下1、终止进程：当信号产生后，当前进程就会立即结束。2、缺省处理：当信号产生后，当前进程不做任何处理。3、停止进程：当信号产生后，使得当前进程停止。4、让停止的进程回复运行：当信号产生后，停止的进程会回复执行（后台进程）。注意：每一个信号只有一个默认的处理方式</code></pre><h3 id="2-1-4-进程接收到信号后的处理方式"><a href="#2-1-4-进程接收到信号后的处理方式" class="headerlink" title="2-1-4 进程接收到信号后的处理方式"></a>2-1-4 进程接收到信号后的处理方式</h3><pre><code>1、执行系统默认动作对大多数信号来说，系统默认动作是用来终止该进程。2、忽略此信号接收到此信号后没有任何动作。3、执行自定义信号处理函数用用户定义的信号处理函数处理该信号。注意：SIGKILL和SIGSTOP这两个信号只能以默认的处理方式执行，不能忽略也不能自定义</code></pre><h3 id="2-1-5-常见的信号"><a href="#2-1-5-常见的信号" class="headerlink" title="2-1-5 常见的信号"></a>2-1-5 常见的信号</h3><pre><code>信号 值 性质 默认处理方式SIGKILL 9 当产生这个信号后，当前进程会退出，不能被缺省和捕捉退出进程SIGSTOP 19 当产生这个信号后，当前进程会停止，不能被缺省和捕捉停止进程SIGINT 2 键盘输入ctrl+c时产生信号 退出进程SIGQUIT 3  键盘输入ctrl+\时产生信号 退出进程SIGTSTP 20 键盘输入ctrl+z时产生信号 停止进程SIGCONT 18 当产生当前信号后，当前停止的进程会恢复运行停止的进程恢复运行SIGALRM 14 当调用alarm函数设置的时间到达时会产生当前信号退出进程SIGPIPE 13 当管道破裂时，会产生当前信号 退出进程SIGABRT 6 当调用abort函数时会产生当前信号 退出进程SIGCHLD 17当使用fork创建一个子进程时，如果子进程状态改变（退出），会产生当前信号缺省SIGUSR1 10用户自定义信号，不会自动产生，只能使用kill函数或者命令给指定的进程发送当前信号缺省SIGUSR2 12用户自定义信号，不会自动产生，只能使用kill函数或者命令给指定的进程发送当前信号缺省</code></pre><h2 id="2-2、-kill函数"><a href="#2-2、-kill函数" class="headerlink" title="2-2、 kill函数"></a>2-2、 kill函数</h2><pre><code>kill并不是杀死的意思，是表示对进程发送一个信号。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int kill(pid_t pid, int sig);</span><br><span class="line">功能：给指定的进程或者进程组发送信号</span><br><span class="line">参数：</span><br><span class="line">pid：</span><br><span class="line">pid&gt;0: 将信号传送给进程ID为pid的进程。</span><br><span class="line">pid=0: 将信号传送给当前进程所在进程组中的所有进程。</span><br><span class="line">pid=‐1: 将信号传送给系统内所有的进程，除了init进程</span><br><span class="line"> pid&lt;‐1: 将信号传给指定进程组的所有进程。这个进程组号等于pid的绝对值。</span><br><span class="line"> sig：指定的信号</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">     pid = fork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">     else if(pid &gt; 0) //父进程的代码区</span><br><span class="line">        &#123;</span><br><span class="line">        while(1)</span><br><span class="line">            &#123;</span><br><span class="line">            printf(&quot;This is parent peocess\n&quot;);</span><br><span class="line"></span><br><span class="line">            sleep(1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     else //子进程的代码区</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;This is son process\n&quot;);</span><br><span class="line"></span><br><span class="line">         //子进程在3秒之后，让父进程退出</span><br><span class="line">         sleep(3);</span><br><span class="line"></span><br><span class="line">         //使用kill给父进程发送信号，然后父进程接收到信号后直接退出就可以了</span><br><span class="line">         kill(getppid(), SIGINT);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/795cc297eb924527a0d4b55d98a7f663.png"></p><h2 id="2-3、alarm函数"><a href="#2-3、alarm函数" class="headerlink" title="2-3、alarm函数"></a>2-3、alarm函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">功能：定时器，闹钟，当设定的时间到达时，会产生SIGALRM信号</span><br><span class="line">参数：</span><br><span class="line">seconds：设定的秒数</span><br><span class="line">返回值：</span><br><span class="line">如果alarm函数之前没有alarm设置，则返回0</span><br><span class="line">如果有，则返回上一个alarm剩余的时间</span><br></pre></td></tr></table></figure><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    unsigned int sec;</span><br><span class="line">    //当执行到alarm之后，代码会接着往下执行，当设定的时间到后，会产生SIGALRM信号</span><br><span class="line"></span><br><span class="line">    //如果alarm之前没有设置其他闹钟，则返回0，如果之前设置了，则返回之前剩余的秒数</span><br><span class="line">    //如果一个程序中出现多个alarm闹钟，第一个如果没有到达指定的时间就遇到第二个</span><br><span class="line">    //则第一个的闹钟时间清除，按照第二个alarm闹钟的时间继续向下运行</span><br><span class="line"></span><br><span class="line">    sec = alarm(5);</span><br><span class="line">    printf(&quot;sec = %d\n&quot;, sec);</span><br><span class="line"></span><br><span class="line">    sleep(3);</span><br><span class="line"></span><br><span class="line">    sec = alarm(6);</span><br><span class="line">    printf(&quot;sec = %d\n&quot;, sec);</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/11e68407338a438dadc496a5c0a27840.png"></p><pre><code>第二个定时被重重了，剩余时间被清楚，按照第二个的时间进行。</code></pre><h2 id="2-4、-raise函数"><a href="#2-4、-raise函数" class="headerlink" title="2-4、 raise函数"></a>2-4、 raise函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int raise(int sig);</span><br><span class="line">功能：给调用进程本身发送信号</span><br><span class="line">参数：</span><br><span class="line">sig：指定的信号</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br><span class="line"> raise(sig) &lt;==&gt; kill(getpid(), sig)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;  </span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    num++;</span><br><span class="line">    </span><br><span class="line">    //当循环执行5秒后，进程退出</span><br><span class="line">    if(num == 5)</span><br><span class="line">        &#123;</span><br><span class="line">        //使用raise给当前进程本身发送信号</span><br><span class="line">        raise(SIGALRM);</span><br><span class="line">        //kill(getpid(), SIGALRM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/89c4cd241f1a49c3a20ee6f8bfead789.png"></p><h2 id="2-5、-abort函数"><a href="#2-5、-abort函数" class="headerlink" title="2-5、 abort函数"></a>2-5、 abort函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line">void abort(void);</span><br><span class="line">功能：向进程发送一个SIGABRT信号，默认情况下进程会退出。</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><pre><code>注意：即使SIGABRT信号被加入阻塞集，一旦进程调用了abort函数，进程也还是会被终止，且在终止前会刷新缓冲区，关闭文件描述符。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> sleep(1);</span><br><span class="line"> num++;</span><br><span class="line"></span><br><span class="line"> //当循环执行5秒后，进程退出</span><br><span class="line"> if(num == 5)</span><br><span class="line"> &#123;</span><br><span class="line"> abort();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/de5d4268dab149dd9d345800bbebe841.png"></p><h2 id="2-6、-pause函数"><a href="#2-6、-pause函数" class="headerlink" title="2-6、 pause函数"></a>2-6、 pause函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pause(void);</span><br><span class="line">功能：阻塞等待一个信号的产生</span><br><span class="line">参数：</span><br><span class="line">无</span><br><span class="line">返回值：</span><br><span class="line">当有信号产生时，函数返回‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">    &#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">     pid = fork();</span><br><span class="line">     if(pid &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to fork&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">     else if(pid &gt; 0) //父进程的代码区</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;This is parent peocess\n&quot;);</span><br><span class="line"></span><br><span class="line">        //使用pause阻塞等待捕捉信号</span><br><span class="line">        pause();</span><br><span class="line">        &#125;</span><br><span class="line">     else //子进程的代码区</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;This is son process\n&quot;);</span><br><span class="line"></span><br><span class="line">         sleep(3);</span><br><span class="line"></span><br><span class="line">         kill(getppid(), SIGINT);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     return 0;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c8ee20ea2daf42269e0a729f4d209956.png"></p><h2 id="2-7、-signal函数"><a href="#2-7、-signal函数" class="headerlink" title="2-7、 signal函数"></a>2-7、 signal函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void (*signal(int sig, void (*func)(int)))(int);</span><br><span class="line">‐‐&gt;</span><br><span class="line">typedef void (*sighandler_t)(int);</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="line">功能：当进程中产生某一个信号时，对当前信号进行处理</span><br><span class="line">参数：</span><br><span class="line">sig：指定要处理的信号                                                                                                                                                                                                                                                                                                                                                                                                                                                </span><br><span class="line">handler：处理方式</span><br><span class="line"> SIG_IGN 当信号产生时，以缺省（忽略）的方式处理</span><br><span class="line"> SIG_DFL 当信号产生时，以当前信号默认的方式处理</span><br><span class="line"> void handler(int sig)：当信号产生时，通过信号处</span><br><span class="line"> 理函数自定义方式处理，函数名可以随便写，</span><br><span class="line"> 参数表示当前的信号</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回函数地址，该地址为此信号上一次注册的信号处理函数的地址</span><br><span class="line"> 失败：SIG_ERR</span><br></pre></td></tr></table></figure><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void handler(int sig);</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //以默认的方式处理信号</span><br><span class="line"> #if 0</span><br><span class="line"> if(signal(SIGINT, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGQUIT, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGTSTP, SIG_DFL) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //以忽略的方式来处理信号</span><br><span class="line"> #if 0</span><br><span class="line"> if(signal(SIGINT, SIG_IGN) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGQUIT, SIG_IGN) == SIG_ERR)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to signal&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> if(signal(SIGTSTP, SIG_IGN) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //注意：SIGKILL和SIGSTOP这两个信号只能以默认的方式处理，不能忽略或者捕捉</span><br><span class="line"> // if(signal(SIGKILL, SIG_IGN) == SIG_ERR)</span><br><span class="line"> // &#123;</span><br><span class="line"> // perror(&quot;fail to signal&quot;);</span><br><span class="line"> // exit(1);</span><br><span class="line"> // &#125;</span><br><span class="line"></span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //以用户自定义方式处理信号</span><br><span class="line"> #if 1</span><br><span class="line"> if(signal(SIGINT, handler) == SIG_ERR)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to signal&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> if(signal(SIGQUIT, handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(signal(SIGTSTP, handler) == SIG_ERR)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to signal&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> #endif</span><br><span class="line"> while(1)</span><br><span class="line">     &#123;</span><br><span class="line">     printf(&quot;hello world\n&quot;);</span><br><span class="line">     sleep(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void handler(int sig)</span><br><span class="line"> &#123;</span><br><span class="line"> if(sig == SIGINT)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;SIGINT正在处理\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> if(sig == SIGQUIT)</span><br><span class="line">     &#123;</span><br><span class="line">     printf(&quot;SIGQUIT正在处理\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> if(sig == SIGTSTP)</span><br><span class="line">     &#123;</span><br><span class="line">     printf(&quot;SIGTSTP正在处理\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><pre><code>返回值</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *ret_handler;</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;**********************\n&quot;);</span><br><span class="line">    printf(&quot;nihao beijing\n&quot;);</span><br><span class="line">     printf(&quot;welcome to 1000phone\n&quot;);</span><br><span class="line">     printf(&quot;**********************\n&quot;);</span><br><span class="line"></span><br><span class="line">     if(signal(SIGINT, ret_handler) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if((ret_handler = signal(SIGINT, handler)) == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to signal&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>signal的返回值返回的是当前处理方式的上一次处理的方式</code></p><p><img src="https://img-blog.csdnimg.cn/904ada98e3c446d38cbdc8f4815180d9.png"></p><h2 id="2-8、-可重入函数"><a href="#2-8、-可重入函数" class="headerlink" title="2-8、 可重入函数"></a>2-8、 可重入函数</h2><pre><code>可重入函数是指函数可以由多个任务并发使用，而不必担心数据错误。可重入函数就是可以被中断的函数，当前函数可以在任何时刻中断它，并执行另一块代码，当执行完毕后，回到原本的代码还可以正常继续运行。编写可重入函数：1、不使用（返回）静态的数据、全局变量（除非用信号量互斥）。2、不调用动态内存分配、释放的函数。3、不调用任何不可重入的函数（如标准I/O函数）。注：    即使信号处理函数使用的都是可重入函数（常见的可重入函数），也要注意进入处理函数时，首先要保存errno的值，结束时，再恢复原值。因为，信号处理过程中，errno值随时可能被改变。</code></pre><p><img src="https://img-blog.csdnimg.cn/e51ee614616843a9b2cd90b4b117b20f.png"></p><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void handler(int sig)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;SIGINT\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> signal(SIGINT, handler);</span><br><span class="line"></span><br><span class="line"> //案例1：</span><br><span class="line"> #if 0</span><br><span class="line"> //sleep是一个可重入函数，但是当执行信号处理函数之后，不会回到原本的位置继续睡眠</span><br><span class="line"> //sleep(10);</span><br><span class="line"></span><br><span class="line"> //alarm函数是一个可重入函数，当他执行时，如果有信号产生并执行信号处理函数，执行完毕后，会继续运行</span><br><span class="line"> alarm(10);</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //案例2：</span><br><span class="line"> #if 1</span><br><span class="line"> char buf[32] = &quot;&quot;;</span><br><span class="line"></span><br><span class="line"> //read也是一个可重入函数，在等待终端输入时，如果产生信号并执行信号处理函数，信号处理</span><br><span class="line"> //函数执行完毕后，可以继续输入数据，read可以读取到信号处理函数之后的数据</span><br><span class="line"> if(read(0, buf, 20) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to read&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> #endif</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f62086f379844a1f8c3522109488117c.png"></p><h2 id="2-9、-信号集"><a href="#2-9、-信号集" class="headerlink" title="2-9、 信号集"></a>2-9、 信号集</h2><pre><code>信号集概述一个用户进程常常需要对多个信号做出处理。为了方便对多个信号进行处理，在Linux系统中引入了信号集。信号集是用来表示多个信号的数据类型。信号集数据类型sigset_t定义路径：/usr/include/i386-linux-gnu/bits/sigset.h (ubuntu 12.04)/usr/include/x86_64-linux-gnu/bits/sigset.h (ubuntu16.04)</code></pre><p>信号集相关的操作主要有如下几个函数：<br><code>sigemptyset</code><br><code>sigfillset</code><br><code>sigismember</code><br><code>sigaddset</code><br><code>sigdelset</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">1 ‐‐ sigemptyset()</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigemptyset(sigset_t *set)；</span><br><span class="line">功能：</span><br><span class="line">初始化由set指向的信号集，清除其中所有的信号即初始化一个空信号集。</span><br><span class="line">参数：</span><br><span class="line">set：信号集标识的地址，以后操作此信号集，对set进行操作就可以了。</span><br><span class="line">返回值:</span><br><span class="line">成功返回 0</span><br><span class="line"> 失败返回 ‐1</span><br><span class="line"></span><br><span class="line"> 2 ‐‐ sigfillset()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigfillset(sigset_t *set)；</span><br><span class="line"> 功能：</span><br><span class="line"> 初始化信号集合set, 将信号集合设置为所有信号的集合。</span><br><span class="line"> 参数：</span><br><span class="line"> 信号集标识的地址，以后操作此信号集，对set进行操作就可以了。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功返回 0</span><br><span class="line"> 失败返回 ‐1</span><br><span class="line"></span><br><span class="line"> 3 ‐‐ sigismember()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigismember(const sigset_t *set,int signum);</span><br><span class="line"> 功能：</span><br><span class="line"> 查询signum标识的信号是否在信号集合set之中。</span><br><span class="line"> 参数：</span><br><span class="line"> set：信号集标识符号的地址。</span><br><span class="line"> signum：信号的编号。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功：在信号集中返回 1，不在信号集中返回 0</span><br><span class="line"> 错误：返回 ‐1</span><br><span class="line"></span><br><span class="line"> 4 ‐‐ sigaddset()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigaddset(sigset_t *set, int signum);</span><br><span class="line"> 功能：</span><br><span class="line"> 将信号signum加入到信号集合set之中。</span><br><span class="line"> 参数：</span><br><span class="line"> set：信号集标识的地址。</span><br><span class="line"> signum：信号的编号。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功返回 0</span><br><span class="line"> 失败返回 ‐1</span><br><span class="line"></span><br><span class="line"> 5 ‐‐ sigdelset()</span><br><span class="line"> #include &lt;signal.h&gt;</span><br><span class="line"> int sigdelset(sigset_t *set, int signum);</span><br><span class="line"> 功能：</span><br><span class="line"> 将signum所标识的信号从信号集合set中删除。</span><br><span class="line"> 参数：</span><br><span class="line"> set：信号集标识的地址。</span><br><span class="line"> signum：信号的编号。</span><br><span class="line"> 返回值:</span><br><span class="line"> 成功：返回 0</span><br><span class="line"> 失败：返回 ‐1</span><br></pre></td></tr></table></figure><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//创建一个信号集</span><br><span class="line">sigset_t set;</span><br><span class="line">int ret = 0;</span><br><span class="line"> //初始化一个空的信号集</span><br><span class="line"> sigemptyset(&amp;set);</span><br><span class="line"></span><br><span class="line"> //判断SIGINT信号是否在信号集中</span><br><span class="line"> ret = sigismember(&amp;set, SIGINT);</span><br><span class="line"> if(ret == 0)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;SIGINT is not a member of sigprocmask \nret = %d\n&quot;, ret);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //将指定的信号添加到信号集中</span><br><span class="line"> sigaddset(&amp;set, SIGINT);</span><br><span class="line"> sigaddset(&amp;set, SIGQUIT);</span><br><span class="line"></span><br><span class="line"> ret = sigismember(&amp;set, SIGINT);</span><br><span class="line"> if(ret == 1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;SIGINT is a member of sigprocmask \nret = %d\n&quot;, ret);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cb2ac531866940e89756cea0449adbe6.png"></p><h2 id="2-10、-信号阻塞集"><a href="#2-10、-信号阻塞集" class="headerlink" title="2-10、 信号阻塞集"></a>2-10、 信号阻塞集</h2><pre><code>每个进程都有一个阻塞集，它用来描述哪些信号递送到该进程的时候被阻塞(在信号发生时记住它，直到进程准备好时再将信号通知进程)。所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)；</span><br><span class="line">功能：检查或修改信号阻塞集，根据how指定的方法对进程的阻塞集合进行修改，新的信号阻塞集由set指定，而原先的信号阻塞集合由oldset保存。</span><br><span class="line">参数：</span><br><span class="line">how：信号阻塞集合的修改方法。</span><br><span class="line">SIG_BLOCK：向信号阻塞集合中添加set信号集</span><br><span class="line">SIG_UNBLOCK：从信号阻塞集合中删除set集合</span><br><span class="line">SIG_SETMASK：将信号阻塞集合设为set集合</span><br><span class="line">set：要操作的信号集地址。</span><br><span class="line">oldset：保存原先信号集地址。</span><br><span class="line">注：若set为NULL，则不改变信号阻塞集合，函数只把当前信号阻塞集合保存到oldset中。</span><br><span class="line">返回值:</span><br><span class="line">成功：返回 0</span><br><span class="line">失败：返回 ‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int i=0;</span><br><span class="line"> //创建信号集并在信号集中添加信号</span><br><span class="line"> sigset_t set;</span><br><span class="line"> sigemptyset(&amp;set);</span><br><span class="line"> sigaddset(&amp;set, SIGINT);</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    //将set信号集添加到信号阻塞集中</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;set, NULL);</span><br><span class="line">    for(i=0; i&lt;5; i++)</span><br><span class="line">         &#123;</span><br><span class="line">         printf(&quot;SIGINT signal is blocked\n&quot;);</span><br><span class="line">         sleep(1);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    //将set信号集从信号阻塞集中删除</span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;set, NULL);</span><br><span class="line">    for(i=0; i&lt;5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;SIGINT signal unblocked\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/27abd170ad49469bbee0fe5abfa45a06.png"></p><h1 id="3、管道"><a href="#3、管道" class="headerlink" title="3、管道"></a>3、管道</h1><h2 id="3-1、无名管道概述"><a href="#3-1、无名管道概述" class="headerlink" title="3-1、无名管道概述"></a>3-1、无名管道概述</h2><pre><code>管道(pipe)又称无名管道。无名管道是一种特殊类型的文件，在应用层体现为两个打开的文件描述符。任何一个进程在创建的时候，系统都会 给他分配4G的虚拟内存，分为3G的用户空间和1G的内核空间，内核空间是所有进程公有的，</code></pre><p><code>无名管道就是创建在内核空间的</code>,</p><pre><code>多个进程知道同一个无名管道的空间，就可以利用他来进行通信</code></pre><p><img src="https://img-blog.csdnimg.cn/2b9b0d0acc504faeadb848c73a0b91b1.png"></p><pre><code>无名管道虽然是在内核空间创建的，但是会给当前用户进程两个文件描述符，一个负责执行读操作，一个负责执行写操作。</code></pre><p>管道是最古老的UNIX IPC方式，其特点是:<br>1、半双工，数据在同一时刻只能在一个方向上流动。<br><code>2、数据只能从管道的一端写入，从另一端读出。</code><br>3、写入管道中的数据遵循先入先出的规则。<br>4、管道所传送的数据是无格式的，这要求管道的读出方与写入方必须事先约定好数据的格<br>式，如多少字节算一个消息等。<br><code>5、管道不是普通的文件，不属于某个文件系统，其只存在于内存中。</code><br>6、管道在内存中对应一个缓冲区。不同的系统其大小不一定相同。<br>7、从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写<br>更多的数据。<br><code>8、管道没有名字，只能在具有公共祖先的进程之间使用</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 #include &lt;unistd.h&gt;</span><br><span class="line">2 int pipe(int pipefd[2]);</span><br><span class="line">3 功能：创建一个有名管道，返回两个文件描述符负责对管道进行读写操作</span><br><span class="line">4 参数：</span><br><span class="line">5 pipefd：int型数组的首地址，里面有两个元素</span><br><span class="line">6 pipefd[0] 负责对管道执行读操作</span><br><span class="line">7 pipefd[1] 负责对管道执行写操作</span><br><span class="line">8 返回值：</span><br><span class="line">9 成功：0</span><br><span class="line">10 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>案例</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用pipe创建一个无名管道</span><br><span class="line">int fd_pipe[2];</span><br><span class="line"> if(pipe(fd_pipe) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to pipe&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;fd_pipe[0] = %d\n&quot;, fd_pipe[0]);</span><br><span class="line"> printf(&quot;fd_pipe[1] = %d\n&quot;, fd_pipe[1]);</span><br><span class="line"></span><br><span class="line"> //对无名管道执行读写操作</span><br><span class="line"> //由于无名管道给当前用户进程两个文件描述符，所以只要操作这两个文件</span><br><span class="line"> //描述符就可以操作无名管道，所以通过文件IO中的read和write函数对无名管道进行操作</span><br><span class="line"></span><br><span class="line"> //通过write函数向无名管道中写入数据</span><br><span class="line"> //fd_pipe[1]负责执行写操作</span><br><span class="line"> //如果管道中有数据，再次写入的数据会放在之前数据的后面，不会把之前的数据替换</span><br><span class="line"> if(write(fd_pipe[1], &quot;hello world&quot;, 11) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to write&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> write(fd_pipe[1], &quot;nihao beijing&quot;, strlen(&quot;nihao beijing&quot;)+1);</span><br><span class="line"></span><br><span class="line"> //通过read函数从无名管道中读取数据</span><br><span class="line"> //fd_pipe[0]负责执行读操作</span><br><span class="line"> //读取数据时，直接从管道中读取指定个数的数据，如果管道中没有数据了，则read函数会阻塞等待</span><br><span class="line"> char buf[32] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> if((bytes = read(fd_pipe[0], buf, 20)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to read&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes); </span><br><span class="line"></span><br><span class="line"> bytes = read(fd_pipe[0], buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"></span><br><span class="line"> bytes = read(fd_pipe[0], buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2、-无名管道实现进程间通信"><a href="#3-2、-无名管道实现进程间通信" class="headerlink" title="3-2、 无名管道实现进程间通信"></a>3-2、 无名管道实现进程间通信</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">//使用无名管道实现父子进程间的通信</span><br><span class="line">//由于无名管道创建之后给当前进程两个文件描述符，所以如果是完全不相关的进程</span><br><span class="line">//无法获取同一个无名管道的文件描述符，所以无名管道只能在具有亲缘关系的进程间通信</span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //创建一个无名管道</span><br><span class="line"> int pipefd[2];</span><br><span class="line"> if(pipe(pipefd) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pipe&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //使用fork函数创建子进程</span><br><span class="line"> pid_t pid;</span><br><span class="line"> if((pid = fork()) &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to fork&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> else if(pid &gt; 0) // 父进程</span><br><span class="line">     &#123;</span><br><span class="line">     //父进程负责给子进程发送数据</span><br><span class="line">     char buf[128] = &#123;&#125;;</span><br><span class="line">     while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         fgets(buf, sizeof(buf), stdin);</span><br><span class="line">         buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">        </span><br><span class="line">         if(write(pipefd[1], buf, sizeof(buf)) == -1)</span><br><span class="line">             &#123;</span><br><span class="line">             perror(&quot;fail to write&quot;);</span><br><span class="line">             exit(1);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> else //子进程</span><br><span class="line">     &#123;</span><br><span class="line">     //子进程接收父进程的数据</span><br><span class="line">     char buf[128] = &quot;&quot;;</span><br><span class="line">     while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         if(read(pipefd[0], buf, sizeof(buf)) == -1)</span><br><span class="line">            &#123;</span><br><span class="line">            perror(&quot;fail to read&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         printf(&quot;from parent: %s\n&quot;, buf);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8159d6d1ccf748bfa9e00c3fda9d6b2a.png"></p><pre><code>可以在上面的基础上再创建一个无名管道，两个进程之间进行互相读写操作。注意：利用无名管道实现进程间的通信，都是父进程创建无名管道，然后再创建子进程，子进程继承父进程的无名管道的文件描述符，然后父子进程通过读写无名管道实现通信。</code></pre><h2 id="3-3、无名管道的读写规律"><a href="#3-3、无名管道的读写规律" class="headerlink" title="3-3、无名管道的读写规律"></a>3-3、无名管道的读写规律</h2><h3 id="3-3-1、读写端都存在，只读不写"><a href="#3-3-1、读写端都存在，只读不写" class="headerlink" title="3-3-1、读写端都存在，只读不写"></a>3-3-1、读写端都存在，只读不写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">if(pipe(pipefd) == -1)</span><br><span class="line">&#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只读不写</span><br><span class="line"> //如果管道中有数据，会正常读取数据</span><br><span class="line"> //如果管道中没有数据，则读操作会阻塞等待，直到有数据为止</span><br><span class="line"></span><br><span class="line"> write(pipefd[1], &quot;hello world&quot;, 11);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> if(read(pipefd[0], buf, sizeof(buf)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> if(read(pipefd[0], buf, sizeof(buf)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2eba9664db524c6293fdd0d0a0c186af.png"></p><pre><code>读完之后会阻塞</code></pre><h3 id="3-3-2、读写端都存在，只写不读"><a href="#3-3-2、读写端都存在，只写不读" class="headerlink" title="3-3-2、读写端都存在，只写不读"></a>3-3-2、读写端都存在，只写不读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">if(pipe(pipefd) == -1)</span><br><span class="line">&#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只写不读</span><br><span class="line"> //如果一直执行写操作，则无名管道对应的缓冲区会被写满，写满之后，write函数会阻塞等待</span><br><span class="line"> //默认无名管道的缓冲区64K字节</span><br><span class="line"></span><br><span class="line"> int num = 0;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(write(pipefd[1], &quot;6666&quot;, 1024) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to write&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> printf(&quot;num = %d\n&quot;, num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bace39d7e97d49dc99a7ac0ccafb71e4.png"></p><h3 id="3-3-3、只有读端，没有写端"><a href="#3-3-3、只有读端，没有写端" class="headerlink" title="3-3-3、只有读端，没有写端"></a>3-3-3、只有读端，没有写端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int pipefd[2];</span><br><span class="line">if(pipe(pipefd) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> write(pipefd[1], &quot;hello world&quot;,11);</span><br><span class="line"></span><br><span class="line"> //关闭写文件描述符，只有读端</span><br><span class="line"> //如果原本管道中有数据，则读操作正常读取数据</span><br><span class="line"> //如果管道中没有数据，则read函数会返回0</span><br><span class="line"> close(pipefd[1]);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> if((bytes = read(pipefd[0], buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> //清除字符串中的内容，用来清除内存的函数</span><br><span class="line"> memset(buf, 0, sizeof(buf));</span><br><span class="line"></span><br><span class="line"> if((bytes = read(pipefd[0], buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/877a80aa17c84936ac8eca7aa35df182.png"></p><h3 id="3-3-4、只有写端，没有读端"><a href="#3-3-4、只有写端，没有读端" class="headerlink" title="3-3-4、只有写端，没有读端"></a>3-3-4、只有写端，没有读端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;SIGPIPE信号产生了，管道破裂了\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> signal(SIGPIPE, handler);</span><br><span class="line"></span><br><span class="line"> int pipefd[2];</span><br><span class="line"> if(pipe(pipefd) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pipe&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //关闭写操作文件描述符，只有写端</span><br><span class="line"> //如果关闭读端，一旦执行写操作，就会产生一个信号SIGPIPE（管道破裂），</span><br><span class="line"> //这个信号的默认处理方式是退出进程</span><br><span class="line"> close(pipefd[0]);</span><br><span class="line"></span><br><span class="line"> int num = 0;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(write(pipefd[1], &quot;hello world&quot;, 1024) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to write&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> num++;</span><br><span class="line"> printf(&quot;num = %d\n&quot;, num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4d96bf1bc95040778a9717807c935cd4.png"></p><h2 id="3-4、通过fcntl函数设置文件的阻塞特性"><a href="#3-4、通过fcntl函数设置文件的阻塞特性" class="headerlink" title="3-4、通过fcntl函数设置文件的阻塞特性"></a>3-4、通过fcntl函数设置文件的阻塞特性</h2><pre><code>设置为阻塞：fcntl(fd, F_SETFL, 0);设置为非阻塞：fcntl(fd, F_SETFL, O_NONBLOCK);非阻塞：如果是阻塞，管道中没有数据，read会一直等待，直到有数据才会继续运行，否则一直等待.如果是非阻塞，read函数运行时，会先看一下管道中是否有数据，如果有数据，则正常运行读取数据，如果管道中没有数据，则read函数会立即返回，继续下面的代码运行</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> int fd_pipe[2];</span><br><span class="line"> char buf[] = &quot;hello world&quot;;</span><br><span class="line"> pid_t pid;</span><br><span class="line"></span><br><span class="line"> if (pipe(fd_pipe) &lt; 0)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to pipe&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> pid = fork();</span><br><span class="line"> if (pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to fork&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"> if (pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        sleep(5);</span><br><span class="line">        write(fd_pipe[1], buf, strlen(buf));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> else</span><br><span class="line">     &#123;</span><br><span class="line">     //将fd_pipe[0]设置为阻塞</span><br><span class="line">     //fcntl(fd_pipe[0], F_SETFL, 0);</span><br><span class="line">     //将fd_pipe[0]设置为非阻塞</span><br><span class="line">     fcntl(fd_pipe[0], F_SETFL, O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">     while(1)</span><br><span class="line">         &#123;</span><br><span class="line">         memset(buf, 0, sizeof(buf));</span><br><span class="line">         read(fd_pipe[0], buf, sizeof(buf));</span><br><span class="line">         printf(&quot;buf=[%s]\n&quot;, buf);</span><br><span class="line">         sleep(1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/26e2f1945fc64919bde9ffa438e8d222.png"></p><h1 id="4、文件描述符概述"><a href="#4、文件描述符概述" class="headerlink" title="4、文件描述符概述"></a>4、文件描述符概述</h1><pre><code>文件描述符是非负整数，是文件的标识。用户使用文件描述符（file descriptor）来访问文件。利用open打开一个文件时，内核会返回一个文件描述符。每个进程都有一张文件描述符的表，进程刚被创建时，标准输入、标准输出、标准错误输出。设备文件被打开，对应的文件描述符0、1、2 记录在表中。在进程中打开其他文件时，系统会返回文件描述符表中最小可用的文件描述符，并将此文件描述符记录在表中。注意：Linux中一个进程最多只能打开NR_OPEN_DEFAULT（即1024）个文件，故当文件不再使用时应及时调用close函数关闭文件。echo log &gt; /dev/null 2&gt;&amp;1&gt;  ：表示将输出结果重定向到哪里，例如：echo &quot;123&quot; &gt; /home/123.txt/dev/null ：表示空设备文件所以 echo log &gt; /dev/null 表示把日志输出到空文件设备，也就是将打印信息丢弃掉，屏幕上什么也不显示。1  ：表示stdout标准输出2  ：表示stderr标准错误&amp;  ：表示等同于的意思所以  2&gt;&amp;1 表示2的输出重定向等同于1，也就是标准错误输出重定向到标准输出。因为前面标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //在进程中打开其他文件时，</span><br><span class="line"> //系统会返回文件描述符表中最小可用的文件描述符，</span><br><span class="line"> //并将此文件描述符记录在进程的文件描述符表中。</span><br><span class="line"> //注意：新创建的文件描述符的值不一定是最大的</span><br><span class="line"> #if 0</span><br><span class="line"> close(0);</span><br><span class="line"></span><br><span class="line"> int fd1, fd2, fd3;</span><br><span class="line"> fd1 = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664);</span><br><span class="line"> fd2 = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664);</span><br><span class="line"> fd3 = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664);</span><br><span class="line"></span><br><span class="line"> printf(&quot;fd1 = %d\n&quot;, fd1);</span><br><span class="line"> printf(&quot;fd2 = %d\n&quot;, fd2);</span><br><span class="line"> printf(&quot;fd3 = %d\n&quot;, fd3);</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> //Linux中一个进程最多只能打开NR_OPEN_DEFAULT（即1024）个文件，</span><br><span class="line"> //故当文件不再使用时应及时调用close函数关闭文件</span><br><span class="line"> int fd;</span><br><span class="line"> while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if((fd = open(&quot;file.txt&quot;, O_RDONLY | O_CREAT, 0664)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to open&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;fd = %d\n&quot;, fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-1、dup函数"><a href="#4-1、dup函数" class="headerlink" title="4-1、dup函数"></a>4-1、dup函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dup函数</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup(int oldfd);</span><br><span class="line">功能：复制oldfd文件描述符，并分配一个新的文件描述符，新的文件描述符是调用进程文件描述符表中最小可用的文件描述符。</span><br><span class="line">参数：</span><br><span class="line">要复制的文件描述符oldfd。</span><br><span class="line">返回值：</span><br><span class="line">成功：新文件描述符。</span><br><span class="line">失败：返回－1，错误代码存于errno中。</span><br></pre></td></tr></table></figure><h3 id="案例1："><a href="#案例1：" class="headerlink" title="案例1："></a>案例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line"> &#123;</span><br><span class="line"> //通过dup函数复制一个文件描述符</span><br><span class="line"> int fd;</span><br><span class="line"> //dup执行后给返回值文件描述符分配的值是文件描述符表中最小可用的文件描述符</span><br><span class="line"> fd = dup(1);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd);</span><br><span class="line"> //由于通过dup函数将1这个文件描述符复制了一份为fd，所以fd现在就相当于1，所以写数据就是想终端写入数据</span><br><span class="line"> write(fd, &quot;nihao beijing\n&quot;, strlen(&quot;nihao beijing\n&quot;));</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4e360e4f6f664295b40ce00a355ef284.png"></p><h3 id="案例2：实现输出重定向的功能"><a href="#案例2：实现输出重定向的功能" class="headerlink" title="案例2：实现输出重定向的功能"></a>案例2：实现输出重定向的功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //如果需要实现输出重定向的功能</span><br><span class="line"> //首先像printf函数是操作文件描述符1所对应的文件，</span><br><span class="line"> //默认是操作终端，只要能够把1对应标识的文件改变，就可以实现输出重定向</span><br><span class="line"> //所以实现创建好文件对应的文件描述符之后，将1文件描述符关闭，接着通过dup</span><br><span class="line"> //函数复制的新的文件描述符就是1，这样printf函数对1操作，就写到了文件中</span><br><span class="line"> int fd_file;</span><br><span class="line"> fd_file = open(&quot;test.txt&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0664);</span><br><span class="line"> if(fd_file == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> close(1);</span><br><span class="line"></span><br><span class="line"> int fd = dup(fd_file);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="案例3：实现输出重定向后，还想标准输出，如何实现"><a href="#案例3：实现输出重定向后，还想标准输出，如何实现" class="headerlink" title="案例3：实现输出重定向后，还想标准输出，如何实现"></a>案例3：实现输出重定向后，还想标准输出，如何实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int fd1;</span><br><span class="line"> int fd2;</span><br><span class="line"> fd2 = dup(1);</span><br><span class="line"> printf(&quot;new:fd2 = %d\n&quot;,fd2);</span><br><span class="line"></span><br><span class="line"> fd1 = open(&quot;test.txt&quot;, O_RDWR | O_CREAT, 0664);</span><br><span class="line"></span><br><span class="line"> close(1);</span><br><span class="line"> int fd3 = dup(fd1);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd3);</span><br><span class="line"></span><br><span class="line"> close(1);</span><br><span class="line"> int fd4 = dup(fd2);</span><br><span class="line"> printf(&quot;nihao beijing\n&quot;);</span><br><span class="line"> printf(&quot;fd = %d\n&quot;, fd4);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-2、dup2函数"><a href="#4-2、dup2函数" class="headerlink" title="4-2、dup2函数"></a>4-2、dup2函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int dup2(int oldfd, int newfd)</span><br><span class="line">功能：复制一份打开的文件描述符oldfd，</span><br><span class="line">并分配新的文件描述符newfd，newfd也标识oldfd所标识的文件。</span><br><span class="line">注意：</span><br><span class="line">newfd是小于文件描述符最大允许值的非负整数，</span><br><span class="line">如果newfd是一个已经打开的文件描述符，则首先关闭该文件，然后再复制。</span><br><span class="line">参数：</span><br><span class="line">oldfd：要复制的文件描述符</span><br><span class="line"> newfd：分配的新的文件描述符</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：返回newfd</span><br><span class="line"> 失败：返回‐1，错误代码存于errno中</span><br></pre></td></tr></table></figure><h3 id="实现输出重定向"><a href="#实现输出重定向" class="headerlink" title="实现输出重定向"></a>实现输出重定向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> int fd1;</span><br><span class="line"> int fd2;</span><br><span class="line"></span><br><span class="line"> fd1 = open(&quot;test.txt&quot;, O_CREAT | O_WRONLY, 0664);</span><br><span class="line"> if (fd1 &lt; 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //首先关闭1文件描述符，然后将fd1复制给1，意味着1和fd1都标识test.txt文件,返回值跟1是一样的</span><br><span class="line"> fd2 = dup2(fd1, 1);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"> printf(&quot;fd2 = %d\n&quot;, fd2);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="实现输出重定向后，再恢复标准输出"><a href="#实现输出重定向后，再恢复标准输出" class="headerlink" title="实现输出重定向后，再恢复标准输出"></a>实现输出重定向后，再恢复标准输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int fd1;</span><br><span class="line"> //如果使用dup2，则需要实现给第二个参数对应的变量赋一个初始值</span><br><span class="line"> int fd2 = 3;</span><br><span class="line"></span><br><span class="line"> //将1复制一份为fd2，所以fd2标识的是标准输出</span><br><span class="line"> dup2(1, fd2);</span><br><span class="line"> printf(&quot;fd2 = %d\n&quot;, fd2);</span><br><span class="line"></span><br><span class="line"> fd1 = open(&quot;test.txt&quot;, O_CREAT | O_RDWR, 0664);</span><br><span class="line"></span><br><span class="line"> //输出重定向：关闭文件描述符1，将fd1复制一份为1，所以1此时标识的是test.txt文件</span><br><span class="line"> dup2(fd1, 1);</span><br><span class="line"> printf(&quot;hello world\n&quot;);</span><br><span class="line"></span><br><span class="line"> //再次实现标准输出：关闭文件描述符1，将fd2复制一份为1，所以1此时标识的是标准输出</span><br><span class="line"> dup2(fd2, 1);</span><br><span class="line"> printf(&quot;你好北京\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="5、有名管道"><a href="#5、有名管道" class="headerlink" title="5、有名管道"></a>5、有名管道</h1><h2 id="5-1、有名管道概述"><a href="#5-1、有名管道概述" class="headerlink" title="5-1、有名管道概述"></a>5-1、有名管道概述</h2><pre><code>命名管道(FIFO)和管道(pipe)基本相同，但也有一些显著的不同，其特点是:1、半双工，数据在同一时刻只能在一个方向上流动。2、写入FIFO中的数据遵循先入先出的规则。3、FIFO所传送的数据是无格式的，    这要求FIFO的读出方与写入方必须事先约定好数据的格式，    如多少字节算一个消息等。4、FIFO在文件系统中作为一个特殊的文件而存在并且在文件系统中可见，    所以有名管道可以实现不相关进程间通信，    但FIFO中的内容却存放在内存中。5、管道在内存中对应一个缓冲区。    不同的系统其大小不一定相同。6、从FIFO读数据是一次性操作，    数据一旦被读，    它就从FIFO中被抛弃，    释放空间以便写更多的数据。7、当使用FIFO的进程退出后，    FIFO文件将继续保存在文件系统中以便以后使用。8、FIFO有名字，    不相关的进程可以通过打开命名管道进行通信。</code></pre><p><code>linux中有7种文件类型</code></p><p><img src="https://img-blog.csdnimg.cn/cc023d405c604fbf80e6e5883103579f.png"></p><h2 id="5-2、有名管道的创建"><a href="#5-2、有名管道的创建" class="headerlink" title="5-2、有名管道的创建"></a>5-2、有名管道的创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法1：用过shell命令mkfifo创建有名管道</span><br><span class="line">mkfifo 文件名</span><br><span class="line">方法2：使用函数mkfifo</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line">功能：创建一个有名管道，产生一个本地文件系统可见的文件pathname</span><br><span class="line">参数：</span><br><span class="line">pathname：有名管道创建后生成的文件，可以带路径</span><br><span class="line">mode：管道文件的权限，一般通过八进制数设置即可，例如0664</span><br><span class="line">返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //通过mkfifo函数创建有名管道</span><br><span class="line"> if(mkfifo(&quot;fifo_file&quot;, 0664) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    //printf(&quot;errno = %d\n&quot;, errno);</span><br><span class="line">    //如果管道文件已经存在，不需要报错退出，直接使用即可，所以需要在错误输之前把</span><br><span class="line">    //因为文件存在的错误排除</span><br><span class="line">    if(errno != EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to mkfifo&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-3、有名管道的基本读写操作"><a href="#5-3、有名管道的基本读写操作" class="headerlink" title="5-3、有名管道的基本读写操作"></a>5-3、有名管道的基本读写操作</h2><p>由于有名管道在本地创建了一个管道文件，<br>所以系统调用的IO函数基本都可以对有名管道进行操作，<br>但是不能使用lseek修改管道文件的偏移量<br>注意：有名管道创建的本地的文件只是起到标识作用，<br>真正有名管道实现进程间通信还是在内核空间开辟内存，<br>所以本地产生的文件只是一个标识，<br>没有其他作用，<br>对本地管道文件的操作实质就是对内核空间的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> #define FIFONAME &quot;fifo_file&quot;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //通过mkfifo函数创建有名管道</span><br><span class="line"> if(mkfifo(FIFONAME, 0664) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(errno != EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">        perror(&quot;fail to mkfifo&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //对有名管道进行操作</span><br><span class="line"> //管道后写入的数据会保存在之前写入数据的后面，不会替换</span><br><span class="line"> //如果管道中没有数据了，读操作会阻塞</span><br><span class="line"></span><br><span class="line"> //通过open函数打开管道文件并得到文件描述符</span><br><span class="line"> int fd;</span><br><span class="line"> fd = open(FIFONAME, O_RDWR);</span><br><span class="line"> if(fd == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to open&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //通过write函数向管道中写入数据</span><br><span class="line"> if(write(fd, &quot;hello world&quot;, strlen(&quot;hello world&quot;)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to write&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> write(fd, &quot;nihao beijing&quot;, strlen(&quot;nihao beijing&quot;));</span><br><span class="line"></span><br><span class="line"> //通过read函数读取管道中的数据</span><br><span class="line"> char buf[32] = &quot;&quot;;</span><br><span class="line"> if(read(fd, buf, sizeof(buf)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to read&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> if(read(fd, buf, sizeof(buf)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to read&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"> printf(&quot;buf = [%s]\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> //使用close函数关闭文件描述符</span><br><span class="line"> close(fd);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-4、有名管道实现进程间通信"><a href="#5-4、有名管道实现进程间通信" class="headerlink" title="5-4、有名管道实现进程间通信"></a>5-4、有名管道实现进程间通信</h2><pre><code>由于有名管道在本地创建了一个管道文件，所以不相关的进程间也可以实现通信。</code></pre><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //如果没有创建有名管道，则创建有名管道</span><br><span class="line"> //为了实现两个进程都可以收发数据，所以需要创建两个有名管道</span><br><span class="line"> if(mkfifo(&quot;myfifo1&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if(mkfifo(&quot;myfifo2&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //打开两个有名管道并得到文件描述符</span><br><span class="line"> int fd_w, fd_r;</span><br><span class="line"> if((fd_w = open(&quot;myfifo1&quot;, O_WRONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if((fd_r = open(&quot;myfifo2&quot;, O_RDONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> fgets(buf, sizeof(buf), stdin);</span><br><span class="line"> buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line"> //send进程负责将数据写入myfifo1，接着从myfifo2中读取数据</span><br><span class="line"> if((bytes = write(fd_w, buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to write&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if((bytes = read(fd_r, buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;from recv: %s\n&quot;, buf);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="recv"><a href="#recv" class="headerlink" title="recv"></a>recv</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo1&quot;, 0664) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if(mkfifo(&quot;myfifo2&quot;, 0664) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int fd_w, fd_r;</span><br><span class="line"></span><br><span class="line"> if((fd_r = open(&quot;myfifo1&quot;, O_RDONLY)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if((fd_w = open(&quot;myfifo2&quot;, O_WRONLY)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if((bytes = read(fd_r, buf, sizeof(buf))) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;from send: %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> fgets(buf, sizeof(buf), stdin);</span><br><span class="line"> buf[strlen(buf) ‐ 1] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line"> write(fd_w, buf, sizeof(buf));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-5、有名管道的读写规律（阻塞）"><a href="#5-5、有名管道的读写规律（阻塞）" class="headerlink" title="5-5、有名管道的读写规律（阻塞）"></a>5-5、有名管道的读写规律（阻塞）</h2><h3 id="5-5-1、读写端都存在，只读不写"><a href="#5-5-1、读写端都存在，只读不写" class="headerlink" title="5-5-1、读写端都存在，只读不写"></a>5-5-1、读写端都存在，只读不写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只读不写</span><br><span class="line"> //如果原本管道中有数据，则正常读取</span><br><span class="line"> //如果管道中没有数据，则read函数会阻塞等待</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_RDWR)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> write(fd, &quot;hello world&quot;, 11);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> read(fd, buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> read(fd, buf, sizeof(buf));</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7117b44f47f74ecca90c99321b4dc8e7.png"></p><h3 id="5-5-2、读写端都存在，只写不读"><a href="#5-5-2、读写端都存在，只写不读" class="headerlink" title="5-5-2、读写端都存在，只写不读"></a>5-5-2、读写端都存在，只写不读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //读写端都存在，只写不读</span><br><span class="line"> //当有名管道的缓冲区写满后，write函数会发生阻塞</span><br><span class="line"> //默认有名管道的缓冲区为64K字节</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_RDWR)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int num = 0;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> write(fd, &quot;&quot;, 1024);</span><br><span class="line"> num++;</span><br><span class="line"> printf(&quot;num = %d\n&quot;, num);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/fa500384f5c74afeaae1b51c1f26eb45.png" alt="在这里插入图片描述"></p><h3 id="5-5-3、在一个进程中，只有读端，没有写端"><a href="#5-5-3、在一个进程中，只有读端，没有写端" class="headerlink" title="5-5-3、在一个进程中，只有读端，没有写端"></a>5-5-3、在一个进程中，只有读端，没有写端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //在一个进程中，只有读端，没有写端</span><br><span class="line"> //会在open函数的位置阻塞</span><br><span class="line"></span><br><span class="line"> printf(&quot;***********************\n&quot;);</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_RDONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;------------------------\n&quot;);</span><br><span class="line"></span><br><span class="line"> char buf[128] = &quot;&quot;;</span><br><span class="line"> ssize_t bytes;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> if((bytes = read(fd, buf, sizeof(buf))) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to read&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;bytes = %ld\n&quot;, bytes);</span><br><span class="line"> printf(&quot;buf = %s\n&quot;, buf);</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c4e59bc08d5b4d168372c894caff590b.png"></p><h3 id="5-5-4、在一个进程中，只有写端，没有读端"><a href="#5-5-4、在一个进程中，只有写端，没有读端" class="headerlink" title="5-5-4、在一个进程中，只有写端，没有读端"></a>5-5-4、在一个进程中，只有写端，没有读端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> if(errno != EEXIST)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to mkfifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //在一个进程中，只有写端，没有读端</span><br><span class="line"> //会在open函数的位置阻塞</span><br><span class="line"></span><br><span class="line"> printf(&quot;*****************************\n&quot;);</span><br><span class="line"></span><br><span class="line"> int fd;</span><br><span class="line"> if((fd = open(&quot;myfifo&quot;, O_WRONLY)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to open&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;-----------------------------\n&quot;);</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> write(fd, &quot;hello world&quot;, 11);</span><br><span class="line"> printf(&quot;666\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-5、-一个进程只读，一个进程只写"><a href="#5-5-5、-一个进程只读，一个进程只写" class="headerlink" title="5-5-5、 一个进程只读，一个进程只写"></a>5-5-5、 一个进程只读，一个进程只写</h3><pre><code>将上面5-5-3和5-5-4两个代码一起运行，保证有名管道读写端都存在规律：只要保证有名管道的读写端都存在，不管是几个进程，都不会再open这阻塞了如果一个进程只读，一个进程只写，都运行后，如果关闭写端，读端read会返回0如果一个进程只读，一个进程只写，都运行后，如果关闭读端，写端会立即产生SIGPIPE信号，默认的处理方式是退出进程</code></pre><h3 id="5-5-6、有名管道的读写规律（非阻塞）"><a href="#5-5-6、有名管道的读写规律（非阻塞）" class="headerlink" title="5-5-6、有名管道的读写规律（非阻塞）"></a>5-5-6、有名管道的读写规律（非阻塞）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> int fd;</span><br><span class="line"></span><br><span class="line"> if(mkfifo(&quot;myfifo&quot;, 0664) == -1)</span><br><span class="line"> &#123;</span><br><span class="line">    if(errno != EEXIST)</span><br><span class="line">         &#123;</span><br><span class="line">         perror(&quot;fail to mkfifo&quot;);</span><br><span class="line">         exit(1);</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> #if 0</span><br><span class="line"> //如果open标志位设置为非阻塞，并且以只读的方式打开管道文件</span><br><span class="line"> //open函数和read函数都不会阻塞</span><br><span class="line"> fd = open(&quot;myfifo&quot;, O_RDONLY | O_NONBLOCK);</span><br><span class="line"> if(fd &lt; 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;open fifo&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> char recv[100];</span><br><span class="line"></span><br><span class="line"> bzero(recv, sizeof(recv));</span><br><span class="line"> read(fd, recv, sizeof(recv));</span><br><span class="line"> printf(&quot;read from my_fifo buf=[%s]\n&quot;,recv);</span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> #if 1</span><br><span class="line"> //如果open标志位设置为非阻塞，并且以只写的方式打开管道文件</span><br><span class="line"> //open函数会直接报错</span><br><span class="line"> //如果open设置为可读可写，那么跟阻塞是一样的效果</span><br><span class="line"> char send[100] = &quot;Hello I love you&quot;;</span><br><span class="line"></span><br><span class="line"> fd = open(&quot;myfifo&quot;, O_WRONLY | O_NONBLOCK);</span><br><span class="line"> //fd = open(&quot;myfifo&quot;, O_RDWR | O_NONBLOCK);</span><br><span class="line"> if(fd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;open fifo&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> write(fd, send, strlen(send));</span><br><span class="line"></span><br><span class="line"> char recv[100];</span><br><span class="line"> read(fd, recv, sizeof(recv));</span><br><span class="line"> printf(&quot;read from my_fifo buf=[%s]\n&quot;,recv);</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="6、消息队列"><a href="#6、消息队列" class="headerlink" title="6、消息队列"></a>6、消息队列</h1><pre><code>除了最原始的进程间通信方式信号、无名管道和有名管道外，还有三种进程间通信方式，这三种方式称之为IPC对象。IPC对象分类：消息队列、共享内存、信号灯集IPC对象也是在内核空间开辟区域，每一种IPC对象创建好之后都会将其设置为全局，并且会给其分配一个编号，只要找到唯一的这个编号就可以进行通信，所以不相关的进程可以通过IPC对象通信IPC对象创建好之后，会在当前系统中可见，只要不删除或者不关闭系统，就会一直存在。查看已经创建的IPC对象：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ipcs 查看当前系统中所有创建的IPC对象</span><br><span class="line">ipcs ‐q 查看创建的消息队列</span><br><span class="line">ipcs ‐m 查看创建的共享内存</span><br><span class="line">ipcs ‐s 查看信号量</span><br><span class="line"></span><br><span class="line">ipcrm 删除IPC对象</span><br><span class="line">例如：ipcrm ‐q msqid 删除标号为msqid的消息队列</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b67fd96af7f9415a82870579cb40e183.png"></p><h3 id="6-1、消息队列概述"><a href="#6-1、消息队列概述" class="headerlink" title="6-1、消息队列概述"></a>6-1、消息队列概述</h3><pre><code>消息队列是消息的链表，存放在内存中，由内核维护。消息队列的特点1、消息队列中的消息是有类型的。2、消息队列中的消息是有格式的。3、消息队列可以实现消息的随机查询。    消息不一定要以先进先出的次序读取，    编程时可以按消息的类型读取。4、消息队列允许一个或多个进程向它写入或者读取消息。5、与无名管道、命名管道一样，从消息队列中读出消息，    消息队列中对应的数据都会被删除。6、每个消息队列都有消息队列标识符，    消息队列的标识符在整个系统中是唯一的。7、只有内核重启或人工删除消息队列时，    该消息队列才会被删除。    若不人工删除消息队列，    消息队列会一直存在于系统中。在ubuntu 12.04中消息队列限制值如下:每个消息内容最多为8K字节每个消息队列容量最多为16K字节系统中消息队列个数最多为1609个系统中消息个数最多为16384个System V提供的IPC通信机制需要一个key值，通过key值就可在系统内获得一个唯一的消息队列标识符。key值可以是人为指定的，也可以通过ftok函数获得。如果多个进程想通过IPC对象通信，则必须找到唯一的标识，而唯一的标识是由key决定的，所以只要key知道，则就可以实现多个进程通信.</code></pre><h3 id="6-2、ftok函数"><a href="#6-2、ftok函数" class="headerlink" title="6-2、ftok函数"></a>6-2、ftok函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">功能：通过文件名和目标值共同创造一个键值并返回值</span><br><span class="line">参数：</span><br><span class="line">pathname：任意一个文件名（文件名或者目录名）</span><br><span class="line">proj_id：目标值，范围一般是0~127</span><br><span class="line">返回值：</span><br><span class="line">成功：键值</span><br><span class="line"> 失败：‐1</span><br><span class="line"></span><br><span class="line"> 如果使用ftok函数获取键值，得到的键值是由ftok的第一个</span><br><span class="line"> 参数对应文件的信息和第二个参数一起决定的</span><br></pre></td></tr></table></figure><h3 id="6-3、消息队列的操作"><a href="#6-3、消息队列的操作" class="headerlink" title="6-3、消息队列的操作"></a>6-3、消息队列的操作</h3><h4 id="6-3-1、创建消息队列-–-msgget"><a href="#6-3-1、创建消息队列-–-msgget" class="headerlink" title="6-3-1、创建消息队列 – msgget( )"></a>6-3-1、创建消息队列 – msgget( )</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">功能：创建一个消息队列，得到消息队列的id</span><br><span class="line">参数：</span><br><span class="line">key：键值，唯一的键值确定唯一的消息队列</span><br><span class="line">方法1：任意指定一个数</span><br><span class="line">方法2：使用ftok函数获取键值</span><br><span class="line"> msgflg：消息队列的访问权限，</span><br><span class="line"> 一般设置为 IPC_CREAT | IPC_EXCL | 0777 或者 IPC_CREAT | 0777</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：消息队列的id</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> //通过ftok函数获取ipc键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to ftok&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;mykey = %#x\n&quot;, mykey);</span><br><span class="line"></span><br><span class="line"> //通过msgget函数创建一个消息队列</span><br><span class="line"> int msqid;</span><br><span class="line"> if((msqid = msgget(mykey, IPC_CREAT | 0666)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to msgget&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;msqid = %d\n&quot;, msqid);</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-2、发送消息-–-msgsnd"><a href="#6-3-2、发送消息-–-msgsnd" class="headerlink" title="6-3-2、发送消息 – msgsnd( )"></a>6-3-2、发送消息 – msgsnd( )</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span><br><span class="line">功能：向指定的消息队列发送数据（写操作）</span><br><span class="line">参数：</span><br><span class="line">msqid：消息队列的id</span><br><span class="line">msgp：要写入的数据，需要自己定义结构体</span><br><span class="line">struct struct_name&#123;</span><br><span class="line"> long mtype; //消息的编号，必须大于0</span><br><span class="line"> char mtext[128]; //消息正文，可以定义多个成员</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> msgsz：消息正文的大小，不包括消息的编号长度</span><br><span class="line"> msgflg：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> IPC_NOWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">#define N 128</span><br><span class="line"> typedef struct&#123;</span><br><span class="line"> long msg_type; //消息类型，必须在结构体的第一个位置并且类型必须是long</span><br><span class="line"> char msg_text[N]; //消息正文，也可以有多个成员并且类型也可以是任意</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> #define MSGTEXT_SIZE (sizeof(MSG) - sizeof(long))</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //使用ftok函数获取键值</span><br><span class="line"> key_t key;</span><br><span class="line"> if((key = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to ftok&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //使用msgget函数创建一个消息队列</span><br><span class="line"> int msgid;</span><br><span class="line"> if((msgid = msgget(key, IPC_CREAT | 0777)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgget&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -q&quot;);</span><br><span class="line"></span><br><span class="line"> //使用msgsnd函数向消息队列中发送数据（写操作）</span><br><span class="line"> MSG msg1 = &#123;1, &quot;hello world&quot;&#125;;</span><br><span class="line"> MSG msg2 = &#123;4, &quot;nihao beijing&quot;&#125;;</span><br><span class="line"> MSG msg3 = &#123;2, &quot;hello kitty&quot;&#125;;</span><br><span class="line"> MSG msg4 = &#123;3, &quot;welcome to 1000phone&quot;&#125;;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg1, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg2, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg3, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> if(msgsnd(msgid, &amp;msg4, MSGTEXT_SIZE, 0) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to msgsnd&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"> system(&quot;ipcs -q&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3、接收消息-–-msgrcv"><a href="#6-3-3、接收消息-–-msgrcv" class="headerlink" title="6-3-3、接收消息 – msgrcv( )"></a>6-3-3、接收消息 – msgrcv( )</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/msg.h&gt;</span><br><span class="line">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz,</span><br><span class="line">long msgtyp, int msgflg);</span><br><span class="line">功能：从消息队列中接收数据（读操作），接收的数据会从消息队列中删除</span><br><span class="line">参数：</span><br><span class="line">msqid：消息队列id</span><br><span class="line">msgp：保存接收到的数据的结构体</span><br><span class="line"> struct struct_name&#123;</span><br><span class="line"> long mtype; //消息的编号，必须大于0</span><br><span class="line"> char mtext[128]; //消息正文，可以定义多个成员</span><br><span class="line"> &#125;</span><br><span class="line"> msgsz：消息正文的大小</span><br><span class="line"> msgtyp：设置要接收哪个消息</span><br><span class="line"> 0 按照写入消息队列的顺序依次读取</span><br><span class="line"> &gt;0 只读取消息队列中消息编号为当前参数的第一个消息</span><br><span class="line"> &lt;0 只读取消息队列中小于等于当前参数的绝对中内最小的第一个消息</span><br><span class="line"> msgflg：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> IPC_NOWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：接收到的消息正文的长度</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h1 id="7、共享内存"><a href="#7、共享内存" class="headerlink" title="7、共享内存"></a>7、共享内存</h1><pre><code>共享内存允许两个或者多个进程共享给定的存储区域。共享内存的特点1、 共享内存是进程间共享数据的一种最快的方法。    一个进程向共享的内存区域写入了数据，    共享这个内存区域的所有进程就可以立刻看到其中的内容。2、使用共享内存要注意的是多个进程之间对一个给定存储区访问的互斥。    若一个进程正在向共享内存区写数据，    则在它做完这一步操作前，    别的进程不应当去读、写这些数据。</code></pre><p>共享内存示意图<br><img src="https://img-blog.csdnimg.cn/1f9d75c83e934f85880357dacf416fdf.png"><br>    总结：共享内存是进程间通信方式中效率最高的，<br>    原因在于进程是直接在物理内存上进行操作，<br>    将物理地址映射到用户进程这，<br>    所以只要对其地址进行操作，<br>    就是直接对物理地址操作。</p><pre><code>在ubuntu 12.04中共享内存限制值如下1、共享存储区的最小字节数：12、共享存储区的最大字节数：32M3、共享存储区的最大个数：40964、每个进程最多能映射的共享存储区的个数：4096</code></pre><h2 id="7-1、-获得一个共享存储标识符"><a href="#7-1、-获得一个共享存储标识符" class="headerlink" title="7-1、 获得一个共享存储标识符"></a>7-1、 获得一个共享存储标识符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">功能：创建一个共享内存</span><br><span class="line">参数：</span><br><span class="line">key：键值，唯一的键值确定唯一的共享内存</span><br><span class="line">size：创建的共享内存的大小</span><br><span class="line">shmflg：共享内存的访问权限，</span><br><span class="line">一般为 IPC_CREAT | 0777</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：共享内存的id</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>使用shell命令操作共享内存: 查看共享内存 ipcs ‐m 删除共享内存 ipcrm ‐m shmid </code></pre><p>案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">   perror(&quot;fail to ftok&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == -1)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to shmget&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;shmid = %d\n&quot;, shmid);</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-2、-共享内存映射-attach"><a href="#7-2、-共享内存映射-attach" class="headerlink" title="7-2、 共享内存映射(attach)"></a>7-2、 共享内存映射(attach)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">功能：映射共享内存</span><br><span class="line">参数</span><br><span class="line">shmid：共享内存的id</span><br><span class="line">shmaddr：映射的地址，设置为NULL为系统自动分配</span><br><span class="line">shmflg：标志位</span><br><span class="line">0：共享内存具有可读可写权限。</span><br><span class="line"> SHM_RDONLY：只读。</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：映射的地址</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>注意：    shmat函数使用的时候第二个和第三个参数一般设为NULL和0，    即系统自动指定共享内存地址，    并且共享内存可读可写。</code></pre><h2 id="7-3、解除共享内存映射-detach"><a href="#7-3、解除共享内存映射-detach" class="headerlink" title="7-3、解除共享内存映射(detach)"></a>7-3、解除共享内存映射(detach)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">功能：解除共享内存的映射</span><br><span class="line">参数：</span><br><span class="line">shmaddr：映射的地址，shmat的返回值</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br></pre></td></tr></table></figure><h2 id="7-4、案例：使用共享内存实现读写操作"><a href="#7-4、案例：使用共享内存实现读写操作" class="headerlink" title="7-4、案例：使用共享内存实现读写操作"></a>7-4、案例：使用共享内存实现读写操作</h2><p>写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int a;</span><br><span class="line"> char b;</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to ftok&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmget&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> //使用shmat函数映射共享内存的地址</span><br><span class="line"> //char *text;</span><br><span class="line"> MSG *text;</span><br><span class="line"> if((text = shmat(shmid, NULL, 0)) == (void *)-1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmat&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmat的返回值对共享内存操作</span><br><span class="line"> //strcpy(text, &quot;hello world&quot;);</span><br><span class="line"> text-&gt;a = 100;</span><br><span class="line"> text-&gt;b = &#x27;w&#x27;;</span><br><span class="line"></span><br><span class="line"> //操作完毕后要结束共享内存的映射</span><br><span class="line"> if(shmdt(text) == -1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmdt&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>读出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line"> &#125;MSG;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to ftok&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to shmget&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> //映射共享内存的地址</span><br><span class="line"> //char *text;</span><br><span class="line"> MSG *text;</span><br><span class="line"> if((text = shmat(shmid, NULL, 0)) == (void *)-1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to shmat&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> //获取共享内存中的数据</span><br><span class="line"> //printf(&quot;text = %s\n&quot;, text);</span><br><span class="line"> printf(&quot;a = %d, b = %c\n&quot;, text-&gt;a, text-&gt;b);</span><br><span class="line"></span><br><span class="line"> //解除共享内存映射</span><br><span class="line"> if(shmdt(text) == -1)</span><br><span class="line">     &#123;</span><br><span class="line">     perror(&quot;fail to shmdt&quot;);</span><br><span class="line">     exit(1);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs -m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="7-5、共享内存控制"><a href="#7-5、共享内存控制" class="headerlink" title="7-5、共享内存控制"></a>7-5、共享内存控制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">功能：设置或者获取共享内存你的属性</span><br><span class="line">参数：</span><br><span class="line">shmid：共享内存的id</span><br><span class="line">cmd：执行操作的命令</span><br><span class="line">IPC_STAT 获取共享内存的属性</span><br><span class="line">IPC_SET 设置共享内存的属性</span><br><span class="line"> IPC_RMID 删除共享内存</span><br><span class="line"> shmid_ds：共享内存的属性结构体</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><p>例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">//使用ftok函数获取键值</span><br><span class="line"> key_t mykey;</span><br><span class="line"> if((mykey = ftok(&quot;.&quot;, 100)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to ftok&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过shmget函数创建或者打开一个共享内存，返回一个共享内存的标识符</span><br><span class="line"> int shmid;</span><br><span class="line"> if((shmid = shmget(mykey, 500, IPC_CREAT | 0666)) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmget&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;shmid = %d\n&quot;, shmid);</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs ‐m&quot;);</span><br><span class="line"></span><br><span class="line"> //通过shmctl函数删除共享内存</span><br><span class="line"> if(shmctl(shmid, IPC_RMID, NULL) == ‐1)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to shmctl&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> system(&quot;ipcs ‐m&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="8、线程"><a href="#8、线程" class="headerlink" title="8、线程"></a>8、线程</h1><pre><code>每个进程都拥有自己的数据段、代码段和堆栈段，这就造成进程在进行创建、切换、撤销操作时，需要较大的系统开销。为了减少系统开销，从进程中演化出了线程。线程存在于进程中，共享进程的资源。线程是进程中的独立控制流，由环境（包括寄存器组和程序计数器）和一系列的执行指令组成。每个进程有一个地址空间和一个控制线程。</code></pre><p><img src="https://img-blog.csdnimg.cn/b72659b36b374e72a9b828675e4ecb8f.png"></p><h2 id="8-1、线程和进程的比较"><a href="#8-1、线程和进程的比较" class="headerlink" title="8-1、线程和进程的比较"></a>8-1、线程和进程的比较</h2><pre><code>调度：线程是CPU调度和分派的基本单位。拥有资源：进程是系统中程序执行和资源分配的基本单位。线程自己一般不拥有资源（除了必不可少的程序计数器，一组寄存器和栈），但它可以去访问其所属进程的资源，如进程代码段，数据段以及系统资源（已打开的文件，I/O设备等）。系统开销：同一个进程中的多个线程可共享同一地址空间，因此它们之间的同步和通信的实现也变得比较容易。在进程切换时候，    涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置；    而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作，    从而能更有效地使用系统资源和提高系统的吞吐量。并发性：    不仅进程间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行。总结：    一般把线程称之为轻量级的进程    一个进程可以创建多个线程，    多个线程共享一个进程的资源，    每一个进程创建的时候系统会给其4G虚拟内存，    3G用户空间是私有的，所以进程切换时，    用户空间也会切换，所以会增加系统开销，    而一个进程中的多个线程共享一个进程的资源，    所以线程切换时不用切换这些资源，效率会更高，    线程的调度机制跟进程是一样的，多个线程来回切换运行。</code></pre><h2 id="8-2、多线程的用处"><a href="#8-2、多线程的用处" class="headerlink" title="8-2、多线程的用处"></a>8-2、多线程的用处</h2><pre><code>使用多线程的目的主要有以下几点：多任务程序的设计    一个程序可能要处理不同应用，要处理多种任务，    如果开发不同的进程来处理，系统开销很大，    数据共享，程序结构都不方便，    这时可使用多线程编程方法。并发程序设计    一个任务可能分成不同的步骤去完成，    这些不同的步骤之间可能是松散耦合，    可能通过线程的互斥，同步并发完成。    这样可以为不同的任务步骤建立线程。网络程序设计    为提高网络的利用效率，    我们可能使用多线程，    对每个连接用一个线程去处理。数据共享    同一个进程中的不同线程共享进程的数据空间，    方便不同线程间的数据共享。在多CPU系统中，实现真正的并行。</code></pre><h2 id="8-3、线程的基本操作"><a href="#8-3、线程的基本操作" class="headerlink" title="8-3、线程的基本操作"></a>8-3、线程的基本操作</h2><h3 id="8-3-1、线程的创建"><a href="#8-3-1、线程的创建" class="headerlink" title="8-3-1、线程的创建"></a>8-3-1、线程的创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span><br><span class="line">void *(*start_routine) (void *), void *arg);</span><br><span class="line">功能：创建一个新的子线程</span><br><span class="line">参数：</span><br><span class="line">thread：当前创建的线程id</span><br><span class="line">attr：线程的属性，设置为NULL表示以默认的属性创建</span><br><span class="line">start_routine：线程处理函数，如果当前函数执行完毕，则子线程也执行完毕</span><br><span class="line">arg：给线程处理函数传参用的</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure><pre><code>注意事项：与fork不同的是pthread_create创建的线程不与父线程在同一点开始运行，而是从指定的函数开始运行，该函数运行完后，该线程也就退出了。线程依赖进程存在的，如果创建线程的进程结束了，线程也就结束了。线程函数的程序在pthread库中，故链接时要加上参数-lpthread。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">//由于线程库原本不是系统本身的，所以在链接时需要手动链接库文件 gcc *.c ‐lpthread</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> //通过pthread_create函数创建子线程</span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //由于进程结束后，进程中所有的线程都会强制退出，所以现阶段不要让进程退出</span><br><span class="line"> while(1);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-2、线程调度机制的验证"><a href="#8-3-2、线程调度机制的验证" class="headerlink" title="8-3-2、线程调度机制的验证"></a>8-3-2、线程调度机制的验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">//一个进程中的多个线程执行顺序是不确定的，没有先后顺序可言</span><br><span class="line">//多线程执行时跟进程一样，是来回切换运行的，跟进程的调度机制一样</span><br><span class="line">void *pthread_fun1(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程1正在运行\n&quot;);</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;**********************\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *pthread_fun2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程2正在运行\n&quot;);</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;-----------------------\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread1, thread2;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread1, NULL, pthread_fun1, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> if(pthread_create(&amp;thread2, NULL, pthread_fun2, NULL) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> while(1);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-3、线程处理函数传参"><a href="#8-3-3、线程处理函数传参" class="headerlink" title="8-3-3、线程处理函数传参"></a>8-3-3、线程处理函数传参</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int num = 100;</span><br><span class="line">//线程处理函数可以认为就是一个普通的全局函数，只不过与普通函数最大的区别</span><br><span class="line">//在于，线程处理函数是并行执行，来回交替执行，但是普通函数一定是按照顺序一个一个执行</span><br><span class="line"> void *pthread_fun1(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程1：num = %d\n&quot;, num);</span><br><span class="line"> num++;</span><br><span class="line"></span><br><span class="line"> int n = *(int *)arg;</span><br><span class="line"> printf(&quot;1 n = %d\n&quot;, n);</span><br><span class="line"> *(int *)arg = 111;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *pthread_fun2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> sleep(1);</span><br><span class="line"> printf(&quot;子线程2：num = %d\n&quot;, num);</span><br><span class="line"></span><br><span class="line"> int n = *(int *)arg;</span><br><span class="line"> printf(&quot;2 n = %d\n&quot;, n);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread1, thread2;</span><br><span class="line"></span><br><span class="line"> int a = 666;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread1, NULL, pthread_fun1, (void *)&amp;a) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread2, NULL, pthread_fun2, (void *)&amp;a) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> while(1);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-4、线程等待"><a href="#8-3-4、线程等待" class="headerlink" title="8-3-4、线程等待"></a>8-3-4、线程等待</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_join(pthread_t thread, void **retval);</span><br><span class="line">功能：阻塞等待一个子线程的退出，</span><br><span class="line">可以接收到某一个子线程调用pthread_exit时设置的退出状态值</span><br><span class="line">参数：</span><br><span class="line">thread：指定线程的id</span><br><span class="line">retval：保存子线程的退出状态值，如果不接受则设置为NULL</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> sleep(3);</span><br><span class="line"></span><br><span class="line"> printf(&quot;子线程要退出了\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //通过调用pthread_join函数阻塞等待子线程退出</span><br><span class="line"> if(pthread_join(thread, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_join&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;进程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-5、线程的返回值"><a href="#8-3-5、线程的返回值" class="headerlink" title="8-3-5、线程的返回值"></a>8-3-5、线程的返回值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">static int num = 666;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"></span><br><span class="line"> printf(&quot;子线程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> //子线程如果要返回退出状态，可以通过返回值或者通过pthread_exit函数</span><br><span class="line"> return (void *)&amp;num;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int *num;</span><br><span class="line"> if(pthread_join(thread, (void **)&amp;num) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_join&quot;);</span><br><span class="line"> exit(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> printf(&quot;ret_val = %d\n&quot;, *num);</span><br><span class="line"> printf(&quot;进程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-6、线程分离"><a href="#8-3-6、线程分离" class="headerlink" title="8-3-6、线程分离"></a>8-3-6、线程分离</h3><pre><code>线程的结合态和分离态linux线程执行和windows不同，pthread有两种状态：可结合的（joinable）或者是分离的（detached），线程默认创建为可结合态。如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了pthread_join之后这些资源才会被释放。若是detached状态的线程，这些资源在线程函数退出时或pthread_exit时自动会被释放，使用pthread_detach函数将线程设置为分离态。创建一个线程后应回收其资源，但使用pthread_join函数会使调用者阻塞，故Linux提供了线程分离函数：pthread_detach</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_detach(pthread_t thread);</span><br><span class="line">功能：使调用线程与当前进程分离，使其成为一个独立的线程，</span><br><span class="line">该线程终止时，系统将自动回收它的资源。</span><br><span class="line">参数：</span><br><span class="line">thread：指定的子线程的id</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> sleep(3);</span><br><span class="line"></span><br><span class="line"> printf(&quot;子线程要退出了\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> //通过pthread_detach函数将子线程设置为分离态，既不用阻塞，也可以自动回收子线程退出的资源</span><br><span class="line"> if(pthread_detach(thread) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(&quot;fail to pthread_detach&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //如果原本子线程是结合态，需要通过pthrad_join函数回收子线程退出的资源，</span><br><span class="line"> //但是这个函数是一个阻塞函数，如果子线程不退出，就会导致当前进程（主控线程）</span><br><span class="line"> //无法继续执行，大大的限制了代码的运行效率</span><br><span class="line"> //如果子线程已经设置为分离态，就不需要再使用pthread_join了</span><br><span class="line"> #if 0</span><br><span class="line"> if(pthread_join(thread, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_join&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"> #endif</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line">   &#123;</span><br><span class="line">   printf(&quot;hello world\n&quot;);</span><br><span class="line">   sleep(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-7、线程的退出"><a href="#8-3-7、线程的退出" class="headerlink" title="8-3-7、线程的退出"></a>8-3-7、线程的退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_exit(void *retval);</span><br><span class="line">功能：退出正在执行的线程</span><br><span class="line">参数：</span><br><span class="line">retval：当前线程的退出状态值，</span><br><span class="line">这个值可以被调用pthread_join函数的线程接收到</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><pre><code>注：    一个进程中的多个线程是共享该进程的数据段，因此，通常线程退出后所占用的资源并不会释放。如果要释放资源，结合态需要通过pthread_join函数，分离态则自动释放。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *thread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"> static char buf[] = &quot;This thread has quited&quot;;</span><br><span class="line"></span><br><span class="line"> int i;</span><br><span class="line"> for(int i = 0; i &lt; 10; i++)</span><br><span class="line">   &#123;</span><br><span class="line">   if(i == 5)</span><br><span class="line">      &#123;</span><br><span class="line">      //通过pthread_exit函数退出当前线程</span><br><span class="line">      //pthread_exit(NULL);</span><br><span class="line">      pthread_exit(buf);</span><br><span class="line">      &#125;</span><br><span class="line">   printf(&quot;*******************\n&quot;);</span><br><span class="line">   sleep(1);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;主控线程正在执行\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, thread_fun, NULL) != 0)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(&quot;fail to pthread_create&quot;);</span><br><span class="line">   exit(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> //pthread_join(thread, NULL);</span><br><span class="line"> char *str;</span><br><span class="line"> pthread_join(thread, (void **)&amp;str);</span><br><span class="line"> printf(&quot;str = %s\n&quot;, str);</span><br><span class="line"></span><br><span class="line"> printf(&quot;进程要退出了\n&quot;);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-8、线程的取消"><a href="#8-3-8、线程的取消" class="headerlink" title="8-3-8、线程的取消"></a>8-3-8、线程的取消</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_cancel(pthread_t thread);</span><br><span class="line">功能：取消线程</span><br><span class="line">参数：</span><br><span class="line">thread：要销毁的线程的id</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure><pre><code>pthread_cancel函数的实质是发信号给目标线程thread，使目标线程退出。    此函数只是发送终止信号给目标线程，    不会等待取消目标线程执行完才返回。然而发送成功并不意味着目标线程一定就会终止，线程被取消时，    线程的取消属性会决定线程能否被取消以及何时被取消。线程的取消状态    即线程能不能被取消。线程取消点    即线程被取消的地方。线程的取消类型    在线程能被取消的状态下，    是立马被取消结束还是执行到取消点的时候被取消结束。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //通过调用pthread_cancel函数取消另一个线程</span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-8-1、设置线程是否可以被取消pthread-setcancelstate"><a href="#8-3-8-1、设置线程是否可以被取消pthread-setcancelstate" class="headerlink" title="8-3-8-1、设置线程是否可以被取消pthread_setcancelstate()"></a>8-3-8-1、设置线程是否可以被取消pthread_setcancelstate()</h4><p>线程的取消状态<br>在Linux系统下，线程默认可以被取消。<br>编程时可以通过pthread_setcancelstate函数<br>设置线程是否可以被取消。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_setcancelstate(int state, int *oldstate);</span><br><span class="line">功能：设置线程是否被取消</span><br><span class="line">参数：</span><br><span class="line">state：新的状态</span><br><span class="line">PTHREAD_CANCEL_DISABLE：不可以被取消</span><br><span class="line">PTHREAD_CANCEL_ENABLE：可以被取消</span><br><span class="line">oldstate：保存调用线程原来的可取消状态的内存地址</span><br><span class="line">返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">//通过pthread_setcancelstate设置取消的状态</span><br><span class="line">//设置为可以取消</span><br><span class="line"> //pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);</span><br><span class="line"> //设置为不可取消</span><br><span class="line"> pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);</span><br><span class="line"></span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-8-2、设置线程的取消点pthread-testcancel"><a href="#8-3-8-2、设置线程的取消点pthread-testcancel" class="headerlink" title="8-3-8-2、设置线程的取消点pthread_testcancel()"></a>8-3-8-2、设置线程的取消点pthread_testcancel()</h4><pre><code>线程的取消点线程被取消后，该线程并不是马上终止，默认情况下线程执行到消点时才能被终止。编程时可以通过pthread_testcancel函数设置线程的取消点。void pthread_testcancel(void);当别的线程取消调用此函数的线程时候，被取消的线程执行到此函数时结束。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_testcancel(void);</span><br><span class="line">功能：设置线程的取消点</span><br><span class="line">参数：无</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;子线程从循环开始正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"></span><br><span class="line"> pthread_testcancel();</span><br><span class="line"> printf(&quot;子线程从循环末尾正在运行\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-8-3、设置线程是否可以被立即取消-pthread-setcanceltype"><a href="#8-3-8-3、设置线程是否可以被立即取消-pthread-setcanceltype" class="headerlink" title="8-3-8-3、设置线程是否可以被立即取消 pthread_setcanceltype()"></a>8-3-8-3、设置线程是否可以被立即取消 pthread_setcanceltype()</h4><pre><code>线程被取消后，该线程并不是马上终止，默认情况下线程执行到消点时才能被终止。编程时可以通过pthread_setcanceltype函数设置线程是否可以立即被取消。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_setcanceltype(int type, int *oldtype);</span><br><span class="line">功能：设置线程是否可以立即被取消</span><br><span class="line">参数：</span><br><span class="line">type：类型</span><br><span class="line">PTHREAD_CANCEL_ASYNCHRONOUS：立即取消、</span><br><span class="line">PTHREAD_CANCEL_DEFERRED：不立即被取消</span><br><span class="line">oldtype：保存调用线程原来的可取消类型的内存地址</span><br><span class="line">返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *pthread_fun(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);</span><br><span class="line"> //设置线程取消的类型</span><br><span class="line"> //设置为立即取消</span><br><span class="line"> //pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);</span><br><span class="line"> //设置为不立即取消</span><br><span class="line"> pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;子线程正在运行\n&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char const *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t thread;</span><br><span class="line"></span><br><span class="line"> if(pthread_create(&amp;thread, NULL, pthread_fun, NULL) != 0)</span><br><span class="line"> &#123;</span><br><span class="line"> perror(&quot;fail to pthread_create&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> pthread_cancel(thread);</span><br><span class="line"></span><br><span class="line"> pthread_join(thread, NULL);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="8-3-9、线程的退出pthread-cleanup-push"><a href="#8-3-9、线程的退出pthread-cleanup-push" class="headerlink" title="8-3-9、线程的退出pthread_cleanup_push()"></a>8-3-9、线程的退出pthread_cleanup_push()</h3><pre><code>和进程的退出清理一样，线程也可以注册它退出时要调用的函数，这样的函数称为线程清理处理程序(thread cleanup handler)。注意:    线程可以建立多个清理处理程序。    处理程序在栈中，故它们的执行顺序与它们注册时的顺序相反。    当线程执行以下动作时会调用清理函数：    1、调用pthread_exit退出线程。    2、响应其它线程的取消请求。    3、用非零execute调用pthread_cleanup_pop。</code></pre><h4 id="8-3-9-1、pthread-cleanup-push"><a href="#8-3-9-1、pthread-cleanup-push" class="headerlink" title="8-3-9-1、pthread_cleanup_push()"></a>8-3-9-1、pthread_cleanup_push()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_cleanup_push(void (* routine)(void *), void *arg);</span><br><span class="line">功能:将清除函数压栈。即注册清理函数。</span><br><span class="line">参数:</span><br><span class="line">routine：线程清理函数的指针。</span><br><span class="line">arg：传给线程清理函数的参数。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><h4 id="8-3-9-2、pthread-cleanup-pop"><a href="#8-3-9-2、pthread-cleanup-pop" class="headerlink" title="8-3-9-2、pthread_cleanup_pop()"></a>8-3-9-2、pthread_cleanup_pop()</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">void pthread_cleanup_pop(int execute);</span><br><span class="line">功能：将清除函数弹栈，即删除清理函数。</span><br><span class="line">参数：</span><br><span class="line">execute:线程清理函数执行标志位。</span><br><span class="line">非0，弹出清理函数，执行清理函数。</span><br><span class="line">0，弹出清理函数，不执行清理函数。</span><br><span class="line">返回值：无</span><br></pre></td></tr></table></figure><h4 id="8-3-9-3、案例：验证线程调用pthread-exit函数时，系统自动调用线程清理函数"><a href="#8-3-9-3、案例：验证线程调用pthread-exit函数时，系统自动调用线程清理函数" class="headerlink" title="8-3-9-3、案例：验证线程调用pthread_exit函数时，系统自动调用线程清理函数"></a>8-3-9-3、案例：验证线程调用pthread_exit函数时，系统自动调用线程清理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void mycleanup(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;clean up ptr = %s\n&quot;, (char *)arg);</span><br><span class="line"> free((char *)arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> /*建立线程清理程序*/</span><br><span class="line"> printf(&quot;this is new thread\n&quot;);</span><br><span class="line"></span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"> ptr = (char*)malloc(100);</span><br><span class="line"> pthread_cleanup_push(mycleanup, (void*)(ptr));</span><br><span class="line"> bzero(ptr, 100);//内存清除与memset的区别是，memset可以设置为设置为其他数，不一定为0</span><br><span class="line"> strcpy(ptr, &quot;memory from malloc&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(3);</span><br><span class="line"> printf(&quot;before exit\n&quot;);</span><br><span class="line"></span><br><span class="line"> pthread_exit(NULL);</span><br><span class="line"></span><br><span class="line"> /*注意push与pop必须配对使用，即使pop执行不到*/</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t tid;</span><br><span class="line"> pthread_create(&amp;tid, NULL, thread, NULL); // 创建一个线程</span><br><span class="line"> pthread_join(tid,NULL);</span><br><span class="line"> printf(&quot;process is dying\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数"><a href="#8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数" class="headerlink" title="8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数"></a>8-3-9-4、案例：验证线程被取消时，系统自动调用线程清理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void cleanup(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;clean up ptr = %s\n&quot;, (char *)arg);</span><br><span class="line"> free((char *)arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"></span><br><span class="line"> /*建立线程清理程序*/</span><br><span class="line"> printf(&quot;this is new thread\n&quot;);</span><br><span class="line"> ptr = (char*)malloc(100);</span><br><span class="line"> pthread_cleanup_push(cleanup, (void*)(ptr));</span><br><span class="line"> bzero(ptr, 100);</span><br><span class="line"> strcpy(ptr, &quot;memory from malloc&quot;);</span><br><span class="line"></span><br><span class="line"> sleep(10);</span><br><span class="line"></span><br><span class="line"> /*注意push与pop必须配对使用，即使pop执行不到*/</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t tid;</span><br><span class="line"> pthread_create(&amp;tid, NULL, thread, NULL); // 创建一个线程</span><br><span class="line"> sleep(5);</span><br><span class="line"> printf(&quot;before cancel\n&quot;);</span><br><span class="line"> /*子线程响应pthread_cancel后，会执行线程处理函数*/</span><br><span class="line"> pthread_cancel(tid);</span><br><span class="line"> pthread_join(tid,NULL);</span><br><span class="line"> printf(&quot;process is dying\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-9-5、案例：验证调用pthread-cleanup-pop函数时，系统自动调用线程清理函数"><a href="#8-3-9-5、案例：验证调用pthread-cleanup-pop函数时，系统自动调用线程清理函数" class="headerlink" title="8-3-9-5、案例：验证调用pthread_cleanup_pop函数时，系统自动调用线程清理函数"></a>8-3-9-5、案例：验证调用pthread_cleanup_pop函数时，系统自动调用线程清理函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">void cleanup_func1(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;in cleanup func1\n&quot;);</span><br><span class="line"> printf(&quot;clean up ptr = %s\n&quot;, (char *)arg);</span><br><span class="line"> free((char *)arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void cleanup_func2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;in cleanup func2\n&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *ptr = NULL;</span><br><span class="line"></span><br><span class="line"> /*建立线程清理程序*/</span><br><span class="line"> printf(&quot;this is new thread\n&quot;);</span><br><span class="line"> ptr = (char*)malloc(100);</span><br><span class="line"> pthread_cleanup_push(cleanup_func1, (void*)(ptr));</span><br><span class="line"> pthread_cleanup_push(cleanup_func2, NULL);</span><br><span class="line"> bzero(ptr, 100);</span><br><span class="line"> strcpy(ptr, &quot;memory from malloc&quot;);</span><br><span class="line"> /*注意push与pop必须配对使用，即使pop执行不到*/</span><br><span class="line"> sleep(3);</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> printf(&quot;before pop\n&quot;);</span><br><span class="line"> pthread_cleanup_pop(1);</span><br><span class="line"> return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> pthread_t tid;</span><br><span class="line"> pthread_create(&amp;tid, NULL, thread, NULL); // 创建一个线程</span><br><span class="line"> pthread_join(tid,NULL);</span><br><span class="line"> printf(&quot;process is dying\n&quot;);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="9、多任务同步与互斥"><a href="#9、多任务同步与互斥" class="headerlink" title="9、多任务同步与互斥"></a>9、多任务同步与互斥</h1><pre><code>在多任务操作系统中，同时运行的多个任务可能都需要访问/使用同一种资源。多个任务之间有依赖关系，某个任务的运行依赖于另一个任务。同步和互斥就是用于解决这两个问题的。互斥:一个公共资源同一时刻只能被一个进程或线程使用，多个进程或线程不能同时使用公共资源。POSIX标准中进程和线程同步和互斥的方法,主要有信号量和互斥锁两种方式。同步:两个或两个以上的进程或线程在运行过程中协同步调，按预定的先后次序运行。同步就是在互斥的基础上有顺序。</code></pre><h2 id="9-1、互斥锁"><a href="#9-1、互斥锁" class="headerlink" title="9-1、互斥锁"></a>9-1、互斥锁</h2><h3 id="9-1-1-互斥锁的概念"><a href="#9-1-1-互斥锁的概念" class="headerlink" title="9-1-1 互斥锁的概念"></a>9-1-1 互斥锁的概念</h3><pre><code>mutex是一种简单的加锁的方法来控制对共享资源的访问，mutex只有两种状态,即上锁(lock)和解锁(unlock)。在访问该资源前，首先应申请mutex，如果mutex处于unlock状态，则会申请到mutex并立即lock；如果mutex处于lock状态，则默认阻塞申请者。unlock操作应该由lock者进行。</code></pre><h3 id="9-1-2、-互斥锁的操作"><a href="#9-1-2、-互斥锁的操作" class="headerlink" title="9-1-2、 互斥锁的操作"></a>9-1-2、 互斥锁的操作</h3><h4 id="9-1-2-1、-初始化互斥锁"><a href="#9-1-2-1、-初始化互斥锁" class="headerlink" title="9-1-2-1、 初始化互斥锁"></a>9-1-2-1、 初始化互斥锁</h4><pre><code>mutex用pthread_mutex_t数据类型表示，在使用互斥锁前,必须先对它进行初始化。静态分配的互斥锁：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;动态分配互斥锁:pthread_mutex_t mutex;pthread_mutex_init(&amp;mutex, NULL);在所有使用过此互斥锁的线程都不再需要使用时候，应调用pthread_mutex_destroy销毁互斥锁。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t*mutexattr);</span><br><span class="line">功能：初始化一个互斥锁</span><br><span class="line">参数：</span><br><span class="line">mutex：指定的互斥锁</span><br><span class="line">mutexattr：互斥锁的属性，为NULL表示默认属性</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br></pre></td></tr></table></figure><h4 id="9-1-2-2、互斥锁上锁"><a href="#9-1-2-2、互斥锁上锁" class="headerlink" title="9-1-2-2、互斥锁上锁"></a>9-1-2-2、互斥锁上锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex);</span><br><span class="line">功能：对互斥锁上锁，若已经上锁，则调用者一直阻塞到互斥锁解锁</span><br><span class="line">参数：</span><br><span class="line">mutex：指定的互斥锁</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br><span class="line"> #include &lt;pthread.h&gt;</span><br><span class="line"> int pthread_mutex_trylock(pthread_mutex_t *mutex);</span><br><span class="line"> 功能：对互斥锁上锁，若已经上锁，则上锁失败，函数立即返回。</span><br><span class="line"> 参数：</span><br><span class="line"> mutex：互斥锁地址。</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：非0。</span><br></pre></td></tr></table></figure><h4 id="9-1-2-3、互斥锁解锁"><a href="#9-1-2-3、互斥锁解锁" class="headerlink" title="9-1-2-3、互斥锁解锁"></a>9-1-2-3、互斥锁解锁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t * mutex);</span><br><span class="line">功能：对指定的互斥锁解锁。</span><br><span class="line">参数：</span><br><span class="line">mutex：互斥锁地址。</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：非0</span><br></pre></td></tr></table></figure><h4 id="9-1-2-4、销毁互斥锁"><a href="#9-1-2-4、销毁互斥锁" class="headerlink" title="9-1-2-4、销毁互斥锁"></a>9-1-2-4、销毁互斥锁</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="number">2</span> <span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="number">3</span> 功能：销毁指定的一个互斥锁。</span><br><span class="line"><span class="number">4</span> 参数：</span><br><span class="line"><span class="number">5</span> mutex：互斥锁地址。</span><br><span class="line"><span class="number">6</span> 返回值：</span><br><span class="line"><span class="number">7</span> 成功：<span class="number">0</span></span><br><span class="line"><span class="number">8</span> 失败：非<span class="number">0</span>。</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>若不上锁</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> money = <span class="number">10000</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">pthread_fun1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">   &#123;</span><br><span class="line">   shiji = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  shiji = get;</span><br><span class="line">  yu = yu - get;</span><br><span class="line">  money = yu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">pthread_fun2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">   &#123;</span><br><span class="line">   shiji = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   shiji = get;</span><br><span class="line">   yu = yu - get;</span><br><span class="line">   money = yu;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread1, <span class="literal">NULL</span>, pthread_fun1, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread2, <span class="literal">NULL</span>, pthread_fun2, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line"> pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/ef03ed82811e46d1adc0009a7e37a47e.png"></p><pre><code>使用了互斥锁</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//通过互斥锁解决线程间互斥问题</span></span><br><span class="line"><span class="type">int</span> money = <span class="number">10000</span>;</span><br><span class="line"> <span class="comment">//第一步：创建互斥锁(由于两个线程操作同一个互斥锁，所以定义在全局更加方便一点)</span></span><br><span class="line"> <span class="type">pthread_mutex_t</span> mymutex;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">pthread_fun1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第三步：对共享资源的操作进行上锁</span></span><br><span class="line"> pthread_mutex_lock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">  &#123;</span><br><span class="line">  shiji = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  shiji = get;</span><br><span class="line">  yu = yu - get;</span><br><span class="line">  money = yu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;张三想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第四步：当共享资源的操作执行完毕后，对互斥锁执行解锁操作</span></span><br><span class="line"> pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> *<span class="title function_">pthread_fun2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> get, yu, shiji;</span><br><span class="line"> get = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第三步：对共享资源的操作进行上锁</span></span><br><span class="line"> pthread_mutex_lock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在查询余额...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> yu = money;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四正在取钱...\n&quot;</span>);</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">if</span>(get &gt; yu)</span><br><span class="line">   &#123;</span><br><span class="line">   shiji = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">  shiji = get;</span><br><span class="line">  yu = yu - get;</span><br><span class="line">  money = yu;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;李四想取%d元，实际取了%d元，余额为%d元\n&quot;</span>, get, shiji, yu);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第四步：当共享资源的操作执行完毕后，对互斥锁执行解锁操作</span></span><br><span class="line"> pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">//第二步：初始化互斥锁</span></span><br><span class="line"> pthread_mutex_init(&amp;mymutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread1, <span class="literal">NULL</span>, pthread_fun1, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(pthread_create(&amp;thread2, <span class="literal">NULL</span>, pthread_fun2, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  perror(<span class="string">&quot;fail to pthread_create&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> pthread_join(thread1, <span class="literal">NULL</span>);</span><br><span class="line"> pthread_join(thread2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第五步：当互斥锁使用完毕后，要销毁</span></span><br><span class="line"> pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0480297b4cf8424bb965e5bc9cd3a374.png"></p><h2 id="9-2、信号量"><a href="#9-2、信号量" class="headerlink" title="9-2、信号量"></a>9-2、信号量</h2><h3 id="9-2-1、信号量的概念"><a href="#9-2-1、信号量的概念" class="headerlink" title="9-2-1、信号量的概念"></a>9-2-1、信号量的概念</h3><pre><code>信号量广泛用于进程或线程间的同步和互斥，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。编程时可根据操作信号量值的结果判断是否对公共资源具有访问的权限，当信号量值大于０时，则可以访问，否则将阻塞。信号量又称之为PV操作，ＰＶ原语是对信号量的操作，一次Ｐ操作使信号量sem减１，一次Ｖ操作使信号量sem加１，对于P操作，如果信号量的sem值为小于等于0，则P操作就会阻塞，如果信号量的值大于0，才可以执行P操作进行减1信号量主要用于进程或线程间的同步和互斥这两种典型情况。1、若用于互斥，几个进程（或线程）往往只设置一个信号量。2、若用于同步操作，往往会设置多个信号量，并且安排不同的初始值，来实现它们之间的执行顺序。</code></pre><p>信号量用于互斥<br><img src="https://img-blog.csdnimg.cn/ba6ef89e6784407385d7cd5750323559.png"></p><p>信号量用于同步<br><img src="https://img-blog.csdnimg.cn/956825e64a504b3d98fa553a0c427ae4.png"></p><h3 id="9-2-2、信号量的操作"><a href="#9-2-2、信号量的操作" class="headerlink" title="9-2-2、信号量的操作"></a>9-2-2、信号量的操作</h3><h4 id="9-2-2-1、信号量的初始化"><a href="#9-2-2-1、信号量的初始化" class="headerlink" title="9-2-2-1、信号量的初始化"></a>9-2-2-1、信号量的初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">功能：初始化一个信号量</span><br><span class="line">参数：</span><br><span class="line">sem：指定的信号量</span><br><span class="line">pshared：是否在线程间或者进程间共享</span><br><span class="line">0 线程间共享</span><br><span class="line">1 进程间共享</span><br><span class="line">value：信号量的初始值</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h4 id="9-2-2-2、信号量的p操作"><a href="#9-2-2-2、信号量的p操作" class="headerlink" title="9-2-2-2、信号量的p操作"></a>9-2-2-2、信号量的p操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_wait(sem_t *sem);</span><br><span class="line">功能：将信号量的值减1，若信号量的值小于等于0，此函数会引起调用者阻塞</span><br><span class="line">参数：</span><br><span class="line">sem：指定的信号量</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br><span class="line"> #include &lt;semaphore.h&gt;</span><br><span class="line"> int sem_trywait(sem_t *sem);</span><br><span class="line"> 功能：将信号量的值减1，若信号量的值小于0，则对信号量的操作失败，函数立即返回。</span><br><span class="line"> 参数：</span><br><span class="line"> sem：信号量地址。</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h4 id="9-2-2-3、信号量的v操作"><a href="#9-2-2-3、信号量的v操作" class="headerlink" title="9-2-2-3、信号量的v操作"></a>9-2-2-3、信号量的v操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_post(sem_t *sem);</span><br><span class="line">功能：执行V操作，执行一次，信号量的值加1</span><br><span class="line">参数：</span><br><span class="line">sem：指定的信号量</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br></pre></td></tr></table></figure><h4 id="9-2-2-3、获取信号量的计数"><a href="#9-2-2-3、获取信号量的计数" class="headerlink" title="9-2-2-3、获取信号量的计数"></a>9-2-2-3、获取信号量的计数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="line">功能：获取sem标识的信号量的值，保存在sval中。</span><br><span class="line">参数：</span><br><span class="line">sem：信号量地址。</span><br><span class="line">sval：保存信号量值的地址。</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1。</span><br></pre></td></tr></table></figure><h4 id="9-2-2-4、信号量的销毁"><a href="#9-2-2-4、信号量的销毁" class="headerlink" title="9-2-2-4、信号量的销毁"></a>9-2-2-4、信号量的销毁</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_destroy(sem_t *sem);</span><br><span class="line">功能：</span><br><span class="line">删除sem标识的信号量。</span><br><span class="line">参数：</span><br><span class="line">sem：信号量地址。</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1。</span><br></pre></td></tr></table></figure><h3 id="9-2-3、信号量的使用"><a href="#9-2-3、信号量的使用" class="headerlink" title="9-2-3、信号量的使用"></a>9-2-3、信号量的使用</h3><h4 id="信号量实现互斥功能"><a href="#信号量实现互斥功能" class="headerlink" title="信号量实现互斥功能"></a>信号量实现互斥功能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">//通过信号量实现互斥操作</span><br><span class="line">//第一步：创建一个信号量</span><br><span class="line">sem_t sem;</span><br><span class="line"></span><br><span class="line"> void printer(char *str)</span><br><span class="line"> &#123;</span><br><span class="line"> //第三步：执行P操作</span><br><span class="line"> //由于使用信号量实现互斥，信号量的初始值设置为1，则两个线程执行P操作，</span><br><span class="line"> //先执行P操作的线程继续执行，后执行P操作的先阻塞等待</span><br><span class="line"> sem_wait(&amp;sem);</span><br><span class="line"> while(*str)</span><br><span class="line"> &#123;</span><br><span class="line"> putchar(*str);</span><br><span class="line"> fflush(stdout);</span><br><span class="line"> str++;</span><br><span class="line"> sleep(1);</span><br><span class="line"> &#125;</span><br><span class="line"> //第四步：执行V操作</span><br><span class="line"> sem_post(&amp;sem);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread_fun1(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *str1 = &quot;hello&quot;;</span><br><span class="line"> printer(str1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> void *thread_fun2(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> char *str2 = &quot;world&quot;;</span><br><span class="line"> printer(str2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(void)</span><br><span class="line"> &#123;</span><br><span class="line"> //第二步：初始化信号量</span><br><span class="line"> sem_init(&amp;sem, 0, 1);</span><br><span class="line"></span><br><span class="line"> pthread_t tid1, tid2;</span><br><span class="line"></span><br><span class="line"> pthread_create(&amp;tid1, NULL, thread_fun1, NULL);</span><br><span class="line"> pthread_create(&amp;tid2, NULL, thread_fun2, NULL);</span><br><span class="line"></span><br><span class="line"> pthread_join(tid1, NULL);</span><br><span class="line"> pthread_join(tid2, NULL);</span><br><span class="line"></span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"> //第五步：使用完毕后销毁信号量</span><br><span class="line"> sem_destroy(&amp;sem);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">//使用信号量实现同步功能，如果两个线程实现同步，需要通过两个信号量</span><br><span class="line">char ch = &#x27;A&#x27;;</span><br><span class="line"> //第一步：创建两个信号量</span><br><span class="line"> sem_t sem_g, sem_p;</span><br><span class="line"></span><br><span class="line"> void * pthread_g(void *arg)</span><br><span class="line"> &#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> //第四步：后执行的线程中，信号量的初始值设置为0的信号量执行P操作</span><br><span class="line"> sem_wait(&amp;sem_g);</span><br><span class="line"></span><br><span class="line"> ch++;</span><br><span class="line"> sleep(1);</span><br><span class="line"></span><br><span class="line"> //第六步：后执行的线程执行完毕后，信号量初始值为1的信号量执行V操作</span><br><span class="line"> sem_post(&amp;sem_p);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> void * pthread_p(void *arg) //此线程打印ch的值</span><br><span class="line"> &#123;</span><br><span class="line"> while(1)</span><br><span class="line"> &#123;</span><br><span class="line"> //第三步：先执行的线程中，信号量初始值设置为1的信号量执行P操作</span><br><span class="line"> sem_wait(&amp;sem_p);</span><br><span class="line"></span><br><span class="line"> printf(&quot;%c&quot;,ch);</span><br><span class="line"> fflush(stdout);</span><br><span class="line"></span><br><span class="line"> //第五步：当先执行的线程执行完毕后，信号量初始值为0的信号量执行V操作</span><br><span class="line"> sem_post(&amp;sem_g);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> int main(int argc, char *argv[])</span><br><span class="line"> &#123;</span><br><span class="line"> //初始化信号量</span><br><span class="line"> sem_init(&amp;sem_g, 0, 0);</span><br><span class="line"> sem_init(&amp;sem_p, 0, 1);</span><br><span class="line"></span><br><span class="line"> pthread_t tid1,tid2;</span><br><span class="line"></span><br><span class="line"> pthread_create(&amp;tid1,NULL,pthread_g,NULL);</span><br><span class="line"> pthread_create(&amp;tid2,NULL,pthread_p,NULL);</span><br><span class="line"></span><br><span class="line"> pthread_join(tid1,NULL);</span><br><span class="line"> pthread_join(tid2,NULL);</span><br><span class="line"></span><br><span class="line"> printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"> //第七步：使用完毕后销毁信号量</span><br><span class="line"> sem_destroy(&amp;sem_g);</span><br><span class="line"> sem_destroy(&amp;sem_p);</span><br><span class="line"></span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uboot移植（uboot2024.4移植）</title>
      <link href="/posts/4d7a5285.html"/>
      <url>/posts/4d7a5285.html</url>
      
        <content type="html"><![CDATA[<p>imx6ull板子为例：<br>下载源码：<a href="https://github.com/nxp-imx/uboot-imx/tree/lf_v2024.04">https://github.com/nxp-imx/uboot-imx/tree/lf_v2024.04</a><br>注意设备树的语法最后要空行</p><h1 id="1、编译"><a href="#1、编译" class="headerlink" title="1、编译"></a>1、编译</h1><p>拿到源码后，先编译一遍和自己要移植的板子所用的芯片匹配的配置文件。如我这里用的是imx6ull的板子，就需要编译imx6ull的配置文件。<br><code>编译过后，需要改的目录下生成了一些文件，可以按照文件去判定编译的配置文件是否和自己板子匹配。</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">path=&quot;arm CROSS_COMPILE=/home/ygc/Desktop/linux-gcc/2021-6ull/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-&quot;</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125; distclean</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125; menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=$&#123;path&#125; mx6ull_14x14_naro_emmc_defconfig</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make ARCH=arm CROSS_COMPILE=<span class="variable">$&#123;path&#125;</span> mx6ull_14x14_evk_emmc_defconfig</span></span><br><span class="line">make V=1 ARCH=arm CROSS_COMPILE=$&#123;path&#125; -j12</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabihf- savedefconfig <span class="comment">#生成配置文件 与之前的配置文件相比较，看哪些配置变了</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">path 为自己的编译器路径</span></span><br></pre></td></tr></table></figure><h1 id="2、查看u-boot-map文件"><a href="#2、查看u-boot-map文件" class="headerlink" title="2、查看u-boot.map文件"></a>2、查看u-boot.map文件</h1><p>编译完成后，会在u-boot-2024.04&#x2F;build&#x2F;目录下生成u-boot.bin文件，这个文件就是我们最终要烧写的文件。<br>查看uboot.map文件，可以知道参与编译的文件。</p><h1 id="3、烧写到板子上"><a href="#3、烧写到板子上" class="headerlink" title="3、烧写到板子上"></a>3、烧写到板子上</h1><p>烧写到板子上，观察有无打印，没打印的，需要检查是否编译的配置文件和自己板子匹配。<br>一般串口优先使用原厂的串口，如果不行，再尝试其他的串口。</p><h1 id="4、修改配置文件"><a href="#4、修改配置文件" class="headerlink" title="4、修改配置文件"></a>4、修改配置文件</h1><p>将配置文件改为自己的配置文件。mx6ull_14x14_emmc_naro_defconfig、改为自己的配置文件，如mx6ull_14x14_naro_emmc_defconfig。文件存在于uboot&#x2F;configs&#x2F;目录下。</p><p>这个文件中主要改这几条：</p><ul><li><p>第一条：设备树的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DEFAULT_DEVICE_TREE=&quot;imx6ull-14x14-evk-emmc&quot;</span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DEFAULT_DEVICE_TREE=&quot;imx6ull-14x14-naro-emmc&quot;</span><br></pre></td></tr></table></figure></li><li><p>第二条：这个开发版编译的一个条件，存在于uboot&#x2F;board&#x2F;freescale&#x2F;imx6ullevk中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_TARGET_MX6ULL_14X14_EVK=y</span><br></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_TARGET_MX6ULL_14X14_NARO=y</span><br></pre></td></tr></table></figure></li><li><p>还有一条网络后面说。</p></li></ul><h1 id="5、修改板级文件"><a href="#5、修改板级文件" class="headerlink" title="5、修改板级文件"></a>5、修改板级文件</h1><ul><li><p>复制一份mx6ullevk,改为自己的板子名，如mx6ullnaro</p></li><li><p>将mx6ullevk.c文件改为自己的板子名，如mx6ullnaro.c</p></li><li><p>更改Kconfig文件，添加自己的板子名。<br>原文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_14X14_EVK || TARGET_MX6ULL_9X9_EVK</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default &quot;mx6ullevk&quot;</span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default &quot;freescale&quot;</span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default &quot;mx6ullevk&quot;</span><br><span class="line"></span><br><span class="line">config IMX_CONFIG</span><br><span class="line">default &quot;board/freescale/mx6ullevk/imximage.cfg&quot;</span><br><span class="line"></span><br><span class="line">config TEXT_BASE</span><br><span class="line">default 0x87800000</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改为自己的，前面的配置就是在这里用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if TARGET_MX6ULL_14X14_NARO</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">default &quot;mx6ullnaro&quot;</span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">default &quot;freescale&quot;</span><br><span class="line"></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">default &quot;mx6ullnaro&quot;</span><br><span class="line"></span><br><span class="line">config IMX_CONFIG</span><br><span class="line">default &quot;board/freescale/mx6ullnaro/imximage.cfg&quot;</span><br><span class="line"></span><br><span class="line">config TEXT_BASE</span><br><span class="line">default 0x87800000</span><br><span class="line">endif</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是一些条件编译宏</p></li><li><p>更改MAINTAINERS文件：<br>原文：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MX6ULLEVK BOARD</span><br><span class="line">M:Peng Fan &lt;peng.fan@nxp.com&gt;</span><br><span class="line">S:Maintained</span><br><span class="line">F:board/freescale/mx6ullevk/</span><br><span class="line">F:include/configs/mx6ullevk.h</span><br><span class="line">F:configs/mx6ull_14x14_evk_defconfig</span><br><span class="line">F:configs/mx6ull_14x14_evk_plugin_defconfig</span><br><span class="line">F:configs/mx6ulz_14x14_evk_defconfig</span><br></pre></td></tr></table></figure><p>这段代码描述了MX6ULL NARO开发板的相关维护信息和配置文件路径。具体说明如下：</p></li></ul><p>M: 维护者信息，Peng Fan <a href="mailto:&#112;&#101;&#110;&#103;&#x2e;&#x66;&#x61;&#110;&#x40;&#x6e;&#x78;&#112;&#46;&#x63;&#x6f;&#109;">&#112;&#101;&#110;&#103;&#x2e;&#x66;&#x61;&#110;&#x40;&#x6e;&#x78;&#112;&#46;&#x63;&#x6f;&#109;</a>。<br>S: 当前状态为“Maintained”，表示该板子正在维护中。<br>F: 列出了与MX6ULL NARO开发板相关的配置文件路径，包括：<br>board&#x2F;freescale&#x2F;mx6ullevk&#x2F;<br>include&#x2F;configs&#x2F;mx6ullevk.h<br>configs&#x2F;mx6ull_14x14_evk_defconfig<br>configs&#x2F;mx6ull_14x14_evk_plugin_defconfig<br>configs&#x2F;mx6ulz_14x14_evk_defconfig<br>这些文件定义了开发板的硬件配置和启动参数。</p><p>改为自己的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MX6ULLNARO BOARD</span><br><span class="line">M:Peng Fan &lt;peng.fan@nxp.com&gt;</span><br><span class="line">S:Maintained</span><br><span class="line">F:board/freescale/mx6ullnaro/</span><br><span class="line">F:include/configs/mx6ullnaro.h</span><br><span class="line">F:configs/mx6ull_14x14_naro_defconfig</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>更改Makefile文件：<br>原文：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line"><span class="comment"># (C) Copyright 2016 Freescale Semiconductor, Inc.</span></span><br><span class="line"> </span><br><span class="line">obj-y  := mx6ullevk.o</span><br></pre></td></tr></table></figure><p>改为自己的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0+</span></span><br><span class="line"><span class="comment"># (C) Copyright 2016 Freescale Semiconductor, Inc.</span></span><br><span class="line"></span><br><span class="line">obj-y  := mx6ullnaro.o</span><br><span class="line"></span><br><span class="line">```     </span><br><span class="line"> 更改mx6ullalpha.c文件：</span><br><span class="line"> 原文：</span><br><span class="line"> ```C</span><br><span class="line"> // SPDX-License-Identifier: GPL-2.0+</span><br><span class="line">/*</span><br><span class="line"> * Copyright (C) 2016 Freescale Semiconductor, Inc.</span><br><span class="line"> * Copyright 2017 NXP</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;init.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/arch/clock.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/arch/iomux.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/arch/imx-regs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/arch/crm_regs.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/arch/mx6-pins.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/arch/sys_proto.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/global_data.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/gpio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach-imx/iomux-v3.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach-imx/boot_mode.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/mach-imx/mxc_i2c.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;asm/io.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;common.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;env.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;fsl_esdhc_imx.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;i2c.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;miiphy.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/sizes.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;linux/delay.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;mmc.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;miiphy.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;power/pmic.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;power/pfuze3000_pmic.h&gt;</span></span><br><span class="line"><span class="comment">#include &quot;../common/pfuze.h&quot;</span></span><br><span class="line"></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"></span><br><span class="line">// 定义I2C引脚控制寄存器的配置</span><br><span class="line"><span class="comment">#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \</span></span><br><span class="line">PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \</span><br><span class="line">PAD_CTL_DSE_40ohm | PAD_CTL_HYS |\</span><br><span class="line">PAD_CTL_ODE)</span><br><span class="line"></span><br><span class="line">// 定义LCD引脚控制寄存器的配置</span><br><span class="line"><span class="comment">#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \</span></span><br><span class="line">PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)</span><br><span class="line"></span><br><span class="line">// 定义GPMI NAND引脚控制寄存器的配置</span><br><span class="line"><span class="comment">#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)</span></span><br><span class="line"><span class="comment">#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \</span></span><br><span class="line">PAD_CTL_SRE_FAST)</span><br><span class="line"><span class="comment">#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_DM_PMIC</span></span><br><span class="line">// 初始化电源管理IC（PMIC）</span><br><span class="line">int power_init_board(void)</span><br><span class="line">&#123;</span><br><span class="line">struct udevice *dev;</span><br><span class="line">int ret, dev_id, rev_id;</span><br><span class="line">unsigned int reg;</span><br><span class="line"></span><br><span class="line">// 获取PFUZE3000 PMIC设备</span><br><span class="line">ret = pmic_get(<span class="string">&quot;pfuze3000@8&quot;</span>, &amp;dev);</span><br><span class="line">if (ret == -ENODEV)</span><br><span class="line">return 0; // 如果设备不存在，返回0</span><br><span class="line">if (ret != 0)</span><br><span class="line">return ret; // 如果获取设备失败，返回错误码</span><br><span class="line"></span><br><span class="line">// 读取PMIC的设备ID和修订ID</span><br><span class="line">dev_id = pmic_reg_read(dev, PFUZE3000_DEVICEID);</span><br><span class="line">rev_id = pmic_reg_read(dev, PFUZE3000_REVID);</span><br><span class="line">printf(<span class="string">&quot;PMIC: PFUZE3000 DEV_ID=0x%x REV_ID=0x%x\n&quot;</span>, dev_id, rev_id);</span><br><span class="line"></span><br><span class="line">// 禁用待机模式期间的低功耗模式</span><br><span class="line">reg = pmic_reg_read(dev, PFUZE3000_LDOGCTL);</span><br><span class="line">reg |= 0x1;</span><br><span class="line">pmic_reg_write(dev, PFUZE3000_LDOGCTL, reg);</span><br><span class="line"></span><br><span class="line">// 设置SW1B的上升时间从2us到4us/25mV</span><br><span class="line">pmic_reg_write(dev, PFUZE3000_SW1BCONF, 0x40);</span><br><span class="line"></span><br><span class="line">// 设置SW1B模式为APS/PFM</span><br><span class="line">pmic_reg_write(dev, PFUZE3000_SW1BMODE, 0xc);</span><br><span class="line"></span><br><span class="line">// 设置SW1B待机电压为0.975V</span><br><span class="line">pmic_reg_write(dev, PFUZE3000_SW1BSTBY, 0xb);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_LDO_BYPASS_CHECK</span></span><br><span class="line">// 设置LDO旁路模式</span><br><span class="line">void ldo_mode_set(int ldo_bypass)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int value;</span><br><span class="line">u32 vddarm;</span><br><span class="line">struct udevice *dev;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">// 获取PFUZE3000 PMIC设备</span><br><span class="line">ret = pmic_get(<span class="string">&quot;pfuze3000@8&quot;</span>, &amp;dev);</span><br><span class="line">if (ret == -ENODEV) &#123;</span><br><span class="line">printf(<span class="string">&quot;No PMIC found!\n&quot;</span>);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 切换到LDO旁路模式</span><br><span class="line">if (ldo_bypass) &#123;</span><br><span class="line">prep_anatop_bypass();</span><br><span class="line">// 将VDDARM电压降低到1.275V</span><br><span class="line">value = pmic_reg_read(dev, PFUZE3000_SW1BVOLT);</span><br><span class="line">value &amp;= ~0x1f;</span><br><span class="line">value |= PFUZE3000_SW1AB_SETP(12750);</span><br><span class="line">pmic_reg_write(dev, PFUZE3000_SW1BVOLT, value);</span><br><span class="line"></span><br><span class="line">set_anatop_bypass(1);</span><br><span class="line">vddarm = PFUZE3000_SW1AB_SETP(11750);</span><br><span class="line"></span><br><span class="line">value = pmic_reg_read(dev, PFUZE3000_SW1BVOLT);</span><br><span class="line">value &amp;= ~0x1f;</span><br><span class="line">value |= vddarm;</span><br><span class="line">pmic_reg_write(dev, PFUZE3000_SW1BVOLT, value);</span><br><span class="line"></span><br><span class="line">finish_anatop_bypass();</span><br><span class="line"></span><br><span class="line">printf(<span class="string">&quot;switch to ldo_bypass mode!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 初始化DRAM</span><br><span class="line">int dram_init(void)</span><br><span class="line">&#123;</span><br><span class="line">gd-&gt;ram_size = imx_ddr_size(); // 获取DDR内存大小</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取MMC设备编号</span><br><span class="line">int board_mmc_get_env_dev(int devno)</span><br><span class="line">&#123;</span><br><span class="line">return devno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_FSL_QSPI</span></span><br><span class="line"><span class="comment">#ifndef CONFIG_DM_SPI</span></span><br><span class="line">// 定义QuadSPI引脚控制寄存器的配置</span><br><span class="line"><span class="comment">#define QSPI_PAD_CTRL1\</span></span><br><span class="line">(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \</span><br><span class="line"> PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_120ohm)</span><br><span class="line"></span><br><span class="line">// QuadSPI引脚配置数组</span><br><span class="line">static iomux_v3_cfg_t const quadspi_pads[] = &#123;</span><br><span class="line">MX6_PAD_NAND_WP_B__QSPI_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),</span><br><span class="line">MX6_PAD_NAND_READY_B__QSPI_A_DATA00 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),</span><br><span class="line">MX6_PAD_NAND_CE0_B__QSPI_A_DATA01 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),</span><br><span class="line">MX6_PAD_NAND_CE1_B__QSPI_A_DATA02 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),</span><br><span class="line">MX6_PAD_NAND_CLE__QSPI_A_DATA03 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),</span><br><span class="line">MX6_PAD_NAND_DQS__QSPI_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL1),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 初始化QuadSPI</span><br><span class="line">static int board_qspi_init(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#ifndef CONFIG_DM_SPI</span></span><br><span class="line">// 设置QuadSPI引脚</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(quadspi_pads,</span><br><span class="line"> ARRAY_SIZE(quadspi_pads));</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">// 启用QuadSPI时钟</span><br><span class="line">enable_qspi_clk(0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_NAND_MXS</span></span><br><span class="line">// NAND引脚配置数组</span><br><span class="line">static iomux_v3_cfg_t const nand_pads[] = &#123;</span><br><span class="line">MX6_PAD_NAND_DATA00__RAWNAND_DATA00 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA01__RAWNAND_DATA01 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA02__RAWNAND_DATA02 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA03__RAWNAND_DATA03 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA04__RAWNAND_DATA04 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA05__RAWNAND_DATA05 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA06__RAWNAND_DATA06 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DATA07__RAWNAND_DATA07 | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_CLE__RAWNAND_CLE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_ALE__RAWNAND_ALE | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_CE0_B__RAWNAND_CE0_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_CE1_B__RAWNAND_CE1_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_RE_B__RAWNAND_RE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_WE_B__RAWNAND_WE_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_WP_B__RAWNAND_WP_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_READY_B__RAWNAND_READY_B | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">MX6_PAD_NAND_DQS__RAWNAND_DQS | MUX_PAD_CTRL(GPMI_PAD_CTRL2),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化GPMI NAND</span><br><span class="line">static void setup_gpmi_nand(void)</span><br><span class="line">&#123;</span><br><span class="line">struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;</span><br><span class="line"></span><br><span class="line">// 设置GPMI NAND引脚</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(nand_pads, ARRAY_SIZE(nand_pads));</span><br><span class="line"></span><br><span class="line">// 设置GPMI IO时钟</span><br><span class="line">setup_gpmi_io_clk((MXC_CCM_CS2CDR_ENFC_CLK_PODF(0) |</span><br><span class="line">MXC_CCM_CS2CDR_ENFC_CLK_PRED(3) |</span><br><span class="line">MXC_CCM_CS2CDR_ENFC_CLK_SEL(3)));</span><br><span class="line"></span><br><span class="line">// 启用APBH时钟门控</span><br><span class="line">setbits_le32(&amp;mxc_ccm-&gt;CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_FEC_MXC</span></span><br><span class="line">// 初始化FEC（以太网）</span><br><span class="line">static int setup_fec(void)</span><br><span class="line">&#123;</span><br><span class="line">struct iomuxc *const iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 使用50M anatop环回REF_CLK1作为ENET1的时钟源，</span><br><span class="line"> * 清除gpr1[13]，设置gpr1[17]。</span><br><span class="line"> */</span><br><span class="line">clrsetbits_le32(&amp;iomuxc_regs-&gt;gpr[1], IOMUX_GPR1_FEC1_MASK,</span><br><span class="line">IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK);</span><br><span class="line">/*</span><br><span class="line"> * 使用50M anatop环回REF_CLK2作为ENET2的时钟源，</span><br><span class="line"> * 清除gpr1[14]，设置gpr1[18]。</span><br><span class="line"> */</span><br><span class="line">if (!check_module_fused(MODULE_ENET2)) &#123;</span><br><span class="line">clrsetbits_le32(&amp;iomuxc_regs-&gt;gpr[1], IOMUX_GPR1_FEC2_MASK,</span><br><span class="line">IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 启用ENET1的anatop时钟</span><br><span class="line">ret = enable_fec_anatop_clock(0, ENET_50MHZ);</span><br><span class="line">if (ret)</span><br><span class="line">return ret;</span><br><span class="line"></span><br><span class="line">// 启用ENET2的anatop时钟</span><br><span class="line">if (!check_module_fused(MODULE_ENET2)) &#123;</span><br><span class="line">ret = enable_fec_anatop_clock(1, ENET_50MHZ);</span><br><span class="line">if (ret)</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 启用ENET时钟</span><br><span class="line">enable_enet_clk(1);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 配置PHY设备</span><br><span class="line">int board_phy_config(struct phy_device *phydev)</span><br><span class="line">&#123;</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, 0x1f, 0x8190);</span><br><span class="line"></span><br><span class="line">if (phydev-&gt;drv-&gt;config)</span><br><span class="line">phydev-&gt;drv-&gt;config(phydev);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_VIDEO</span></span><br><span class="line">// LCD引脚配置数组</span><br><span class="line">static iomux_v3_cfg_t const lcd_pads[] = &#123;</span><br><span class="line">/* 使用GPIO进行亮度调整，占空比=周期。 */</span><br><span class="line">MX6_PAD_GPIO1_IO08__GPIO1_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 初始化LCD</span><br><span class="line">static int setup_lcd(void)</span><br><span class="line">&#123;</span><br><span class="line">// 启用LCDIF时钟</span><br><span class="line">enable_lcdif_clock(LCDIF1_BASE_ADDR, 1);</span><br><span class="line"></span><br><span class="line">// 设置LCD引脚</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));</span><br><span class="line"></span><br><span class="line">// 重置LCD</span><br><span class="line">gpio_request(IMX_GPIO_NR(5, 9), <span class="string">&quot;lcd reset&quot;</span>);</span><br><span class="line">gpio_direction_output(IMX_GPIO_NR(5, 9) , 0);</span><br><span class="line">udelay(500);</span><br><span class="line">gpio_direction_output(IMX_GPIO_NR(5, 9) , 1);</span><br><span class="line"></span><br><span class="line">// 设置亮度为高</span><br><span class="line">gpio_request(IMX_GPIO_NR(1, 8), <span class="string">&quot;backlight&quot;</span>);</span><br><span class="line">gpio_direction_output(IMX_GPIO_NR(1, 8) , 1);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#else</span></span><br><span class="line">static inline int setup_lcd(void) &#123; return 0; &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 早期初始化</span><br><span class="line">int board_early_init_f(void)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 板级初始化</span><br><span class="line">int board_init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 设置启动参数地址 */</span><br><span class="line">gd-&gt;bd-&gt;bi_boot_params = PHYS_SDRAM + 0x100;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdefCONFIG_FEC_MXC</span></span><br><span class="line">// 初始化FEC</span><br><span class="line">setup_fec();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_FSL_QSPI</span></span><br><span class="line">// 初始化QuadSPI</span><br><span class="line">board_qspi_init();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_NAND_MXS</span></span><br><span class="line">// 初始化GPMI NAND</span><br><span class="line">setup_gpmi_nand();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_CMD_BMODE</span></span><br><span class="line">// 定义启动模式</span><br><span class="line">static const struct boot_mode board_boot_modes[] = &#123;</span><br><span class="line">/* 4位总线宽度 */</span><br><span class="line">&#123;<span class="string">&quot;sd1&quot;</span>, MAKE_CFGVAL(0x42, 0x20, 0x00, 0x00)&#125;,</span><br><span class="line">&#123;<span class="string">&quot;sd2&quot;</span>, MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)&#125;,</span><br><span class="line">&#123;<span class="string">&quot;qspi1&quot;</span>, MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)&#125;,</span><br><span class="line">&#123;NULL, 0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 板子初始化</span><br><span class="line">int board_late_init(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#ifdef CONFIG_CMD_BMODE</span></span><br><span class="line">// 添加启动模式</span><br><span class="line">add_board_boot_modes(board_boot_modes);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 设置tee环境变量</span><br><span class="line">env_set(<span class="string">&quot;tee&quot;</span>, <span class="string">&quot;no&quot;</span>);</span><br><span class="line"><span class="comment">#ifdef CONFIG_IMX_OPTEE</span></span><br><span class="line">env_set(<span class="string">&quot;tee&quot;</span>, <span class="string">&quot;yes&quot;</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG</span></span><br><span class="line">// 设置板级名称</span><br><span class="line">env_set(<span class="string">&quot;board_name&quot;</span>, <span class="string">&quot;EVK&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 设置板级版本</span><br><span class="line">if (is_mx6ull_9x9_evk())</span><br><span class="line">env_set(<span class="string">&quot;board_rev&quot;</span>, <span class="string">&quot;9X9&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">env_set(<span class="string">&quot;board_rev&quot;</span>, <span class="string">&quot;14X14&quot;</span>);</span><br><span class="line"></span><br><span class="line">// 如果是MX6ULZ CPU，设置特定的环境变量</span><br><span class="line">if (is_cpu_type(MXC_CPU_MX6ULZ)) &#123;</span><br><span class="line">env_set(<span class="string">&quot;board_name&quot;</span>, <span class="string">&quot;ULZ-EVK&quot;</span>);</span><br><span class="line">env_set(<span class="string">&quot;usb_net_cmd&quot;</span>, <span class="string">&quot;usb start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 初始化LCD</span><br><span class="line">setup_lcd();</span><br><span class="line"></span><br><span class="line"><span class="comment">#ifdef CONFIG_ENV_IS_IN_MMC</span></span><br><span class="line">// 初始化MMC环境</span><br><span class="line">board_late_mmc_env_init();</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">// 设置看门狗复位</span><br><span class="line">set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查板级信息</span><br><span class="line">int checkboard(void)</span><br><span class="line">&#123;</span><br><span class="line">if (is_mx6ull_9x9_evk())</span><br><span class="line">puts(<span class="string">&quot;Board: MX6ULL 9x9 EVK\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> if (is_cpu_type(MXC_CPU_MX6ULZ))</span><br><span class="line">puts(<span class="string">&quot;Board: MX6ULZ 14x14 EVK\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">puts(<span class="string">&quot;Board: MX6ULL 14x14 EVK\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静音设备</span><br><span class="line">void board_quiesce_devices(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#if defined(CONFIG_VIDEO_MXS)</span></span><br><span class="line">// 禁用LCDIF时钟</span><br><span class="line">enable_lcdif_clock(LCDIF1_BASE_ADDR, 0);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>搜索CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG配置项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG</span></span><br><span class="line">env_set(<span class="string">&quot;board_name&quot;</span>, <span class="string">&quot;EVK&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_mx6ull_9x9_evk())</span><br><span class="line">env_set(<span class="string">&quot;board_rev&quot;</span>, <span class="string">&quot;9X9&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">env_set(<span class="string">&quot;board_rev&quot;</span>, <span class="string">&quot;14X14&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (is_cpu_type(MXC_CPU_MX6ULZ)) &#123;</span><br><span class="line">env_set(<span class="string">&quot;board_name&quot;</span>, <span class="string">&quot;ULZ-EVK&quot;</span>);</span><br><span class="line">env_set(<span class="string">&quot;usb_net_cmd&quot;</span>, <span class="string">&quot;usb start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG</span></span><br><span class="line">env_set(<span class="string">&quot;board_name&quot;</span>, <span class="string">&quot;naro&quot;</span>);</span><br><span class="line">env_set(<span class="string">&quot;board_rev&quot;</span>, <span class="string">&quot;14X14&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>找到checkboard函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkboard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (is_mx6ull_9x9_evk())</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL 9x9 EVK\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (is_cpu_type(MXC_CPU_MX6ULZ))</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULZ 14x14 EVK\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL 14x14 EVK\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkboard</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Board: MX6ULL ALPHA\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="6、添加板级头文件"><a href="#6、添加板级头文件" class="headerlink" title="6、添加板级头文件"></a>6、添加板级头文件</h1><p>原文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016 Freescale Semiconductor, Inc.</span></span><br><span class="line"><span class="comment"> * Copyright 2017 NXP</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Configuration settings for the Freescale i.MX6UL 14x14 EVK board.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MX6ULLEVK_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MX6ULLEVK_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/imx-regs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sizes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stringify.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mx6_common.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach-imx/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx_env.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义用于检查是否是MX6ULL 9x9 EVK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_mx6ull_9x9_evk()CONFIG_IS_ENABLED(TARGET_MX6ULL_9X9_EVK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据是否是MX6ULL 9x9 EVK定义CMA大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TARGET_MX6ULL_9X9_EVK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTARGS_CMA_SIZE   <span class="string">&quot;cma=96M &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTARGS_CMA_SIZE   <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义MXC UART基地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_MXC_UART_BASEUART1_BASE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MMC Configs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSL_USDHC</span></span><br><span class="line"><span class="comment">// 定义USDHC基地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_SYS_FSL_ESDHC_ADDRUSDHC2_BASE_ADDR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NAND pin conflicts with usdhc2 */</span></span><br><span class="line"><span class="comment">// 如果启用NAND，USDHC数量设置为1，否则设置为2</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NAND_MXS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_FSL_USDHC_NUM1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_FSL_USDHC_NUM2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义NAND启动时的分区信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NAND_BOOT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MFG_NAND_PARTITION <span class="string">&quot;mtdparts=gpmi-nand:64m(nandboot),16m(nandkernel),16m(nanddtb),16m(nandtee),-(nandrootfs)&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MFG_NAND_PARTITION <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义制造环境设置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_MFG_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">CFG_MFG_ENV_SETTINGS_DEFAULT \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;initrd_addr=0x86800000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;initrd_high=0xffffffff\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;emmc_dev=1\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;emmc_ack=1\0&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;sd_dev=1\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mtdparts=&quot;</span> MFG_NAND_PARTITION \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\0&quot;</span>\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">// 根据是否是NAND启动定义额外的环境设置</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NAND_BOOT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_EXTRA_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">CFG_MFG_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">TEE_ENV \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;splashimage=0x8c000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdt_addr=0x83000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdt_high=0xffffffff\0&quot;</span>  \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;tee_addr=0x84000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;console=ttymxc0\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootargs=console=ttymxc0,115200 ubi.mtd=nandrootfs &quot;</span>  \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;root=ubi0:rootfs rootfstype=ubifs &quot;</span>     \</span></span><br><span class="line"><span class="meta">BOOTARGS_CMA_SIZE \</span></span><br><span class="line"><span class="meta">MFG_NAND_PARTITION \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootcmd=nand read $&#123;loadaddr&#125; 0x4000000 0xc00000;&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;nand read $&#123;fdt_addr&#125; 0x5000000 0x100000;&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;tee&#125; = yes; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;nand read $&#123;tee_addr&#125; 0x6000000 0x400000;&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootm $&#123;tee_addr&#125; - $&#123;fdt_addr&#125;;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi\0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_EXTRA_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">CFG_MFG_ENV_SETTINGS \</span></span><br><span class="line"><span class="meta">TEE_ENV \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;script=boot.scr\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;image=zImage\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;console=ttymxc0\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdt_high=0xffffffff\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;initrd_high=0xffffffff\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdt_file=undefined\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fdt_addr=0x83000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;tee_addr=0x84000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;tee_file=undefined\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;boot_fdt=try\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;ip_dyn=yes\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;splashimage=0x8c000000\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmcdev=&quot;</span>__stringify(CONFIG_SYS_MMC_ENV_DEV)<span class="string">&quot;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmcpart=1\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmcroot=/dev/mmcblk1p2 rootwait rw\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmcautodetect=yes\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span></span><br><span class="line"><span class="meta">BOOTARGS_CMA_SIZE \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;root=$&#123;mmcroot&#125;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;loadbootscript=&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootscript=echo Running bootscript from mmc ...; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;source\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;loadtee=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;tee_addr&#125; $&#123;tee_file&#125;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;mmcboot=echo Booting from mmc ...; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run mmcargs; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;tee&#125; = yes; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run loadfdt; run loadtee; bootm $&#123;tee_addr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if run loadfdt; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;echo WARN: Cannot load the DT; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;netargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; &quot;</span> \</span></span><br><span class="line"><span class="meta">BOOTARGS_CMA_SIZE \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;root=/dev/nfs &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;ip=dhcp nfsroot=$&#123;serverip&#125;:$&#123;nfsroot&#125;,v3,tcp\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;netboot=echo Booting from net ...; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;$&#123;usb_net_cmd&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;run netargs; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;ip_dyn&#125; = yes; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv get_cmd dhcp; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv get_cmd tftp; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;$&#123;get_cmd&#125; $&#123;image&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;tee&#125; = yes; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;$&#123;get_cmd&#125; $&#123;tee_addr&#125; $&#123;tee_file&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;$&#123;get_cmd&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootm $&#123;tee_addr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;boot_fdt&#125; = yes || test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if $&#123;get_cmd&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $&#123;boot_fdt&#125; = try; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;echo WARN: Cannot load the DT; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;else &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;bootz; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;findfdt=&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $board_name = ULZ-EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv fdt_file imx6ulz-14x14-evk.dtb; fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;echo WARNING: Could not determine dtb to use; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;findtee=&quot;</span>\</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $tee_file = undefined; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $board_name = ULZ-EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv tee_file uTee-6ulzevk; fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv tee_file uTee-6ullevk; fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;setenv tee_file uTee-6ullevk; fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;if test $tee_file = undefined; then &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;echo WARNING: Could not determine tee to use; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi; &quot;</span> \</span></span><br><span class="line"><span class="meta"><span class="string">&quot;fi;\0&quot;</span> \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Miscellaneous configurable options */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Physical Memory Map */</span></span><br><span class="line"><span class="comment">// 定义物理内存基地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_SDRAMMMDC0_ARB_BASE_ADDR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义系统SDRAM基地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_SYS_SDRAM_BASEPHYS_SDRAM</span></span><br><span class="line"><span class="comment">// 定义初始化RAM地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_SYS_INIT_RAM_ADDRIRAM_BASE_ADDR</span></span><br><span class="line"><span class="comment">// 定义初始化RAM大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_SYS_INIT_RAM_SIZEIRAM_SIZE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* environment organization */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NAND stuff */</span></span><br><span class="line"><span class="comment">// 定义NAND基地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_SYS_NAND_BASE0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>evk关键字进行修改，防止遗漏。<br>宏定义改了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MX6ULLNARO_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MX6ULLNARO_CONFIG_H</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>找到CONFIG_TARGET_MX6ULL_9X9_EVK。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TARGET_MX6ULL_9X9_EVK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTARGS_CMA_SIZE   <span class="string">&quot;cma=96M &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTARGS_CMA_SIZE   <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BOOTARGS_CMA_SIZE   <span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure><p>找findfdt：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;findfdt=&quot;</span>\</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = ULZ-EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ulz-14x14-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARNING: Could not determine dtb to use; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;findfdt=&quot;</span>\</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = naro &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-14x14-naro.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARNING: Could not determine dtb to use; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure><p>这里配置的设备树是linux启动时所需要的设备树。</p><p>找到findtee：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if test $tee_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = ULZ-EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv tee_file uTee-6ulzevk; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv tee_file uTee-6ullevk; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv tee_file uTee-6ullevk; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $tee_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARNING: Could not determine tee to use; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;findtee=&quot;</span>\</span><br><span class="line"><span class="string">&quot;if test $tee_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = naro &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv tee_file uTee-6ullnaro; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $tee_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARNING: Could not determine tee to use; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure><h1 id="7-、配置Kconfig"><a href="#7-、配置Kconfig" class="headerlink" title="7 、配置Kconfig"></a>7 、配置Kconfig</h1><p>找到arch&#x2F;arm&#x2F;mach-imx&#x2F;mx6&#x2F;Kconfig文件。<br>搜索TARGET_MX6ULL_14X14_EVK，默认内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_14X14_EVK</span><br><span class="line"><span class="type">bool</span> <span class="string">&quot;Support mx6ull_14x14_evk&quot;</span></span><br><span class="line">depends on MX6ULL</span><br><span class="line">select BOARD_LATE_INIT</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br><span class="line">select IOMUX_LPSR</span><br><span class="line">select IMX_MODULE_FUSE</span><br><span class="line">select OF_SYSTEM_SETUP</span><br><span class="line">imply CMD_DM</span><br></pre></td></tr></table></figure><p>下方添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_14X14_NARO</span><br><span class="line"><span class="type">bool</span> <span class="string">&quot;Support mx6ull_14x14_naro&quot;</span></span><br><span class="line">depends on MX6ULL</span><br><span class="line">select BOARD_LATE_INIT</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br><span class="line">select IOMUX_LPSR</span><br><span class="line">select IMX_MODULE_FUSE</span><br><span class="line">select OF_SYSTEM_SETUP</span><br><span class="line">imply CMD_DM</span><br></pre></td></tr></table></figure><p>搜索source “board&#x2F;freescale&#x2F;mx6ullevk&#x2F;Kconfig” ，在其下方添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source <span class="string">&quot;board/freescale/mx6ullnaro/Kconfig&quot;</span></span><br></pre></td></tr></table></figure><h1 id="8、添加相应设备树文件"><a href="#8、添加相应设备树文件" class="headerlink" title="8、添加相应设备树文件"></a>8、添加相应设备树文件</h1><h2 id="8-1、dtsi和dts区别"><a href="#8-1、dtsi和dts区别" class="headerlink" title="8-1、dtsi和dts区别"></a>8-1、dtsi和dts区别</h2><p>.dtsi文件：类似于C语言中的头文件（.h文件），通常包含多个设备或子系统的公共定义和配置。这些文件可以被多个.dts文件引用，以避免重复定义。例如，处理器的通用外设定义、引脚复用配置等。<br>.dts文件：是具体的设备树源文件，针对特定的板级配置。它会包含对具体硬件平台的所有详细描述，并且可以引用一个或多个.dtsi文件来组合成完整的设备树。</p><p>找到imx6ull-14x14-evk.dts,打开看的包含的文件，也要改，include了下面几个文件，所以也要复制。<br>找到arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-14x14-evk.dts文件，复制为arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-14X14-naro.dts。</p><p>找到arch&#x2F;arm&#x2F;dts&#x2F;imx6ul-14x14-evk.dtsi文件，复制为arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-14X14-naro.dtsi。</p><p>找到arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-14x14-evk-u-boot.dtsi文件，复制为arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-14X14-naro-u-boot.dtsi。</p><p>修改imx6ull-14X14-naro.dts文件。<br>原文:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: (GPL-2.0 OR MIT)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (C) 2016 Freescale Semiconductor, Inc.</span></span><br><span class="line"> </span><br><span class="line">/dts-v1/;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ull.dtsi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ul-14x14-evk.dtsi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ul-14x14-evk-u-boot.dtsi&quot;</span></span></span><br><span class="line"> </span><br><span class="line">/ &#123;</span><br><span class="line">model = <span class="string">&quot;i.MX6 ULL 14x14 EVK Board&quot;</span>;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6ull-14x14-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&amp;clks &#123;</span><br><span class="line">assigned-clocks = &lt;&amp;clks IMX6UL_CLK_PLL3_PFD2&gt;,</span><br><span class="line">  &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;</span><br><span class="line">assigned-clock-rates = &lt;<span class="number">320000000</span>&gt;, &lt;<span class="number">786432000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&amp;csi &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&amp;ov5640 &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/delete-node/ &amp;sim2;</span><br></pre></td></tr></table></figure><p>改为:移植的是EMMC版本的，所以需要将imx6ull-14x14-evk-emmc.dts文件的usdhc2结点复制到imx6ull-alpha.dts文件中，修改后文件内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: (GPL-2.0 OR MIT)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Copyright (C) 2016 Freescale Semiconductor, Inc.</span></span><br><span class="line"></span><br><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ull-naro.dtsi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ul-14x14-naro.dtsi&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ull-14x14-naro-u-boot.dtsi&quot;</span></span></span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">model = <span class="string">&quot;i.MX6 ULL 14x14 naro Board&quot;</span>;</span><br><span class="line">compatible = <span class="string">&quot;fsl,imx6ull-14x14-naro&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;clks &#123;</span><br><span class="line">assigned-clocks = &lt;&amp;clks IMX6UL_CLK_PLL3_PFD2&gt;,</span><br><span class="line">  &lt;&amp;clks IMX6UL_CLK_PLL4_AUDIO_DIV&gt;;</span><br><span class="line">assigned-clock-rates = &lt;<span class="number">320000000</span>&gt;, &lt;<span class="number">786432000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;csi &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;ov5640 &#123;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/delete-node/ &amp;sim2;</span><br><span class="line"></span><br><span class="line">&amp;usdhc2 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;state_100mhz&quot;</span>, <span class="string">&quot;state_200mhz&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc2_8bit&gt;;</span><br><span class="line">pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;</span><br><span class="line">pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;</span><br><span class="line">bus-width = &lt;<span class="number">8</span>&gt;;</span><br><span class="line">non-removable;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="9、移植网络"><a href="#9、移植网络" class="headerlink" title="9、移植网络"></a>9、移植网络</h1><p>找到configs&#x2F;mx6ull_alpha_defconfig文件，搜索CONFIG_PHY_MICREL和CONFIG_PHY_MICREL_KSZ8XXX，注释掉这两行，添加CONFIG_PHY_SMSC&#x3D;y。</p><p>找到arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-alpha.dtsi文件，搜索fec1，看到网络默认配置为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;fec1 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1&gt;;</span><br><span class="line">phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">phy-supply = &lt;&amp;reg_peri_3v3&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2&gt;;</span><br><span class="line">phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">phy-supply = &lt;&amp;reg_peri_3v3&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> </span><br><span class="line">mdio &#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"> </span><br><span class="line">ethphy0: ethernet-phy@<span class="number">2</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;ethernet-phy-id0022.1560&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">micrel,led-mode = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ENET_REF&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;rmii-ref&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;ethernet-phy-id0022.1560&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">micrel,led-mode = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ENET2_REF&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;rmii-ref&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&amp;fec1 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1</span><br><span class="line"> &amp;pinctrl_enet1_reset&gt;;</span><br><span class="line">phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">phy-reset-gpios = &lt;&amp;gpio5 <span class="number">7</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line">status = <span class="string">&quot;disable&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2</span><br><span class="line"> &amp;pinctrl_enet2_reset&gt;;</span><br><span class="line">phy-mode = <span class="string">&quot;rmii&quot;</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">phy-reset-gpios = &lt;&amp;gpio5 <span class="number">8</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> </span><br><span class="line">mdio &#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"> </span><br><span class="line">ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;ethernet-phy-id0022.1560&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">smsc,led-mode = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ENET_REF&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;rmii-ref&quot;</span>;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;ethernet-phy-id0022.1560&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">smsc,led-mode = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">clocks = &lt;&amp;clks IMX6UL_CLK_ENET2_REF&gt;;</span><br><span class="line">clock-names = <span class="string">&quot;rmii-ref&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>uboot只能使能一个网口，所以我们需要disable一个网口，fec1使能比较麻烦，所以我这里使能fec2，同时添加了复位引脚。<br>搜索找到pinctrl_enet1结点位置，在此节点后面添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_enet1_reset:enet1resetgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07<span class="number">0x10B0</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理，在pinctrl_enet2后面添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_enet2_reset:enet2resetgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08<span class="number">0x10B0</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后需要修改drivers&#x2F;net&#x2F;phy&#x2F;phy.c文件，找到genphy_config_aneg函数，在int result;后面加上phy_reset(phydev);让网口复位</p><h1 id="10、编译-测试"><a href="#10、编译-测试" class="headerlink" title="10、编译 测试"></a>10、编译 测试</h1><p><code>最后会发现无法启动内核，是需要将arch/arm/mach-imx/mx6/Kconfig文件中把select OF_SYSTEM_SETUP去掉----重点</code><br>这里不改，就起不来。</p><h1 id="11、修改屏幕"><a href="#11、修改屏幕" class="headerlink" title="11、修改屏幕"></a>11、修改屏幕</h1><p>arch&#x2F;arm&#x2F;dts&#x2F;imx6ull-naro.dtsi文件，搜索lcdicc结点，找到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat</span><br><span class="line">     &amp;pinctrl_lcdif_ctrl&gt;;</span><br><span class="line">display = &lt;&amp;display0&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> </span><br><span class="line">display0: display@<span class="number">0</span> &#123;</span><br><span class="line">bits-per-pixel = &lt;<span class="number">24</span>&gt;;</span><br><span class="line">bus-width = &lt;<span class="number">24</span>&gt;;</span><br><span class="line"> </span><br><span class="line">display-timings &#123;</span><br><span class="line">native-mode = &lt;&amp;timing0&gt;;</span><br><span class="line"> </span><br><span class="line">timing0: timing0 &#123;</span><br><span class="line">clock-frequency = &lt;<span class="number">9200000</span>&gt;;</span><br><span class="line">hactive = &lt;<span class="number">480</span>&gt;;</span><br><span class="line">vactive = &lt;<span class="number">272</span>&gt;;</span><br><span class="line">hfront-porch = &lt;<span class="number">8</span>&gt;;</span><br><span class="line">hback-porch = &lt;<span class="number">4</span>&gt;;</span><br><span class="line">hsync-len = &lt;<span class="number">41</span>&gt;;</span><br><span class="line">vback-porch = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">vfront-porch = &lt;<span class="number">4</span>&gt;;</span><br><span class="line">vsync-len = &lt;<span class="number">10</span>&gt;;</span><br><span class="line">hsync-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">vsync-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">de-active = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">pixelclk-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改为自己的屏幕参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;lcdif &#123;</span><br><span class="line">pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat</span><br><span class="line">     &amp;pinctrl_lcdif_ctrl&gt;;</span><br><span class="line">display = &lt;&amp;display0&gt;;</span><br><span class="line">status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">display0: display &#123;</span><br><span class="line">bits-per-pixel = &lt;<span class="number">24</span>&gt;;</span><br><span class="line">bus-width = &lt;<span class="number">24</span>&gt;;</span><br><span class="line"></span><br><span class="line">display-timings &#123;</span><br><span class="line">native-mode = &lt;&amp;timing0&gt;;</span><br><span class="line">timing0: timing0 &#123;</span><br><span class="line">clock-frequency = &lt;<span class="number">33000000</span>&gt;;</span><br><span class="line">hactive = &lt;<span class="number">800</span>&gt;;</span><br><span class="line">vactive = &lt;<span class="number">480</span>&gt;;</span><br><span class="line">hfront-porch = &lt;<span class="number">40</span>&gt;;</span><br><span class="line">hback-porch = &lt;<span class="number">88</span>&gt;;</span><br><span class="line">hsync-len = &lt;<span class="number">48</span>&gt;;</span><br><span class="line">vback-porch = &lt;<span class="number">32</span>&gt;;</span><br><span class="line">vfront-porch = &lt;<span class="number">13</span>&gt;;</span><br><span class="line">vsync-len = &lt;<span class="number">3</span>&gt;;</span><br><span class="line"></span><br><span class="line">hsync-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">vsync-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">de-active = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">pixelclk-active = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正点原子的uboot移植视频里还讲了校验码的修改，这个文件写的就是生成的bin文件的头部信息，只有校验码正确了，我们才能够直接烧写uboot编译生成的uboot-dtb.imx文件。<br>找到board&#x2F;freescale&#x2F;mx6ullalpha&#x2F;imximage.cfg文件，搜索0x021B083C，连续三行默认值为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="number">4</span> <span class="number">0x021B083C</span> <span class="number">0x41640158</span></span><br><span class="line">DATA <span class="number">4</span> <span class="number">0x021B0848</span> <span class="number">0x40403237</span></span><br><span class="line">DATA <span class="number">4</span> <span class="number">0x021B0850</span> <span class="number">0x40403C33</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="number">4</span> <span class="number">0x021B083C</span> <span class="number">0x01380138</span></span><br><span class="line">DATA <span class="number">4</span> <span class="number">0x021B0848</span> <span class="number">0x40402E32</span></span><br><span class="line">DATA <span class="number">4</span> <span class="number">0x021B0850</span> <span class="number">0x40403432</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="12、编译测试"><a href="#12、编译测试" class="headerlink" title="12、编译测试"></a>12、编译测试</h1><p>重置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env default -a</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>配置uboot网络环境,有两个网口，设置mac要注意顺序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setenv ipaddr 192.168.8.11</span><br><span class="line">setenv eth1addr b8:ae:1d:01:00:00</span><br><span class="line">setenv gatewayip 192.168.8.1</span><br><span class="line">setenv netmask 255.255.255.0</span><br><span class="line">setenv serverip 192.168.8.9</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>启动后。测试ping通，显示正常。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=&gt; ping 192.168.8.9</span><br><span class="line">Using ethernet@20b4000 device</span><br><span class="line">host 192.168.8.9 is alive</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; imx6ull-14x14-emmc-4.3-800x480-c.dtb; bootz 80800000 - 83000000;&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><p>可以通过下面命令核对。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mmc part</span><br><span class="line">fatls mmc 1:1</span><br></pre></td></tr></table></figure><p>网络挂载系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-evk-naro-emmc.dtb; bootz 80800000 - 83000000&#x27;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure><h1 id="13、修改emmc"><a href="#13、修改emmc" class="headerlink" title="13、修改emmc"></a>13、修改emmc</h1><p>测试发现emmc的设备节点相比旧版本，缺少了重置的gpio，所以需要修改dts文件。<br>报错信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Normal Boot</span><br><span class="line">Hit any key to stop autoboot:  0</span><br><span class="line">Card did not respond to voltage select! : -110</span><br><span class="line">Card did not respond to voltage select! : -110</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">reg_sd1_vmmc: regulator-sd1-vmmc &#123;</span><br><span class="line">compatible = &quot;regulator-fixed&quot;;</span><br><span class="line">regulator-name = &quot;VSD_3V3&quot;;</span><br><span class="line">regulator-min-microvolt = &lt;3300000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line">gpio = &lt;&amp;gpio1 9 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">off-on-delay-us = &lt;20000&gt;;</span><br><span class="line">enable-active-high;</span><br><span class="line">&#125;;</span><br><span class="line">//下面新增</span><br><span class="line">reg_sd2_vmmc: regulator-sd2-vmmc &#123;</span><br><span class="line">compatible = &quot;regulator-fixed&quot;;</span><br><span class="line">regulator-name = &quot;+V3.3&quot;;</span><br><span class="line">regulator-min-microvolt = &lt;3300000&gt;;</span><br><span class="line">regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line">gpio = &lt;&amp;gpio4 10 GPIO_ACTIVE_HIGH&gt;; //重置引脚，要和硬件对应</span><br><span class="line">off-on-delay-us = &lt;20000&gt;;</span><br><span class="line">enable-active-high;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;usdhc2 &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;, &quot;state_100mhz&quot;, &quot;state_200mhz&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_usdhc2_8bit&gt;;</span><br><span class="line">pinctrl-1 = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;</span><br><span class="line">pinctrl-2 = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;</span><br><span class="line">bus-width = &lt;8&gt;;</span><br><span class="line">non-removable;</span><br><span class="line">no-1-8-v;</span><br><span class="line">vmmc-supply = &lt;&amp;reg_sd2_vmmc&gt;; //新增</span><br><span class="line">status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>移植linux时注意用emmc版本</p>]]></content>
      
      
      <categories>
          
          <category> 驱动、bootleader、文件系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件机制</title>
      <link href="/posts/31a6b40.html"/>
      <url>/posts/31a6b40.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、同步阻塞（bio）、同步非阻塞（nio）、select、poll、epoll、信号驱动式io、异步io"><a href="#1、同步阻塞（bio）、同步非阻塞（nio）、select、poll、epoll、信号驱动式io、异步io" class="headerlink" title="1、同步阻塞（bio）、同步非阻塞（nio）、select、poll、epoll、信号驱动式io、异步io"></a>1、同步阻塞（bio）、同步非阻塞（nio）、select、poll、epoll、信号驱动式io、异步io</h1><h2 id="1-1-同步阻塞"><a href="#1-1-同步阻塞" class="headerlink" title="1.1 同步阻塞"></a>1.1 同步阻塞</h2><p>1、阻塞式IO，客户端发送请求，服务端接收请求，服务端处理请求，服务端返回结果，客户端接收结果。</p><p>客户端会先去访问文件描述符状态，如果文件描述符就绪，则读取数据；如果文件描述符未就绪，则会阻塞等待。<br>数据经过网卡，dma拷贝到内核环形缓冲区后，触发一个中断，将文件描述符改到就绪态，将数据拷贝到用户空间，然后返回。<br><img src="./../../../../../img/7_linux%E5%BC%80%E5%8F%91/io%E6%93%8D%E4%BD%9C/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-io/%E5%90%8C%E6%AD%A5%E5%A0%B5%E5%A1%9E.png"></p><h2 id="1-2-同步非阻塞"><a href="#1-2-同步非阻塞" class="headerlink" title="1.2 同步非阻塞"></a>1.2 同步非阻塞</h2><p>相比与阻塞式IO，非阻塞式IO在等待数据就绪时不会阻塞。直接在发送或者读的时候返回负1，然后通过轮询的方式来检查数据是否就绪。<br>注意<code>文件描述符是需要同步内核的</code><br>本质上，也还是会阻塞，读的时候就是阻塞的，只不过是在等待的过程中没有<br>阻塞</p><h2 id="1-3-select"><a href="#1-3-select" class="headerlink" title="1.3 select"></a>1.3 select</h2><p>select本身是阻塞的，它通过一个数组，将一组文件描述符加入到这个数组中<br>，然后发给内核，内核去同步有没有写或者读事件，如果有，就将对应数据的描述符位置为1，然后返回。这样就知道那个文件描述符就绪了。select的缺点是每次都要将所有的文件描述符都发给内核，然后内核再去同步。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>select这些函数要配合fctl来使用，设置文件描述符的状态为非阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {        background: transparent !important;      }      #page-header {        background: transparent !important;      }            /* 白天模式遮罩透明 */      #footer::before {        background: transparent !important;      }      #page-header::before {        background: transparent !important;      }          /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {        background: #1e1e1e;        color: antiquewhite;      }      /* 鼠标悬浮状态 */      [data-theme="dark"] .magnet_link_context:hover {        background: #3ecdf1;        color: #f2f2f2;      }      /* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 背景宇宙星光  */#universe{        display: block;        position: fixed;        margin: 0;        padding: 0;        border: 0;        outline: 0;        left: 0;        top: 0;        width: 100%;        height: 100%;        pointer-events: none;        /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */        z-index: -1;      }      @font-face {        /* 为载入的字体取名字(随意) */        font-family: 'YSHST';        /* 字体文件地址(相对或者绝对路径都可以) */        src: url(/font/方正楷体简体.woff2);        /* 定义加粗样式(加粗多少) */        font-weight: normal;        /* 定义字体样式(斜体/非斜体) */        font-style: normal;        /* 定义显示样式 */        font-display: block;      }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
